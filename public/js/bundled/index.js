// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== "undefined"
      ? globalThis
      : typeof self !== "undefined"
      ? self
      : typeof window !== "undefined"
      ? window
      : typeof global !== "undefined"
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === "function" &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== "undefined" &&
    typeof module.require === "function" &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === "function" &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === "string") {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this,
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, "root", {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === "function" && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})(
  {
    "3FfGI": [
      function (require, module, exports) {
        var global = arguments[3];
        var HMR_HOST = null;
        var HMR_PORT = 1234;
        var HMR_SECURE = false;
        var HMR_ENV_HASH = "803aa66b09d263e6";
        module.bundle.HMR_BUNDLE_ID = "53122a40964c73a0";
        ("use strict");
        /* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
        var OldModule = module.bundle.Module;
        function Module(moduleName) {
          OldModule.call(this, moduleName);
          this.hot = {
            data: module.bundle.hotData[moduleName],
            _acceptCallbacks: [],
            _disposeCallbacks: [],
            accept: function (fn) {
              this._acceptCallbacks.push(fn || function () {});
            },
            dispose: function (fn) {
              this._disposeCallbacks.push(fn);
            },
          };
          module.bundle.hotData[moduleName] = undefined;
        }
        module.bundle.Module = Module;
        module.bundle.hotData = {};
        var checkedAssets /*: {|[string]: boolean|} */,
          assetsToDispose /*: Array<[ParcelRequire, string]> */,
          assetsToAccept /*: Array<[ParcelRequire, string]> */;
        function getHostname() {
          return (
            HMR_HOST ||
            (location.protocol.indexOf("http") === 0
              ? location.hostname
              : "localhost")
          );
        }
        function getPort() {
          return HMR_PORT || location.port;
        }
        // eslint-disable-next-line no-redeclare
        var parent = module.bundle.parent;
        if (
          (!parent || !parent.isParcelRequire) &&
          typeof WebSocket !== "undefined"
        ) {
          var hostname = getHostname();
          var port = getPort();
          var protocol =
            HMR_SECURE ||
            (location.protocol == "https:" &&
              !["localhost", "127.0.0.1", "0.0.0.0"].includes(hostname))
              ? "wss"
              : "ws";
          var ws;
          try {
            ws = new WebSocket(
              protocol + "://" + hostname + (port ? ":" + port : "") + "/",
            );
          } catch (err) {
            if (err.message) console.error(err.message);
            ws = {};
          }
          // Web extension context
          var extCtx =
            typeof browser === "undefined"
              ? typeof chrome === "undefined"
                ? null
                : chrome
              : browser;
          // Safari doesn't support sourceURL in error stacks.
          // eval may also be disabled via CSP, so do a quick check.
          var supportsSourceURL = false;
          try {
            (0, eval)('throw new Error("test"); //# sourceURL=test.js');
          } catch (err) {
            supportsSourceURL = err.stack.includes("test.js");
          }
          // $FlowFixMe
          ws.onmessage = async function (event /*: {data: string, ...} */) {
            checkedAssets = {} /*: {|[string]: boolean|} */;
            assetsToAccept = [];
            assetsToDispose = [];
            var data /*: HMRMessage */ = JSON.parse(event.data);
            if (data.type === "update") {
              // Remove error overlay if there is one
              if (typeof document !== "undefined") removeErrorOverlay();
              let assets = data.assets.filter(
                (asset) => asset.envHash === HMR_ENV_HASH,
              );
              // Handle HMR Update
              let handled = assets.every((asset) => {
                return (
                  asset.type === "css" ||
                  (asset.type === "js" &&
                    hmrAcceptCheck(
                      module.bundle.root,
                      asset.id,
                      asset.depsByBundle,
                    ))
                );
              });
              if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (
                  typeof window !== "undefined" &&
                  typeof CustomEvent !== "undefined"
                )
                  window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {}; /*: {|[string]: boolean|} */
                for (let i = 0; i < assetsToDispose.length; i++) {
                  let id = assetsToDispose[i][1];
                  if (!processedAssets[id]) {
                    hmrDispose(assetsToDispose[i][0], id);
                    processedAssets[id] = true;
                  }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for (let i = 0; i < assetsToAccept.length; i++) {
                  let id = assetsToAccept[i][1];
                  if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                  }
                }
              } else fullReload();
            }
            if (data.type === "error") {
              // Log parcel errors to console
              for (let ansiDiagnostic of data.diagnostics.ansi) {
                let stack = ansiDiagnostic.codeframe
                  ? ansiDiagnostic.codeframe
                  : ansiDiagnostic.stack;
                console.error(
                  "\uD83D\uDEA8 [parcel]: " +
                    ansiDiagnostic.message +
                    "\n" +
                    stack +
                    "\n\n" +
                    ansiDiagnostic.hints.join("\n"),
                );
              }
              if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
              }
            }
          };
          ws.onerror = function (e) {
            if (e.message) console.error(e.message);
          };
          ws.onclose = function () {
            console.warn(
              "[parcel] \uD83D\uDEA8 Connection to the HMR server was lost",
            );
          };
        }
        function removeErrorOverlay() {
          var overlay = document.getElementById(OVERLAY_ID);
          if (overlay) {
            overlay.remove();
            console.log("[parcel] \u2728 Error resolved");
          }
        }
        function createErrorOverlay(diagnostics) {
          var overlay = document.createElement("div");
          overlay.id = OVERLAY_ID;
          let errorHTML =
            '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
          for (let diagnostic of diagnostics) {
            let stack = diagnostic.frames.length
              ? diagnostic.frames.reduce((p, frame) => {
                  return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(
                    frame.location,
                  )}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${
                    frame.location
                  }</a>
${frame.code}`;
                }, "")
              : diagnostic.stack;
            errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints
            .map((hint) => "<div>\uD83D\uDCA1 " + hint + "</div>")
            .join("")}
        </div>
        ${
          diagnostic.documentation
            ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>`
            : ""
        }
      </div>
    `;
          }
          errorHTML += "</div>";
          overlay.innerHTML = errorHTML;
          return overlay;
        }
        function fullReload() {
          if ("reload" in location) location.reload();
          else if (extCtx && extCtx.runtime && extCtx.runtime.reload)
            extCtx.runtime.reload();
        }
        function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
          var modules = bundle.modules;
          if (!modules) return [];
          var parents = [];
          var k, d, dep;
          for (k in modules)
            for (d in modules[k][1]) {
              dep = modules[k][1][d];
              if (
                dep === id ||
                (Array.isArray(dep) && dep[dep.length - 1] === id)
              )
                parents.push([bundle, k]);
            }
          if (bundle.parent)
            parents = parents.concat(getParents(bundle.parent, id));
          return parents;
        }
        function updateLink(link) {
          var href = link.getAttribute("href");
          if (!href) return;
          var newLink = link.cloneNode();
          newLink.onload = function () {
            if (link.parentNode !== null)
              // $FlowFixMe
              link.parentNode.removeChild(link);
          };
          newLink.setAttribute(
            "href", // $FlowFixMe
            href.split("?")[0] + "?" + Date.now(),
          );
          // $FlowFixMe
          link.parentNode.insertBefore(newLink, link.nextSibling);
        }
        var cssTimeout = null;
        function reloadCSS() {
          if (cssTimeout) return;
          cssTimeout = setTimeout(function () {
            var links = document.querySelectorAll('link[rel="stylesheet"]');
            for (var i = 0; i < links.length; i++) {
              // $FlowFixMe[incompatible-type]
              var href /*: string */ = links[i].getAttribute("href");
              var hostname = getHostname();
              var servedFromHMRServer =
                hostname === "localhost"
                  ? new RegExp(
                      "^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" +
                        getPort(),
                    ).test(href)
                  : href.indexOf(hostname + ":" + getPort());
              var absolute =
                /^https?:\/\//i.test(href) &&
                href.indexOf(location.origin) !== 0 &&
                !servedFromHMRServer;
              if (!absolute) updateLink(links[i]);
            }
            cssTimeout = null;
          }, 50);
        }
        function hmrDownload(asset) {
          if (asset.type === "js") {
            if (typeof document !== "undefined") {
              let script = document.createElement("script");
              script.src = asset.url + "?t=" + Date.now();
              if (asset.outputFormat === "esmodule") script.type = "module";
              return new Promise((resolve, reject) => {
                var _document$head;
                script.onload = () => resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null ||
                  _document$head === void 0 ||
                  _document$head.appendChild(script);
              });
            } else if (typeof importScripts === "function") {
              // Worker scripts
              if (asset.outputFormat === "esmodule")
                return import(asset.url + "?t=" + Date.now());
              else
                return new Promise((resolve, reject) => {
                  try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                  } catch (err) {
                    reject(err);
                  }
                });
            }
          }
        }
        async function hmrApplyUpdates(assets) {
          global.parcelHotUpdate = Object.create(null);
          let scriptsToRemove;
          try {
            // If sourceURL comments aren't supported in eval, we need to load
            // the update from the dev server over HTTP so that stack traces
            // are correct in errors/logs. This is much slower than eval, so
            // we only do it if needed (currently just Safari).
            // https://bugs.webkit.org/show_bug.cgi?id=137297
            // This path is also taken if a CSP disallows eval.
            if (!supportsSourceURL) {
              let promises = assets.map((asset) => {
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null ||
                  _hmrDownload === void 0
                  ? void 0
                  : _hmrDownload.catch((err) => {
                      // Web extension fix
                      if (
                        extCtx &&
                        extCtx.runtime &&
                        extCtx.runtime.getManifest().manifest_version == 3 &&
                        typeof ServiceWorkerGlobalScope != "undefined" &&
                        global instanceof ServiceWorkerGlobalScope
                      ) {
                        extCtx.runtime.reload();
                        return;
                      }
                      throw err;
                    });
              });
              scriptsToRemove = await Promise.all(promises);
            }
            assets.forEach(function (asset) {
              hmrApply(module.bundle.root, asset);
            });
          } finally {
            delete global.parcelHotUpdate;
            if (scriptsToRemove)
              scriptsToRemove.forEach((script) => {
                if (script) {
                  var _document$head2;
                  (_document$head2 = document.head) === null ||
                    _document$head2 === void 0 ||
                    _document$head2.removeChild(script);
                }
              });
          }
        }
        function hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {
          var modules = bundle.modules;
          if (!modules) return;
          if (asset.type === "css") reloadCSS();
          else if (asset.type === "js") {
            let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
            if (deps) {
              if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for (let dep in oldDeps)
                  if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                  }
              }
              if (supportsSourceURL)
                // Global eval. We would use `new Function` here but browser
                // support for source maps is better with eval.
                (0, eval)(asset.output);
              // $FlowFixMe
              let fn = global.parcelHotUpdate[asset.id];
              modules[asset.id] = [fn, deps];
            } else if (bundle.parent) hmrApply(bundle.parent, asset);
          }
        }
        function hmrDelete(bundle, id) {
          let modules = bundle.modules;
          if (!modules) return;
          if (modules[id]) {
            // Collect dependencies that will become orphaned when this module is deleted.
            let deps = modules[id][1];
            let orphans = [];
            for (let dep in deps) {
              let parents = getParents(module.bundle.root, deps[dep]);
              if (parents.length === 1) orphans.push(deps[dep]);
            }
            // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
            delete modules[id];
            delete bundle.cache[id];
            // Now delete the orphans.
            orphans.forEach((id) => {
              hmrDelete(module.bundle.root, id);
            });
          } else if (bundle.parent) hmrDelete(bundle.parent, id);
        }
        function hmrAcceptCheck(
          bundle /*: ParcelRequire */,
          id /*: string */,
          depsByBundle /*: ?{ [string]: { [string]: string } }*/,
        ) {
          if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
          // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
          let parents = getParents(module.bundle.root, id);
          let accepted = false;
          while (parents.length > 0) {
            let v = parents.shift();
            let a = hmrAcceptCheckOne(v[0], v[1], null);
            if (a)
              // If this parent accepts, stop traversing upward, but still consider siblings.
              accepted = true;
            else {
              // Otherwise, queue the parents in the next level upward.
              let p = getParents(module.bundle.root, v[1]);
              if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
              }
              parents.push(...p);
            }
          }
          return accepted;
        }
        function hmrAcceptCheckOne(
          bundle /*: ParcelRequire */,
          id /*: string */,
          depsByBundle /*: ?{ [string]: { [string]: string } }*/,
        ) {
          var modules = bundle.modules;
          if (!modules) return;
          if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
            // If we reached the root bundle without finding where the asset should go,
            // there's nothing to do. Mark as "accepted" so we don't reload the page.
            if (!bundle.parent) return true;
            return hmrAcceptCheck(bundle.parent, id, depsByBundle);
          }
          if (checkedAssets[id]) return true;
          checkedAssets[id] = true;
          var cached = bundle.cache[id];
          assetsToDispose.push([bundle, id]);
          if (!cached || (cached.hot && cached.hot._acceptCallbacks.length)) {
            assetsToAccept.push([bundle, id]);
            return true;
          }
        }
        function hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {
          var cached = bundle.cache[id];
          bundle.hotData[id] = {};
          if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
          if (cached && cached.hot && cached.hot._disposeCallbacks.length)
            cached.hot._disposeCallbacks.forEach(function (cb) {
              cb(bundle.hotData[id]);
            });
          delete bundle.cache[id];
        }
        function hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {
          // Execute the module.
          bundle(id);
          // Run the accept callbacks in the new version of the module.
          var cached = bundle.cache[id];
          if (cached && cached.hot && cached.hot._acceptCallbacks.length)
            cached.hot._acceptCallbacks.forEach(function (cb) {
              var assetsToAlsoAccept = cb(function () {
                return getParents(module.bundle.root, id);
              });
              if (assetsToAlsoAccept && assetsToAccept.length) {
                assetsToAlsoAccept.forEach(function (a) {
                  hmrDispose(a[0], a[1]);
                });
                // $FlowFixMe[method-unbinding]
                assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
              }
            });
        }
      },
      {},
    ],
    de0CH: [
      function (require, module, exports) {
        /* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        var _polyfill = require("@babel/polyfill");
        var _loginJs = require("./login.js");
        var _mapboxJs = require("./mapbox.js");
        var _mapboxJsDefault = parcelHelpers.interopDefault(_mapboxJs);
        var _updateSettingsJs = require("./updateSettings.js");
        var _updateSettingsJsDefault =
          parcelHelpers.interopDefault(_updateSettingsJs);
        var _stripeJs = require("./stripe.js");
        var _stripeJsDefault = parcelHelpers.interopDefault(_stripeJs);
        const mapBox = document.querySelector("#map");
        const loginForm = document.querySelector(".form--login");
        const logoutBtn = document.querySelector(".nav__el--logout");
        const updateUserDataForm = document.querySelector(".form-user-data");
        const updatePasswordForm = document.querySelector(
          ".form-user-settings",
        );
        const bookBtn = document.querySelector("#book-tour");
        if (mapBox) {
          const locations = JSON.parse(
            document.querySelector("#map").dataset.locations,
          );
          (0, _mapboxJsDefault.default)(locations);
        }
        if (loginForm)
          loginForm.addEventListener("submit", (e) => {
            e.preventDefault();
            const email = document.querySelector("#email").value;
            const password = document.querySelector("#password").value;
            (0, _loginJs.login)(email, password);
          });
        if (logoutBtn)
          logoutBtn.addEventListener("click", (0, _loginJs.logout));
        if (updateUserDataForm)
          updateUserDataForm.addEventListener("submit", (e) => {
            e.preventDefault();
            const form = new FormData();
            form.append("name", document.querySelector("#name").value);
            form.append("email", document.querySelector("#email").value);
            form.append("photo", document.querySelector("#photo").files[0]);
            (0, _updateSettingsJsDefault.default)(form, "data");
          });
        if (updatePasswordForm)
          updatePasswordForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            document.querySelector(".btn--save-password").textContent =
              "Updating...";
            const passwordCurrent =
              document.querySelector("#password-current").value;
            const password = document.querySelector("#password").value;
            const passwordConfirm =
              document.querySelector("#password-confirm").value;
            await (0, _updateSettingsJsDefault.default)(
              {
                passwordCurrent,
                password,
                passwordConfirm,
              },
              "password",
            );
            document.querySelector(".btn--save-password").textContent =
              "Save password";
            document.querySelector("#password-current").value = "";
            document.querySelector("#password").value = "";
            document.querySelector("#password-confirm").value = "";
          });
        if (bookBtn)
          bookBtn.addEventListener("click", (e) => {
            e.target.textContent = "Processing...";
            const { tourId } = e.target.dataset;
            (0, _stripeJsDefault.default)(tourId);
          });
      },
      {
        "@babel/polyfill": "lSuZI",
        "./login.js": "6J3OJ",
        "./mapbox.js": "cfjWV",
        "./updateSettings.js": "5aoxi",
        "./stripe.js": "a2htd",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    lSuZI: [
      function (require, module, exports) {
        "use strict";
        require("f50de0aa433a589b");
        var _global = _interopRequireDefault(require("4142986752a079d4"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }
        if (
          _global["default"]._babelPolyfill &&
          typeof console !== "undefined" &&
          console.warn
        )
          console.warn(
            "@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning.",
          );
        _global["default"]._babelPolyfill = true;
      },
      { f50de0aa433a589b: "9WAgE", "4142986752a079d4": "fuWG2" },
    ],
    "9WAgE": [
      function (require, module, exports) {
        "use strict";
        require("20d5adc6d0f9d0ec");
        require("5393e06e6601db86");
        require("b5ec37d53a8038a3");
        require("3b1c6638424f7cc9");
        require("a94df941b08ed34b");
        require("27f1c6610972fa8f");
        require("736edc9ff1c820fc");
        require("e913642ec1cdbfc0");
        require("bbc44ee8d910fc67");
        require("78c9cbd887a23ab3");
        require("6280d07c0d3b0e0d");
        require("889779cb2fdd24f4");
        require("a3f453df0c362f3a");
        require("5149e6c04d66148b");
      },
      {
        "20d5adc6d0f9d0ec": "4RAFh",
        "5393e06e6601db86": "9TCAK",
        b5ec37d53a8038a3: "eqfjm",
        "3b1c6638424f7cc9": "95xbb",
        a94df941b08ed34b: "9VEom",
        "27f1c6610972fa8f": "dKFZd",
        "736edc9ff1c820fc": "jAKR4",
        e913642ec1cdbfc0: "20k8S",
        bbc44ee8d910fc67: "jRDnb",
        "78c9cbd887a23ab3": "7ZBdl",
        "6280d07c0d3b0e0d": "58Rer",
        "889779cb2fdd24f4": "i4AUN",
        a3f453df0c362f3a: "bZzik",
        "5149e6c04d66148b": "2TPpP",
      },
    ],
    "4RAFh": [
      function (require, module, exports) {
        require("3da956e7429fddca");
        require("a1daecb51c726868");
        require("90b93ac0707ed119");
        require("6d74d3580a952b94");
        require("b110fe907df367bb");
        require("d0b2324ffc5d8c73");
        require("d5180b78b2c64df0");
        require("85fedcbfdc63fcf3");
        require("b70ff16f60336c97");
        require("e7759c73e569a52f");
        require("6ecb5a9b4dee0add");
        require("fb7629de70a7834");
        require("d5d35b08dc3bbb2c");
        require("e2eabbbb1ecb8a61");
        require("5d19921c14f3a80");
        require("ea7a74bd96a721c3");
        require("7ac8373cd0120e59");
        require("c125b3fc9a9af5fd");
        require("18a3574671c132b1");
        require("897f72dee5659285");
        require("199bb55052b45dca");
        require("97fe82716459b981");
        require("e8cb8899a6679ee3");
        require("5971297cc8ccca23");
        require("793459ebe9528614");
        require("d9b5f69822a70295");
        require("a90c0d5df2c1a775");
        require("a8901c7915aee7d7");
        require("74b7c173bed97a98");
        require("de66aff6caae8069");
        require("fc47b5aaa26b0c2");
        require("a6080778a1bd8f33");
        require("f89e60a6c43a9a26");
        require("dc35b62a9be52ec0");
        require("a45969ab4217c16");
        require("e35abc811fc1a094");
        require("9cdc42688e364ffc");
        require("6c65bdd276569a67");
        require("bdab1a280f847356");
        require("d89677a2265a8f1d");
        require("3b1b1a03114daf81");
        require("69dcea93bb3d1126");
        require("74337fc26fe7bb70");
        require("7412a2ba32c964de");
        require("1ea321a6e8693986");
        require("2bfe717225e3578c");
        require("a79aac0d4f1056fc");
        require("922c7ea7fa9b6a86");
        require("187144ccf0cb89d8");
        require("f584b19977c1b0c");
        require("e8d1912c0fdbf96d");
        require("49d18c8667987a31");
        require("6f592f021031154f");
        require("554d431264e7773f");
        require("826ec509b22fafe");
        require("6164b630aa5d9d2d");
        require("5ea290feaaf5ae54");
        require("f92a3893e2b9a81");
        require("eb5b8f35973aa900");
        require("8afc6fea7a345f35");
        require("4dd8a1e2dd3f3c3c");
        require("d44ef7fd0fe04593");
        require("7fdff4335fe79055");
        require("dc7f6b8e673404ee");
        require("27ef0faa27cba53c");
        require("85d1f3bb61fd5b57");
        require("e84cf00873a0c3b9");
        require("b82adf45ca744695");
        require("6cd01848d44336e1");
        require("39b80e92b4a5042e");
        require("abe9eaeedae05b05");
        require("b836c5f01ee64c78");
        require("278defafd389aeaa");
        require("10d6657cec9e8a00");
        require("3207c49ef6f58f80");
        require("1c3d5d9d3fedc1c5");
        require("67255491d0ca0a6f");
        require("9f8a5e6c95154cac");
        require("be603317597f489f");
        require("4954f6a5612b686f");
        require("f562c7c7a6a29e23");
        require("a74ccbd6872aec7c");
        require("f01249d3558ff814");
        require("ab01a99fb5a4aab");
        require("a80c1129c1f5ea49");
        require("2047b8993e780898");
        require("44e123e8481121a9");
        require("6183c9e7280d8a51");
        require("d400b58d551035b1");
        require("8578cf303722bddb");
        require("a8347784a43f5487");
        require("47e007d180f0fcca");
        require("e7f2b57266cd0b76");
        require("11590f083e3441a");
        require("418fd34894515bf6");
        require("5cdbcb445ffc33df");
        require("95c8cb8627141f3a");
        require("6f4e8798655513b7");
        require("b7cf128545923423");
        require("f32cb7f60b1c5757");
        require("2129799c6bad4b9d");
        require("c85757628b40cedb");
        require("e58c2c918f5fd380");
        require("7f20f079a9dde19");
        require("7d025150509f6855");
        require("f318be8704faf468");
        require("90aa678e495927d9");
        require("d050f58df6ebad0d");
        require("4038f36f191c2fbc");
        require("9c18618ba51b71e1");
        require("14f3d45e48b5bc6c");
        require("b46a332f28e1f984");
        require("8f1a924b47fa1f91");
        require("ac7648351f6f6344");
        require("763f39697c3eb840");
        require("ddb11562352f03c8");
        require("42f839c0e73d230a");
        require("d938fe43fb9536dc");
        require("64889fa4e6f4a1ec");
        require("abc365f420497a92");
        require("c99edc24fa5e885a");
        require("d084b4f516879db4");
        require("3e884d5c5fc604df");
        require("4b900a7d4ae7f9f6");
        require("bb31ae4607dbf33e");
        require("f06c0130b7cc6496");
        require("e1dc90de80e3e03d");
        require("9e5e8fffbd4124c0");
        require("99390bb26a919163");
        require("e60a1db1f00e6b14");
        require("9cdad9c245d226fb");
        require("73f9fc58f1bd4a71");
        require("e7d07df6dcfaddf4");
        require("ae935fe0a6268290");
        require("57f9c5b010af6440");
        require("3592abd76f4b334c");
        require("b69db544df79ec7");
        require("112cf7bffdad691");
        module.exports = require("4510f81ff0745a84");
      },
      {
        "3da956e7429fddca": "brtDM",
        a1daecb51c726868: "1lOlG",
        "90b93ac0707ed119": "K4v28",
        "6d74d3580a952b94": "h4iD6",
        b110fe907df367bb: "jtaJZ",
        d0b2324ffc5d8c73: "e59Bp",
        d5180b78b2c64df0: "1vpnn",
        "85fedcbfdc63fcf3": "35CNG",
        b70ff16f60336c97: "didx1",
        e7759c73e569a52f: "ej71o",
        "6ecb5a9b4dee0add": "23Wb5",
        fb7629de70a7834: "1Jyce",
        d5d35b08dc3bbb2c: "5i3tk",
        e2eabbbb1ecb8a61: "cP6Fy",
        "5d19921c14f3a80": "6Fo0t",
        ea7a74bd96a721c3: "3Pmt8",
        "7ac8373cd0120e59": "k3ks5",
        c125b3fc9a9af5fd: "lwmiM",
        "18a3574671c132b1": "bX4FS",
        "897f72dee5659285": "7ksV8",
        "199bb55052b45dca": "kPhac",
        "97fe82716459b981": "5ZSup",
        e8cb8899a6679ee3: "3QBT2",
        "5971297cc8ccca23": "7sYcR",
        "793459ebe9528614": "RVyCT",
        d9b5f69822a70295: "6e1J6",
        a90c0d5df2c1a775: "d1Q1g",
        a8901c7915aee7d7: "7pnki",
        "74b7c173bed97a98": "5UTe3",
        de66aff6caae8069: "g6zXU",
        fc47b5aaa26b0c2: "cS05b",
        a6080778a1bd8f33: "365K7",
        f89e60a6c43a9a26: "tXAuf",
        dc35b62a9be52ec0: "7GiWu",
        a45969ab4217c16: "d0Mpd",
        e35abc811fc1a094: "4DJ1Q",
        "9cdc42688e364ffc": "79F2G",
        "6c65bdd276569a67": "3eSia",
        bdab1a280f847356: "eIazd",
        d89677a2265a8f1d: "6RDjb",
        "3b1b1a03114daf81": "9u062",
        "69dcea93bb3d1126": "bVZP5",
        "74337fc26fe7bb70": "bS2ub",
        "7412a2ba32c964de": "jrwHx",
        "1ea321a6e8693986": "1NwYP",
        "2bfe717225e3578c": "gHtQs",
        a79aac0d4f1056fc: "7lS5g",
        "922c7ea7fa9b6a86": "kcnnb",
        "187144ccf0cb89d8": "bX8th",
        f584b19977c1b0c: "dhEAw",
        e8d1912c0fdbf96d: "bIHxi",
        "49d18c8667987a31": "lzpi2",
        "6f592f021031154f": "1OD4s",
        "554d431264e7773f": "fWSHh",
        "826ec509b22fafe": "8Woox",
        "6164b630aa5d9d2d": "gq4xf",
        "5ea290feaaf5ae54": "go3Mo",
        f92a3893e2b9a81: "l49L7",
        eb5b8f35973aa900: "dsEX7",
        "8afc6fea7a345f35": "9hYro",
        "4dd8a1e2dd3f3c3c": "jZsZQ",
        d44ef7fd0fe04593: "6iFZe",
        "7fdff4335fe79055": "1Tuxq",
        dc7f6b8e673404ee: "l1HTH",
        "27ef0faa27cba53c": "jofh9",
        "85d1f3bb61fd5b57": "6B6Wp",
        e84cf00873a0c3b9: "hwXyT",
        b82adf45ca744695: "2fGWg",
        "6cd01848d44336e1": "8nqOX",
        "39b80e92b4a5042e": "dCtAQ",
        abe9eaeedae05b05: "jaeTs",
        b836c5f01ee64c78: "8Uye6",
        "278defafd389aeaa": "ge0MJ",
        "10d6657cec9e8a00": "8sNGY",
        "3207c49ef6f58f80": "3Amrf",
        "1c3d5d9d3fedc1c5": "gSjyb",
        "67255491d0ca0a6f": "e89dG",
        "9f8a5e6c95154cac": "18WXb",
        be603317597f489f: "7ajak",
        "4954f6a5612b686f": "iwBlJ",
        f562c7c7a6a29e23: "9WHF6",
        a74ccbd6872aec7c: "gKvoj",
        f01249d3558ff814: "4PTwA",
        ab01a99fb5a4aab: "04eFF",
        a80c1129c1f5ea49: "aysu2",
        "2047b8993e780898": "iJQzP",
        "44e123e8481121a9": "ipnmS",
        "6183c9e7280d8a51": "lvMIp",
        d400b58d551035b1: "hqvXI",
        "8578cf303722bddb": "8h2yQ",
        a8347784a43f5487: "GtUdz",
        "47e007d180f0fcca": "fnWfY",
        e7f2b57266cd0b76: "1T1Z7",
        "11590f083e3441a": "wo8n0",
        "418fd34894515bf6": "2VW9D",
        "5cdbcb445ffc33df": "15nzR",
        "95c8cb8627141f3a": "bi2ft",
        "6f4e8798655513b7": "TztOt",
        b7cf128545923423: "9YawV",
        f32cb7f60b1c5757: "cYJcA",
        "2129799c6bad4b9d": "aNQK1",
        c85757628b40cedb: "9Qt83",
        e58c2c918f5fd380: "lItlQ",
        "7f20f079a9dde19": "euwOW",
        "7d025150509f6855": "lBgqj",
        f318be8704faf468: "lIohS",
        "90aa678e495927d9": "4NG4w",
        d050f58df6ebad0d: "4OaGh",
        "4038f36f191c2fbc": "xHtR0",
        "9c18618ba51b71e1": "b6ohp",
        "14f3d45e48b5bc6c": "gagBf",
        b46a332f28e1f984: "l51dy",
        "8f1a924b47fa1f91": "5rmEC",
        ac7648351f6f6344: "5WMBT",
        "763f39697c3eb840": "b6euG",
        ddb11562352f03c8: "dBA71",
        "42f839c0e73d230a": "dUrzk",
        d938fe43fb9536dc: "eOurR",
        "64889fa4e6f4a1ec": "1XyL0",
        abc365f420497a92: "6OpoX",
        c99edc24fa5e885a: "ianWm",
        d084b4f516879db4: "jxe5Y",
        "3e884d5c5fc604df": "cSLOG",
        "4b900a7d4ae7f9f6": "kbXub",
        bb31ae4607dbf33e: "2pCox",
        f06c0130b7cc6496: "7DZDZ",
        e1dc90de80e3e03d: "XkGHK",
        "9e5e8fffbd4124c0": "a9ovp",
        "99390bb26a919163": "2rcoi",
        e60a1db1f00e6b14: "JoWx5",
        "9cdad9c245d226fb": "9lT0r",
        "73f9fc58f1bd4a71": "g1TgE",
        e7d07df6dcfaddf4: "61FzT",
        ae935fe0a6268290: "gkwW8",
        "57f9c5b010af6440": "lMGbj",
        "3592abd76f4b334c": "2ukxk",
        b69db544df79ec7: "lPRu7",
        "112cf7bffdad691": "c9HUg",
        "4510f81ff0745a84": "8jGrK",
      },
    ],
    brtDM: [
      function (require, module, exports) {
        "use strict";
        // ECMAScript 6 symbols shim
        var global = require("85b674bfde1becc8");
        var has = require("5202605509dac3e3");
        var DESCRIPTORS = require("e7a81e365f7c1b2e");
        var $export = require("a8ec227e38a697a9");
        var redefine = require("cecf64984c824a62");
        var META = require("ba9f490c087e9b9d").KEY;
        var $fails = require("fcfebb68ffabd950");
        var shared = require("464a781dc1ce7379");
        var setToStringTag = require("121a432568465270");
        var uid = require("5899792a6e9f0392");
        var wks = require("afce0118fa7f0f48");
        var wksExt = require("eb15d0637350a9a3");
        var wksDefine = require("d19b51218798dc16");
        var enumKeys = require("18e47c57a38ba0e");
        var isArray = require("cbfdd94713bf657d");
        var anObject = require("bf0b742f0c2891f2");
        var isObject = require("57d3d3f74a6d0a39");
        var toObject = require("8a3f4f33a87b8393");
        var toIObject = require("fce19ba526ae2909");
        var toPrimitive = require("157ccd489cf6719a");
        var createDesc = require("f032df6fddc255dc");
        var _create = require("effb60b2814cace4");
        var gOPNExt = require("526baba19c621e08");
        var $GOPD = require("9af912d533524855");
        var $GOPS = require("41bb3df691eb9c1b");
        var $DP = require("3fcdf396ba1b3b09");
        var $keys = require("9053f2b8d4078173");
        var gOPD = $GOPD.f;
        var dP = $DP.f;
        var gOPN = gOPNExt.f;
        var $Symbol = global.Symbol;
        var $JSON = global.JSON;
        var _stringify = $JSON && $JSON.stringify;
        var PROTOTYPE = "prototype";
        var HIDDEN = wks("_hidden");
        var TO_PRIMITIVE = wks("toPrimitive");
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = shared("symbol-registry");
        var AllSymbols = shared("symbols");
        var OPSymbols = shared("op-symbols");
        var ObjectProto = Object[PROTOTYPE];
        var USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f;
        var QObject = global.QObject;
        // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
        var setter =
          !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
        var setSymbolDesc =
          DESCRIPTORS &&
          $fails(function () {
            return (
              _create(
                dP({}, "a", {
                  get: function () {
                    return dP(this, "a", {
                      value: 7,
                    }).a;
                  },
                }),
              ).a != 7
            );
          })
            ? function (it, key, D) {
                var protoDesc = gOPD(ObjectProto, key);
                if (protoDesc) delete ObjectProto[key];
                dP(it, key, D);
                if (protoDesc && it !== ObjectProto)
                  dP(ObjectProto, key, protoDesc);
              }
            : dP;
        var wrap = function (tag) {
          var sym = (AllSymbols[tag] = _create($Symbol[PROTOTYPE]));
          sym._k = tag;
          return sym;
        };
        var isSymbol =
          USE_NATIVE && typeof $Symbol.iterator == "symbol"
            ? function (it) {
                return typeof it == "symbol";
              }
            : function (it) {
                return it instanceof $Symbol;
              };
        var $defineProperty = function defineProperty(it, key, D) {
          if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
          anObject(it);
          key = toPrimitive(key, true);
          anObject(D);
          if (has(AllSymbols, key)) {
            if (!D.enumerable) {
              if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
              it[HIDDEN][key] = true;
            } else {
              if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
              D = _create(D, {
                enumerable: createDesc(0, false),
              });
            }
            return setSymbolDesc(it, key, D);
          }
          return dP(it, key, D);
        };
        var $defineProperties = function defineProperties(it, P) {
          anObject(it);
          var keys = enumKeys((P = toIObject(P)));
          var i = 0;
          var l = keys.length;
          var key;
          while (l > i) $defineProperty(it, (key = keys[i++]), P[key]);
          return it;
        };
        var $create = function create(it, P) {
          return P === undefined
            ? _create(it)
            : $defineProperties(_create(it), P);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
          var E = isEnum.call(this, (key = toPrimitive(key, true)));
          if (
            this === ObjectProto &&
            has(AllSymbols, key) &&
            !has(OPSymbols, key)
          )
            return false;
          return E ||
            !has(this, key) ||
            !has(AllSymbols, key) ||
            (has(this, HIDDEN) && this[HIDDEN][key])
            ? E
            : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(
          it,
          key,
        ) {
          it = toIObject(it);
          key = toPrimitive(key, true);
          if (
            it === ObjectProto &&
            has(AllSymbols, key) &&
            !has(OPSymbols, key)
          )
            return;
          var D = gOPD(it, key);
          if (
            D &&
            has(AllSymbols, key) &&
            !(has(it, HIDDEN) && it[HIDDEN][key])
          )
            D.enumerable = true;
          return D;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
          var names = gOPN(toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i)
            if (
              !has(AllSymbols, (key = names[i++])) &&
              key != HIDDEN &&
              key != META
            )
              result.push(key);
          return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
          var IS_OP = it === ObjectProto;
          var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i)
            if (
              has(AllSymbols, (key = names[i++])) &&
              (IS_OP ? has(ObjectProto, key) : true)
            )
              result.push(AllSymbols[key]);
          return result;
        };
        // 19.4.1.1 Symbol([description])
        if (!USE_NATIVE) {
          $Symbol = function Symbol() {
            if (this instanceof $Symbol)
              throw TypeError("Symbol is not a constructor!");
            var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
            var $set = function (value) {
              if (this === ObjectProto) $set.call(OPSymbols, value);
              if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                this[HIDDEN][tag] = false;
              setSymbolDesc(this, tag, createDesc(1, value));
            };
            if (DESCRIPTORS && setter)
              setSymbolDesc(ObjectProto, tag, {
                configurable: true,
                set: $set,
              });
            return wrap(tag);
          };
          redefine($Symbol[PROTOTYPE], "toString", function toString() {
            return this._k;
          });
          $GOPD.f = $getOwnPropertyDescriptor;
          $DP.f = $defineProperty;
          require("f13518c7f553caab").f = gOPNExt.f = $getOwnPropertyNames;
          require("f33ee2929fe644c7").f = $propertyIsEnumerable;
          $GOPS.f = $getOwnPropertySymbols;
          if (DESCRIPTORS && !require("fff988306c4f1972"))
            redefine(
              ObjectProto,
              "propertyIsEnumerable",
              $propertyIsEnumerable,
              true,
            );
          wksExt.f = function (name) {
            return wrap(wks(name));
          };
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
          Symbol: $Symbol,
        });
        for (
          var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
              "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(
                ",",
              ),
            j = 0;
          es6Symbols.length > j;

        )
          wks(es6Symbols[j++]);
        for (
          var wellKnownSymbols = $keys(wks.store), k = 0;
          wellKnownSymbols.length > k;

        )
          wksDefine(wellKnownSymbols[k++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
          // 19.4.2.1 Symbol.for(key)
          for: function (key) {
            return has(SymbolRegistry, (key += ""))
              ? SymbolRegistry[key]
              : (SymbolRegistry[key] = $Symbol(key));
          },
          // 19.4.2.5 Symbol.keyFor(sym)
          keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
            for (var key in SymbolRegistry)
              if (SymbolRegistry[key] === sym) return key;
          },
          useSetter: function () {
            setter = true;
          },
          useSimple: function () {
            setter = false;
          },
        });
        $export($export.S + $export.F * !USE_NATIVE, "Object", {
          // 19.1.2.2 Object.create(O [, Properties])
          create: $create,
          // 19.1.2.4 Object.defineProperty(O, P, Attributes)
          defineProperty: $defineProperty,
          // 19.1.2.3 Object.defineProperties(O, Properties)
          defineProperties: $defineProperties,
          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
          // 19.1.2.7 Object.getOwnPropertyNames(O)
          getOwnPropertyNames: $getOwnPropertyNames,
          // 19.1.2.8 Object.getOwnPropertySymbols(O)
          getOwnPropertySymbols: $getOwnPropertySymbols,
        });
        // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
        // https://bugs.chromium.org/p/v8/issues/detail?id=3443
        var FAILS_ON_PRIMITIVES = $fails(function () {
          $GOPS.f(1);
        });
        $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
          getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return $GOPS.f(toObject(it));
          },
        });
        // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON &&
          $export(
            $export.S +
              $export.F *
                (!USE_NATIVE ||
                  $fails(function () {
                    var S = $Symbol();
                    // MS Edge converts symbol values to JSON as {}
                    // WebKit converts symbol values to JSON as null
                    // V8 throws on boxed symbols
                    return (
                      _stringify([S]) != "[null]" ||
                      _stringify({
                        a: S,
                      }) != "{}" ||
                      _stringify(Object(S)) != "{}"
                    );
                  })),
            "JSON",
            {
              stringify: function stringify(it) {
                var args = [it];
                var i = 1;
                var replacer, $replacer;
                while (arguments.length > i) args.push(arguments[i++]);
                $replacer = replacer = args[1];
                if ((!isObject(replacer) && it === undefined) || isSymbol(it))
                  return; // IE8 returns string on undefined
                if (!isArray(replacer))
                  replacer = function (key, value) {
                    if (typeof $replacer == "function")
                      value = $replacer.call(this, key, value);
                    if (!isSymbol(value)) return value;
                  };
                args[1] = replacer;
                return _stringify.apply($JSON, args);
              },
            },
          );
        // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] ||
          require("10fbd33c0b268827")(
            $Symbol[PROTOTYPE],
            TO_PRIMITIVE,
            $Symbol[PROTOTYPE].valueOf,
          );
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, "Symbol");
        // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, "Math", true);
        // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, "JSON", true);
      },
      {
        "85b674bfde1becc8": "c0KvC",
        "5202605509dac3e3": "jnyQA",
        e7a81e365f7c1b2e: "4XHXy",
        a8ec227e38a697a9: "77Dy0",
        cecf64984c824a62: "kcOGE",
        ba9f490c087e9b9d: "jIXDG",
        fcfebb68ffabd950: "jYBY4",
        "464a781dc1ce7379": "6xxwM",
        "121a432568465270": "eBrgu",
        "5899792a6e9f0392": "8b505",
        afce0118fa7f0f48: "ea5XI",
        eb15d0637350a9a3: "fAFfy",
        d19b51218798dc16: "fqXKV",
        "18e47c57a38ba0e": "bfkd5",
        cbfdd94713bf657d: "3C2EA",
        bf0b742f0c2891f2: "dkWKr",
        "57d3d3f74a6d0a39": "joZov",
        "8a3f4f33a87b8393": "dZ3od",
        fce19ba526ae2909: "ibyad",
        "157ccd489cf6719a": "9GXBY",
        f032df6fddc255dc: "ciJKK",
        effb60b2814cace4: "2DOWX",
        "526baba19c621e08": "bCUnj",
        "9af912d533524855": "jfoaU",
        "41bb3df691eb9c1b": "b0BO3",
        "3fcdf396ba1b3b09": "evkkn",
        "9053f2b8d4078173": "ctfEa",
        f13518c7f553caab: "aij03",
        f33ee2929fe644c7: "aCVNF",
        fff988306c4f1972: "4YPyS",
        "10fbd33c0b268827": "4uQIf",
      },
    ],
    c0KvC: [
      function (require, module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = (module.exports =
          typeof window != "undefined" && window.Math == Math
            ? window
            : typeof self != "undefined" && self.Math == Math
            ? self
            : Function("return this")());
        if (typeof __g == "number") __g = global; // eslint-disable-line no-undef
      },
      {},
    ],
    jnyQA: [
      function (require, module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };
      },
      {},
    ],
    "4XHXy": [
      function (require, module, exports) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !require("c3ddebb06976432e")(function () {
          return (
            Object.defineProperty({}, "a", {
              get: function () {
                return 7;
              },
            }).a != 7
          );
        });
      },
      { c3ddebb06976432e: "jYBY4" },
    ],
    jYBY4: [
      function (require, module, exports) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
      },
      {},
    ],
    "77Dy0": [
      function (require, module, exports) {
        var global = require("42f6b821d919e9e3");
        var core = require("c78b0a9a56aa2fa8");
        var hide = require("31d57f90251ab520");
        var redefine = require("ced7c23f8cd6b0bf");
        var ctx = require("242cc4d0fd4e0ba");
        var PROTOTYPE = "prototype";
        var $export = function (type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL
            ? global
            : IS_STATIC
            ? global[name] || (global[name] = {})
            : (global[name] || {})[PROTOTYPE];
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL) source = name;
          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined;
            // export native or passed
            out = (own ? target : source)[key];
            // bind timers to global for call from export context
            exp =
              IS_BIND && own
                ? ctx(out, global)
                : IS_PROTO && typeof out == "function"
                ? ctx(Function.call, out)
                : out;
            // extend global
            if (target) redefine(target, key, out, type & $export.U);
            // export
            if (exports[key] != out) hide(exports, key, exp);
            if (IS_PROTO && expProto[key] != out) expProto[key] = out;
          }
        };
        global.core = core;
        // type bitmap
        $export.F = 1; // forced
        $export.G = 2; // global
        $export.S = 4; // static
        $export.P = 8; // proto
        $export.B = 16; // bind
        $export.W = 32; // wrap
        $export.U = 64; // safe
        $export.R = 128; // real proto method for `library`
        module.exports = $export;
      },
      {
        "42f6b821d919e9e3": "c0KvC",
        c78b0a9a56aa2fa8: "8jGrK",
        "31d57f90251ab520": "4uQIf",
        ced7c23f8cd6b0bf: "kcOGE",
        "242cc4d0fd4e0ba": "gpAgQ",
      },
    ],
    "8jGrK": [
      function (require, module, exports) {
        var core = (module.exports = {
          version: "2.6.12",
        });
        if (typeof __e == "number") __e = core; // eslint-disable-line no-undef
      },
      {},
    ],
    "4uQIf": [
      function (require, module, exports) {
        var dP = require("d8943525bab1b2ec");
        var createDesc = require("25bf6cacb7cbb32e");
        module.exports = require("2ee055831716c8bb")
          ? function (object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            }
          : function (object, key, value) {
              object[key] = value;
              return object;
            };
      },
      {
        d8943525bab1b2ec: "evkkn",
        "25bf6cacb7cbb32e": "ciJKK",
        "2ee055831716c8bb": "4XHXy",
      },
    ],
    evkkn: [
      function (require, module, exports) {
        var anObject = require("b930f648b0f27382");
        var IE8_DOM_DEFINE = require("f0c219e68320c9ed");
        var toPrimitive = require("c690e12f2fe9bab0");
        var dP = Object.defineProperty;
        exports.f = require("1bceab5c9179ba04")
          ? Object.defineProperty
          : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return dP(O, P, Attributes);
                } catch (e) {}
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
      },
      {
        b930f648b0f27382: "dkWKr",
        f0c219e68320c9ed: "2x7l9",
        c690e12f2fe9bab0: "9GXBY",
        "1bceab5c9179ba04": "4XHXy",
      },
    ],
    dkWKr: [
      function (require, module, exports) {
        var isObject = require("56587b8863452108");
        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + " is not an object!");
          return it;
        };
      },
      { "56587b8863452108": "joZov" },
    ],
    joZov: [
      function (require, module, exports) {
        module.exports = function (it) {
          return typeof it === "object"
            ? it !== null
            : typeof it === "function";
        };
      },
      {},
    ],
    "2x7l9": [
      function (require, module, exports) {
        module.exports =
          !require("a100528cf6641f10") &&
          !require("ae70d15ac8e4b8ac")(function () {
            return (
              Object.defineProperty(require("e10245d0320221b6")("div"), "a", {
                get: function () {
                  return 7;
                },
              }).a != 7
            );
          });
      },
      {
        a100528cf6641f10: "4XHXy",
        ae70d15ac8e4b8ac: "jYBY4",
        e10245d0320221b6: "kIGVy",
      },
    ],
    kIGVy: [
      function (require, module, exports) {
        var isObject = require("f5128ecc02fb78bd");
        var document = require("e008eb78a0a4d5d9").document;
        // typeof document.createElement is 'object' in old IE
        var is = isObject(document) && isObject(document.createElement);
        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };
      },
      { f5128ecc02fb78bd: "joZov", e008eb78a0a4d5d9: "c0KvC" },
    ],
    "9GXBY": [
      function (require, module, exports) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = require("c2dffef8c8a7e11e");
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (
            S &&
            typeof (fn = it.toString) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          if (
            typeof (fn = it.valueOf) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          if (
            !S &&
            typeof (fn = it.toString) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      { c2dffef8c8a7e11e: "joZov" },
    ],
    ciJKK: [
      function (require, module, exports) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value,
          };
        };
      },
      {},
    ],
    kcOGE: [
      function (require, module, exports) {
        var global = require("3b38cb7bba0034de");
        var hide = require("37b3e928e2cfb7b2");
        var has = require("bd4fb43c56216f66");
        var SRC = require("47999eeb3f9b97e1")("src");
        var $toString = require("212e71942acb17f");
        var TO_STRING = "toString";
        var TPL = ("" + $toString).split(TO_STRING);
        require("bd522f9ac2f77541").inspectSource = function (it) {
          return $toString.call(it);
        };
        (module.exports = function (O, key, val, safe) {
          var isFunction = typeof val == "function";
          if (isFunction) has(val, "name") || hide(val, "name", key);
          if (O[key] === val) return;
          if (isFunction)
            has(val, SRC) ||
              hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
          if (O === global) O[key] = val;
          else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) O[key] = val;
          else hide(O, key, val);
          // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, TO_STRING, function toString() {
          return (
            (typeof this == "function" && this[SRC]) || $toString.call(this)
          );
        });
      },
      {
        "3b38cb7bba0034de": "c0KvC",
        "37b3e928e2cfb7b2": "4uQIf",
        bd4fb43c56216f66: "jnyQA",
        "47999eeb3f9b97e1": "8b505",
        "212e71942acb17f": "97J8k",
        bd522f9ac2f77541: "8jGrK",
      },
    ],
    "8b505": [
      function (require, module, exports) {
        var id = 0;
        var px = Math.random();
        module.exports = function (key) {
          return "Symbol(".concat(
            key === undefined ? "" : key,
            ")_",
            (++id + px).toString(36),
          );
        };
      },
      {},
    ],
    "97J8k": [
      function (require, module, exports) {
        module.exports = require("a0b71ba6307b2840")(
          "native-function-to-string",
          Function.toString,
        );
      },
      { a0b71ba6307b2840: "6xxwM" },
    ],
    "6xxwM": [
      function (require, module, exports) {
        var core = require("90e03ff0cf1ea41f");
        var global = require("61da234d01f94041");
        var SHARED = "__core-js_shared__";
        var store = global[SHARED] || (global[SHARED] = {});
        (module.exports = function (key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })("versions", []).push({
          version: core.version,
          mode: require("25c466c2e133b76a") ? "pure" : "global",
          copyright: "\xa9 2020 Denis Pushkarev (zloirock.ru)",
        });
      },
      {
        "90e03ff0cf1ea41f": "8jGrK",
        "61da234d01f94041": "c0KvC",
        "25c466c2e133b76a": "4YPyS",
      },
    ],
    "4YPyS": [
      function (require, module, exports) {
        module.exports = false;
      },
      {},
    ],
    gpAgQ: [
      function (require, module, exports) {
        // optional / simple context binding
        var aFunction = require("2e030b8cbf2f950a");
        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };
            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function () {
            return fn.apply(that, arguments);
          };
        };
      },
      { "2e030b8cbf2f950a": "7M8Zs" },
    ],
    "7M8Zs": [
      function (require, module, exports) {
        module.exports = function (it) {
          if (typeof it != "function")
            throw TypeError(it + " is not a function!");
          return it;
        };
      },
      {},
    ],
    jIXDG: [
      function (require, module, exports) {
        var META = require("40ec7f2c81fb4198")("meta");
        var isObject = require("498c38da4bdfa764");
        var has = require("d90706b349d15293");
        var setDesc = require("857af6be1be64bb4").f;
        var id = 0;
        var isExtensible =
          Object.isExtensible ||
          function () {
            return true;
          };
        var FREEZE = !require("24f6d71b7063add0")(function () {
          return isExtensible(Object.preventExtensions({}));
        });
        var setMeta = function (it) {
          setDesc(it, META, {
            value: {
              i: "O" + ++id,
              w: {}, // weak collections IDs
            },
          });
        };
        var fastKey = function (it, create) {
          // return primitive with prefix
          if (!isObject(it))
            return typeof it == "symbol"
              ? it
              : (typeof it == "string" ? "S" : "P") + it;
          if (!has(it, META)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return "F";
            // not necessary to add metadata
            if (!create) return "E";
            // add missing metadata
            setMeta(it);
            // return object ID
          }
          return it[META].i;
        };
        var getWeak = function (it, create) {
          if (!has(it, META)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return true;
            // not necessary to add metadata
            if (!create) return false;
            // add missing metadata
            setMeta(it);
            // return hash weak collections IDs
          }
          return it[META].w;
        };
        // add metadata on freeze-family methods calling
        var onFreeze = function (it) {
          if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
            setMeta(it);
          return it;
        };
        var meta = (module.exports = {
          KEY: META,
          NEED: false,
          fastKey: fastKey,
          getWeak: getWeak,
          onFreeze: onFreeze,
        });
      },
      {
        "40ec7f2c81fb4198": "8b505",
        "498c38da4bdfa764": "joZov",
        d90706b349d15293: "jnyQA",
        "857af6be1be64bb4": "evkkn",
        "24f6d71b7063add0": "jYBY4",
      },
    ],
    eBrgu: [
      function (require, module, exports) {
        var def = require("55a39bb0862b6531").f;
        var has = require("a1951599cc84354c");
        var TAG = require("4639ea2dcb5eafaa")("toStringTag");
        module.exports = function (it, tag, stat) {
          if (it && !has((it = stat ? it : it.prototype), TAG))
            def(it, TAG, {
              configurable: true,
              value: tag,
            });
        };
      },
      {
        "55a39bb0862b6531": "evkkn",
        a1951599cc84354c: "jnyQA",
        "4639ea2dcb5eafaa": "ea5XI",
      },
    ],
    ea5XI: [
      function (require, module, exports) {
        var store = require("e78351b80ca7a00")("wks");
        var uid = require("e20147c7312d8aa4");
        var Symbol = require("9e2a9103e3f66d3e").Symbol;
        var USE_SYMBOL = typeof Symbol == "function";
        var $exports = (module.exports = function (name) {
          return (
            store[name] ||
            (store[name] =
              (USE_SYMBOL && Symbol[name]) ||
              (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
          );
        });
        $exports.store = store;
      },
      {
        e78351b80ca7a00: "6xxwM",
        e20147c7312d8aa4: "8b505",
        "9e2a9103e3f66d3e": "c0KvC",
      },
    ],
    fAFfy: [
      function (require, module, exports) {
        exports.f = require("e310a3bb0fc3f9e2");
      },
      { e310a3bb0fc3f9e2: "ea5XI" },
    ],
    fqXKV: [
      function (require, module, exports) {
        var global = require("7cbf62177fb21053");
        var core = require("257cd460035f5963");
        var LIBRARY = require("28311ba0defda054");
        var wksExt = require("e8d1f29c1f3cf4c3");
        var defineProperty = require("90cac1157dd94c90").f;
        module.exports = function (name) {
          var $Symbol =
            core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
          if (name.charAt(0) != "_" && !(name in $Symbol))
            defineProperty($Symbol, name, {
              value: wksExt.f(name),
            });
        };
      },
      {
        "7cbf62177fb21053": "c0KvC",
        "257cd460035f5963": "8jGrK",
        "28311ba0defda054": "4YPyS",
        e8d1f29c1f3cf4c3: "fAFfy",
        "90cac1157dd94c90": "evkkn",
      },
    ],
    bfkd5: [
      function (require, module, exports) {
        // all enumerable object keys, includes symbols
        var getKeys = require("19eabddac6af80db");
        var gOPS = require("bee3be4f84873a98");
        var pIE = require("d89a9e019c1538ac");
        module.exports = function (it) {
          var result = getKeys(it);
          var getSymbols = gOPS.f;
          if (getSymbols) {
            var symbols = getSymbols(it);
            var isEnum = pIE.f;
            var i = 0;
            var key;
            while (symbols.length > i)
              if (isEnum.call(it, (key = symbols[i++]))) result.push(key);
          }
          return result;
        };
      },
      {
        "19eabddac6af80db": "ctfEa",
        bee3be4f84873a98: "b0BO3",
        d89a9e019c1538ac: "aCVNF",
      },
    ],
    ctfEa: [
      function (require, module, exports) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = require("859364a8448e5180");
        var enumBugKeys = require("d512a3fad33f1923");
        module.exports =
          Object.keys ||
          function keys(O) {
            return $keys(O, enumBugKeys);
          };
      },
      { "859364a8448e5180": "Md9PG", d512a3fad33f1923: "gkkBT" },
    ],
    Md9PG: [
      function (require, module, exports) {
        var has = require("c45bd25336764313");
        var toIObject = require("8822f3b74e600abc");
        var arrayIndexOf = require("bb4e5f9e6db0d166")(false);
        var IE_PROTO = require("a4a9e66f2bae18ba")("IE_PROTO");
        module.exports = function (object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
          // Don't enum bug & hidden keys
          while (names.length > i)
            if (has(O, (key = names[i++])))
              ~arrayIndexOf(result, key) || result.push(key);
          return result;
        };
      },
      {
        c45bd25336764313: "jnyQA",
        "8822f3b74e600abc": "ibyad",
        bb4e5f9e6db0d166: "1pIJc",
        a4a9e66f2bae18ba: "4hmXj",
      },
    ],
    ibyad: [
      function (require, module, exports) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = require("408d3ef1b927c5b3");
        var defined = require("1004f8fa2c8f7708");
        module.exports = function (it) {
          return IObject(defined(it));
        };
      },
      { "408d3ef1b927c5b3": "b1FtL", "1004f8fa2c8f7708": "ic3CF" },
    ],
    b1FtL: [
      function (require, module, exports) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = require("d1c5bff517d41312");
        // eslint-disable-next-line no-prototype-builtins
        module.exports = Object("z").propertyIsEnumerable(0)
          ? Object
          : function (it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
      },
      { d1c5bff517d41312: "8ezVG" },
    ],
    "8ezVG": [
      function (require, module, exports) {
        var toString = {}.toString;
        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };
      },
      {},
    ],
    ic3CF: [
      function (require, module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };
      },
      {},
    ],
    "1pIJc": [
      function (require, module, exports) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = require("9102db37e977ba53");
        var toLength = require("dcdce2a1878188ff");
        var toAbsoluteIndex = require("e523ffa8fd6bf25e");
        module.exports = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
              }
            else
              for (; length > index; index++)
                if (IS_INCLUDES || index in O) {
                  if (O[index] === el) return IS_INCLUDES || index || 0;
                }
            return !IS_INCLUDES && -1;
          };
        };
      },
      {
        "9102db37e977ba53": "ibyad",
        dcdce2a1878188ff: "kGg3g",
        e523ffa8fd6bf25e: "N3OwE",
      },
    ],
    kGg3g: [
      function (require, module, exports) {
        // 7.1.15 ToLength
        var toInteger = require("17c0b90d6beef225");
        var min = Math.min;
        module.exports = function (it) {
          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };
      },
      { "17c0b90d6beef225": "jmpId" },
    ],
    jmpId: [
      function (require, module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;
        module.exports = function (it) {
          return isNaN((it = +it)) ? 0 : (it > 0 ? floor : ceil)(it);
        };
      },
      {},
    ],
    N3OwE: [
      function (require, module, exports) {
        var toInteger = require("a5d5a32b7ecbc6aa");
        var max = Math.max;
        var min = Math.min;
        module.exports = function (index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
      },
      { a5d5a32b7ecbc6aa: "jmpId" },
    ],
    "4hmXj": [
      function (require, module, exports) {
        var shared = require("4d446900c2a89897")("keys");
        var uid = require("17ce3fdc25b80ced");
        module.exports = function (key) {
          return shared[key] || (shared[key] = uid(key));
        };
      },
      { "4d446900c2a89897": "6xxwM", "17ce3fdc25b80ced": "8b505" },
    ],
    gkkBT: [
      function (require, module, exports) {
        // IE 8- don't enum bug keys
        module.exports =
          "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
            ",",
          );
      },
      {},
    ],
    b0BO3: [
      function (require, module, exports) {
        exports.f = Object.getOwnPropertySymbols;
      },
      {},
    ],
    aCVNF: [
      function (require, module, exports) {
        exports.f = {}.propertyIsEnumerable;
      },
      {},
    ],
    "3C2EA": [
      function (require, module, exports) {
        // 7.2.2 IsArray(argument)
        var cof = require("810608961fbe02d7");
        module.exports =
          Array.isArray ||
          function isArray(arg) {
            return cof(arg) == "Array";
          };
      },
      { "810608961fbe02d7": "8ezVG" },
    ],
    dZ3od: [
      function (require, module, exports) {
        // 7.1.13 ToObject(argument)
        var defined = require("3092c9db3e303294");
        module.exports = function (it) {
          return Object(defined(it));
        };
      },
      { "3092c9db3e303294": "ic3CF" },
    ],
    "2DOWX": [
      function (require, module, exports) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = require("4617c70783084bb1");
        var dPs = require("85be686972b680f0");
        var enumBugKeys = require("1e22a8ce9bab03c7");
        var IE_PROTO = require("4b2ec769884c77a9")("IE_PROTO");
        var Empty = function () {};
        var PROTOTYPE = "prototype";
        // Create object with fake `null` prototype: use iframe Object with cleared prototype
        var createDict = function () {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = require("b8d885c39cc1b809")("iframe");
          var i = enumBugKeys.length;
          var lt = "<";
          var gt = ">";
          var iframeDocument;
          iframe.style.display = "none";
          require("75dbd6551c27098b").appendChild(iframe);
          iframe.src = "javascript:"; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(
            lt + "script" + gt + "document.F=Object" + lt + "/script" + gt,
          );
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
          return createDict();
        };
        module.exports =
          Object.create ||
          function create(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              // add "__proto__" for Object.getPrototypeOf polyfill
              result[IE_PROTO] = O;
            } else result = createDict();
            return Properties === undefined ? result : dPs(result, Properties);
          };
      },
      {
        "4617c70783084bb1": "dkWKr",
        "85be686972b680f0": "4jAtG",
        "1e22a8ce9bab03c7": "gkkBT",
        "4b2ec769884c77a9": "4hmXj",
        b8d885c39cc1b809: "kIGVy",
        "75dbd6551c27098b": "lqTMW",
      },
    ],
    "4jAtG": [
      function (require, module, exports) {
        var dP = require("407d4ac4a36f7348");
        var anObject = require("75862e41d726d770");
        var getKeys = require("9dfe6dff952a669c");
        module.exports = require("d9decc63dcf66a12")
          ? Object.defineProperties
          : function defineProperties(O, Properties) {
              anObject(O);
              var keys = getKeys(Properties);
              var length = keys.length;
              var i = 0;
              var P;
              while (length > i) dP.f(O, (P = keys[i++]), Properties[P]);
              return O;
            };
      },
      {
        "407d4ac4a36f7348": "evkkn",
        "75862e41d726d770": "dkWKr",
        "9dfe6dff952a669c": "ctfEa",
        d9decc63dcf66a12: "4XHXy",
      },
    ],
    lqTMW: [
      function (require, module, exports) {
        var document = require("4f8d3f9801bd0f96").document;
        module.exports = document && document.documentElement;
      },
      { "4f8d3f9801bd0f96": "c0KvC" },
    ],
    bCUnj: [
      function (require, module, exports) {
        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = require("93a0f28c806a24f7");
        var gOPN = require("9cfaeaa18db857b6").f;
        var toString = {}.toString;
        var windowNames =
          typeof window == "object" && window && Object.getOwnPropertyNames
            ? Object.getOwnPropertyNames(window)
            : [];
        var getWindowNames = function (it) {
          try {
            return gOPN(it);
          } catch (e) {
            return windowNames.slice();
          }
        };
        module.exports.f = function getOwnPropertyNames(it) {
          return windowNames && toString.call(it) == "[object Window]"
            ? getWindowNames(it)
            : gOPN(toIObject(it));
        };
      },
      { "93a0f28c806a24f7": "ibyad", "9cfaeaa18db857b6": "aij03" },
    ],
    aij03: [
      function (require, module, exports) {
        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = require("6c98bd335a7830ac");
        var hiddenKeys = require("e09697e9394b5f2a").concat(
          "length",
          "prototype",
        );
        exports.f =
          Object.getOwnPropertyNames ||
          function getOwnPropertyNames(O) {
            return $keys(O, hiddenKeys);
          };
      },
      { "6c98bd335a7830ac": "Md9PG", e09697e9394b5f2a: "gkkBT" },
    ],
    jfoaU: [
      function (require, module, exports) {
        var pIE = require("fd1b5a26bb2c0e5f");
        var createDesc = require("dc68fcbccaf4b5df");
        var toIObject = require("18a60dbcde707e61");
        var toPrimitive = require("c8c4f6acaf89a23b");
        var has = require("c0ece5d430274844");
        var IE8_DOM_DEFINE = require("402f4e06b21571b");
        var gOPD = Object.getOwnPropertyDescriptor;
        exports.f = require("3324c2c2db82d382")
          ? gOPD
          : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE)
                try {
                  return gOPD(O, P);
                } catch (e) {}
              if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
            };
      },
      {
        fd1b5a26bb2c0e5f: "aCVNF",
        dc68fcbccaf4b5df: "ciJKK",
        "18a60dbcde707e61": "ibyad",
        c8c4f6acaf89a23b: "9GXBY",
        c0ece5d430274844: "jnyQA",
        "402f4e06b21571b": "2x7l9",
        "3324c2c2db82d382": "4XHXy",
      },
    ],
    "1lOlG": [
      function (require, module, exports) {
        var $export = require("9ebe9310a792cb87");
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, "Object", {
          create: require("85f74a50eb219ab3"),
        });
      },
      { "9ebe9310a792cb87": "77Dy0", "85f74a50eb219ab3": "2DOWX" },
    ],
    K4v28: [
      function (require, module, exports) {
        var $export = require("37e5a0cd377c9119");
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export(
          $export.S + $export.F * !require("a30d4bb83fa8bea3"),
          "Object",
          {
            defineProperty: require("3b8bb011254b1409").f,
          },
        );
      },
      {
        "37e5a0cd377c9119": "77Dy0",
        a30d4bb83fa8bea3: "4XHXy",
        "3b8bb011254b1409": "evkkn",
      },
    ],
    h4iD6: [
      function (require, module, exports) {
        var $export = require("95afda302b6ce13e");
        // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
        $export(
          $export.S + $export.F * !require("54faafcd67782ce3"),
          "Object",
          {
            defineProperties: require("ed849a5ff0cd12e2"),
          },
        );
      },
      {
        "95afda302b6ce13e": "77Dy0",
        "54faafcd67782ce3": "4XHXy",
        ed849a5ff0cd12e2: "4jAtG",
      },
    ],
    jtaJZ: [
      function (require, module, exports) {
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        var toIObject = require("811516b4bf2b4389");
        var $getOwnPropertyDescriptor = require("b9e11a348001dfba").f;
        require("318b94e77dceebe8")("getOwnPropertyDescriptor", function () {
          return function getOwnPropertyDescriptor(it, key) {
            return $getOwnPropertyDescriptor(toIObject(it), key);
          };
        });
      },
      {
        "811516b4bf2b4389": "ibyad",
        b9e11a348001dfba: "jfoaU",
        "318b94e77dceebe8": "jpN4d",
      },
    ],
    jpN4d: [
      function (require, module, exports) {
        // most Object methods by ES6 should accept primitives
        var $export = require("fbf6f83c4835eaa2");
        var core = require("3fc2bee74dbdf791");
        var fails = require("57ca248372a05587");
        module.exports = function (KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export(
            $export.S +
              $export.F *
                fails(function () {
                  fn(1);
                }),
            "Object",
            exp,
          );
        };
      },
      {
        fbf6f83c4835eaa2: "77Dy0",
        "3fc2bee74dbdf791": "8jGrK",
        "57ca248372a05587": "jYBY4",
      },
    ],
    e59Bp: [
      function (require, module, exports) {
        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = require("369e7fd1d63d16dc");
        var $getPrototypeOf = require("6416d553cdd5a3c6");
        require("ca593de26192c17e")("getPrototypeOf", function () {
          return function getPrototypeOf(it) {
            return $getPrototypeOf(toObject(it));
          };
        });
      },
      {
        "369e7fd1d63d16dc": "dZ3od",
        "6416d553cdd5a3c6": "gQspV",
        ca593de26192c17e: "jpN4d",
      },
    ],
    gQspV: [
      function (require, module, exports) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = require("4fae79477f425941");
        var toObject = require("a236a6adb76097");
        var IE_PROTO = require("e660e579f34812e3")("IE_PROTO");
        var ObjectProto = Object.prototype;
        module.exports =
          Object.getPrototypeOf ||
          function (O) {
            O = toObject(O);
            if (has(O, IE_PROTO)) return O[IE_PROTO];
            if (
              typeof O.constructor == "function" &&
              O instanceof O.constructor
            )
              return O.constructor.prototype;
            return O instanceof Object ? ObjectProto : null;
          };
      },
      {
        "4fae79477f425941": "jnyQA",
        a236a6adb76097: "dZ3od",
        e660e579f34812e3: "4hmXj",
      },
    ],
    "1vpnn": [
      function (require, module, exports) {
        // 19.1.2.14 Object.keys(O)
        var toObject = require("def436ecc6becd2");
        var $keys = require("78e0ff6cb72a6834");
        require("7ea1d86a64a64fc")("keys", function () {
          return function keys(it) {
            return $keys(toObject(it));
          };
        });
      },
      {
        def436ecc6becd2: "dZ3od",
        "78e0ff6cb72a6834": "ctfEa",
        "7ea1d86a64a64fc": "jpN4d",
      },
    ],
    "35CNG": [
      function (require, module, exports) {
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        require("978c006860de3ccb")("getOwnPropertyNames", function () {
          return require("103e4da4e89aa3dc").f;
        });
      },
      { "978c006860de3ccb": "jpN4d", "103e4da4e89aa3dc": "bCUnj" },
    ],
    didx1: [
      function (require, module, exports) {
        // 19.1.2.5 Object.freeze(O)
        var isObject = require("e1efff903ce0ec51");
        var meta = require("2d0b8c0365cea10b").onFreeze;
        require("2d6b746ec2a926e6")("freeze", function ($freeze) {
          return function freeze(it) {
            return $freeze && isObject(it) ? $freeze(meta(it)) : it;
          };
        });
      },
      {
        e1efff903ce0ec51: "joZov",
        "2d0b8c0365cea10b": "jIXDG",
        "2d6b746ec2a926e6": "jpN4d",
      },
    ],
    ej71o: [
      function (require, module, exports) {
        // 19.1.2.17 Object.seal(O)
        var isObject = require("873a4e2ea94640bf");
        var meta = require("113f592dd4d7d4f3").onFreeze;
        require("cb77902ed8b9bea2")("seal", function ($seal) {
          return function seal(it) {
            return $seal && isObject(it) ? $seal(meta(it)) : it;
          };
        });
      },
      {
        "873a4e2ea94640bf": "joZov",
        "113f592dd4d7d4f3": "jIXDG",
        cb77902ed8b9bea2: "jpN4d",
      },
    ],
    "23Wb5": [
      function (require, module, exports) {
        // 19.1.2.15 Object.preventExtensions(O)
        var isObject = require("7a7575df84a1257f");
        var meta = require("5ddd3e63e0d28f2c").onFreeze;
        require("f97c055544c4544f")(
          "preventExtensions",
          function ($preventExtensions) {
            return function preventExtensions(it) {
              return $preventExtensions && isObject(it)
                ? $preventExtensions(meta(it))
                : it;
            };
          },
        );
      },
      {
        "7a7575df84a1257f": "joZov",
        "5ddd3e63e0d28f2c": "jIXDG",
        f97c055544c4544f: "jpN4d",
      },
    ],
    "1Jyce": [
      function (require, module, exports) {
        // 19.1.2.12 Object.isFrozen(O)
        var isObject = require("c710fe12664018c1");
        require("96656e16a05afb2c")("isFrozen", function ($isFrozen) {
          return function isFrozen(it) {
            return isObject(it) ? ($isFrozen ? $isFrozen(it) : false) : true;
          };
        });
      },
      { c710fe12664018c1: "joZov", "96656e16a05afb2c": "jpN4d" },
    ],
    "5i3tk": [
      function (require, module, exports) {
        // 19.1.2.13 Object.isSealed(O)
        var isObject = require("6135908de717e1a1");
        require("a6bf605f71664a2a")("isSealed", function ($isSealed) {
          return function isSealed(it) {
            return isObject(it) ? ($isSealed ? $isSealed(it) : false) : true;
          };
        });
      },
      { "6135908de717e1a1": "joZov", a6bf605f71664a2a: "jpN4d" },
    ],
    cP6Fy: [
      function (require, module, exports) {
        // 19.1.2.11 Object.isExtensible(O)
        var isObject = require("dae0c7930f1d730c");
        require("3293ec9ed70a0946")("isExtensible", function ($isExtensible) {
          return function isExtensible(it) {
            return isObject(it)
              ? $isExtensible
                ? $isExtensible(it)
                : true
              : false;
          };
        });
      },
      { dae0c7930f1d730c: "joZov", "3293ec9ed70a0946": "jpN4d" },
    ],
    "6Fo0t": [
      function (require, module, exports) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = require("63d783e795dc8ec0");
        $export($export.S + $export.F, "Object", {
          assign: require("b1828629707a7120"),
        });
      },
      { "63d783e795dc8ec0": "77Dy0", b1828629707a7120: "godd7" },
    ],
    godd7: [
      function (require, module, exports) {
        "use strict";
        // 19.1.2.1 Object.assign(target, source, ...)
        var DESCRIPTORS = require("40ea79cd2418bdbf");
        var getKeys = require("fd0fd04e4aa8cb04");
        var gOPS = require("2f52daf0ae926e81");
        var pIE = require("b9e3af94c4af105c");
        var toObject = require("6ed4c3a202624511");
        var IObject = require("db3dec3cc1346665");
        var $assign = Object.assign;
        // should work with symbols and should have deterministic property order (V8 bug)
        module.exports =
          !$assign ||
          require("4d3c729d6715d4d2")(function () {
            var A = {};
            var B = {};
            // eslint-disable-next-line no-undef
            var S = Symbol();
            var K = "abcdefghijklmnopqrst";
            A[S] = 7;
            K.split("").forEach(function (k) {
              B[k] = k;
            });
            return (
              $assign({}, A)[S] != 7 ||
              Object.keys($assign({}, B)).join("") != K
            );
          })
            ? function assign(target, source) {
                var T = toObject(target);
                var aLen = arguments.length;
                var index = 1;
                var getSymbols = gOPS.f;
                var isEnum = pIE.f;
                while (aLen > index) {
                  var S = IObject(arguments[index++]);
                  var keys = getSymbols
                    ? getKeys(S).concat(getSymbols(S))
                    : getKeys(S);
                  var length = keys.length;
                  var j = 0;
                  var key;
                  while (length > j) {
                    key = keys[j++];
                    if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
                  }
                }
                return T;
              }
            : $assign;
      },
      {
        "40ea79cd2418bdbf": "4XHXy",
        fd0fd04e4aa8cb04: "ctfEa",
        "2f52daf0ae926e81": "b0BO3",
        b9e3af94c4af105c: "aCVNF",
        "6ed4c3a202624511": "dZ3od",
        db3dec3cc1346665: "b1FtL",
        "4d3c729d6715d4d2": "jYBY4",
      },
    ],
    "3Pmt8": [
      function (require, module, exports) {
        // 19.1.3.10 Object.is(value1, value2)
        var $export = require("fd4d39b2fdd9b662");
        $export($export.S, "Object", {
          is: require("109c149932d2630e"),
        });
      },
      { fd4d39b2fdd9b662: "77Dy0", "109c149932d2630e": "2xNNp" },
    ],
    "2xNNp": [
      function (require, module, exports) {
        // 7.2.9 SameValue(x, y)
        module.exports =
          Object.is ||
          function is(x, y) {
            // eslint-disable-next-line no-self-compare
            return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
          };
      },
      {},
    ],
    k3ks5: [
      function (require, module, exports) {
        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = require("a3c919a11af312d5");
        $export($export.S, "Object", {
          setPrototypeOf: require("3317f621449ee075").set,
        });
      },
      { a3c919a11af312d5: "77Dy0", "3317f621449ee075": "3XLh5" },
    ],
    "3XLh5": [
      function (require, module, exports) {
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */ var isObject = require("c46dcbd09e2c6b5e");
        var anObject = require("f5d8cc09f8eb53ac");
        var check = function (O, proto) {
          anObject(O);
          if (!isObject(proto) && proto !== null)
            throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
          set:
            Object.setPrototypeOf ||
            ("__proto__" in {}
              ? (function (test, buggy, set) {
                  try {
                    set = require("e4b605ca9d898ca")(
                      Function.call,
                      require("7daa7f87680668b2").f(
                        Object.prototype,
                        "__proto__",
                      ).set,
                      2,
                    );
                    set(test, []);
                    buggy = !(test instanceof Array);
                  } catch (e) {
                    buggy = true;
                  }
                  return function setPrototypeOf(O, proto) {
                    check(O, proto);
                    if (buggy) O.__proto__ = proto;
                    else set(O, proto);
                    return O;
                  };
                })({}, false)
              : undefined),
          check: check,
        };
      },
      {
        c46dcbd09e2c6b5e: "joZov",
        f5d8cc09f8eb53ac: "dkWKr",
        e4b605ca9d898ca: "gpAgQ",
        "7daa7f87680668b2": "jfoaU",
      },
    ],
    lwmiM: [
      function (require, module, exports) {
        "use strict";
        // 19.1.3.6 Object.prototype.toString()
        var classof = require("ecad58ed426de04");
        var test = {};
        test[require("fc922552f068b592")("toStringTag")] = "z";
        if (test + "" != "[object z]")
          require("cb31423c92d22864")(
            Object.prototype,
            "toString",
            function toString() {
              return "[object " + classof(this) + "]";
            },
            true,
          );
      },
      {
        ecad58ed426de04: "hCCia",
        fc922552f068b592: "ea5XI",
        cb31423c92d22864: "kcOGE",
      },
    ],
    hCCia: [
      function (require, module, exports) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = require("8c34b60d4bd3561c");
        var TAG = require("7fdc32f7a410c8b9")("toStringTag");
        // ES3 wrong here
        var ARG =
          cof(
            (function () {
              return arguments;
            })(),
          ) == "Arguments";
        // fallback for IE11 Script Access Denied error
        var tryGet = function (it, key) {
          try {
            return it[key];
          } catch (e) {}
        };
        module.exports = function (it) {
          var O, T, B;
          return it === undefined
            ? "Undefined"
            : it === null
            ? "Null"
            : typeof (T = tryGet((O = Object(it)), TAG)) == "string"
            ? T
            : ARG
            ? cof(O)
            : (B = cof(O)) == "Object" && typeof O.callee == "function"
            ? "Arguments"
            : B;
        };
      },
      { "8c34b60d4bd3561c": "8ezVG", "7fdc32f7a410c8b9": "ea5XI" },
    ],
    bX4FS: [
      function (require, module, exports) {
        // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
        var $export = require("518fae11946baddf");
        $export($export.P, "Function", {
          bind: require("4da8833989776e2"),
        });
      },
      { "518fae11946baddf": "77Dy0", "4da8833989776e2": "7iPYO" },
    ],
    "7iPYO": [
      function (require, module, exports) {
        "use strict";
        var aFunction = require("eec3385b1552f08a");
        var isObject = require("a6672627a885ae50");
        var invoke = require("c6d3dcb95bfb4755");
        var arraySlice = [].slice;
        var factories = {};
        var construct = function (F, len, args) {
          if (!(len in factories)) {
            for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
            // eslint-disable-next-line no-new-func
            factories[len] = Function(
              "F,a",
              "return new F(" + n.join(",") + ")",
            );
          }
          return factories[len](F, args);
        };
        module.exports =
          Function.bind ||
          function bind(that /* , ...args */) {
            var fn = aFunction(this);
            var partArgs = arraySlice.call(arguments, 1);
            var bound = function () {
              var args = partArgs.concat(arraySlice.call(arguments));
              return this instanceof bound
                ? construct(fn, args.length, args)
                : invoke(fn, args, that);
            };
            if (isObject(fn.prototype)) bound.prototype = fn.prototype;
            return bound;
          };
      },
      {
        eec3385b1552f08a: "7M8Zs",
        a6672627a885ae50: "joZov",
        c6d3dcb95bfb4755: "7ihys",
      },
    ],
    "7ihys": [
      function (require, module, exports) {
        // fast apply, http://jsperf.lnkit.com/fast-apply/5
        module.exports = function (fn, args, that) {
          var un = that === undefined;
          switch (args.length) {
            case 0:
              return un ? fn() : fn.call(that);
            case 1:
              return un ? fn(args[0]) : fn.call(that, args[0]);
            case 2:
              return un
                ? fn(args[0], args[1])
                : fn.call(that, args[0], args[1]);
            case 3:
              return un
                ? fn(args[0], args[1], args[2])
                : fn.call(that, args[0], args[1], args[2]);
            case 4:
              return un
                ? fn(args[0], args[1], args[2], args[3])
                : fn.call(that, args[0], args[1], args[2], args[3]);
          }
          return fn.apply(that, args);
        };
      },
      {},
    ],
    "7ksV8": [
      function (require, module, exports) {
        var dP = require("8aa6ec813cca2f54").f;
        var FProto = Function.prototype;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = "name";
        // 19.2.4.2 name
        NAME in FProto ||
          (require("eb8ba868a759094e") &&
            dP(FProto, NAME, {
              configurable: true,
              get: function () {
                try {
                  return ("" + this).match(nameRE)[1];
                } catch (e) {
                  return "";
                }
              },
            }));
      },
      { "8aa6ec813cca2f54": "evkkn", eb8ba868a759094e: "4XHXy" },
    ],
    kPhac: [
      function (require, module, exports) {
        "use strict";
        var isObject = require("b49c18ca62b92dc8");
        var getPrototypeOf = require("5fc733d58add8c20");
        var HAS_INSTANCE = require("cc5e8a46953a7d1a")("hasInstance");
        var FunctionProto = Function.prototype;
        // 19.2.3.6 Function.prototype[@@hasInstance](V)
        if (!(HAS_INSTANCE in FunctionProto))
          require("839fa970a9615fa3").f(FunctionProto, HAS_INSTANCE, {
            value: function (O) {
              if (typeof this != "function" || !isObject(O)) return false;
              if (!isObject(this.prototype)) return O instanceof this;
              // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
              while ((O = getPrototypeOf(O)))
                if (this.prototype === O) return true;
              return false;
            },
          });
      },
      {
        b49c18ca62b92dc8: "joZov",
        "5fc733d58add8c20": "gQspV",
        cc5e8a46953a7d1a: "ea5XI",
        "839fa970a9615fa3": "evkkn",
      },
    ],
    "5ZSup": [
      function (require, module, exports) {
        var $export = require("9ebdb4d0e28fe62");
        var $parseInt = require("143e057ab74e7b55");
        // 18.2.5 parseInt(string, radix)
        $export($export.G + $export.F * (parseInt != $parseInt), {
          parseInt: $parseInt,
        });
      },
      { "9ebdb4d0e28fe62": "77Dy0", "143e057ab74e7b55": "erIC3" },
    ],
    erIC3: [
      function (require, module, exports) {
        var $parseInt = require("ed568fd9326d1a95").parseInt;
        var $trim = require("fc13afb5c6a8615e").trim;
        var ws = require("19ac546c198807c9");
        var hex = /^[-+]?0[xX]/;
        module.exports =
          $parseInt(ws + "08") !== 8 || $parseInt(ws + "0x16") !== 22
            ? function parseInt(str, radix) {
                var string = $trim(String(str), 3);
                return $parseInt(
                  string,
                  radix >>> 0 || (hex.test(string) ? 16 : 10),
                );
              }
            : $parseInt;
      },
      {
        ed568fd9326d1a95: "c0KvC",
        fc13afb5c6a8615e: "dkad2",
        "19ac546c198807c9": "3jmGB",
      },
    ],
    dkad2: [
      function (require, module, exports) {
        var $export = require("3937f110b9ee2988");
        var defined = require("84e2102cc91d3ddd");
        var fails = require("a5e716b40d96272f");
        var spaces = require("eb8c5ae89a09ec39");
        var space = "[" + spaces + "]";
        var non = "\u200B\x85";
        var ltrim = RegExp("^" + space + space + "*");
        var rtrim = RegExp(space + space + "*$");
        var exporter = function (KEY, exec, ALIAS) {
          var exp = {};
          var FORCE = fails(function () {
            return !!spaces[KEY]() || non[KEY]() != non;
          });
          var fn = (exp[KEY] = FORCE ? exec(trim) : spaces[KEY]);
          if (ALIAS) exp[ALIAS] = fn;
          $export($export.P + $export.F * FORCE, "String", exp);
        };
        // 1 -> String#trimLeft
        // 2 -> String#trimRight
        // 3 -> String#trim
        var trim = (exporter.trim = function (string, TYPE) {
          string = String(defined(string));
          if (TYPE & 1) string = string.replace(ltrim, "");
          if (TYPE & 2) string = string.replace(rtrim, "");
          return string;
        });
        module.exports = exporter;
      },
      {
        "3937f110b9ee2988": "77Dy0",
        "84e2102cc91d3ddd": "ic3CF",
        a5e716b40d96272f: "jYBY4",
        eb8c5ae89a09ec39: "3jmGB",
      },
    ],
    "3jmGB": [
      function (require, module, exports) {
        module.exports =
          "	\n\v\f\r \xa0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
      },
      {},
    ],
    "3QBT2": [
      function (require, module, exports) {
        var $export = require("2437174737b70d58");
        var $parseFloat = require("8208464a6f13c704");
        // 18.2.4 parseFloat(string)
        $export($export.G + $export.F * (parseFloat != $parseFloat), {
          parseFloat: $parseFloat,
        });
      },
      { "2437174737b70d58": "77Dy0", "8208464a6f13c704": "krdpa" },
    ],
    krdpa: [
      function (require, module, exports) {
        var $parseFloat = require("c05ab4e92cdb73f").parseFloat;
        var $trim = require("e43a8d29b7e212c3").trim;
        module.exports =
          1 / $parseFloat(require("2b05be59a0cfac2f") + "-0") !== -Infinity
            ? function parseFloat(str) {
                var string = $trim(String(str), 3);
                var result = $parseFloat(string);
                return result === 0 && string.charAt(0) == "-" ? -0 : result;
              }
            : $parseFloat;
      },
      {
        c05ab4e92cdb73f: "c0KvC",
        e43a8d29b7e212c3: "dkad2",
        "2b05be59a0cfac2f": "3jmGB",
      },
    ],
    "7sYcR": [
      function (require, module, exports) {
        "use strict";
        var global = require("319b9ecfba9d1643");
        var has = require("752de16a6c597ae8");
        var cof = require("f186ba2084220f40");
        var inheritIfRequired = require("9eb8ea98a293a23f");
        var toPrimitive = require("dd163a4956fc83da");
        var fails = require("61a63ce1f7465c97");
        var gOPN = require("1b949ef99478ec11").f;
        var gOPD = require("9a53b22361554d61").f;
        var dP = require("53e618da4b06f84b").f;
        var $trim = require("c1d94aa7258c0026").trim;
        var NUMBER = "Number";
        var $Number = global[NUMBER];
        var Base = $Number;
        var proto = $Number.prototype;
        // Opera ~12 has broken Object#toString
        var BROKEN_COF = cof(require("4731f7201fb3e14f")(proto)) == NUMBER;
        var TRIM = "trim" in String.prototype;
        // 7.1.3 ToNumber(argument)
        var toNumber = function (argument) {
          var it = toPrimitive(argument, false);
          if (typeof it == "string" && it.length > 2) {
            it = TRIM ? it.trim() : $trim(it, 3);
            var first = it.charCodeAt(0);
            var third, radix, maxCode;
            if (first === 43 || first === 45) {
              third = it.charCodeAt(2);
              if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
            } else if (first === 48) {
              switch (it.charCodeAt(1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break; // fast equal /^0b[01]+$/i
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break; // fast equal /^0o[0-7]+$/i
                default:
                  return +it;
              }
              for (
                var digits = it.slice(2), i = 0, l = digits.length, code;
                i < l;
                i++
              ) {
                code = digits.charCodeAt(i);
                // parseInt parses a string to a first unavailable symbol
                // but ToNumber should return NaN if a string contains unavailable symbols
                if (code < 48 || code > maxCode) return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it;
        };
        if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
          $Number = function Number(value) {
            var it = arguments.length < 1 ? 0 : value;
            var that = this;
            return that instanceof $Number &&
              (BROKEN_COF
                ? fails(function () {
                    proto.valueOf.call(that);
                  })
                : cof(that) != NUMBER)
              ? inheritIfRequired(new Base(toNumber(it)), that, $Number)
              : toNumber(it);
          };
          for (
            var keys = require("71e37fe50ad92d73")
                ? gOPN(Base) // ES3:
                : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(
                    ",",
                  ),
              j = 0,
              key;
            keys.length > j;
            j++
          )
            if (has(Base, (key = keys[j])) && !has($Number, key))
              dP($Number, key, gOPD(Base, key));
          $Number.prototype = proto;
          proto.constructor = $Number;
          require("63a513ad59947408")(global, NUMBER, $Number);
        }
      },
      {
        "319b9ecfba9d1643": "c0KvC",
        "752de16a6c597ae8": "jnyQA",
        f186ba2084220f40: "8ezVG",
        "9eb8ea98a293a23f": "gjUNA",
        dd163a4956fc83da: "9GXBY",
        "61a63ce1f7465c97": "jYBY4",
        "1b949ef99478ec11": "aij03",
        "9a53b22361554d61": "jfoaU",
        "53e618da4b06f84b": "evkkn",
        c1d94aa7258c0026: "dkad2",
        "4731f7201fb3e14f": "2DOWX",
        "71e37fe50ad92d73": "4XHXy",
        "63a513ad59947408": "kcOGE",
      },
    ],
    gjUNA: [
      function (require, module, exports) {
        var isObject = require("7932868a4d256c22");
        var setPrototypeOf = require("7a5341a2ef040082").set;
        module.exports = function (that, target, C) {
          var S = target.constructor;
          var P;
          if (
            S !== C &&
            typeof S == "function" &&
            (P = S.prototype) !== C.prototype &&
            isObject(P) &&
            setPrototypeOf
          )
            setPrototypeOf(that, P);
          return that;
        };
      },
      { "7932868a4d256c22": "joZov", "7a5341a2ef040082": "3XLh5" },
    ],
    RVyCT: [
      function (require, module, exports) {
        "use strict";
        var $export = require("9a6c25903ec29f7e");
        var toInteger = require("4f7c71813e809df8");
        var aNumberValue = require("86fc48a383c0d06f");
        var repeat = require("cb70e5590795f18a");
        var $toFixed = (1.0).toFixed;
        var floor = Math.floor;
        var data = [0, 0, 0, 0, 0, 0];
        var ERROR = "Number.toFixed: incorrect invocation!";
        var ZERO = "0";
        var multiply = function (n, c) {
          var i = -1;
          var c2 = c;
          while (++i < 6) {
            c2 += n * data[i];
            data[i] = c2 % 1e7;
            c2 = floor(c2 / 1e7);
          }
        };
        var divide = function (n) {
          var i = 6;
          var c = 0;
          while (--i >= 0) {
            c += data[i];
            data[i] = floor(c / n);
            c = (c % n) * 1e7;
          }
        };
        var numToString = function () {
          var i = 6;
          var s = "";
          while (--i >= 0)
            if (s !== "" || i === 0 || data[i] !== 0) {
              var t = String(data[i]);
              s = s === "" ? t : s + repeat.call(ZERO, 7 - t.length) + t;
            }
          return s;
        };
        var pow = function (x, n, acc) {
          return n === 0
            ? acc
            : n % 2 === 1
            ? pow(x, n - 1, acc * x)
            : pow(x * x, n / 2, acc);
        };
        var log = function (x) {
          var n = 0;
          var x2 = x;
          while (x2 >= 4096) {
            n += 12;
            x2 /= 4096;
          }
          while (x2 >= 2) {
            n += 1;
            x2 /= 2;
          }
          return n;
        };
        $export(
          $export.P +
            $export.F *
              ((!!$toFixed &&
                ((0.00008).toFixed(3) !== "0.000" ||
                  (0.9).toFixed(0) !== "1" ||
                  (1.255).toFixed(2) !== "1.25" ||
                  (1000000000000000128.0).toFixed(0) !==
                    "1000000000000000128")) ||
                !require("59c264088c85660f")(function () {
                  // V8 ~ Android 4.3-
                  $toFixed.call({});
                })),
          "Number",
          {
            toFixed: function toFixed(fractionDigits) {
              var x = aNumberValue(this, ERROR);
              var f = toInteger(fractionDigits);
              var s = "";
              var m = ZERO;
              var e, z, j, k;
              if (f < 0 || f > 20) throw RangeError(ERROR);
              // eslint-disable-next-line no-self-compare
              if (x != x) return "NaN";
              if (x <= -1000000000000000000000 || x >= 1e21) return String(x);
              if (x < 0) {
                s = "-";
                x = -x;
              }
              if (x > 1e-21) {
                e = log(x * pow(2, 69, 1)) - 69;
                z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
                z *= 0x10000000000000;
                e = 52 - e;
                if (e > 0) {
                  multiply(0, z);
                  j = f;
                  while (j >= 7) {
                    multiply(1e7, 0);
                    j -= 7;
                  }
                  multiply(pow(10, j, 1), 0);
                  j = e - 1;
                  while (j >= 23) {
                    divide(8388608);
                    j -= 23;
                  }
                  divide(1 << j);
                  multiply(1, 1);
                  divide(2);
                  m = numToString();
                } else {
                  multiply(0, z);
                  multiply(1 << -e, 0);
                  m = numToString() + repeat.call(ZERO, f);
                }
              }
              if (f > 0) {
                k = m.length;
                m =
                  s +
                  (k <= f
                    ? "0." + repeat.call(ZERO, f - k) + m
                    : m.slice(0, k - f) + "." + m.slice(k - f));
              } else m = s + m;
              return m;
            },
          },
        );
      },
      {
        "9a6c25903ec29f7e": "77Dy0",
        "4f7c71813e809df8": "jmpId",
        "86fc48a383c0d06f": "gqTu5",
        cb70e5590795f18a: "hUJ09",
        "59c264088c85660f": "jYBY4",
      },
    ],
    gqTu5: [
      function (require, module, exports) {
        var cof = require("f4a5c83860d51e78");
        module.exports = function (it, msg) {
          if (typeof it != "number" && cof(it) != "Number")
            throw TypeError(msg);
          return +it;
        };
      },
      { f4a5c83860d51e78: "8ezVG" },
    ],
    hUJ09: [
      function (require, module, exports) {
        "use strict";
        var toInteger = require("5c7693adc692fa15");
        var defined = require("22b71e751d611e73");
        module.exports = function repeat(count) {
          var str = String(defined(this));
          var res = "";
          var n = toInteger(count);
          if (n < 0 || n == Infinity)
            throw RangeError("Count can't be negative");
          for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
          return res;
        };
      },
      { "5c7693adc692fa15": "jmpId", "22b71e751d611e73": "ic3CF" },
    ],
    "6e1J6": [
      function (require, module, exports) {
        "use strict";
        var $export = require("c4d6bbb4e2a9efa7");
        var $fails = require("a32b046865b8bbf0");
        var aNumberValue = require("1eb80c9641112793");
        var $toPrecision = (1.0).toPrecision;
        $export(
          $export.P +
            $export.F *
              ($fails(function () {
                // IE7-
                return $toPrecision.call(1, undefined) !== "1";
              }) ||
                !$fails(function () {
                  // V8 ~ Android 4.3-
                  $toPrecision.call({});
                })),
          "Number",
          {
            toPrecision: function toPrecision(precision) {
              var that = aNumberValue(
                this,
                "Number#toPrecision: incorrect invocation!",
              );
              return precision === undefined
                ? $toPrecision.call(that)
                : $toPrecision.call(that, precision);
            },
          },
        );
      },
      {
        c4d6bbb4e2a9efa7: "77Dy0",
        a32b046865b8bbf0: "jYBY4",
        "1eb80c9641112793": "gqTu5",
      },
    ],
    d1Q1g: [
      function (require, module, exports) {
        // 20.1.2.1 Number.EPSILON
        var $export = require("6b6cca589b7b06bc");
        $export($export.S, "Number", {
          EPSILON: Math.pow(2, -52),
        });
      },
      { "6b6cca589b7b06bc": "77Dy0" },
    ],
    "7pnki": [
      function (require, module, exports) {
        // 20.1.2.2 Number.isFinite(number)
        var $export = require("6ae6983b0119d83c");
        var _isFinite = require("5b74e33a67966900").isFinite;
        $export($export.S, "Number", {
          isFinite: function isFinite(it) {
            return typeof it == "number" && _isFinite(it);
          },
        });
      },
      { "6ae6983b0119d83c": "77Dy0", "5b74e33a67966900": "c0KvC" },
    ],
    "5UTe3": [
      function (require, module, exports) {
        // 20.1.2.3 Number.isInteger(number)
        var $export = require("2a44588f16863d30");
        $export($export.S, "Number", {
          isInteger: require("b2072703045af366"),
        });
      },
      { "2a44588f16863d30": "77Dy0", b2072703045af366: "bOhY1" },
    ],
    bOhY1: [
      function (require, module, exports) {
        // 20.1.2.3 Number.isInteger(number)
        var isObject = require("57d4ebbc716c29fe");
        var floor = Math.floor;
        module.exports = function isInteger(it) {
          return !isObject(it) && isFinite(it) && floor(it) === it;
        };
      },
      { "57d4ebbc716c29fe": "joZov" },
    ],
    g6zXU: [
      function (require, module, exports) {
        // 20.1.2.4 Number.isNaN(number)
        var $export = require("b9f7472f1082b365");
        $export($export.S, "Number", {
          isNaN: function isNaN(number) {
            // eslint-disable-next-line no-self-compare
            return number != number;
          },
        });
      },
      { b9f7472f1082b365: "77Dy0" },
    ],
    cS05b: [
      function (require, module, exports) {
        // 20.1.2.5 Number.isSafeInteger(number)
        var $export = require("769b52cd3a839f14");
        var isInteger = require("b369e2952e0f44fc");
        var abs = Math.abs;
        $export($export.S, "Number", {
          isSafeInteger: function isSafeInteger(number) {
            return isInteger(number) && abs(number) <= 0x1fffffffffffff;
          },
        });
      },
      { "769b52cd3a839f14": "77Dy0", b369e2952e0f44fc: "bOhY1" },
    ],
    "365K7": [
      function (require, module, exports) {
        // 20.1.2.6 Number.MAX_SAFE_INTEGER
        var $export = require("495cce916bbeb7bf");
        $export($export.S, "Number", {
          MAX_SAFE_INTEGER: 0x1fffffffffffff,
        });
      },
      { "495cce916bbeb7bf": "77Dy0" },
    ],
    tXAuf: [
      function (require, module, exports) {
        // 20.1.2.10 Number.MIN_SAFE_INTEGER
        var $export = require("f14831559a0e532");
        $export($export.S, "Number", {
          MIN_SAFE_INTEGER: -9007199254740991,
        });
      },
      { f14831559a0e532: "77Dy0" },
    ],
    "7GiWu": [
      function (require, module, exports) {
        var $export = require("2040b21706750d2b");
        var $parseFloat = require("e0405d7dbc157d64");
        // 20.1.2.12 Number.parseFloat(string)
        $export(
          $export.S + $export.F * (Number.parseFloat != $parseFloat),
          "Number",
          {
            parseFloat: $parseFloat,
          },
        );
      },
      { "2040b21706750d2b": "77Dy0", e0405d7dbc157d64: "krdpa" },
    ],
    d0Mpd: [
      function (require, module, exports) {
        var $export = require("1717b8022e7188ee");
        var $parseInt = require("3e9f49d705b659f4");
        // 20.1.2.13 Number.parseInt(string, radix)
        $export(
          $export.S + $export.F * (Number.parseInt != $parseInt),
          "Number",
          {
            parseInt: $parseInt,
          },
        );
      },
      { "1717b8022e7188ee": "77Dy0", "3e9f49d705b659f4": "erIC3" },
    ],
    "4DJ1Q": [
      function (require, module, exports) {
        // 20.2.2.3 Math.acosh(x)
        var $export = require("4e0eb205f8aa901b");
        var log1p = require("8d2e549ee3ad26c4");
        var sqrt = Math.sqrt;
        var $acosh = Math.acosh;
        $export(
          $export.S +
            $export.F *
              !(
                $acosh &&
                Math.floor($acosh(Number.MAX_VALUE)) == 710 &&
                $acosh(Infinity) == Infinity
              ),
          "Math",
          {
            acosh: function acosh(x) {
              return (x = +x) < 1
                ? NaN
                : x > 94906265.62425156
                ? Math.log(x) + Math.LN2
                : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
            },
          },
        );
      },
      { "4e0eb205f8aa901b": "77Dy0", "8d2e549ee3ad26c4": "6yCVf" },
    ],
    "6yCVf": [
      function (require, module, exports) {
        // 20.2.2.20 Math.log1p(x)
        module.exports =
          Math.log1p ||
          function log1p(x) {
            return (x = +x) > -0.00000001 && x < 1e-8
              ? x - (x * x) / 2
              : Math.log(1 + x);
          };
      },
      {},
    ],
    "79F2G": [
      function (require, module, exports) {
        // 20.2.2.5 Math.asinh(x)
        var $export = require("afb72ad7755fbfc3");
        var $asinh = Math.asinh;
        function asinh(x) {
          return !isFinite((x = +x)) || x == 0
            ? x
            : x < 0
            ? -asinh(-x)
            : Math.log(x + Math.sqrt(x * x + 1));
        }
        // Tor Browser bug: Math.asinh(0) -> -0
        $export(
          $export.S + $export.F * !($asinh && 1 / $asinh(0) > 0),
          "Math",
          {
            asinh: asinh,
          },
        );
      },
      { afb72ad7755fbfc3: "77Dy0" },
    ],
    "3eSia": [
      function (require, module, exports) {
        // 20.2.2.7 Math.atanh(x)
        var $export = require("c245557ed8e8cfc6");
        var $atanh = Math.atanh;
        // Tor Browser bug: Math.atanh(-0) -> 0
        $export(
          $export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0),
          "Math",
          {
            atanh: function atanh(x) {
              return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
            },
          },
        );
      },
      { c245557ed8e8cfc6: "77Dy0" },
    ],
    eIazd: [
      function (require, module, exports) {
        // 20.2.2.9 Math.cbrt(x)
        var $export = require("3889be51abb784c9");
        var sign = require("ef4fb053899999f2");
        $export($export.S, "Math", {
          cbrt: function cbrt(x) {
            return sign((x = +x)) * Math.pow(Math.abs(x), 1 / 3);
          },
        });
      },
      { "3889be51abb784c9": "77Dy0", ef4fb053899999f2: "kpCOl" },
    ],
    kpCOl: [
      function (require, module, exports) {
        // 20.2.2.28 Math.sign(x)
        module.exports =
          Math.sign ||
          function sign(x) {
            // eslint-disable-next-line no-self-compare
            return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
          };
      },
      {},
    ],
    "6RDjb": [
      function (require, module, exports) {
        // 20.2.2.11 Math.clz32(x)
        var $export = require("e27effdeeaaaeacc");
        $export($export.S, "Math", {
          clz32: function clz32(x) {
            return (x >>>= 0)
              ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E)
              : 32;
          },
        });
      },
      { e27effdeeaaaeacc: "77Dy0" },
    ],
    "9u062": [
      function (require, module, exports) {
        // 20.2.2.12 Math.cosh(x)
        var $export = require("57f4793d87279b17");
        var exp = Math.exp;
        $export($export.S, "Math", {
          cosh: function cosh(x) {
            return (exp((x = +x)) + exp(-x)) / 2;
          },
        });
      },
      { "57f4793d87279b17": "77Dy0" },
    ],
    bVZP5: [
      function (require, module, exports) {
        // 20.2.2.14 Math.expm1(x)
        var $export = require("d26d32dead94220f");
        var $expm1 = require("231241d4c3782253");
        $export($export.S + $export.F * ($expm1 != Math.expm1), "Math", {
          expm1: $expm1,
        });
      },
      { d26d32dead94220f: "77Dy0", "231241d4c3782253": "h5lWF" },
    ],
    h5lWF: [
      function (require, module, exports) {
        // 20.2.2.14 Math.expm1(x)
        var $expm1 = Math.expm1;
        module.exports =
          !$expm1 ||
          $expm1(10) > 22025.465794806719 ||
          $expm1(10) < 22025.4657948067165168 ||
          $expm1(-0.00000000000000002) != -0.00000000000000002
            ? function expm1(x) {
                return (x = +x) == 0
                  ? x
                  : x > -0.000001 && x < 1e-6
                  ? x + (x * x) / 2
                  : Math.exp(x) - 1;
              }
            : $expm1;
      },
      {},
    ],
    bS2ub: [
      function (require, module, exports) {
        // 20.2.2.16 Math.fround(x)
        var $export = require("b4f84ceb01ccf740");
        $export($export.S, "Math", {
          fround: require("adcfd2b8718fa026"),
        });
      },
      { b4f84ceb01ccf740: "77Dy0", adcfd2b8718fa026: "guqvy" },
    ],
    guqvy: [
      function (require, module, exports) {
        // 20.2.2.16 Math.fround(x)
        var sign = require("a5559b08c34fc8d4");
        var pow = Math.pow;
        var EPSILON = pow(2, -52);
        var EPSILON32 = pow(2, -23);
        var MAX32 = pow(2, 127) * (2 - EPSILON32);
        var MIN32 = pow(2, -126);
        var roundTiesToEven = function (n) {
          return n + 1 / EPSILON - 1 / EPSILON;
        };
        module.exports =
          Math.fround ||
          function fround(x) {
            var $abs = Math.abs(x);
            var $sign = sign(x);
            var a, result;
            if ($abs < MIN32)
              return (
                $sign *
                roundTiesToEven($abs / MIN32 / EPSILON32) *
                MIN32 *
                EPSILON32
              );
            a = (1 + EPSILON32 / EPSILON) * $abs;
            result = a - (a - $abs);
            // eslint-disable-next-line no-self-compare
            if (result > MAX32 || result != result) return $sign * Infinity;
            return $sign * result;
          };
      },
      { a5559b08c34fc8d4: "kpCOl" },
    ],
    jrwHx: [
      function (require, module, exports) {
        // 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
        var $export = require("84cadabf2e15f5a0");
        var abs = Math.abs;
        $export($export.S, "Math", {
          hypot: function hypot(value1, value2) {
            var sum = 0;
            var i = 0;
            var aLen = arguments.length;
            var larg = 0;
            var arg, div;
            while (i < aLen) {
              arg = abs(arguments[i++]);
              if (larg < arg) {
                div = larg / arg;
                sum = sum * div * div + 1;
                larg = arg;
              } else if (arg > 0) {
                div = arg / larg;
                sum += div * div;
              } else sum += arg;
            }
            return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
          },
        });
      },
      { "84cadabf2e15f5a0": "77Dy0" },
    ],
    "1NwYP": [
      function (require, module, exports) {
        // 20.2.2.18 Math.imul(x, y)
        var $export = require("3ecccb0bd4f952c0");
        var $imul = Math.imul;
        // some WebKit versions fails with big numbers, some has wrong arity
        $export(
          $export.S +
            $export.F *
              require("c0f7d24767d226f1")(function () {
                return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
              }),
          "Math",
          {
            imul: function imul(x, y) {
              var UINT16 = 0xffff;
              var xn = +x;
              var yn = +y;
              var xl = UINT16 & xn;
              var yl = UINT16 & yn;
              return (
                0 |
                (xl * yl +
                  ((((UINT16 & (xn >>> 16)) * yl +
                    xl * (UINT16 & (yn >>> 16))) <<
                    16) >>>
                    0))
              );
            },
          },
        );
      },
      { "3ecccb0bd4f952c0": "77Dy0", c0f7d24767d226f1: "jYBY4" },
    ],
    gHtQs: [
      function (require, module, exports) {
        // 20.2.2.21 Math.log10(x)
        var $export = require("46091734a2c1beac");
        $export($export.S, "Math", {
          log10: function log10(x) {
            return Math.log(x) * Math.LOG10E;
          },
        });
      },
      { "46091734a2c1beac": "77Dy0" },
    ],
    "7lS5g": [
      function (require, module, exports) {
        // 20.2.2.20 Math.log1p(x)
        var $export = require("4310126c480fb2da");
        $export($export.S, "Math", {
          log1p: require("2f8b73569d7aab9d"),
        });
      },
      { "4310126c480fb2da": "77Dy0", "2f8b73569d7aab9d": "6yCVf" },
    ],
    kcnnb: [
      function (require, module, exports) {
        // 20.2.2.22 Math.log2(x)
        var $export = require("68f975e0b17dea06");
        $export($export.S, "Math", {
          log2: function log2(x) {
            return Math.log(x) / Math.LN2;
          },
        });
      },
      { "68f975e0b17dea06": "77Dy0" },
    ],
    bX8th: [
      function (require, module, exports) {
        // 20.2.2.28 Math.sign(x)
        var $export = require("6fa2b755b04f6191");
        $export($export.S, "Math", {
          sign: require("9c3bad6dc7d68514"),
        });
      },
      { "6fa2b755b04f6191": "77Dy0", "9c3bad6dc7d68514": "kpCOl" },
    ],
    dhEAw: [
      function (require, module, exports) {
        // 20.2.2.30 Math.sinh(x)
        var $export = require("c7b9f728b94240fb");
        var expm1 = require("7ec8abc6fd18ef6e");
        var exp = Math.exp;
        // V8 near Chromium 38 has a problem with very small numbers
        $export(
          $export.S +
            $export.F *
              require("52062a5cb8d9bd8a")(function () {
                return !Math.sinh(-0.00000000000000002) != -0.00000000000000002;
              }),
          "Math",
          {
            sinh: function sinh(x) {
              return Math.abs((x = +x)) < 1
                ? (expm1(x) - expm1(-x)) / 2
                : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
            },
          },
        );
      },
      {
        c7b9f728b94240fb: "77Dy0",
        "7ec8abc6fd18ef6e": "h5lWF",
        "52062a5cb8d9bd8a": "jYBY4",
      },
    ],
    bIHxi: [
      function (require, module, exports) {
        // 20.2.2.33 Math.tanh(x)
        var $export = require("8ce3321092019a5");
        var expm1 = require("487eacd1ddabd493");
        var exp = Math.exp;
        $export($export.S, "Math", {
          tanh: function tanh(x) {
            var a = expm1((x = +x));
            var b = expm1(-x);
            return a == Infinity
              ? 1
              : b == Infinity
              ? -1
              : (a - b) / (exp(x) + exp(-x));
          },
        });
      },
      { "8ce3321092019a5": "77Dy0", "487eacd1ddabd493": "h5lWF" },
    ],
    lzpi2: [
      function (require, module, exports) {
        // 20.2.2.34 Math.trunc(x)
        var $export = require("25861a180f34eb08");
        $export($export.S, "Math", {
          trunc: function trunc(it) {
            return (it > 0 ? Math.floor : Math.ceil)(it);
          },
        });
      },
      { "25861a180f34eb08": "77Dy0" },
    ],
    "1OD4s": [
      function (require, module, exports) {
        var $export = require("ac88793de26887ce");
        var toAbsoluteIndex = require("157a5bd9fddf4309");
        var fromCharCode = String.fromCharCode;
        var $fromCodePoint = String.fromCodePoint;
        // length should be 1, old FF problem
        $export(
          $export.S +
            $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1),
          "String",
          {
            // 21.1.2.2 String.fromCodePoint(...codePoints)
            fromCodePoint: function fromCodePoint(x) {
              var res = [];
              var aLen = arguments.length;
              var i = 0;
              var code;
              while (aLen > i) {
                code = +arguments[i++];
                if (toAbsoluteIndex(code, 0x10ffff) !== code)
                  throw RangeError(code + " is not a valid code point");
                res.push(
                  code < 0x10000
                    ? fromCharCode(code)
                    : fromCharCode(
                        ((code -= 0x10000) >> 10) + 0xd800,
                        (code % 0x400) + 0xdc00,
                      ),
                );
              }
              return res.join("");
            },
          },
        );
      },
      { ac88793de26887ce: "77Dy0", "157a5bd9fddf4309": "N3OwE" },
    ],
    fWSHh: [
      function (require, module, exports) {
        var $export = require("2f2695459f0e9202");
        var toIObject = require("3ee89babef174683");
        var toLength = require("ca7459493068a64f");
        $export($export.S, "String", {
          // 21.1.2.4 String.raw(callSite, ...substitutions)
          raw: function raw(callSite) {
            var tpl = toIObject(callSite.raw);
            var len = toLength(tpl.length);
            var aLen = arguments.length;
            var res = [];
            var i = 0;
            while (len > i) {
              res.push(String(tpl[i++]));
              if (i < aLen) res.push(String(arguments[i]));
            }
            return res.join("");
          },
        });
      },
      {
        "2f2695459f0e9202": "77Dy0",
        "3ee89babef174683": "ibyad",
        ca7459493068a64f: "kGg3g",
      },
    ],
    "8Woox": [
      function (require, module, exports) {
        "use strict";
        // 21.1.3.25 String.prototype.trim()
        require("aaa36cd8819ea92b")("trim", function ($trim) {
          return function trim() {
            return $trim(this, 3);
          };
        });
      },
      { aaa36cd8819ea92b: "dkad2" },
    ],
    gq4xf: [
      function (require, module, exports) {
        "use strict";
        var $at = require("5b26ce63a1a11454")(true);
        // 21.1.3.27 String.prototype[@@iterator]()
        require("12a568cf4a87d237")(
          String,
          "String",
          function (iterated) {
            this._t = String(iterated); // target
            this._i = 0; // next index
            // 21.1.5.2.1 %StringIteratorPrototype%.next()
          },
          function () {
            var O = this._t;
            var index = this._i;
            var point;
            if (index >= O.length)
              return {
                value: undefined,
                done: true,
              };
            point = $at(O, index);
            this._i += point.length;
            return {
              value: point,
              done: false,
            };
          },
        );
      },
      { "5b26ce63a1a11454": "jFcMf", "12a568cf4a87d237": "5T86g" },
    ],
    jFcMf: [
      function (require, module, exports) {
        var toInteger = require("31251103f88dabc0");
        var defined = require("151bf783d872ac39");
        // true  -> String#at
        // false -> String#codePointAt
        module.exports = function (TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? "" : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 ||
              a > 0xdbff ||
              i + 1 === l ||
              (b = s.charCodeAt(i + 1)) < 0xdc00 ||
              b > 0xdfff
              ? TO_STRING
                ? s.charAt(i)
                : a
              : TO_STRING
              ? s.slice(i, i + 2)
              : ((a - 0xd800) << 10) + (b - 0xdc00) + 0x10000;
          };
        };
      },
      { "31251103f88dabc0": "jmpId", "151bf783d872ac39": "ic3CF" },
    ],
    "5T86g": [
      function (require, module, exports) {
        "use strict";
        var LIBRARY = require("e349062efb729aa4");
        var $export = require("fc8c5a9ab4e03c44");
        var redefine = require("51a1825bcdf5f849");
        var hide = require("8eaaafca8d7861aa");
        var Iterators = require("6ed88cb0bb3b2a9f");
        var $iterCreate = require("f5be1db74c77c51");
        var setToStringTag = require("8cb14719533d7a15");
        var getPrototypeOf = require("fa8eb8fdf68a8c8c");
        var ITERATOR = require("42aef5e1e8e03a8")("iterator");
        var BUGGY = !([].keys && "next" in [].keys()); // Safari has buggy iterators w/o `next`
        var FF_ITERATOR = "@@iterator";
        var KEYS = "keys";
        var VALUES = "values";
        var returnThis = function () {
          return this;
        };
        module.exports = function (
          Base,
          NAME,
          Constructor,
          next,
          DEFAULT,
          IS_SET,
          FORCED,
        ) {
          $iterCreate(Constructor, NAME, next);
          var getMethod = function (kind) {
            if (!BUGGY && kind in proto) return proto[kind];
            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };
              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }
            return function entries() {
              return new Constructor(this, kind);
            };
          };
          var TAG = NAME + " Iterator";
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native =
            proto[ITERATOR] ||
            proto[FF_ITERATOR] ||
            (DEFAULT && proto[DEFAULT]);
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT
            ? !DEF_VALUES
              ? $default
              : getMethod("entries")
            : undefined;
          var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype;
          // Fix native
          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
            if (
              IteratorPrototype !== Object.prototype &&
              IteratorPrototype.next
            ) {
              // Set @@toStringTag to native iterators
              setToStringTag(IteratorPrototype, TAG, true);
              // fix for some old engines
              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                hide(IteratorPrototype, ITERATOR, returnThis);
            }
          }
          // fix Array#{values, @@iterator}.name in V8 / FF
          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;
            $default = function values() {
              return $native.call(this);
            };
          }
          // Define iterator
          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR]))
            hide(proto, ITERATOR, $default);
          // Plug for library
          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;
          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries,
            };
            if (FORCED) {
              for (key in methods)
                if (!(key in proto)) redefine(proto, key, methods[key]);
            } else
              $export(
                $export.P + $export.F * (BUGGY || VALUES_BUG),
                NAME,
                methods,
              );
          }
          return methods;
        };
      },
      {
        e349062efb729aa4: "4YPyS",
        fc8c5a9ab4e03c44: "77Dy0",
        "51a1825bcdf5f849": "kcOGE",
        "8eaaafca8d7861aa": "4uQIf",
        "6ed88cb0bb3b2a9f": "6RAVz",
        f5be1db74c77c51: "cX3VK",
        "8cb14719533d7a15": "eBrgu",
        fa8eb8fdf68a8c8c: "gQspV",
        "42aef5e1e8e03a8": "ea5XI",
      },
    ],
    "6RAVz": [
      function (require, module, exports) {
        module.exports = {};
      },
      {},
    ],
    cX3VK: [
      function (require, module, exports) {
        "use strict";
        var create = require("dddc0a493caeaafa");
        var descriptor = require("bda969d91db12a0b");
        var setToStringTag = require("84b8eef838de829c");
        var IteratorPrototype = {};
        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        require("2d98cf40b4c29af3")(
          IteratorPrototype,
          require("3dd5468431de18c2")("iterator"),
          function () {
            return this;
          },
        );
        module.exports = function (Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, {
            next: descriptor(1, next),
          });
          setToStringTag(Constructor, NAME + " Iterator");
        };
      },
      {
        dddc0a493caeaafa: "2DOWX",
        bda969d91db12a0b: "ciJKK",
        "84b8eef838de829c": "eBrgu",
        "2d98cf40b4c29af3": "4uQIf",
        "3dd5468431de18c2": "ea5XI",
      },
    ],
    go3Mo: [
      function (require, module, exports) {
        "use strict";
        var $export = require("98a605e551efe386");
        var $at = require("2939621cb67ac273")(false);
        $export($export.P, "String", {
          // 21.1.3.3 String.prototype.codePointAt(pos)
          codePointAt: function codePointAt(pos) {
            return $at(this, pos);
          },
        });
      },
      { "98a605e551efe386": "77Dy0", "2939621cb67ac273": "jFcMf" },
    ],
    l49L7: [
      function (require, module, exports) {
        // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
        "use strict";
        var $export = require("53ccaea92fafe119");
        var toLength = require("15b54d542ee26660");
        var context = require("2fbb5048fcdcab7f");
        var ENDS_WITH = "endsWith";
        var $endsWith = ""[ENDS_WITH];
        $export(
          $export.P + $export.F * require("bf4bb93455eaa17f")(ENDS_WITH),
          "String",
          {
            endsWith: function endsWith(
              searchString /* , endPosition = @length */,
            ) {
              var that = context(this, searchString, ENDS_WITH);
              var endPosition = arguments.length > 1 ? arguments[1] : undefined;
              var len = toLength(that.length);
              var end =
                endPosition === undefined
                  ? len
                  : Math.min(toLength(endPosition), len);
              var search = String(searchString);
              return $endsWith
                ? $endsWith.call(that, search, end)
                : that.slice(end - search.length, end) === search;
            },
          },
        );
      },
      {
        "53ccaea92fafe119": "77Dy0",
        "15b54d542ee26660": "kGg3g",
        "2fbb5048fcdcab7f": "8ZplY",
        bf4bb93455eaa17f: "jhjB4",
      },
    ],
    "8ZplY": [
      function (require, module, exports) {
        // helper for String#{startsWith, endsWith, includes}
        var isRegExp = require("3dc3087cd5b4a334");
        var defined = require("67a24fdd8138a218");
        module.exports = function (that, searchString, NAME) {
          if (isRegExp(searchString))
            throw TypeError("String#" + NAME + " doesn't accept regex!");
          return String(defined(that));
        };
      },
      { "3dc3087cd5b4a334": "hcS20", "67a24fdd8138a218": "ic3CF" },
    ],
    hcS20: [
      function (require, module, exports) {
        // 7.2.8 IsRegExp(argument)
        var isObject = require("dbf8ed982f9cd21a");
        var cof = require("7f70ffd5ff5c19a");
        var MATCH = require("333a8bb7b7b14937")("match");
        module.exports = function (it) {
          var isRegExp;
          return (
            isObject(it) &&
            ((isRegExp = it[MATCH]) !== undefined
              ? !!isRegExp
              : cof(it) == "RegExp")
          );
        };
      },
      {
        dbf8ed982f9cd21a: "joZov",
        "7f70ffd5ff5c19a": "8ezVG",
        "333a8bb7b7b14937": "ea5XI",
      },
    ],
    jhjB4: [
      function (require, module, exports) {
        var MATCH = require("398c09fe9abcde75")("match");
        module.exports = function (KEY) {
          var re = /./;
          try {
            "/./"[KEY](re);
          } catch (e) {
            try {
              re[MATCH] = false;
              return !"/./"[KEY](re);
            } catch (f) {}
          }
          return true;
        };
      },
      { "398c09fe9abcde75": "ea5XI" },
    ],
    dsEX7: [
      function (require, module, exports) {
        // 21.1.3.7 String.prototype.includes(searchString, position = 0)
        "use strict";
        var $export = require("3271f360c835800");
        var context = require("ee3d7e9cf7a72f25");
        var INCLUDES = "includes";
        $export(
          $export.P + $export.F * require("4c74fec14d5b338c")(INCLUDES),
          "String",
          {
            includes: function includes(searchString /* , position = 0 */) {
              return !!~context(this, searchString, INCLUDES).indexOf(
                searchString,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
          },
        );
      },
      {
        "3271f360c835800": "77Dy0",
        ee3d7e9cf7a72f25: "8ZplY",
        "4c74fec14d5b338c": "jhjB4",
      },
    ],
    "9hYro": [
      function (require, module, exports) {
        var $export = require("6d7deffc71f7af3c");
        $export($export.P, "String", {
          // 21.1.3.13 String.prototype.repeat(count)
          repeat: require("445290fd0da53a00"),
        });
      },
      { "6d7deffc71f7af3c": "77Dy0", "445290fd0da53a00": "hUJ09" },
    ],
    jZsZQ: [
      function (require, module, exports) {
        // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
        "use strict";
        var $export = require("6e767b7a1afe6ab2");
        var toLength = require("c1c7c8f07bef8448");
        var context = require("a3bfea2f44bc72ff");
        var STARTS_WITH = "startsWith";
        var $startsWith = ""[STARTS_WITH];
        $export(
          $export.P + $export.F * require("df22a12704f0cb75")(STARTS_WITH),
          "String",
          {
            startsWith: function startsWith(searchString /* , position = 0 */) {
              var that = context(this, searchString, STARTS_WITH);
              var index = toLength(
                Math.min(
                  arguments.length > 1 ? arguments[1] : undefined,
                  that.length,
                ),
              );
              var search = String(searchString);
              return $startsWith
                ? $startsWith.call(that, search, index)
                : that.slice(index, index + search.length) === search;
            },
          },
        );
      },
      {
        "6e767b7a1afe6ab2": "77Dy0",
        c1c7c8f07bef8448: "kGg3g",
        a3bfea2f44bc72ff: "8ZplY",
        df22a12704f0cb75: "jhjB4",
      },
    ],
    "6iFZe": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.2 String.prototype.anchor(name)
        require("fec56c488baeae56")("anchor", function (createHTML) {
          return function anchor(name) {
            return createHTML(this, "a", "name", name);
          };
        });
      },
      { fec56c488baeae56: "9RWyQ" },
    ],
    "9RWyQ": [
      function (require, module, exports) {
        var $export = require("e468493bb467d919");
        var fails = require("e9de0c3285b40274");
        var defined = require("eeb947ea4be8fef0");
        var quot = /"/g;
        // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
        var createHTML = function (string, tag, attribute, value) {
          var S = String(defined(string));
          var p1 = "<" + tag;
          if (attribute !== "")
            p1 +=
              " " +
              attribute +
              '="' +
              String(value).replace(quot, "&quot;") +
              '"';
          return p1 + ">" + S + "</" + tag + ">";
        };
        module.exports = function (NAME, exec) {
          var O = {};
          O[NAME] = exec(createHTML);
          $export(
            $export.P +
              $export.F *
                fails(function () {
                  var test = ""[NAME]('"');
                  return (
                    test !== test.toLowerCase() || test.split('"').length > 3
                  );
                }),
            "String",
            O,
          );
        };
      },
      {
        e468493bb467d919: "77Dy0",
        e9de0c3285b40274: "jYBY4",
        eeb947ea4be8fef0: "ic3CF",
      },
    ],
    "1Tuxq": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.3 String.prototype.big()
        require("45fab05a74ab13d8")("big", function (createHTML) {
          return function big() {
            return createHTML(this, "big", "", "");
          };
        });
      },
      { "45fab05a74ab13d8": "9RWyQ" },
    ],
    l1HTH: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.4 String.prototype.blink()
        require("420e948070061502")("blink", function (createHTML) {
          return function blink() {
            return createHTML(this, "blink", "", "");
          };
        });
      },
      { "420e948070061502": "9RWyQ" },
    ],
    jofh9: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.5 String.prototype.bold()
        require("eee9bbcf5b4c34db")("bold", function (createHTML) {
          return function bold() {
            return createHTML(this, "b", "", "");
          };
        });
      },
      { eee9bbcf5b4c34db: "9RWyQ" },
    ],
    "6B6Wp": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.6 String.prototype.fixed()
        require("502d6863baa1dc7e")("fixed", function (createHTML) {
          return function fixed() {
            return createHTML(this, "tt", "", "");
          };
        });
      },
      { "502d6863baa1dc7e": "9RWyQ" },
    ],
    hwXyT: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.7 String.prototype.fontcolor(color)
        require("6645b26d99f400ca")("fontcolor", function (createHTML) {
          return function fontcolor(color) {
            return createHTML(this, "font", "color", color);
          };
        });
      },
      { "6645b26d99f400ca": "9RWyQ" },
    ],
    "2fGWg": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.8 String.prototype.fontsize(size)
        require("f708138bd7cf0245")("fontsize", function (createHTML) {
          return function fontsize(size) {
            return createHTML(this, "font", "size", size);
          };
        });
      },
      { f708138bd7cf0245: "9RWyQ" },
    ],
    "8nqOX": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.9 String.prototype.italics()
        require("6dc9fd4590068a00")("italics", function (createHTML) {
          return function italics() {
            return createHTML(this, "i", "", "");
          };
        });
      },
      { "6dc9fd4590068a00": "9RWyQ" },
    ],
    dCtAQ: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.10 String.prototype.link(url)
        require("af04fdf7506ab484")("link", function (createHTML) {
          return function link(url) {
            return createHTML(this, "a", "href", url);
          };
        });
      },
      { af04fdf7506ab484: "9RWyQ" },
    ],
    jaeTs: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.11 String.prototype.small()
        require("4a98b3774f88511e")("small", function (createHTML) {
          return function small() {
            return createHTML(this, "small", "", "");
          };
        });
      },
      { "4a98b3774f88511e": "9RWyQ" },
    ],
    "8Uye6": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.12 String.prototype.strike()
        require("2e36e83d27449e2")("strike", function (createHTML) {
          return function strike() {
            return createHTML(this, "strike", "", "");
          };
        });
      },
      { "2e36e83d27449e2": "9RWyQ" },
    ],
    ge0MJ: [
      function (require, module, exports) {
        "use strict";
        // B.2.3.13 String.prototype.sub()
        require("eb4b81224a991e9f")("sub", function (createHTML) {
          return function sub() {
            return createHTML(this, "sub", "", "");
          };
        });
      },
      { eb4b81224a991e9f: "9RWyQ" },
    ],
    "8sNGY": [
      function (require, module, exports) {
        "use strict";
        // B.2.3.14 String.prototype.sup()
        require("1c3eb58951ddee5b")("sup", function (createHTML) {
          return function sup() {
            return createHTML(this, "sup", "", "");
          };
        });
      },
      { "1c3eb58951ddee5b": "9RWyQ" },
    ],
    "3Amrf": [
      function (require, module, exports) {
        // 20.3.3.1 / 15.9.4.4 Date.now()
        var $export = require("fba3efb736ac31d3");
        $export($export.S, "Date", {
          now: function () {
            return new Date().getTime();
          },
        });
      },
      { fba3efb736ac31d3: "77Dy0" },
    ],
    gSjyb: [
      function (require, module, exports) {
        "use strict";
        var $export = require("7fff5118f17879fe");
        var toObject = require("cb889d36fa029d89");
        var toPrimitive = require("e2dc35606fed3453");
        $export(
          $export.P +
            $export.F *
              require("79ce187f7646457f")(function () {
                return (
                  new Date(NaN).toJSON() !== null ||
                  Date.prototype.toJSON.call({
                    toISOString: function () {
                      return 1;
                    },
                  }) !== 1
                );
              }),
          "Date",
          {
            // eslint-disable-next-line no-unused-vars
            toJSON: function toJSON(key) {
              var O = toObject(this);
              var pv = toPrimitive(O);
              return typeof pv == "number" && !isFinite(pv)
                ? null
                : O.toISOString();
            },
          },
        );
      },
      {
        "7fff5118f17879fe": "77Dy0",
        cb889d36fa029d89: "dZ3od",
        e2dc35606fed3453: "9GXBY",
        "79ce187f7646457f": "jYBY4",
      },
    ],
    e89dG: [
      function (require, module, exports) {
        // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
        var $export = require("79027ff153c28118");
        var toISOString = require("eb1bae663bcf99de");
        // PhantomJS / old WebKit has a broken implementations
        $export(
          $export.P + $export.F * (Date.prototype.toISOString !== toISOString),
          "Date",
          {
            toISOString: toISOString,
          },
        );
      },
      { "79027ff153c28118": "77Dy0", eb1bae663bcf99de: "2IJEj" },
    ],
    "2IJEj": [
      function (require, module, exports) {
        "use strict";
        // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
        var fails = require("b471ecc7b8eb2681");
        var getTime = Date.prototype.getTime;
        var $toISOString = Date.prototype.toISOString;
        var lz = function (num) {
          return num > 9 ? num : "0" + num;
        };
        // PhantomJS / old WebKit has a broken implementations
        module.exports =
          fails(function () {
            return (
              $toISOString.call(new Date(-50000000000000 - 1)) !=
              "0385-07-25T07:06:39.999Z"
            );
          }) ||
          !fails(function () {
            $toISOString.call(new Date(NaN));
          })
            ? function toISOString() {
                if (!isFinite(getTime.call(this)))
                  throw RangeError("Invalid time value");
                var d = this;
                var y = d.getUTCFullYear();
                var m = d.getUTCMilliseconds();
                var s = y < 0 ? "-" : y > 9999 ? "+" : "";
                return (
                  s +
                  ("00000" + Math.abs(y)).slice(s ? -6 : -4) +
                  "-" +
                  lz(d.getUTCMonth() + 1) +
                  "-" +
                  lz(d.getUTCDate()) +
                  "T" +
                  lz(d.getUTCHours()) +
                  ":" +
                  lz(d.getUTCMinutes()) +
                  ":" +
                  lz(d.getUTCSeconds()) +
                  "." +
                  (m > 99 ? m : "0" + lz(m)) +
                  "Z"
                );
              }
            : $toISOString;
      },
      { b471ecc7b8eb2681: "jYBY4" },
    ],
    "18WXb": [
      function (require, module, exports) {
        var DateProto = Date.prototype;
        var INVALID_DATE = "Invalid Date";
        var TO_STRING = "toString";
        var $toString = DateProto[TO_STRING];
        var getTime = DateProto.getTime;
        if (new Date(NaN) + "" != INVALID_DATE)
          require("dd867634374d96dd")(
            DateProto,
            TO_STRING,
            function toString() {
              var value = getTime.call(this);
              // eslint-disable-next-line no-self-compare
              return value === value ? $toString.call(this) : INVALID_DATE;
            },
          );
      },
      { dd867634374d96dd: "kcOGE" },
    ],
    "7ajak": [
      function (require, module, exports) {
        var TO_PRIMITIVE = require("a7e0e3af805b8c0d")("toPrimitive");
        var proto = Date.prototype;
        if (!(TO_PRIMITIVE in proto))
          require("a841e1b93abf9dd3")(
            proto,
            TO_PRIMITIVE,
            require("12fe1fac53d1779b"),
          );
      },
      {
        a7e0e3af805b8c0d: "ea5XI",
        a841e1b93abf9dd3: "4uQIf",
        "12fe1fac53d1779b": "ayyw0",
      },
    ],
    ayyw0: [
      function (require, module, exports) {
        "use strict";
        var anObject = require("2a972c63816742c9");
        var toPrimitive = require("9ffd7ea0abf9561c");
        var NUMBER = "number";
        module.exports = function (hint) {
          if (hint !== "string" && hint !== NUMBER && hint !== "default")
            throw TypeError("Incorrect hint");
          return toPrimitive(anObject(this), hint != NUMBER);
        };
      },
      { "2a972c63816742c9": "dkWKr", "9ffd7ea0abf9561c": "9GXBY" },
    ],
    iwBlJ: [
      function (require, module, exports) {
        // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
        var $export = require("815fa24d8cfaf564");
        $export($export.S, "Array", {
          isArray: require("f4404ee360185f3b"),
        });
      },
      { "815fa24d8cfaf564": "77Dy0", f4404ee360185f3b: "3C2EA" },
    ],
    "9WHF6": [
      function (require, module, exports) {
        "use strict";
        var ctx = require("61793f2de15d20f5");
        var $export = require("5a490b0d66d11b7f");
        var toObject = require("606bee41c7773f3");
        var call = require("779f6d301fbeda73");
        var isArrayIter = require("8a776510f9d08e4a");
        var toLength = require("6881f7dba7a7b5a4");
        var createProperty = require("dc40bc082b58ef5c");
        var getIterFn = require("3f5307030d413cdc");
        $export(
          $export.S +
            $export.F *
              !require("6301fff27b612915")(function (iter) {
                Array.from(iter);
              }),
          "Array",
          {
            // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
            from: function from(
              arrayLike /* , mapfn = undefined, thisArg = undefined */,
            ) {
              var O = toObject(arrayLike);
              var C = typeof this == "function" ? this : Array;
              var aLen = arguments.length;
              var mapfn = aLen > 1 ? arguments[1] : undefined;
              var mapping = mapfn !== undefined;
              var index = 0;
              var iterFn = getIterFn(O);
              var length, result, step, iterator;
              if (mapping)
                mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
              // if object isn't iterable or it's array with default iterator - use simple case
              if (iterFn != undefined && !(C == Array && isArrayIter(iterFn)))
                for (
                  iterator = iterFn.call(O), result = new C();
                  !(step = iterator.next()).done;
                  index++
                )
                  createProperty(
                    result,
                    index,
                    mapping
                      ? call(iterator, mapfn, [step.value, index], true)
                      : step.value,
                  );
              else {
                length = toLength(O.length);
                for (result = new C(length); length > index; index++)
                  createProperty(
                    result,
                    index,
                    mapping ? mapfn(O[index], index) : O[index],
                  );
              }
              result.length = index;
              return result;
            },
          },
        );
      },
      {
        "61793f2de15d20f5": "gpAgQ",
        "5a490b0d66d11b7f": "77Dy0",
        "606bee41c7773f3": "dZ3od",
        "779f6d301fbeda73": "bQdzI",
        "8a776510f9d08e4a": "3BsWF",
        "6881f7dba7a7b5a4": "kGg3g",
        dc40bc082b58ef5c: "6j6AZ",
        "3f5307030d413cdc": "3H2Vr",
        "6301fff27b612915": "iJ7Ec",
      },
    ],
    bQdzI: [
      function (require, module, exports) {
        // call something on iterator step with safe closing on error
        var anObject = require("518375c1be4a68ef");
        module.exports = function (iterator, fn, value, entries) {
          try {
            return entries ? fn(anObject(value)[0], value[1]) : fn(value);
            // 7.4.6 IteratorClose(iterator, completion)
          } catch (e) {
            var ret = iterator["return"];
            if (ret !== undefined) anObject(ret.call(iterator));
            throw e;
          }
        };
      },
      { "518375c1be4a68ef": "dkWKr" },
    ],
    "3BsWF": [
      function (require, module, exports) {
        // check on default Array iterator
        var Iterators = require("d33212f831bd4e50");
        var ITERATOR = require("cbc8990ca8f2db89")("iterator");
        var ArrayProto = Array.prototype;
        module.exports = function (it) {
          return (
            it !== undefined &&
            (Iterators.Array === it || ArrayProto[ITERATOR] === it)
          );
        };
      },
      { d33212f831bd4e50: "6RAVz", cbc8990ca8f2db89: "ea5XI" },
    ],
    "6j6AZ": [
      function (require, module, exports) {
        "use strict";
        var $defineProperty = require("87b06d51b7d9c7fb");
        var createDesc = require("e37fd75b7de2eb52");
        module.exports = function (object, index, value) {
          if (index in object)
            $defineProperty.f(object, index, createDesc(0, value));
          else object[index] = value;
        };
      },
      { "87b06d51b7d9c7fb": "evkkn", e37fd75b7de2eb52: "ciJKK" },
    ],
    "3H2Vr": [
      function (require, module, exports) {
        var classof = require("1e19838749aa83b1");
        var ITERATOR = require("a1e2f8397df22245")("iterator");
        var Iterators = require("de2f3607094195ee");
        module.exports = require("eae909258c756f64").getIteratorMethod =
          function (it) {
            if (it != undefined)
              return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
      },
      {
        "1e19838749aa83b1": "hCCia",
        a1e2f8397df22245: "ea5XI",
        de2f3607094195ee: "6RAVz",
        eae909258c756f64: "8jGrK",
      },
    ],
    iJ7Ec: [
      function (require, module, exports) {
        var ITERATOR = require("55fa2de7451178d3")("iterator");
        var SAFE_CLOSING = false;
        try {
          var riter = [7][ITERATOR]();
          riter["return"] = function () {
            SAFE_CLOSING = true;
          };
          // eslint-disable-next-line no-throw-literal
          Array.from(riter, function () {
            throw 2;
          });
        } catch (e) {}
        module.exports = function (exec, skipClosing) {
          if (!skipClosing && !SAFE_CLOSING) return false;
          var safe = false;
          try {
            var arr = [7];
            var iter = arr[ITERATOR]();
            iter.next = function () {
              return {
                done: (safe = true),
              };
            };
            arr[ITERATOR] = function () {
              return iter;
            };
            exec(arr);
          } catch (e) {}
          return safe;
        };
      },
      { "55fa2de7451178d3": "ea5XI" },
    ],
    gKvoj: [
      function (require, module, exports) {
        "use strict";
        var $export = require("6581a9ffc49ab11c");
        var createProperty = require("768714a1b9b8d67d");
        // WebKit Array.of isn't generic
        $export(
          $export.S +
            $export.F *
              require("3faa9e66624aae41")(function () {
                function F() {}
                return !(Array.of.call(F) instanceof F);
              }),
          "Array",
          {
            // 22.1.2.3 Array.of( ...items)
            of: function of() {
              var index = 0;
              var aLen = arguments.length;
              var result = new (typeof this == "function" ? this : Array)(aLen);
              while (aLen > index)
                createProperty(result, index, arguments[index++]);
              result.length = aLen;
              return result;
            },
          },
        );
      },
      {
        "6581a9ffc49ab11c": "77Dy0",
        "768714a1b9b8d67d": "6j6AZ",
        "3faa9e66624aae41": "jYBY4",
      },
    ],
    "4PTwA": [
      function (require, module, exports) {
        "use strict";
        // 22.1.3.13 Array.prototype.join(separator)
        var $export = require("b86ebc8c324c12a9");
        var toIObject = require("a8b004bbbc4ee91a");
        var arrayJoin = [].join;
        // fallback for not array-like strings
        $export(
          $export.P +
            $export.F *
              (require("40d3388fd89f761a") != Object ||
                !require("16e7364c30c01546")(arrayJoin)),
          "Array",
          {
            join: function join(separator) {
              return arrayJoin.call(
                toIObject(this),
                separator === undefined ? "," : separator,
              );
            },
          },
        );
      },
      {
        b86ebc8c324c12a9: "77Dy0",
        a8b004bbbc4ee91a: "ibyad",
        "40d3388fd89f761a": "b1FtL",
        "16e7364c30c01546": "gwRUw",
      },
    ],
    gwRUw: [
      function (require, module, exports) {
        "use strict";
        var fails = require("65a8705a579be6c9");
        module.exports = function (method, arg) {
          return (
            !!method &&
            fails(function () {
              // eslint-disable-next-line no-useless-call
              arg ? method.call(null, function () {}, 1) : method.call(null);
            })
          );
        };
      },
      { "65a8705a579be6c9": "jYBY4" },
    ],
    "04eFF": [
      function (require, module, exports) {
        "use strict";
        var $export = require("fc3151eef3de7fd1");
        var html = require("d6f22f3e2d6abc9d");
        var cof = require("9d3ff992252cb466");
        var toAbsoluteIndex = require("dcf3d2e21953e970");
        var toLength = require("8da59e3fc4b84cfc");
        var arraySlice = [].slice;
        // fallback for not array-like ES3 strings and DOM objects
        $export(
          $export.P +
            $export.F *
              require("929284f11cedba47")(function () {
                if (html) arraySlice.call(html);
              }),
          "Array",
          {
            slice: function slice(begin, end) {
              var len = toLength(this.length);
              var klass = cof(this);
              end = end === undefined ? len : end;
              if (klass == "Array") return arraySlice.call(this, begin, end);
              var start = toAbsoluteIndex(begin, len);
              var upTo = toAbsoluteIndex(end, len);
              var size = toLength(upTo - start);
              var cloned = new Array(size);
              var i = 0;
              for (; i < size; i++)
                cloned[i] =
                  klass == "String" ? this.charAt(start + i) : this[start + i];
              return cloned;
            },
          },
        );
      },
      {
        fc3151eef3de7fd1: "77Dy0",
        d6f22f3e2d6abc9d: "lqTMW",
        "9d3ff992252cb466": "8ezVG",
        dcf3d2e21953e970: "N3OwE",
        "8da59e3fc4b84cfc": "kGg3g",
        "929284f11cedba47": "jYBY4",
      },
    ],
    aysu2: [
      function (require, module, exports) {
        "use strict";
        var $export = require("4a57289a8827ee27");
        var aFunction = require("51546ae8d56cc07f");
        var toObject = require("ded16757af74df50");
        var fails = require("2557d9e9576f4ab8");
        var $sort = [].sort;
        var test = [1, 2, 3];
        $export(
          $export.P +
            $export.F *
              (fails(function () {
                // IE8-
                test.sort(undefined);
              }) ||
                !fails(function () {
                  // V8 bug
                  test.sort(null);
                  // Old WebKit
                }) ||
                !require("4ad99c2340bbb0cc")($sort)),
          "Array",
          {
            // 22.1.3.25 Array.prototype.sort(comparefn)
            sort: function sort(comparefn) {
              return comparefn === undefined
                ? $sort.call(toObject(this))
                : $sort.call(toObject(this), aFunction(comparefn));
            },
          },
        );
      },
      {
        "4a57289a8827ee27": "77Dy0",
        "51546ae8d56cc07f": "7M8Zs",
        ded16757af74df50: "dZ3od",
        "2557d9e9576f4ab8": "jYBY4",
        "4ad99c2340bbb0cc": "gwRUw",
      },
    ],
    iJQzP: [
      function (require, module, exports) {
        "use strict";
        var $export = require("14816edd6b97a82c");
        var $forEach = require("a732542d17180641")(0);
        var STRICT = require("835216e60717f13a")([].forEach, true);
        $export($export.P + $export.F * !STRICT, "Array", {
          // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
          forEach: function forEach(callbackfn /* , thisArg */) {
            return $forEach(this, callbackfn, arguments[1]);
          },
        });
      },
      {
        "14816edd6b97a82c": "77Dy0",
        a732542d17180641: "jpe03",
        "835216e60717f13a": "gwRUw",
      },
    ],
    jpe03: [
      function (require, module, exports) {
        // 0 -> Array#forEach
        // 1 -> Array#map
        // 2 -> Array#filter
        // 3 -> Array#some
        // 4 -> Array#every
        // 5 -> Array#find
        // 6 -> Array#findIndex
        var ctx = require("85a70d828715a2c1");
        var IObject = require("b1744e6e66347d14");
        var toObject = require("dadfb5c111d088a4");
        var toLength = require("a97cc8811734a5a4");
        var asc = require("d56ca12d857b6a99");
        module.exports = function (TYPE, $create) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          var create = $create || asc;
          return function ($this, callbackfn, that) {
            var O = toObject($this);
            var self = IObject(O);
            var f = ctx(callbackfn, that, 3);
            var length = toLength(self.length);
            var index = 0;
            var result = IS_MAP
              ? create($this, length)
              : IS_FILTER
              ? create($this, 0)
              : undefined;
            var val, res;
            for (; length > index; index++)
              if (NO_HOLES || index in self) {
                val = self[index];
                res = f(val, index, O);
                if (TYPE) {
                  if (IS_MAP) result[index] = res; // map
                  else if (res)
                    switch (TYPE) {
                      case 3:
                        return true; // some
                      case 5:
                        return val; // find
                      case 6:
                        return index; // findIndex
                      case 2:
                        result.push(val); // filter
                    }
                  else if (IS_EVERY) return false; // every
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
          };
        };
      },
      {
        "85a70d828715a2c1": "gpAgQ",
        b1744e6e66347d14: "b1FtL",
        dadfb5c111d088a4: "dZ3od",
        a97cc8811734a5a4: "kGg3g",
        d56ca12d857b6a99: "cjpM0",
      },
    ],
    cjpM0: [
      function (require, module, exports) {
        // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
        var speciesConstructor = require("647acf8867f5f1d1");
        module.exports = function (original, length) {
          return new (speciesConstructor(original))(length);
        };
      },
      { "647acf8867f5f1d1": "6o7DM" },
    ],
    "6o7DM": [
      function (require, module, exports) {
        var isObject = require("9e0cf0b9804982b");
        var isArray = require("6c5b8b72b6391bee");
        var SPECIES = require("985b622e3f9d3568")("species");
        module.exports = function (original) {
          var C;
          if (isArray(original)) {
            C = original.constructor;
            // cross-realm fallback
            if (typeof C == "function" && (C === Array || isArray(C.prototype)))
              C = undefined;
            if (isObject(C)) {
              C = C[SPECIES];
              if (C === null) C = undefined;
            }
          }
          return C === undefined ? Array : C;
        };
      },
      {
        "9e0cf0b9804982b": "joZov",
        "6c5b8b72b6391bee": "3C2EA",
        "985b622e3f9d3568": "ea5XI",
      },
    ],
    ipnmS: [
      function (require, module, exports) {
        "use strict";
        var $export = require("4e88b74e00134d9");
        var $map = require("f9d2a28bb9828954")(1);
        $export(
          $export.P + $export.F * !require("7998f8756e0d63a4")([].map, true),
          "Array",
          {
            // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
            map: function map(callbackfn /* , thisArg */) {
              return $map(this, callbackfn, arguments[1]);
            },
          },
        );
      },
      {
        "4e88b74e00134d9": "77Dy0",
        f9d2a28bb9828954: "jpe03",
        "7998f8756e0d63a4": "gwRUw",
      },
    ],
    lvMIp: [
      function (require, module, exports) {
        "use strict";
        var $export = require("d526570d0a03c7d6");
        var $filter = require("90b0f40efa2c0d04")(2);
        $export(
          $export.P + $export.F * !require("a7c6884023685de0")([].filter, true),
          "Array",
          {
            // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
            filter: function filter(callbackfn /* , thisArg */) {
              return $filter(this, callbackfn, arguments[1]);
            },
          },
        );
      },
      {
        d526570d0a03c7d6: "77Dy0",
        "90b0f40efa2c0d04": "jpe03",
        a7c6884023685de0: "gwRUw",
      },
    ],
    hqvXI: [
      function (require, module, exports) {
        "use strict";
        var $export = require("5bbd939d36338285");
        var $some = require("efa85c70e95ead86")(3);
        $export(
          $export.P + $export.F * !require("4b08f81dab9f0590")([].some, true),
          "Array",
          {
            // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
            some: function some(callbackfn /* , thisArg */) {
              return $some(this, callbackfn, arguments[1]);
            },
          },
        );
      },
      {
        "5bbd939d36338285": "77Dy0",
        efa85c70e95ead86: "jpe03",
        "4b08f81dab9f0590": "gwRUw",
      },
    ],
    "8h2yQ": [
      function (require, module, exports) {
        "use strict";
        var $export = require("4a5234dfd2a7fbe7");
        var $every = require("7ddc72d361377254")(4);
        $export(
          $export.P + $export.F * !require("52075b018448a14")([].every, true),
          "Array",
          {
            // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
            every: function every(callbackfn /* , thisArg */) {
              return $every(this, callbackfn, arguments[1]);
            },
          },
        );
      },
      {
        "4a5234dfd2a7fbe7": "77Dy0",
        "7ddc72d361377254": "jpe03",
        "52075b018448a14": "gwRUw",
      },
    ],
    GtUdz: [
      function (require, module, exports) {
        "use strict";
        var $export = require("4a0c9533229795b6");
        var $reduce = require("60378b8ac328c83a");
        $export(
          $export.P + $export.F * !require("9b3df2ae357be63c")([].reduce, true),
          "Array",
          {
            // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
            reduce: function reduce(callbackfn /* , initialValue */) {
              return $reduce(
                this,
                callbackfn,
                arguments.length,
                arguments[1],
                false,
              );
            },
          },
        );
      },
      {
        "4a0c9533229795b6": "77Dy0",
        "60378b8ac328c83a": "59DFQ",
        "9b3df2ae357be63c": "gwRUw",
      },
    ],
    "59DFQ": [
      function (require, module, exports) {
        var aFunction = require("162e28b83ca8984a");
        var toObject = require("847633705b2b3c17");
        var IObject = require("488de6d973a5cae9");
        var toLength = require("4ae72c42d8f10779");
        module.exports = function (that, callbackfn, aLen, memo, isRight) {
          aFunction(callbackfn);
          var O = toObject(that);
          var self = IObject(O);
          var length = toLength(O.length);
          var index = isRight ? length - 1 : 0;
          var i = isRight ? -1 : 1;
          if (aLen < 2)
            for (;;) {
              if (index in self) {
                memo = self[index];
                index += i;
                break;
              }
              index += i;
              if (isRight ? index < 0 : length <= index)
                throw TypeError("Reduce of empty array with no initial value");
            }
          for (; isRight ? index >= 0 : length > index; index += i)
            if (index in self) memo = callbackfn(memo, self[index], index, O);
          return memo;
        };
      },
      {
        "162e28b83ca8984a": "7M8Zs",
        "847633705b2b3c17": "dZ3od",
        "488de6d973a5cae9": "b1FtL",
        "4ae72c42d8f10779": "kGg3g",
      },
    ],
    fnWfY: [
      function (require, module, exports) {
        "use strict";
        var $export = require("2eec45a12cc679a1");
        var $reduce = require("6bb7a23c2c3792c");
        $export(
          $export.P +
            $export.F * !require("7503fe2a34510b5f")([].reduceRight, true),
          "Array",
          {
            // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
            reduceRight: function reduceRight(callbackfn /* , initialValue */) {
              return $reduce(
                this,
                callbackfn,
                arguments.length,
                arguments[1],
                true,
              );
            },
          },
        );
      },
      {
        "2eec45a12cc679a1": "77Dy0",
        "6bb7a23c2c3792c": "59DFQ",
        "7503fe2a34510b5f": "gwRUw",
      },
    ],
    "1T1Z7": [
      function (require, module, exports) {
        "use strict";
        var $export = require("8436a1dc255d243d");
        var $indexOf = require("7c1ec752fae1f25e")(false);
        var $native = [].indexOf;
        var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
        $export(
          $export.P +
            $export.F *
              (NEGATIVE_ZERO || !require("cc45643a9f44777e")($native)),
          "Array",
          {
            // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
            indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
              return NEGATIVE_ZERO
                ? $native.apply(this, arguments) || 0
                : $indexOf(this, searchElement, arguments[1]);
            },
          },
        );
      },
      {
        "8436a1dc255d243d": "77Dy0",
        "7c1ec752fae1f25e": "1pIJc",
        cc45643a9f44777e: "gwRUw",
      },
    ],
    wo8n0: [
      function (require, module, exports) {
        "use strict";
        var $export = require("5da13895e46c60fa");
        var toIObject = require("d2353ed71e884eee");
        var toInteger = require("683ed606347397cf");
        var toLength = require("ffe7bf0e3ab947b2");
        var $native = [].lastIndexOf;
        var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
        $export(
          $export.P +
            $export.F *
              (NEGATIVE_ZERO || !require("b067dcad5bce9783")($native)),
          "Array",
          {
            // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
            lastIndexOf: function lastIndexOf(
              searchElement /* , fromIndex = @[*-1] */,
            ) {
              // convert -0 to +0
              if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
              var O = toIObject(this);
              var length = toLength(O.length);
              var index = length - 1;
              if (arguments.length > 1)
                index = Math.min(index, toInteger(arguments[1]));
              if (index < 0) index = length + index;
              for (; index >= 0; index--)
                if (index in O) {
                  if (O[index] === searchElement) return index || 0;
                }
              return -1;
            },
          },
        );
      },
      {
        "5da13895e46c60fa": "77Dy0",
        d2353ed71e884eee: "ibyad",
        "683ed606347397cf": "jmpId",
        ffe7bf0e3ab947b2: "kGg3g",
        b067dcad5bce9783: "gwRUw",
      },
    ],
    "2VW9D": [
      function (require, module, exports) {
        // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
        var $export = require("da47ab991842db48");
        $export($export.P, "Array", {
          copyWithin: require("f1450153fb4486"),
        });
        require("87089a0f075ed65")("copyWithin");
      },
      {
        da47ab991842db48: "77Dy0",
        f1450153fb4486: "5MnLe",
        "87089a0f075ed65": "9nItQ",
      },
    ],
    "5MnLe": [
      function (require, module, exports) {
        // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
        "use strict";
        var toObject = require("fc822ad491d84792");
        var toAbsoluteIndex = require("9e63b26c2d2c2340");
        var toLength = require("e772b69b4bae481");
        module.exports =
          [].copyWithin ||
          function copyWithin(
            target /* = 0 */,
            start /* = 0, end = @length */,
          ) {
            var O = toObject(this);
            var len = toLength(O.length);
            var to = toAbsoluteIndex(target, len);
            var from = toAbsoluteIndex(start, len);
            var end = arguments.length > 2 ? arguments[2] : undefined;
            var count = Math.min(
              (end === undefined ? len : toAbsoluteIndex(end, len)) - from,
              len - to,
            );
            var inc = 1;
            if (from < to && to < from + count) {
              inc = -1;
              from += count - 1;
              to += count - 1;
            }
            while (count-- > 0) {
              if (from in O) O[to] = O[from];
              else delete O[to];
              to += inc;
              from += inc;
            }
            return O;
          };
      },
      {
        fc822ad491d84792: "dZ3od",
        "9e63b26c2d2c2340": "N3OwE",
        e772b69b4bae481: "kGg3g",
      },
    ],
    "9nItQ": [
      function (require, module, exports) {
        // 22.1.3.31 Array.prototype[@@unscopables]
        var UNSCOPABLES = require("d1d4f96ee4ecb979")("unscopables");
        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == undefined)
          require("830672aff90629bd")(ArrayProto, UNSCOPABLES, {});
        module.exports = function (key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
      },
      { d1d4f96ee4ecb979: "ea5XI", "830672aff90629bd": "4uQIf" },
    ],
    "15nzR": [
      function (require, module, exports) {
        // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
        var $export = require("857b57e76a9518cc");
        $export($export.P, "Array", {
          fill: require("8ea246d61b55ffd2"),
        });
        require("87be4b62e1f00530")("fill");
      },
      {
        "857b57e76a9518cc": "77Dy0",
        "8ea246d61b55ffd2": "3pC37",
        "87be4b62e1f00530": "9nItQ",
      },
    ],
    "3pC37": [
      function (require, module, exports) {
        // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
        "use strict";
        var toObject = require("9cb7ade1960728c7");
        var toAbsoluteIndex = require("a1ff17b726fa5f9b");
        var toLength = require("e3303c4c2c3de16d");
        module.exports = function fill(value /* , start = 0, end = @length */) {
          var O = toObject(this);
          var length = toLength(O.length);
          var aLen = arguments.length;
          var index = toAbsoluteIndex(
            aLen > 1 ? arguments[1] : undefined,
            length,
          );
          var end = aLen > 2 ? arguments[2] : undefined;
          var endPos =
            end === undefined ? length : toAbsoluteIndex(end, length);
          while (endPos > index) O[index++] = value;
          return O;
        };
      },
      {
        "9cb7ade1960728c7": "dZ3od",
        a1ff17b726fa5f9b: "N3OwE",
        e3303c4c2c3de16d: "kGg3g",
      },
    ],
    bi2ft: [
      function (require, module, exports) {
        "use strict";
        // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
        var $export = require("5842c9673b966f0b");
        var $find = require("e7bc29368469a287")(5);
        var KEY = "find";
        var forced = true;
        // Shouldn't skip holes
        if (KEY in [])
          Array(1)[KEY](function () {
            forced = false;
          });
        $export($export.P + $export.F * forced, "Array", {
          find: function find(callbackfn /* , that = undefined */) {
            return $find(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : undefined,
            );
          },
        });
        require("45fac2cbf09bbac")(KEY);
      },
      {
        "5842c9673b966f0b": "77Dy0",
        e7bc29368469a287: "jpe03",
        "45fac2cbf09bbac": "9nItQ",
      },
    ],
    TztOt: [
      function (require, module, exports) {
        "use strict";
        // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
        var $export = require("a1b3b76e32e248f0");
        var $find = require("ae07557cd883a562")(6);
        var KEY = "findIndex";
        var forced = true;
        // Shouldn't skip holes
        if (KEY in [])
          Array(1)[KEY](function () {
            forced = false;
          });
        $export($export.P + $export.F * forced, "Array", {
          findIndex: function findIndex(callbackfn /* , that = undefined */) {
            return $find(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : undefined,
            );
          },
        });
        require("25b28290ed04ff4d")(KEY);
      },
      {
        a1b3b76e32e248f0: "77Dy0",
        ae07557cd883a562: "jpe03",
        "25b28290ed04ff4d": "9nItQ",
      },
    ],
    "9YawV": [
      function (require, module, exports) {
        require("40ac275c0bf4ed19")("Array");
      },
      { "40ac275c0bf4ed19": "37abT" },
    ],
    "37abT": [
      function (require, module, exports) {
        "use strict";
        var global = require("f12070d01f0105c5");
        var dP = require("7f5002d269ed9475");
        var DESCRIPTORS = require("62540ead02776b28");
        var SPECIES = require("80720736c7369fff")("species");
        module.exports = function (KEY) {
          var C = global[KEY];
          if (DESCRIPTORS && C && !C[SPECIES])
            dP.f(C, SPECIES, {
              configurable: true,
              get: function () {
                return this;
              },
            });
        };
      },
      {
        f12070d01f0105c5: "c0KvC",
        "7f5002d269ed9475": "evkkn",
        "62540ead02776b28": "4XHXy",
        "80720736c7369fff": "ea5XI",
      },
    ],
    cYJcA: [
      function (require, module, exports) {
        "use strict";
        var addToUnscopables = require("d51c5dca83369040");
        var step = require("1b40f23ff6410fe1");
        var Iterators = require("472b8790cd6a439e");
        var toIObject = require("86bcda315f9f923e");
        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = require("a4a83f328feb5f97")(
          Array,
          "Array",
          function (iterated, kind) {
            this._t = toIObject(iterated); // target
            this._i = 0; // next index
            this._k = kind; // kind
            // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
          },
          function () {
            var O = this._t;
            var kind = this._k;
            var index = this._i++;
            if (!O || index >= O.length) {
              this._t = undefined;
              return step(1);
            }
            if (kind == "keys") return step(0, index);
            if (kind == "values") return step(0, O[index]);
            return step(0, [index, O[index]]);
          },
          "values",
        );
        // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
      },
      {
        d51c5dca83369040: "9nItQ",
        "1b40f23ff6410fe1": "dprL2",
        "472b8790cd6a439e": "6RAVz",
        "86bcda315f9f923e": "ibyad",
        a4a83f328feb5f97: "5T86g",
      },
    ],
    dprL2: [
      function (require, module, exports) {
        module.exports = function (done, value) {
          return {
            value: value,
            done: !!done,
          };
        };
      },
      {},
    ],
    aNQK1: [
      function (require, module, exports) {
        var global = require("80372437550c9bba");
        var inheritIfRequired = require("c0dc525035d02408");
        var dP = require("3970ce98e570a66b").f;
        var gOPN = require("66e41d91aaa41ce0").f;
        var isRegExp = require("bd3bf63b54838480");
        var $flags = require("64e2dc146a3c3c7d");
        var $RegExp = global.RegExp;
        var Base = $RegExp;
        var proto = $RegExp.prototype;
        var re1 = /a/g;
        var re2 = /a/g;
        // "new" creates a new object, old webkit buggy here
        var CORRECT_NEW = new $RegExp(re1) !== re1;
        if (
          require("718ff0ddf41207c8") &&
          (!CORRECT_NEW ||
            require("63b4a5caa2e10b61")(function () {
              re2[require("1eb254370c60e3d5")("match")] = false;
              // RegExp constructor can alter flags and IsRegExp works correct with @@match
              return (
                $RegExp(re1) != re1 ||
                $RegExp(re2) == re2 ||
                $RegExp(re1, "i") != "/a/i"
              );
            }))
        ) {
          $RegExp = function RegExp(p, f) {
            var tiRE = this instanceof $RegExp;
            var piRE = isRegExp(p);
            var fiU = f === undefined;
            return !tiRE && piRE && p.constructor === $RegExp && fiU
              ? p
              : inheritIfRequired(
                  CORRECT_NEW
                    ? new Base(piRE && !fiU ? p.source : p, f)
                    : Base(
                        (piRE = p instanceof $RegExp) ? p.source : p,
                        piRE && fiU ? $flags.call(p) : f,
                      ),
                  tiRE ? this : proto,
                  $RegExp,
                );
          };
          var proxy = function (key) {
            key in $RegExp ||
              dP($RegExp, key, {
                configurable: true,
                get: function () {
                  return Base[key];
                },
                set: function (it) {
                  Base[key] = it;
                },
              });
          };
          for (var keys = gOPN(Base), i = 0; keys.length > i; )
            proxy(keys[i++]);
          proto.constructor = $RegExp;
          $RegExp.prototype = proto;
          require("889e4f0773521a98")(global, "RegExp", $RegExp);
        }
        require("5989b394352b4425")("RegExp");
      },
      {
        "80372437550c9bba": "c0KvC",
        c0dc525035d02408: "gjUNA",
        "3970ce98e570a66b": "evkkn",
        "66e41d91aaa41ce0": "aij03",
        bd3bf63b54838480: "hcS20",
        "64e2dc146a3c3c7d": "guRRu",
        "718ff0ddf41207c8": "4XHXy",
        "63b4a5caa2e10b61": "jYBY4",
        "1eb254370c60e3d5": "ea5XI",
        "889e4f0773521a98": "kcOGE",
        "5989b394352b4425": "37abT",
      },
    ],
    guRRu: [
      function (require, module, exports) {
        "use strict";
        // 21.2.5.3 get RegExp.prototype.flags
        var anObject = require("775685cdcec4031c");
        module.exports = function () {
          var that = anObject(this);
          var result = "";
          if (that.global) result += "g";
          if (that.ignoreCase) result += "i";
          if (that.multiline) result += "m";
          if (that.unicode) result += "u";
          if (that.sticky) result += "y";
          return result;
        };
      },
      { "775685cdcec4031c": "dkWKr" },
    ],
    "9Qt83": [
      function (require, module, exports) {
        "use strict";
        var regexpExec = require("83977233846759eb");
        require("e5ec81b9776169fa")(
          {
            target: "RegExp",
            proto: true,
            forced: regexpExec !== /./.exec,
          },
          {
            exec: regexpExec,
          },
        );
      },
      { "83977233846759eb": "bnh18", e5ec81b9776169fa: "77Dy0" },
    ],
    bnh18: [
      function (require, module, exports) {
        "use strict";
        var regexpFlags = require("b18976365d49c099");
        var nativeExec = RegExp.prototype.exec;
        // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.
        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var LAST_INDEX = "lastIndex";
        var UPDATES_LAST_INDEX_WRONG = (function () {
          var re1 = /a/,
            re2 = /b*/g;
          nativeExec.call(re1, "a");
          nativeExec.call(re2, "a");
          return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
        })();
        // nonparticipating capturing group, copied from es5-shim's String#split patch.
        var NPCG_INCLUDED = /()??/.exec("")[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
        if (PATCH)
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;
            if (NPCG_INCLUDED)
              reCopy = new RegExp(
                "^" + re.source + "$(?!\\s)",
                regexpFlags.call(re),
              );
            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
            match = nativeExec.call(re, str);
            if (UPDATES_LAST_INDEX_WRONG && match)
              re[LAST_INDEX] = re.global
                ? match.index + match[0].length
                : lastIndex;
            if (NPCG_INCLUDED && match && match.length > 1)
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              // eslint-disable-next-line no-loop-func
              nativeReplace.call(match[0], reCopy, function () {
                for (i = 1; i < arguments.length - 2; i++)
                  if (arguments[i] === undefined) match[i] = undefined;
              });
            return match;
          };
        module.exports = patchedExec;
      },
      { b18976365d49c099: "guRRu" },
    ],
    lItlQ: [
      function (require, module, exports) {
        "use strict";
        require("bf237ce421419801");
        var anObject = require("32dcfc599fc8fa6f");
        var $flags = require("996b4242893ac273");
        var DESCRIPTORS = require("bd1d0c235f4563b1");
        var TO_STRING = "toString";
        var $toString = /./[TO_STRING];
        var define = function (fn) {
          require("51f798ee83c26aff")(RegExp.prototype, TO_STRING, fn, true);
        };
        // 21.2.5.14 RegExp.prototype.toString()
        if (
          require("78f47fa71fa3c3b7")(function () {
            return (
              $toString.call({
                source: "a",
                flags: "b",
              }) != "/a/b"
            );
          })
        )
          define(function toString() {
            var R = anObject(this);
            return "/".concat(
              R.source,
              "/",
              "flags" in R
                ? R.flags
                : !DESCRIPTORS && R instanceof RegExp
                ? $flags.call(R)
                : undefined,
            );
          });
        else if ($toString.name != TO_STRING)
          define(function toString() {
            return $toString.call(this);
          });
      },
      {
        bf237ce421419801: "euwOW",
        "32dcfc599fc8fa6f": "dkWKr",
        "996b4242893ac273": "guRRu",
        bd1d0c235f4563b1: "4XHXy",
        "51f798ee83c26aff": "kcOGE",
        "78f47fa71fa3c3b7": "jYBY4",
      },
    ],
    euwOW: [
      function (require, module, exports) {
        // 21.2.5.3 get RegExp.prototype.flags()
        if (require("f979319066868244") && /./g.flags != "g")
          require("7a70bc15b04e1d93").f(RegExp.prototype, "flags", {
            configurable: true,
            get: require("f4c81a788c207635"),
          });
      },
      {
        f979319066868244: "4XHXy",
        "7a70bc15b04e1d93": "evkkn",
        f4c81a788c207635: "guRRu",
      },
    ],
    lBgqj: [
      function (require, module, exports) {
        "use strict";
        var anObject = require("c6634173e02dc455");
        var toLength = require("6d19feb414a8f771");
        var advanceStringIndex = require("b3311207b0f4e826");
        var regExpExec = require("786fed2e7f6c196e");
        // @@match logic
        require("1e72227f667d7fbe")(
          "match",
          1,
          function (defined, MATCH, $match, maybeCallNative) {
            return [
              // `String.prototype.match` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.match
              function match(regexp) {
                var O = defined(this);
                var fn = regexp == undefined ? undefined : regexp[MATCH];
                return fn !== undefined
                  ? fn.call(regexp, O)
                  : new RegExp(regexp)[MATCH](String(O));
              },
              // `RegExp.prototype[@@match]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
              function (regexp) {
                var res = maybeCallNative($match, regexp, this);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                if (!rx.global) return regExpExec(rx, S);
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
                var A = [];
                var n = 0;
                var result;
                while ((result = regExpExec(rx, S)) !== null) {
                  var matchStr = String(result[0]);
                  A[n] = matchStr;
                  if (matchStr === "")
                    rx.lastIndex = advanceStringIndex(
                      S,
                      toLength(rx.lastIndex),
                      fullUnicode,
                    );
                  n++;
                }
                return n === 0 ? null : A;
              },
            ];
          },
        );
      },
      {
        c6634173e02dc455: "dkWKr",
        "6d19feb414a8f771": "kGg3g",
        b3311207b0f4e826: "7eYbY",
        "786fed2e7f6c196e": "PLpwR",
        "1e72227f667d7fbe": "hBL27",
      },
    ],
    "7eYbY": [
      function (require, module, exports) {
        "use strict";
        var at = require("eb1911677c2b7767")(true);
        // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex
        module.exports = function (S, index, unicode) {
          return index + (unicode ? at(S, index).length : 1);
        };
      },
      { eb1911677c2b7767: "jFcMf" },
    ],
    PLpwR: [
      function (require, module, exports) {
        "use strict";
        var classof = require("be4d38c98980c4eb");
        var builtinExec = RegExp.prototype.exec;
        // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec
        module.exports = function (R, S) {
          var exec = R.exec;
          if (typeof exec === "function") {
            var result = exec.call(R, S);
            if (typeof result !== "object")
              throw new TypeError(
                "RegExp exec method returned something other than an Object or null",
              );
            return result;
          }
          if (classof(R) !== "RegExp")
            throw new TypeError("RegExp#exec called on incompatible receiver");
          return builtinExec.call(R, S);
        };
      },
      { be4d38c98980c4eb: "hCCia" },
    ],
    hBL27: [
      function (require, module, exports) {
        "use strict";
        require("399a5c2685f5eabf");
        var redefine = require("c8249fc8f14cc9bf");
        var hide = require("6ab755b33e6c8d9");
        var fails = require("2eee7a8935588da5");
        var defined = require("ab0043e2a5ffecd0");
        var wks = require("9ac8af721db068d0");
        var regexpExec = require("febb114467bb2007");
        var SPECIES = wks("species");
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;
          re.exec = function () {
            var result = [];
            result.groups = {
              a: "7",
            };
            return result;
          };
          return "".replace(re, "$<a>") !== "7";
        });
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
          // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
          var re = /(?:)/;
          var originalExec = re.exec;
          re.exec = function () {
            return originalExec.apply(this, arguments);
          };
          var result = "ab".split(re);
          return result.length === 2 && result[0] === "a" && result[1] === "b";
        })();
        module.exports = function (KEY, length, exec) {
          var SYMBOL = wks(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};
            O[SYMBOL] = function () {
              return 7;
            };
            return ""[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL
            ? !fails(function () {
                // Symbol-named RegExp methods call .exec
                var execCalled = false;
                var re = /a/;
                re.exec = function () {
                  execCalled = true;
                  return null;
                };
                if (KEY === "split") {
                  // RegExp[@@split] doesn't call the regex's exec method, but first creates
                  // a new one. We need to return the patched regex when creating the new one.
                  re.constructor = {};
                  re.constructor[SPECIES] = function () {
                    return re;
                  };
                }
                re[SYMBOL]("");
                return !execCalled;
              })
            : undefined;
          if (
            !DELEGATES_TO_SYMBOL ||
            !DELEGATES_TO_EXEC ||
            (KEY === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
            (KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
          ) {
            var nativeRegExpMethod = /./[SYMBOL];
            var fns = exec(
              defined,
              SYMBOL,
              ""[KEY],
              function maybeCallNative(
                nativeMethod,
                regexp,
                str,
                arg2,
                forceStringMethod,
              ) {
                if (regexp.exec === regexpExec) {
                  if (DELEGATES_TO_SYMBOL && !forceStringMethod)
                    // The native String method already delegates to @@method (this
                    // polyfilled function), leasing to infinite recursion.
                    // We avoid it by directly calling the native @@method method.
                    return {
                      done: true,
                      value: nativeRegExpMethod.call(regexp, str, arg2),
                    };
                  return {
                    done: true,
                    value: nativeMethod.call(str, regexp, arg2),
                  };
                }
                return {
                  done: false,
                };
              },
            );
            var strfn = fns[0];
            var rxfn = fns[1];
            redefine(String.prototype, KEY, strfn);
            hide(
              RegExp.prototype,
              SYMBOL,
              length == 2
                ? function (string, arg) {
                    return rxfn.call(string, this, arg);
                  }
                : function (string) {
                    return rxfn.call(string, this);
                  },
            );
          }
        };
      },
      {
        "399a5c2685f5eabf": "9Qt83",
        c8249fc8f14cc9bf: "kcOGE",
        "6ab755b33e6c8d9": "4uQIf",
        "2eee7a8935588da5": "jYBY4",
        ab0043e2a5ffecd0: "ic3CF",
        "9ac8af721db068d0": "ea5XI",
        febb114467bb2007: "bnh18",
      },
    ],
    lIohS: [
      function (require, module, exports) {
        "use strict";
        var anObject = require("e6c1bd5473a677ca");
        var toObject = require("b562d6e0987907e2");
        var toLength = require("6631ed129c393eba");
        var toInteger = require("88d71e3fd43d9c28");
        var advanceStringIndex = require("6d8000832081cb0e");
        var regExpExec = require("bed722da05cb7b05");
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
        var maybeToString = function (it) {
          return it === undefined ? it : String(it);
        };
        // @@replace logic
        require("48ef074ae612bff5")(
          "replace",
          2,
          function (defined, REPLACE, $replace, maybeCallNative) {
            return [
              // `String.prototype.replace` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.replace
              function replace(searchValue, replaceValue) {
                var O = defined(this);
                var fn =
                  searchValue == undefined ? undefined : searchValue[REPLACE];
                return fn !== undefined
                  ? fn.call(searchValue, O, replaceValue)
                  : $replace.call(String(O), searchValue, replaceValue);
              },
              // `RegExp.prototype[@@replace]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
              function (regexp, replaceValue) {
                var res = maybeCallNative($replace, regexp, this, replaceValue);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                var functionalReplace = typeof replaceValue === "function";
                if (!functionalReplace) replaceValue = String(replaceValue);
                var global = rx.global;
                if (global) {
                  var fullUnicode = rx.unicode;
                  rx.lastIndex = 0;
                }
                var results = [];
                while (true) {
                  var result = regExpExec(rx, S);
                  if (result === null) break;
                  results.push(result);
                  if (!global) break;
                  var matchStr = String(result[0]);
                  if (matchStr === "")
                    rx.lastIndex = advanceStringIndex(
                      S,
                      toLength(rx.lastIndex),
                      fullUnicode,
                    );
                }
                var accumulatedResult = "";
                var nextSourcePosition = 0;
                for (var i = 0; i < results.length; i++) {
                  result = results[i];
                  var matched = String(result[0]);
                  var position = max(min(toInteger(result.index), S.length), 0);
                  var captures = [];
                  // NOTE: This is equivalent to
                  //   captures = result.slice(1).map(maybeToString)
                  // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                  // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                  // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                  for (var j = 1; j < result.length; j++)
                    captures.push(maybeToString(result[j]));
                  var namedCaptures = result.groups;
                  if (functionalReplace) {
                    var replacerArgs = [matched].concat(captures, position, S);
                    if (namedCaptures !== undefined)
                      replacerArgs.push(namedCaptures);
                    var replacement = String(
                      replaceValue.apply(undefined, replacerArgs),
                    );
                  } else
                    replacement = getSubstitution(
                      matched,
                      S,
                      position,
                      captures,
                      namedCaptures,
                      replaceValue,
                    );
                  if (position >= nextSourcePosition) {
                    accumulatedResult +=
                      S.slice(nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                  }
                }
                return accumulatedResult + S.slice(nextSourcePosition);
              },
            ];
            // https://tc39.github.io/ecma262/#sec-getsubstitution
            function getSubstitution(
              matched,
              str,
              position,
              captures,
              namedCaptures,
              replacement,
            ) {
              var tailPos = position + matched.length;
              var m = captures.length;
              var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
              if (namedCaptures !== undefined) {
                namedCaptures = toObject(namedCaptures);
                symbols = SUBSTITUTION_SYMBOLS;
              }
              return $replace.call(replacement, symbols, function (match, ch) {
                var capture;
                switch (ch.charAt(0)) {
                  case "$":
                    return "$";
                  case "&":
                    return matched;
                  case "`":
                    return str.slice(0, position);
                  case "'":
                    return str.slice(tailPos);
                  case "<":
                    capture = namedCaptures[ch.slice(1, -1)];
                    break;
                  default:
                    var n = +ch;
                    if (n === 0) return match;
                    if (n > m) {
                      var f = floor(n / 10);
                      if (f === 0) return match;
                      if (f <= m)
                        return captures[f - 1] === undefined
                          ? ch.charAt(1)
                          : captures[f - 1] + ch.charAt(1);
                      return match;
                    }
                    capture = captures[n - 1];
                }
                return capture === undefined ? "" : capture;
              });
            }
          },
        );
      },
      {
        e6c1bd5473a677ca: "dkWKr",
        b562d6e0987907e2: "dZ3od",
        "6631ed129c393eba": "kGg3g",
        "88d71e3fd43d9c28": "jmpId",
        "6d8000832081cb0e": "7eYbY",
        bed722da05cb7b05: "PLpwR",
        "48ef074ae612bff5": "hBL27",
      },
    ],
    "4NG4w": [
      function (require, module, exports) {
        "use strict";
        var anObject = require("6f3d9dae65eb8188");
        var sameValue = require("487ba5173107ad06");
        var regExpExec = require("ba50a60c6b262a41");
        // @@search logic
        require("600450f67bc28e21")(
          "search",
          1,
          function (defined, SEARCH, $search, maybeCallNative) {
            return [
              // `String.prototype.search` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.search
              function search(regexp) {
                var O = defined(this);
                var fn = regexp == undefined ? undefined : regexp[SEARCH];
                return fn !== undefined
                  ? fn.call(regexp, O)
                  : new RegExp(regexp)[SEARCH](String(O));
              },
              // `RegExp.prototype[@@search]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
              function (regexp) {
                var res = maybeCallNative($search, regexp, this);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                var previousLastIndex = rx.lastIndex;
                if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
                var result = regExpExec(rx, S);
                if (!sameValue(rx.lastIndex, previousLastIndex))
                  rx.lastIndex = previousLastIndex;
                return result === null ? -1 : result.index;
              },
            ];
          },
        );
      },
      {
        "6f3d9dae65eb8188": "dkWKr",
        "487ba5173107ad06": "2xNNp",
        ba50a60c6b262a41: "PLpwR",
        "600450f67bc28e21": "hBL27",
      },
    ],
    "4OaGh": [
      function (require, module, exports) {
        "use strict";
        var isRegExp = require("54781ea69650ff8");
        var anObject = require("d483ac84ffa879f2");
        var speciesConstructor = require("226ccaf5bb7bf35d");
        var advanceStringIndex = require("8e226ff373f74c84");
        var toLength = require("3a8aee655245654f");
        var callRegExpExec = require("de091a5344ce6048");
        var regexpExec = require("538e4595141e0428");
        var fails = require("485e395e4a2526de");
        var $min = Math.min;
        var $push = [].push;
        var $SPLIT = "split";
        var LENGTH = "length";
        var LAST_INDEX = "lastIndex";
        var MAX_UINT32 = 0xffffffff;
        // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
        var SUPPORTS_Y = !fails(function () {
          RegExp(MAX_UINT32, "y");
        });
        // @@split logic
        require("63e4a602691d5c17")(
          "split",
          2,
          function (defined, SPLIT, $split, maybeCallNative) {
            var internalSplit;
            if (
              "abbc"[$SPLIT](/(b)*/)[1] == "c" ||
              "test"[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
              "ab"[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
              "."[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
              "."[$SPLIT](/()()/)[LENGTH] > 1 ||
              ""[$SPLIT](/.?/)[LENGTH]
            )
              // based on es5-shim implementation, need to rework it
              internalSplit = function (separator, limit) {
                var string = String(this);
                if (separator === undefined && limit === 0) return [];
                // If `separator` is not a regex, use native split
                if (!isRegExp(separator))
                  return $split.call(string, separator, limit);
                var output = [];
                var flags =
                  (separator.ignoreCase ? "i" : "") +
                  (separator.multiline ? "m" : "") +
                  (separator.unicode ? "u" : "") +
                  (separator.sticky ? "y" : "");
                var lastLastIndex = 0;
                var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
                // Make `global` and avoid `lastIndex` issues by working with a copy
                var separatorCopy = new RegExp(separator.source, flags + "g");
                var match, lastIndex, lastLength;
                while ((match = regexpExec.call(separatorCopy, string))) {
                  lastIndex = separatorCopy[LAST_INDEX];
                  if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    if (match[LENGTH] > 1 && match.index < string[LENGTH])
                      $push.apply(output, match.slice(1));
                    lastLength = match[0][LENGTH];
                    lastLastIndex = lastIndex;
                    if (output[LENGTH] >= splitLimit) break;
                  }
                  if (separatorCopy[LAST_INDEX] === match.index)
                    separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
                }
                if (lastLastIndex === string[LENGTH]) {
                  if (lastLength || !separatorCopy.test("")) output.push("");
                } else output.push(string.slice(lastLastIndex));
                return output[LENGTH] > splitLimit
                  ? output.slice(0, splitLimit)
                  : output;
              };
            else if ("0"[$SPLIT](undefined, 0)[LENGTH])
              internalSplit = function (separator, limit) {
                return separator === undefined && limit === 0
                  ? []
                  : $split.call(this, separator, limit);
              };
            else internalSplit = $split;
            return [
              // `String.prototype.split` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.split
              function split(separator, limit) {
                var O = defined(this);
                var splitter =
                  separator == undefined ? undefined : separator[SPLIT];
                return splitter !== undefined
                  ? splitter.call(separator, O, limit)
                  : internalSplit.call(String(O), separator, limit);
              },
              // `RegExp.prototype[@@split]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
              //
              // NOTE: This cannot be properly polyfilled in engines that don't support
              // the 'y' flag.
              function (regexp, limit) {
                var res = maybeCallNative(
                  internalSplit,
                  regexp,
                  this,
                  limit,
                  internalSplit !== $split,
                );
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                var C = speciesConstructor(rx, RegExp);
                var unicodeMatching = rx.unicode;
                var flags =
                  (rx.ignoreCase ? "i" : "") +
                  (rx.multiline ? "m" : "") +
                  (rx.unicode ? "u" : "") +
                  (SUPPORTS_Y ? "y" : "g");
                // ^(? + rx + ) is needed, in combination with some S slicing, to
                // simulate the 'y' flag.
                var splitter = new C(
                  SUPPORTS_Y ? rx : "^(?:" + rx.source + ")",
                  flags,
                );
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (S.length === 0)
                  return callRegExpExec(splitter, S) === null ? [S] : [];
                var p = 0;
                var q = 0;
                var A = [];
                while (q < S.length) {
                  splitter.lastIndex = SUPPORTS_Y ? q : 0;
                  var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                  var e;
                  if (
                    z === null ||
                    (e = $min(
                      toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)),
                      S.length,
                    )) === p
                  )
                    q = advanceStringIndex(S, q, unicodeMatching);
                  else {
                    A.push(S.slice(p, q));
                    if (A.length === lim) return A;
                    for (var i = 1; i <= z.length - 1; i++) {
                      A.push(z[i]);
                      if (A.length === lim) return A;
                    }
                    q = p = e;
                  }
                }
                A.push(S.slice(p));
                return A;
              },
            ];
          },
        );
      },
      {
        "54781ea69650ff8": "hcS20",
        d483ac84ffa879f2: "dkWKr",
        "226ccaf5bb7bf35d": "c539Q",
        "8e226ff373f74c84": "7eYbY",
        "3a8aee655245654f": "kGg3g",
        de091a5344ce6048: "PLpwR",
        "538e4595141e0428": "bnh18",
        "485e395e4a2526de": "jYBY4",
        "63e4a602691d5c17": "hBL27",
      },
    ],
    c539Q: [
      function (require, module, exports) {
        // 7.3.20 SpeciesConstructor(O, defaultConstructor)
        var anObject = require("e180375600aa421b");
        var aFunction = require("d1bfe15a5be8fde4");
        var SPECIES = require("815bf9106a2c841d")("species");
        module.exports = function (O, D) {
          var C = anObject(O).constructor;
          var S;
          return C === undefined || (S = anObject(C)[SPECIES]) == undefined
            ? D
            : aFunction(S);
        };
      },
      {
        e180375600aa421b: "dkWKr",
        d1bfe15a5be8fde4: "7M8Zs",
        "815bf9106a2c841d": "ea5XI",
      },
    ],
    xHtR0: [
      function (require, module, exports) {
        "use strict";
        var LIBRARY = require("371fb788d3e25ee2");
        var global = require("de0e6c5c5eaf09ec");
        var ctx = require("c72364422237a12b");
        var classof = require("12098a4a00b6a26");
        var $export = require("7d074229bf724ef9");
        var isObject = require("3d1b39f67a207a11");
        var aFunction = require("1ea81930212be67b");
        var anInstance = require("c38ca40e425bbdaf");
        var forOf = require("3f2d805e881657d8");
        var speciesConstructor = require("cdba72292e2cbaaa");
        var task = require("7d4dae83e91c8bf0").set;
        var microtask = require("5d8e0718ca67a0af")();
        var newPromiseCapabilityModule = require("4a57915564ebbb2a");
        var perform = require("181832828365fc8");
        var userAgent = require("bcbb063c1566e231");
        var promiseResolve = require("2f21244c25f4a53e");
        var PROMISE = "Promise";
        var TypeError = global.TypeError;
        var process = global.process;
        var versions = process && process.versions;
        var v8 = (versions && versions.v8) || "";
        var $Promise = global[PROMISE];
        var isNode = classof(process) == "process";
        var empty = function () {};
        var Internal,
          newGenericPromiseCapability,
          OwnPromiseCapability,
          Wrapper;
        var newPromiseCapability = (newGenericPromiseCapability =
          newPromiseCapabilityModule.f);
        var USE_NATIVE = !!(function () {
          try {
            // correct subclassing with @@species support
            var promise = $Promise.resolve(1);
            var FakePromise = ((promise.constructor = {})[
              require("bead1b906d4d2012")("species")
            ] = function (exec) {
              exec(empty, empty);
            });
            // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
            return (
              (isNode || typeof PromiseRejectionEvent == "function") &&
              promise.then(empty) instanceof FakePromise &&
              v8.indexOf("6.6") !== 0 &&
              userAgent.indexOf("Chrome/66") === -1
            );
          } catch (e) {}
        })();
        // helpers
        var isThenable = function (it) {
          var then;
          return isObject(it) && typeof (then = it.then) == "function"
            ? then
            : false;
        };
        var notify = function (promise, isReject) {
          if (promise._n) return;
          promise._n = true;
          var chain = promise._c;
          microtask(function () {
            var value = promise._v;
            var ok = promise._s == 1;
            var i = 0;
            var run = function (reaction) {
              var handler = ok ? reaction.ok : reaction.fail;
              var resolve = reaction.resolve;
              var reject = reaction.reject;
              var domain = reaction.domain;
              var result, then, exited;
              try {
                if (handler) {
                  if (!ok) {
                    if (promise._h == 2) onHandleUnhandled(promise);
                    promise._h = 1;
                  }
                  if (handler === true) result = value;
                  else {
                    if (domain) domain.enter();
                    result = handler(value); // may throw
                    if (domain) {
                      domain.exit();
                      exited = true;
                    }
                  }
                  if (result === reaction.promise)
                    reject(TypeError("Promise-chain cycle"));
                  else if ((then = isThenable(result)))
                    then.call(result, resolve, reject);
                  else resolve(result);
                } else reject(value);
              } catch (e) {
                if (domain && !exited) domain.exit();
                reject(e);
              }
            };
            while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
            promise._c = [];
            promise._n = false;
            if (isReject && !promise._h) onUnhandled(promise);
          });
        };
        var onUnhandled = function (promise) {
          task.call(global, function () {
            var value = promise._v;
            var unhandled = isUnhandled(promise);
            var result, handler, console;
            if (unhandled) {
              result = perform(function () {
                if (isNode) process.emit("unhandledRejection", value, promise);
                else if ((handler = global.onunhandledrejection))
                  handler({
                    promise: promise,
                    reason: value,
                  });
                else if ((console = global.console) && console.error)
                  console.error("Unhandled promise rejection", value);
              });
              // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
              promise._h = isNode || isUnhandled(promise) ? 2 : 1;
            }
            promise._a = undefined;
            if (unhandled && result.e) throw result.v;
          });
        };
        var isUnhandled = function (promise) {
          return promise._h !== 1 && (promise._a || promise._c).length === 0;
        };
        var onHandleUnhandled = function (promise) {
          task.call(global, function () {
            var handler;
            if (isNode) process.emit("rejectionHandled", promise);
            else if ((handler = global.onrejectionhandled))
              handler({
                promise: promise,
                reason: promise._v,
              });
          });
        };
        var $reject = function (value) {
          var promise = this;
          if (promise._d) return;
          promise._d = true;
          promise = promise._w || promise; // unwrap
          promise._v = value;
          promise._s = 2;
          if (!promise._a) promise._a = promise._c.slice();
          notify(promise, true);
        };
        var $resolve = function (value) {
          var promise = this;
          var then;
          if (promise._d) return;
          promise._d = true;
          promise = promise._w || promise; // unwrap
          try {
            if (promise === value)
              throw TypeError("Promise can't be resolved itself");
            if ((then = isThenable(value)))
              microtask(function () {
                var wrapper = {
                  _w: promise,
                  _d: false,
                }; // wrap
                try {
                  then.call(
                    value,
                    ctx($resolve, wrapper, 1),
                    ctx($reject, wrapper, 1),
                  );
                } catch (e) {
                  $reject.call(wrapper, e);
                }
              });
            else {
              promise._v = value;
              promise._s = 1;
              notify(promise, false);
            }
          } catch (e) {
            $reject.call(
              {
                _w: promise,
                _d: false,
              },
              e,
            ); // wrap
          }
        };
        // constructor polyfill
        if (!USE_NATIVE) {
          // 25.4.3.1 Promise(executor)
          $Promise = function Promise(executor) {
            anInstance(this, $Promise, PROMISE, "_h");
            aFunction(executor);
            Internal.call(this);
            try {
              executor(ctx($resolve, this, 1), ctx($reject, this, 1));
            } catch (err) {
              $reject.call(this, err);
            }
          };
          // eslint-disable-next-line no-unused-vars
          Internal = function Promise(executor) {
            this._c = []; // <- awaiting reactions
            this._a = undefined; // <- checked in isUnhandled reactions
            this._s = 0; // <- state
            this._d = false; // <- done
            this._v = undefined; // <- value
            this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
            this._n = false; // <- notify
          };
          Internal.prototype = require("18e49a148f1f2edd")($Promise.prototype, {
            // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
            then: function then(onFulfilled, onRejected) {
              var reaction = newPromiseCapability(
                speciesConstructor(this, $Promise),
              );
              reaction.ok =
                typeof onFulfilled == "function" ? onFulfilled : true;
              reaction.fail = typeof onRejected == "function" && onRejected;
              reaction.domain = isNode ? process.domain : undefined;
              this._c.push(reaction);
              if (this._a) this._a.push(reaction);
              if (this._s) notify(this, false);
              return reaction.promise;
            },
            // 25.4.5.1 Promise.prototype.catch(onRejected)
            catch: function (onRejected) {
              return this.then(undefined, onRejected);
            },
          });
          OwnPromiseCapability = function () {
            var promise = new Internal();
            this.promise = promise;
            this.resolve = ctx($resolve, promise, 1);
            this.reject = ctx($reject, promise, 1);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
            return C === $Promise || C === Wrapper
              ? new OwnPromiseCapability(C)
              : newGenericPromiseCapability(C);
          };
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
          Promise: $Promise,
        });
        require("d133728d0503b507")($Promise, PROMISE);
        require("532a511ca76c57cf")(PROMISE);
        Wrapper = require("be411fbb5686adbf")[PROMISE];
        // statics
        $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
          // 25.4.4.5 Promise.reject(r)
          reject: function reject(r) {
            var capability = newPromiseCapability(this);
            var $$reject = capability.reject;
            $$reject(r);
            return capability.promise;
          },
        });
        $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
          // 25.4.4.6 Promise.resolve(x)
          resolve: function resolve(x) {
            return promiseResolve(
              LIBRARY && this === Wrapper ? $Promise : this,
              x,
            );
          },
        });
        $export(
          $export.S +
            $export.F *
              !(
                USE_NATIVE &&
                require("7e16e5fa01f8cae2")(function (iter) {
                  $Promise.all(iter)["catch"](empty);
                })
              ),
          PROMISE,
          {
            // 25.4.4.1 Promise.all(iterable)
            all: function all(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var resolve = capability.resolve;
              var reject = capability.reject;
              var result = perform(function () {
                var values = [];
                var index = 0;
                var remaining = 1;
                forOf(iterable, false, function (promise) {
                  var $index = index++;
                  var alreadyCalled = false;
                  values.push(undefined);
                  remaining++;
                  C.resolve(promise).then(function (value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[$index] = value;
                    --remaining || resolve(values);
                  }, reject);
                });
                --remaining || resolve(values);
              });
              if (result.e) reject(result.v);
              return capability.promise;
            },
            // 25.4.4.4 Promise.race(iterable)
            race: function race(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var reject = capability.reject;
              var result = perform(function () {
                forOf(iterable, false, function (promise) {
                  C.resolve(promise).then(capability.resolve, reject);
                });
              });
              if (result.e) reject(result.v);
              return capability.promise;
            },
          },
        );
      },
      {
        "371fb788d3e25ee2": "4YPyS",
        de0e6c5c5eaf09ec: "c0KvC",
        c72364422237a12b: "gpAgQ",
        "12098a4a00b6a26": "hCCia",
        "7d074229bf724ef9": "77Dy0",
        "3d1b39f67a207a11": "joZov",
        "1ea81930212be67b": "7M8Zs",
        c38ca40e425bbdaf: "8csub",
        "3f2d805e881657d8": "bvJ4u",
        cdba72292e2cbaaa: "c539Q",
        "7d4dae83e91c8bf0": "a9IYo",
        "5d8e0718ca67a0af": "hcggl",
        "4a57915564ebbb2a": "agoDO",
        "181832828365fc8": "dbTZh",
        bcbb063c1566e231: "8s6J7",
        "2f21244c25f4a53e": "aKTpL",
        bead1b906d4d2012: "ea5XI",
        "18e49a148f1f2edd": "6yUMJ",
        d133728d0503b507: "eBrgu",
        "532a511ca76c57cf": "37abT",
        be411fbb5686adbf: "8jGrK",
        "7e16e5fa01f8cae2": "iJ7Ec",
      },
    ],
    "8csub": [
      function (require, module, exports) {
        module.exports = function (it, Constructor, name, forbiddenField) {
          if (
            !(it instanceof Constructor) ||
            (forbiddenField !== undefined && forbiddenField in it)
          )
            throw TypeError(name + ": incorrect invocation!");
          return it;
        };
      },
      {},
    ],
    bvJ4u: [
      function (require, module, exports) {
        var ctx = require("344b7a703b4a8d33");
        var call = require("4e3911dcd6245fb0");
        var isArrayIter = require("cf6b9ad4ee5b0ca0");
        var anObject = require("50dec1e16d0a1de5");
        var toLength = require("e95ed1a8be692276");
        var getIterFn = require("33dd45004194696c");
        var BREAK = {};
        var RETURN = {};
        var exports = (module.exports = function (
          iterable,
          entries,
          fn,
          that,
          ITERATOR,
        ) {
          var iterFn = ITERATOR
            ? function () {
                return iterable;
              }
            : getIterFn(iterable);
          var f = ctx(fn, that, entries ? 2 : 1);
          var index = 0;
          var length, step, iterator, result;
          if (typeof iterFn != "function")
            throw TypeError(iterable + " is not iterable!");
          // fast case for arrays with default iterator
          if (isArrayIter(iterFn))
            for (length = toLength(iterable.length); length > index; index++) {
              result = entries
                ? f(anObject((step = iterable[index]))[0], step[1])
                : f(iterable[index]);
              if (result === BREAK || result === RETURN) return result;
            }
          else
            for (
              iterator = iterFn.call(iterable);
              !(step = iterator.next()).done;

            ) {
              result = call(iterator, f, step.value, entries);
              if (result === BREAK || result === RETURN) return result;
            }
        });
        exports.BREAK = BREAK;
        exports.RETURN = RETURN;
      },
      {
        "344b7a703b4a8d33": "gpAgQ",
        "4e3911dcd6245fb0": "bQdzI",
        cf6b9ad4ee5b0ca0: "3BsWF",
        "50dec1e16d0a1de5": "dkWKr",
        e95ed1a8be692276: "kGg3g",
        "33dd45004194696c": "3H2Vr",
      },
    ],
    a9IYo: [
      function (require, module, exports) {
        var ctx = require("32356da8c45c3f2c");
        var invoke = require("fb4cc083a1a0dab7");
        var html = require("4c3e5a730f62d9d7");
        var cel = require("926c67e3e4b7eb5");
        var global = require("597566726cfd8373");
        var process = global.process;
        var setTask = global.setImmediate;
        var clearTask = global.clearImmediate;
        var MessageChannel = global.MessageChannel;
        var Dispatch = global.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = "onreadystatechange";
        var defer, channel, port;
        var run = function () {
          var id = +this;
          // eslint-disable-next-line no-prototype-builtins
          if (queue.hasOwnProperty(id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
          }
        };
        var listener = function (event) {
          run.call(event.data);
        };
        // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
        if (!setTask || !clearTask) {
          setTask = function setImmediate(fn) {
            var args = [];
            var i = 1;
            while (arguments.length > i) args.push(arguments[i++]);
            queue[++counter] = function () {
              // eslint-disable-next-line no-new-func
              invoke(typeof fn == "function" ? fn : Function(fn), args);
            };
            defer(counter);
            return counter;
          };
          clearTask = function clearImmediate(id) {
            delete queue[id];
          };
          // Node.js 0.8-
          if (require("319575ec41286486")(process) == "process")
            defer = function (id) {
              process.nextTick(ctx(run, id, 1));
            };
          else if (Dispatch && Dispatch.now)
            defer = function (id) {
              Dispatch.now(ctx(run, id, 1));
            };
          else if (MessageChannel) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = ctx(port.postMessage, port, 1);
            // Browsers with postMessage, skip WebWorkers
            // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
          } else if (
            global.addEventListener &&
            typeof postMessage == "function" &&
            !global.importScripts
          ) {
            defer = function (id) {
              global.postMessage(id + "", "*");
            };
            global.addEventListener("message", listener, false);
            // IE8-
          } else if (ONREADYSTATECHANGE in cel("script"))
            defer = function (id) {
              html.appendChild(cel("script"))[ONREADYSTATECHANGE] =
                function () {
                  html.removeChild(this);
                  run.call(id);
                };
            };
          else
            defer = function (id) {
              setTimeout(ctx(run, id, 1), 0);
            };
        }
        module.exports = {
          set: setTask,
          clear: clearTask,
        };
      },
      {
        "32356da8c45c3f2c": "gpAgQ",
        fb4cc083a1a0dab7: "7ihys",
        "4c3e5a730f62d9d7": "lqTMW",
        "926c67e3e4b7eb5": "kIGVy",
        "597566726cfd8373": "c0KvC",
        "319575ec41286486": "8ezVG",
      },
    ],
    hcggl: [
      function (require, module, exports) {
        var global = require("694dced00e8dc026");
        var macrotask = require("b718a14bfedf603a").set;
        var Observer = global.MutationObserver || global.WebKitMutationObserver;
        var process = global.process;
        var Promise = global.Promise;
        var isNode = require("466ee816b23ca065")(process) == "process";
        module.exports = function () {
          var head, last, notify;
          var flush = function () {
            var parent, fn;
            if (isNode && (parent = process.domain)) parent.exit();
            while (head) {
              fn = head.fn;
              head = head.next;
              try {
                fn();
              } catch (e) {
                if (head) notify();
                else last = undefined;
                throw e;
              }
            }
            last = undefined;
            if (parent) parent.enter();
          };
          // Node.js
          if (isNode)
            notify = function () {
              process.nextTick(flush);
            };
          else if (
            Observer &&
            !(global.navigator && global.navigator.standalone)
          ) {
            var toggle = true;
            var node = document.createTextNode("");
            new Observer(flush).observe(node, {
              characterData: true,
            }); // eslint-disable-line no-new
            notify = function () {
              node.data = toggle = !toggle;
            };
            // environments with maybe non-completely correct, but existent Promise
          } else if (Promise && Promise.resolve) {
            // Promise.resolve without an argument throws an error in LG WebOS 2
            var promise = Promise.resolve(undefined);
            notify = function () {
              promise.then(flush);
            };
            // for other environments - macrotask based on:
            // - setImmediate
            // - MessageChannel
            // - window.postMessag
            // - onreadystatechange
            // - setTimeout
          } else
            notify = function () {
              // strange IE + webpack dev server bug - use .call(global)
              macrotask.call(global, flush);
            };
          return function (fn) {
            var task = {
              fn: fn,
              next: undefined,
            };
            if (last) last.next = task;
            if (!head) {
              head = task;
              notify();
            }
            last = task;
          };
        };
      },
      {
        "694dced00e8dc026": "c0KvC",
        b718a14bfedf603a: "a9IYo",
        "466ee816b23ca065": "8ezVG",
      },
    ],
    agoDO: [
      function (require, module, exports) {
        "use strict";
        // 25.4.1.5 NewPromiseCapability(C)
        var aFunction = require("9e95d22305e51341");
        function PromiseCapability(C) {
          var resolve, reject;
          this.promise = new C(function ($$resolve, $$reject) {
            if (resolve !== undefined || reject !== undefined)
              throw TypeError("Bad Promise constructor");
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aFunction(resolve);
          this.reject = aFunction(reject);
        }
        module.exports.f = function (C) {
          return new PromiseCapability(C);
        };
      },
      { "9e95d22305e51341": "7M8Zs" },
    ],
    dbTZh: [
      function (require, module, exports) {
        module.exports = function (exec) {
          try {
            return {
              e: false,
              v: exec(),
            };
          } catch (e) {
            return {
              e: true,
              v: e,
            };
          }
        };
      },
      {},
    ],
    "8s6J7": [
      function (require, module, exports) {
        var global = require("a36a05c591620af2");
        var navigator = global.navigator;
        module.exports = (navigator && navigator.userAgent) || "";
      },
      { a36a05c591620af2: "c0KvC" },
    ],
    aKTpL: [
      function (require, module, exports) {
        var anObject = require("fb7cac3fec17cb98");
        var isObject = require("cd1451dcfb16951c");
        var newPromiseCapability = require("d863eeb559892235");
        module.exports = function (C, x) {
          anObject(C);
          if (isObject(x) && x.constructor === C) return x;
          var promiseCapability = newPromiseCapability.f(C);
          var resolve = promiseCapability.resolve;
          resolve(x);
          return promiseCapability.promise;
        };
      },
      {
        fb7cac3fec17cb98: "dkWKr",
        cd1451dcfb16951c: "joZov",
        d863eeb559892235: "agoDO",
      },
    ],
    "6yUMJ": [
      function (require, module, exports) {
        var redefine = require("306bb238b15d00ab");
        module.exports = function (target, src, safe) {
          for (var key in src) redefine(target, key, src[key], safe);
          return target;
        };
      },
      { "306bb238b15d00ab": "kcOGE" },
    ],
    b6ohp: [
      function (require, module, exports) {
        "use strict";
        var strong = require("f7486487c635bcd4");
        var validate = require("bf6ca021f310b920");
        var MAP = "Map";
        // 23.1 Map Objects
        module.exports = require("c126fd59477c77f2")(
          MAP,
          function (get) {
            return function Map() {
              return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
          },
          {
            // 23.1.3.6 Map.prototype.get(key)
            get: function get(key) {
              var entry = strong.getEntry(validate(this, MAP), key);
              return entry && entry.v;
            },
            // 23.1.3.9 Map.prototype.set(key, value)
            set: function set(key, value) {
              return strong.def(
                validate(this, MAP),
                key === 0 ? 0 : key,
                value,
              );
            },
          },
          strong,
          true,
        );
      },
      {
        f7486487c635bcd4: "hYZyq",
        bf6ca021f310b920: "5pmm3",
        c126fd59477c77f2: "Djufa",
      },
    ],
    hYZyq: [
      function (require, module, exports) {
        "use strict";
        var dP = require("5bfd79c5a759b646").f;
        var create = require("6a12fa151c5a1082");
        var redefineAll = require("ce3a1544e39ad806");
        var ctx = require("35bb843ababdb58b");
        var anInstance = require("45b2cec3cb385c37");
        var forOf = require("e2e983c0ab2c54cb");
        var $iterDefine = require("459ce0bc2f23417c");
        var step = require("8270b8796c6384bd");
        var setSpecies = require("8de729f0aadda0a6");
        var DESCRIPTORS = require("a9fb8ddf192a772d");
        var fastKey = require("ae7461b0d0dd22e9").fastKey;
        var validate = require("823c8ba6cc2133ce");
        var SIZE = DESCRIPTORS ? "_s" : "size";
        var getEntry = function (that, key) {
          // fast case
          var index = fastKey(key);
          var entry;
          if (index !== "F") return that._i[index];
          // frozen object case
          for (entry = that._f; entry; entry = entry.n) {
            if (entry.k == key) return entry;
          }
        };
        module.exports = {
          getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
            var C = wrapper(function (that, iterable) {
              anInstance(that, C, NAME, "_i");
              that._t = NAME; // collection type
              that._i = create(null); // index
              that._f = undefined; // first entry
              that._l = undefined; // last entry
              that[SIZE] = 0; // size
              if (iterable != undefined)
                forOf(iterable, IS_MAP, that[ADDER], that);
            });
            redefineAll(C.prototype, {
              // 23.1.3.1 Map.prototype.clear()
              // 23.2.3.2 Set.prototype.clear()
              clear: function clear() {
                for (
                  var that = validate(this, NAME),
                    data = that._i,
                    entry = that._f;
                  entry;
                  entry = entry.n
                ) {
                  entry.r = true;
                  if (entry.p) entry.p = entry.p.n = undefined;
                  delete data[entry.i];
                }
                that._f = that._l = undefined;
                that[SIZE] = 0;
              },
              // 23.1.3.3 Map.prototype.delete(key)
              // 23.2.3.4 Set.prototype.delete(value)
              delete: function (key) {
                var that = validate(this, NAME);
                var entry = getEntry(that, key);
                if (entry) {
                  var next = entry.n;
                  var prev = entry.p;
                  delete that._i[entry.i];
                  entry.r = true;
                  if (prev) prev.n = next;
                  if (next) next.p = prev;
                  if (that._f == entry) that._f = next;
                  if (that._l == entry) that._l = prev;
                  that[SIZE]--;
                }
                return !!entry;
              },
              // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
              // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
              forEach: function forEach(callbackfn /* , that = undefined */) {
                validate(this, NAME);
                var f = ctx(
                  callbackfn,
                  arguments.length > 1 ? arguments[1] : undefined,
                  3,
                );
                var entry;
                while ((entry = entry ? entry.n : this._f)) {
                  f(entry.v, entry.k, this);
                  // revert to the last existing entry
                  while (entry && entry.r) entry = entry.p;
                }
              },
              // 23.1.3.7 Map.prototype.has(key)
              // 23.2.3.7 Set.prototype.has(value)
              has: function has(key) {
                return !!getEntry(validate(this, NAME), key);
              },
            });
            if (DESCRIPTORS)
              dP(C.prototype, "size", {
                get: function () {
                  return validate(this, NAME)[SIZE];
                },
              });
            return C;
          },
          def: function (that, key, value) {
            var entry = getEntry(that, key);
            var prev, index;
            // change existing entry
            if (entry) entry.v = value;
            else {
              that._l = entry = {
                i: (index = fastKey(key, true)),
                k: key,
                v: value,
                p: (prev = that._l),
                n: undefined,
                r: false, // <- removed
              };
              if (!that._f) that._f = entry;
              if (prev) prev.n = entry;
              that[SIZE]++;
              // add to index
              if (index !== "F") that._i[index] = entry;
            }
            return that;
          },
          getEntry: getEntry,
          setStrong: function (C, NAME, IS_MAP) {
            // add .keys, .values, .entries, [@@iterator]
            // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
            $iterDefine(
              C,
              NAME,
              function (iterated, kind) {
                this._t = validate(iterated, NAME); // target
                this._k = kind; // kind
                this._l = undefined; // previous
              },
              function () {
                var that = this;
                var kind = that._k;
                var entry = that._l;
                // revert to the last existing entry
                while (entry && entry.r) entry = entry.p;
                // get next entry
                if (
                  !that._t ||
                  !(that._l = entry = entry ? entry.n : that._t._f)
                ) {
                  // or finish the iteration
                  that._t = undefined;
                  return step(1);
                }
                // return step by kind
                if (kind == "keys") return step(0, entry.k);
                if (kind == "values") return step(0, entry.v);
                return step(0, [entry.k, entry.v]);
              },
              IS_MAP ? "entries" : "values",
              !IS_MAP,
              true,
            );
            // add [@@species], 23.1.2.2, 23.2.2.2
            setSpecies(NAME);
          },
        };
      },
      {
        "5bfd79c5a759b646": "evkkn",
        "6a12fa151c5a1082": "2DOWX",
        ce3a1544e39ad806: "6yUMJ",
        "35bb843ababdb58b": "gpAgQ",
        "45b2cec3cb385c37": "8csub",
        e2e983c0ab2c54cb: "bvJ4u",
        "459ce0bc2f23417c": "5T86g",
        "8270b8796c6384bd": "dprL2",
        "8de729f0aadda0a6": "37abT",
        a9fb8ddf192a772d: "4XHXy",
        ae7461b0d0dd22e9: "jIXDG",
        "823c8ba6cc2133ce": "5pmm3",
      },
    ],
    "5pmm3": [
      function (require, module, exports) {
        var isObject = require("e727afdaed69bfe0");
        module.exports = function (it, TYPE) {
          if (!isObject(it) || it._t !== TYPE)
            throw TypeError("Incompatible receiver, " + TYPE + " required!");
          return it;
        };
      },
      { e727afdaed69bfe0: "joZov" },
    ],
    Djufa: [
      function (require, module, exports) {
        "use strict";
        var global = require("81785bf07790142");
        var $export = require("98a20a75069249db");
        var redefine = require("eed77c67a61d6bc3");
        var redefineAll = require("56ab35d32fd2ad35");
        var meta = require("cc230034505debd6");
        var forOf = require("1e60feab896f7ad8");
        var anInstance = require("cbc6deedb2303507");
        var isObject = require("9ff4e926c8bee2b1");
        var fails = require("1605bf0457b569e0");
        var $iterDetect = require("18826cab27a9fb1d");
        var setToStringTag = require("ce7d578f27827465");
        var inheritIfRequired = require("238bcffe970dd32d");
        module.exports = function (
          NAME,
          wrapper,
          methods,
          common,
          IS_MAP,
          IS_WEAK,
        ) {
          var Base = global[NAME];
          var C = Base;
          var ADDER = IS_MAP ? "set" : "add";
          var proto = C && C.prototype;
          var O = {};
          var fixMethod = function (KEY) {
            var fn = proto[KEY];
            redefine(
              proto,
              KEY,
              KEY == "delete"
                ? function (a) {
                    return IS_WEAK && !isObject(a)
                      ? false
                      : fn.call(this, a === 0 ? 0 : a);
                  }
                : KEY == "has"
                ? function has(a) {
                    return IS_WEAK && !isObject(a)
                      ? false
                      : fn.call(this, a === 0 ? 0 : a);
                  }
                : KEY == "get"
                ? function get(a) {
                    return IS_WEAK && !isObject(a)
                      ? undefined
                      : fn.call(this, a === 0 ? 0 : a);
                  }
                : KEY == "add"
                ? function add(a) {
                    fn.call(this, a === 0 ? 0 : a);
                    return this;
                  }
                : function set(a, b) {
                    fn.call(this, a === 0 ? 0 : a, b);
                    return this;
                  },
            );
          };
          if (
            typeof C != "function" ||
            !(
              IS_WEAK ||
              (proto.forEach &&
                !fails(function () {
                  new C().entries().next();
                }))
            )
          ) {
            // create collection constructor
            C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
            redefineAll(C.prototype, methods);
            meta.NEED = true;
          } else {
            var instance = new C();
            // early implementations not supports chaining
            var HASNT_CHAINING =
              instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
            // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
            var THROWS_ON_PRIMITIVES = fails(function () {
              instance.has(1);
            });
            // most early implementations doesn't supports iterables, most modern - not close it correctly
            var ACCEPT_ITERABLES = $iterDetect(function (iter) {
              new C(iter);
            }); // eslint-disable-line no-new
            // for early implementations -0 and +0 not the same
            var BUGGY_ZERO =
              !IS_WEAK &&
              fails(function () {
                // V8 ~ Chromium 42- fails only with 5+ elements
                var $instance = new C();
                var index = 5;
                while (index--) $instance[ADDER](index, index);
                return !$instance.has(-0);
              });
            if (!ACCEPT_ITERABLES) {
              C = wrapper(function (target, iterable) {
                anInstance(target, C, NAME);
                var that = inheritIfRequired(new Base(), target, C);
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, that[ADDER], that);
                return that;
              });
              C.prototype = proto;
              proto.constructor = C;
            }
            if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
              fixMethod("delete");
              fixMethod("has");
              IS_MAP && fixMethod("get");
            }
            if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
            // weak collections should not contains .clear method
            if (IS_WEAK && proto.clear) delete proto.clear;
          }
          setToStringTag(C, NAME);
          O[NAME] = C;
          $export($export.G + $export.W + $export.F * (C != Base), O);
          if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
          return C;
        };
      },
      {
        "81785bf07790142": "c0KvC",
        "98a20a75069249db": "77Dy0",
        eed77c67a61d6bc3: "kcOGE",
        "56ab35d32fd2ad35": "6yUMJ",
        cc230034505debd6: "jIXDG",
        "1e60feab896f7ad8": "bvJ4u",
        cbc6deedb2303507: "8csub",
        "9ff4e926c8bee2b1": "joZov",
        "1605bf0457b569e0": "jYBY4",
        "18826cab27a9fb1d": "iJ7Ec",
        ce7d578f27827465: "eBrgu",
        "238bcffe970dd32d": "gjUNA",
      },
    ],
    gagBf: [
      function (require, module, exports) {
        "use strict";
        var strong = require("bf3cc9c0f9af052b");
        var validate = require("58506d51265ff84f");
        var SET = "Set";
        // 23.2 Set Objects
        module.exports = require("15ea8900c67481eb")(
          SET,
          function (get) {
            return function Set() {
              return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
          },
          {
            // 23.2.3.1 Set.prototype.add(value)
            add: function add(value) {
              return strong.def(
                validate(this, SET),
                (value = value === 0 ? 0 : value),
                value,
              );
            },
          },
          strong,
        );
      },
      {
        bf3cc9c0f9af052b: "hYZyq",
        "58506d51265ff84f": "5pmm3",
        "15ea8900c67481eb": "Djufa",
      },
    ],
    l51dy: [
      function (require, module, exports) {
        "use strict";
        var global = require("af8e41d4c6a663c");
        var each = require("878c133d1ce33005")(0);
        var redefine = require("dafb8b6ed6d80c2b");
        var meta = require("f941753974d1a284");
        var assign = require("8cdb87566c162cfe");
        var weak = require("fb72f942510ac277");
        var isObject = require("74f52c6936d126d4");
        var validate = require("bf3277fdf7c80a13");
        var NATIVE_WEAK_MAP = require("bf3277fdf7c80a13");
        var IS_IE11 = !global.ActiveXObject && "ActiveXObject" in global;
        var WEAK_MAP = "WeakMap";
        var getWeak = meta.getWeak;
        var isExtensible = Object.isExtensible;
        var uncaughtFrozenStore = weak.ufstore;
        var InternalMap;
        var wrapper = function (get) {
          return function WeakMap() {
            return get(this, arguments.length > 0 ? arguments[0] : undefined);
          };
        };
        var methods = {
          // 23.3.3.3 WeakMap.prototype.get(key)
          get: function get(key) {
            if (isObject(key)) {
              var data = getWeak(key);
              if (data === true)
                return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
              return data ? data[this._i] : undefined;
            }
          },
          // 23.3.3.5 WeakMap.prototype.set(key, value)
          set: function set(key, value) {
            return weak.def(validate(this, WEAK_MAP), key, value);
          },
        };
        // 23.3 WeakMap Objects
        var $WeakMap = (module.exports = require("46170d74e99895ef")(
          WEAK_MAP,
          wrapper,
          methods,
          weak,
          true,
          true,
        ));
        // IE11 WeakMap frozen keys fix
        if (NATIVE_WEAK_MAP && IS_IE11) {
          InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
          assign(InternalMap.prototype, methods);
          meta.NEED = true;
          each(["delete", "has", "get", "set"], function (key) {
            var proto = $WeakMap.prototype;
            var method = proto[key];
            redefine(proto, key, function (a, b) {
              // store frozen objects on internal weakmap shim
              if (isObject(a) && !isExtensible(a)) {
                if (!this._f) this._f = new InternalMap();
                var result = this._f[key](a, b);
                return key == "set" ? this : result;
                // store all the rest on native weakmap
              }
              return method.call(this, a, b);
            });
          });
        }
      },
      {
        af8e41d4c6a663c: "c0KvC",
        "878c133d1ce33005": "jpe03",
        dafb8b6ed6d80c2b: "kcOGE",
        f941753974d1a284: "jIXDG",
        "8cdb87566c162cfe": "godd7",
        fb72f942510ac277: "cGSFZ",
        "74f52c6936d126d4": "joZov",
        bf3277fdf7c80a13: "5pmm3",
        "46170d74e99895ef": "Djufa",
      },
    ],
    cGSFZ: [
      function (require, module, exports) {
        "use strict";
        var redefineAll = require("4cd8cd170d6e63cb");
        var getWeak = require("b138f5f946864cba").getWeak;
        var anObject = require("5dcdd49297856cc3");
        var isObject = require("20945a5ef56005f0");
        var anInstance = require("a2debcc8923c53b2");
        var forOf = require("2f15642c1aaf4d14");
        var createArrayMethod = require("cb3de60c94cc53a4");
        var $has = require("faaac35fea4ff1be");
        var validate = require("7da226153a4ef688");
        var arrayFind = createArrayMethod(5);
        var arrayFindIndex = createArrayMethod(6);
        var id = 0;
        // fallback for uncaught frozen keys
        var uncaughtFrozenStore = function (that) {
          return that._l || (that._l = new UncaughtFrozenStore());
        };
        var UncaughtFrozenStore = function () {
          this.a = [];
        };
        var findUncaughtFrozen = function (store, key) {
          return arrayFind(store.a, function (it) {
            return it[0] === key;
          });
        };
        UncaughtFrozenStore.prototype = {
          get: function (key) {
            var entry = findUncaughtFrozen(this, key);
            if (entry) return entry[1];
          },
          has: function (key) {
            return !!findUncaughtFrozen(this, key);
          },
          set: function (key, value) {
            var entry = findUncaughtFrozen(this, key);
            if (entry) entry[1] = value;
            else this.a.push([key, value]);
          },
          delete: function (key) {
            var index = arrayFindIndex(this.a, function (it) {
              return it[0] === key;
            });
            if (~index) this.a.splice(index, 1);
            return !!~index;
          },
        };
        module.exports = {
          getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
            var C = wrapper(function (that, iterable) {
              anInstance(that, C, NAME, "_i");
              that._t = NAME; // collection type
              that._i = id++; // collection id
              that._l = undefined; // leak store for uncaught frozen objects
              if (iterable != undefined)
                forOf(iterable, IS_MAP, that[ADDER], that);
            });
            redefineAll(C.prototype, {
              // 23.3.3.2 WeakMap.prototype.delete(key)
              // 23.4.3.3 WeakSet.prototype.delete(value)
              delete: function (key) {
                if (!isObject(key)) return false;
                var data = getWeak(key);
                if (data === true)
                  return uncaughtFrozenStore(validate(this, NAME))["delete"](
                    key,
                  );
                return data && $has(data, this._i) && delete data[this._i];
              },
              // 23.3.3.4 WeakMap.prototype.has(key)
              // 23.4.3.4 WeakSet.prototype.has(value)
              has: function has(key) {
                if (!isObject(key)) return false;
                var data = getWeak(key);
                if (data === true)
                  return uncaughtFrozenStore(validate(this, NAME)).has(key);
                return data && $has(data, this._i);
              },
            });
            return C;
          },
          def: function (that, key, value) {
            var data = getWeak(anObject(key), true);
            if (data === true) uncaughtFrozenStore(that).set(key, value);
            else data[that._i] = value;
            return that;
          },
          ufstore: uncaughtFrozenStore,
        };
      },
      {
        "4cd8cd170d6e63cb": "6yUMJ",
        b138f5f946864cba: "jIXDG",
        "5dcdd49297856cc3": "dkWKr",
        "20945a5ef56005f0": "joZov",
        a2debcc8923c53b2: "8csub",
        "2f15642c1aaf4d14": "bvJ4u",
        cb3de60c94cc53a4: "jpe03",
        faaac35fea4ff1be: "jnyQA",
        "7da226153a4ef688": "5pmm3",
      },
    ],
    "5rmEC": [
      function (require, module, exports) {
        "use strict";
        var weak = require("cb43e4f7e5c19f59");
        var validate = require("60641d41d2aaf7f8");
        var WEAK_SET = "WeakSet";
        // 23.4 WeakSet Objects
        require("30f78a4edc6bf903")(
          WEAK_SET,
          function (get) {
            return function WeakSet() {
              return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
          },
          {
            // 23.4.3.1 WeakSet.prototype.add(value)
            add: function add(value) {
              return weak.def(validate(this, WEAK_SET), value, true);
            },
          },
          weak,
          false,
          true,
        );
      },
      {
        cb43e4f7e5c19f59: "cGSFZ",
        "60641d41d2aaf7f8": "5pmm3",
        "30f78a4edc6bf903": "Djufa",
      },
    ],
    "5WMBT": [
      function (require, module, exports) {
        "use strict";
        var $export = require("d9c36548a0d90227");
        var $typed = require("f1c1597d59a2dd2e");
        var buffer = require("93af829c7c842d23");
        var anObject = require("321e83d7ef505219");
        var toAbsoluteIndex = require("8f4425023cbc8c8");
        var toLength = require("a10068daddb2d138");
        var isObject = require("87551d3f14a6c044");
        var ArrayBuffer = require("dc95cd0c4194aba1").ArrayBuffer;
        var speciesConstructor = require("906ae9a7c78b9bec");
        var $ArrayBuffer = buffer.ArrayBuffer;
        var $DataView = buffer.DataView;
        var $isView = $typed.ABV && ArrayBuffer.isView;
        var $slice = $ArrayBuffer.prototype.slice;
        var VIEW = $typed.VIEW;
        var ARRAY_BUFFER = "ArrayBuffer";
        $export(
          $export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer),
          {
            ArrayBuffer: $ArrayBuffer,
          },
        );
        $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
          // 24.1.3.1 ArrayBuffer.isView(arg)
          isView: function isView(it) {
            return ($isView && $isView(it)) || (isObject(it) && VIEW in it);
          },
        });
        $export(
          $export.P +
            $export.U +
            $export.F *
              require("3e089391f183a0b8")(function () {
                return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
              }),
          ARRAY_BUFFER,
          {
            // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
            slice: function slice(start, end) {
              if ($slice !== undefined && end === undefined)
                return $slice.call(anObject(this), start); // FF fix
              var len = anObject(this).byteLength;
              var first = toAbsoluteIndex(start, len);
              var fin = toAbsoluteIndex(end === undefined ? len : end, len);
              var result = new (speciesConstructor(this, $ArrayBuffer))(
                toLength(fin - first),
              );
              var viewS = new $DataView(this);
              var viewT = new $DataView(result);
              var index = 0;
              while (first < fin)
                viewT.setUint8(index++, viewS.getUint8(first++));
              return result;
            },
          },
        );
        require("d543674322f0cc13")(ARRAY_BUFFER);
      },
      {
        d9c36548a0d90227: "77Dy0",
        f1c1597d59a2dd2e: "2MCYO",
        "93af829c7c842d23": "fROom",
        "321e83d7ef505219": "dkWKr",
        "8f4425023cbc8c8": "N3OwE",
        a10068daddb2d138: "kGg3g",
        "87551d3f14a6c044": "joZov",
        dc95cd0c4194aba1: "c0KvC",
        "906ae9a7c78b9bec": "c539Q",
        "3e089391f183a0b8": "jYBY4",
        d543674322f0cc13: "37abT",
      },
    ],
    "2MCYO": [
      function (require, module, exports) {
        var global = require("a751fecb14d34f56");
        var hide = require("695bc429faa86df5");
        var uid = require("7d1abd8ab56a5518");
        var TYPED = uid("typed_array");
        var VIEW = uid("view");
        var ABV = !!(global.ArrayBuffer && global.DataView);
        var CONSTR = ABV;
        var i = 0;
        var l = 9;
        var Typed;
        var TypedArrayConstructors =
          "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(
            ",",
          );
        while (i < l)
          if ((Typed = global[TypedArrayConstructors[i++]])) {
            hide(Typed.prototype, TYPED, true);
            hide(Typed.prototype, VIEW, true);
          } else CONSTR = false;
        module.exports = {
          ABV: ABV,
          CONSTR: CONSTR,
          TYPED: TYPED,
          VIEW: VIEW,
        };
      },
      {
        a751fecb14d34f56: "c0KvC",
        "695bc429faa86df5": "4uQIf",
        "7d1abd8ab56a5518": "8b505",
      },
    ],
    fROom: [
      function (require, module, exports) {
        "use strict";
        var global = require("9442324afe09e96d");
        var DESCRIPTORS = require("60d70cc4ea34f0db");
        var LIBRARY = require("65fa297fbae9d6d2");
        var $typed = require("bb962db73ea9a36e");
        var hide = require("b3a27ca92807932e");
        var redefineAll = require("f951d1f36e940d4b");
        var fails = require("1b11952576dec9ae");
        var anInstance = require("8476617cda9cb40a");
        var toInteger = require("9fb465dba499e3df");
        var toLength = require("98149dcdbc24087d");
        var toIndex = require("d3dda88e6c226035");
        var gOPN = require("d46cfaadae30c718").f;
        var dP = require("844bc0a3da5e4c19").f;
        var arrayFill = require("560912ec70a9f727");
        var setToStringTag = require("fb2ca171954aed83");
        var ARRAY_BUFFER = "ArrayBuffer";
        var DATA_VIEW = "DataView";
        var PROTOTYPE = "prototype";
        var WRONG_LENGTH = "Wrong length!";
        var WRONG_INDEX = "Wrong index!";
        var $ArrayBuffer = global[ARRAY_BUFFER];
        var $DataView = global[DATA_VIEW];
        var Math = global.Math;
        var RangeError = global.RangeError;
        // eslint-disable-next-line no-shadow-restricted-names
        var Infinity1 = global.Infinity;
        var BaseBuffer = $ArrayBuffer;
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log = Math.log;
        var LN2 = Math.LN2;
        var BUFFER = "buffer";
        var BYTE_LENGTH = "byteLength";
        var BYTE_OFFSET = "byteOffset";
        var $BUFFER = DESCRIPTORS ? "_b" : BUFFER;
        var $LENGTH = DESCRIPTORS ? "_l" : BYTE_LENGTH;
        var $OFFSET = DESCRIPTORS ? "_o" : BYTE_OFFSET;
        // IEEE754 conversions based on https://github.com/feross/ieee754
        function packIEEE754(value, mLen, nBytes) {
          var buffer = new Array(nBytes);
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
          var i = 0;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
          var e, m, c;
          value = abs(value);
          // eslint-disable-next-line no-self-compare
          if (value != value || value === Infinity) {
            // eslint-disable-next-line no-self-compare
            m = value != value ? 1 : 0;
            e = eMax;
          } else {
            e = floor(log(value) / LN2);
            if (value * (c = pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) value += rt / c;
            else value += rt * pow(2, 1 - eBias);
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * pow(2, eBias - 1) * pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
          buffer[--i] |= s * 128;
          return buffer;
        }
        function unpackIEEE754(buffer, mLen, nBytes) {
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = eLen - 7;
          var i = nBytes - 1;
          var s = buffer[i--];
          var e = s & 127;
          var m;
          s >>= 7;
          for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
          if (e === 0) e = 1 - eBias;
          else if (e === eMax) return m ? NaN : s ? -Infinity : Infinity;
          else {
            m = m + pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * pow(2, e - mLen);
        }
        function unpackI32(bytes) {
          return (
            (bytes[3] << 24) | (bytes[2] << 16) | (bytes[1] << 8) | bytes[0]
          );
        }
        function packI8(it) {
          return [it & 0xff];
        }
        function packI16(it) {
          return [it & 0xff, (it >> 8) & 0xff];
        }
        function packI32(it) {
          return [
            it & 0xff,
            (it >> 8) & 0xff,
            (it >> 16) & 0xff,
            (it >> 24) & 0xff,
          ];
        }
        function packF64(it) {
          return packIEEE754(it, 52, 8);
        }
        function packF32(it) {
          return packIEEE754(it, 23, 4);
        }
        function addGetter(C, key, internal) {
          dP(C[PROTOTYPE], key, {
            get: function () {
              return this[internal];
            },
          });
        }
        function get(view, bytes, index, isLittleEndian) {
          var numIndex = +index;
          var intIndex = toIndex(numIndex);
          if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
          var store = view[$BUFFER]._b;
          var start = intIndex + view[$OFFSET];
          var pack = store.slice(start, start + bytes);
          return isLittleEndian ? pack : pack.reverse();
        }
        function set(view, bytes, index, conversion, value, isLittleEndian) {
          var numIndex = +index;
          var intIndex = toIndex(numIndex);
          if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
          var store = view[$BUFFER]._b;
          var start = intIndex + view[$OFFSET];
          var pack = conversion(+value);
          for (var i = 0; i < bytes; i++)
            store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
        }
        if (!$typed.ABV) {
          $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
            var byteLength = toIndex(length);
            this._b = arrayFill.call(new Array(byteLength), 0);
            this[$LENGTH] = byteLength;
          };
          $DataView = function DataView(buffer, byteOffset, byteLength) {
            anInstance(this, $DataView, DATA_VIEW);
            anInstance(buffer, $ArrayBuffer, DATA_VIEW);
            var bufferLength = buffer[$LENGTH];
            var offset = toInteger(byteOffset);
            if (offset < 0 || offset > bufferLength)
              throw RangeError("Wrong offset!");
            byteLength =
              byteLength === undefined
                ? bufferLength - offset
                : toLength(byteLength);
            if (offset + byteLength > bufferLength)
              throw RangeError(WRONG_LENGTH);
            this[$BUFFER] = buffer;
            this[$OFFSET] = offset;
            this[$LENGTH] = byteLength;
          };
          if (DESCRIPTORS) {
            addGetter($ArrayBuffer, BYTE_LENGTH, "_l");
            addGetter($DataView, BUFFER, "_b");
            addGetter($DataView, BYTE_LENGTH, "_l");
            addGetter($DataView, BYTE_OFFSET, "_o");
          }
          redefineAll($DataView[PROTOTYPE], {
            getInt8: function getInt8(byteOffset) {
              return (get(this, 1, byteOffset)[0] << 24) >> 24;
            },
            getUint8: function getUint8(byteOffset) {
              return get(this, 1, byteOffset)[0];
            },
            getInt16: function getInt16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments[1]);
              return (((bytes[1] << 8) | bytes[0]) << 16) >> 16;
            },
            getUint16: function getUint16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments[1]);
              return (bytes[1] << 8) | bytes[0];
            },
            getInt32: function getInt32(byteOffset /* , littleEndian */) {
              return unpackI32(get(this, 4, byteOffset, arguments[1]));
            },
            getUint32: function getUint32(byteOffset /* , littleEndian */) {
              return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
            },
            getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
              return unpackIEEE754(
                get(this, 4, byteOffset, arguments[1]),
                23,
                4,
              );
            },
            getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
              return unpackIEEE754(
                get(this, 8, byteOffset, arguments[1]),
                52,
                8,
              );
            },
            setInt8: function setInt8(byteOffset, value) {
              set(this, 1, byteOffset, packI8, value);
            },
            setUint8: function setUint8(byteOffset, value) {
              set(this, 1, byteOffset, packI8, value);
            },
            setInt16: function setInt16(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 2, byteOffset, packI16, value, arguments[2]);
            },
            setUint16: function setUint16(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 2, byteOffset, packI16, value, arguments[2]);
            },
            setInt32: function setInt32(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 4, byteOffset, packI32, value, arguments[2]);
            },
            setUint32: function setUint32(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 4, byteOffset, packI32, value, arguments[2]);
            },
            setFloat32: function setFloat32(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 4, byteOffset, packF32, value, arguments[2]);
            },
            setFloat64: function setFloat64(
              byteOffset,
              value /* , littleEndian */,
            ) {
              set(this, 8, byteOffset, packF64, value, arguments[2]);
            },
          });
        } else {
          if (
            !fails(function () {
              $ArrayBuffer(1);
            }) ||
            !fails(function () {
              new $ArrayBuffer(-1); // eslint-disable-line no-new
            }) ||
            fails(function () {
              new $ArrayBuffer(); // eslint-disable-line no-new
              new $ArrayBuffer(1.5); // eslint-disable-line no-new
              new $ArrayBuffer(NaN); // eslint-disable-line no-new
              return $ArrayBuffer.name != ARRAY_BUFFER;
            })
          ) {
            $ArrayBuffer = function ArrayBuffer(length) {
              anInstance(this, $ArrayBuffer);
              return new BaseBuffer(toIndex(length));
            };
            var ArrayBufferProto = ($ArrayBuffer[PROTOTYPE] =
              BaseBuffer[PROTOTYPE]);
            for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; )
              if (!((key = keys[j++]) in $ArrayBuffer))
                hide($ArrayBuffer, key, BaseBuffer[key]);
            if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
          }
          // iOS Safari 7.x bug
          var view = new $DataView(new $ArrayBuffer(2));
          var $setInt8 = $DataView[PROTOTYPE].setInt8;
          view.setInt8(0, 2147483648);
          view.setInt8(1, 2147483649);
          if (view.getInt8(0) || !view.getInt8(1))
            redefineAll(
              $DataView[PROTOTYPE],
              {
                setInt8: function setInt8(byteOffset, value) {
                  $setInt8.call(this, byteOffset, (value << 24) >> 24);
                },
                setUint8: function setUint8(byteOffset, value) {
                  $setInt8.call(this, byteOffset, (value << 24) >> 24);
                },
              },
              true,
            );
        }
        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);
        hide($DataView[PROTOTYPE], $typed.VIEW, true);
        exports[ARRAY_BUFFER] = $ArrayBuffer;
        exports[DATA_VIEW] = $DataView;
      },
      {
        "9442324afe09e96d": "c0KvC",
        "60d70cc4ea34f0db": "4XHXy",
        "65fa297fbae9d6d2": "4YPyS",
        bb962db73ea9a36e: "2MCYO",
        b3a27ca92807932e: "4uQIf",
        f951d1f36e940d4b: "6yUMJ",
        "1b11952576dec9ae": "jYBY4",
        "8476617cda9cb40a": "8csub",
        "9fb465dba499e3df": "jmpId",
        "98149dcdbc24087d": "kGg3g",
        d3dda88e6c226035: "2J48S",
        d46cfaadae30c718: "aij03",
        "844bc0a3da5e4c19": "evkkn",
        "560912ec70a9f727": "3pC37",
        fb2ca171954aed83: "eBrgu",
      },
    ],
    "2J48S": [
      function (require, module, exports) {
        // https://tc39.github.io/ecma262/#sec-toindex
        var toInteger = require("4be70d78080589cb");
        var toLength = require("36fc45a4d3539610");
        module.exports = function (it) {
          if (it === undefined) return 0;
          var number = toInteger(it);
          var length = toLength(number);
          if (number !== length) throw RangeError("Wrong length!");
          return length;
        };
      },
      { "4be70d78080589cb": "jmpId", "36fc45a4d3539610": "kGg3g" },
    ],
    b6euG: [
      function (require, module, exports) {
        var $export = require("87193b1207016fe");
        $export(
          $export.G + $export.W + $export.F * !require("d97e5ffffca8077").ABV,
          {
            DataView: require("def90b959f2b70be").DataView,
          },
        );
      },
      {
        "87193b1207016fe": "77Dy0",
        d97e5ffffca8077: "2MCYO",
        def90b959f2b70be: "fROom",
      },
    ],
    dBA71: [
      function (require, module, exports) {
        require("28a4933ee8139e63")("Int8", 1, function (init) {
          return function Int8Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "28a4933ee8139e63": "3K7vj" },
    ],
    "3K7vj": [
      function (require, module, exports) {
        "use strict";
        if (require("418d6dbd601a1b3")) {
          var LIBRARY = require("f88452f9f264fdb3");
          var global = require("cc74c805d545f0a4");
          var fails = require("9f9fdb2e353295e3");
          var $export = require("e11935fe09ccbe3b");
          var $typed = require("6d7548fe459a3611");
          var $buffer = require("55b1a5ca3885e39d");
          var ctx = require("c4cba47146bdf959");
          var anInstance = require("451a1affd9a94f32");
          var propertyDesc = require("54749f89e812537");
          var hide = require("6155f43e982a8fe3");
          var redefineAll = require("6c19607a9dcacf8a");
          var toInteger = require("1d8ebe72bb822ec3");
          var toLength = require("85fb73757d533cc0");
          var toIndex = require("83e05e96d27a018f");
          var toAbsoluteIndex = require("4652bacef7467eee");
          var toPrimitive = require("d0412817509b72f0");
          var has = require("bb18953b50715446");
          var classof = require("5ff3aa5e37f9850c");
          var isObject = require("df90c642ac1b4fad");
          var toObject = require("7a9f0193844a6e03");
          var isArrayIter = require("ce0f67db3a56b4f2");
          var create = require("a1ea54349f1513dd");
          var getPrototypeOf = require("1a0b79728c31d88");
          var gOPN = require("f493bcb9a9a74de").f;
          var getIterFn = require("b28de14373bb016a");
          var uid = require("a4ae9b1a543d96da");
          var wks = require("1a6f624d253d26a5");
          var createArrayMethod = require("65f81fde60e8afd3");
          var createArrayIncludes = require("f19db5e9d3cefd9b");
          var speciesConstructor = require("5fad23f35e91c0ad");
          var ArrayIterators = require("fbb2a4d39470f1c2");
          var Iterators = require("23a9b723266ad310");
          var $iterDetect = require("ffe5a0d910559b5e");
          var setSpecies = require("8823a083ef265c1f");
          var arrayFill = require("71369c73c102e51f");
          var arrayCopyWithin = require("ba06805985988de8");
          var $DP = require("f61d7396bf1e0518");
          var $GOPD = require("66234efc7bb0d74b");
          var dP = $DP.f;
          var gOPD = $GOPD.f;
          var RangeError = global.RangeError;
          var TypeError = global.TypeError;
          var Uint8Array = global.Uint8Array;
          var ARRAY_BUFFER = "ArrayBuffer";
          var SHARED_BUFFER = "Shared" + ARRAY_BUFFER;
          var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
          var PROTOTYPE = "prototype";
          var ArrayProto = Array[PROTOTYPE];
          var $ArrayBuffer = $buffer.ArrayBuffer;
          var $DataView = $buffer.DataView;
          var arrayForEach = createArrayMethod(0);
          var arrayFilter = createArrayMethod(2);
          var arraySome = createArrayMethod(3);
          var arrayEvery = createArrayMethod(4);
          var arrayFind = createArrayMethod(5);
          var arrayFindIndex = createArrayMethod(6);
          var arrayIncludes = createArrayIncludes(true);
          var arrayIndexOf = createArrayIncludes(false);
          var arrayValues = ArrayIterators.values;
          var arrayKeys = ArrayIterators.keys;
          var arrayEntries = ArrayIterators.entries;
          var arrayLastIndexOf = ArrayProto.lastIndexOf;
          var arrayReduce = ArrayProto.reduce;
          var arrayReduceRight = ArrayProto.reduceRight;
          var arrayJoin = ArrayProto.join;
          var arraySort = ArrayProto.sort;
          var arraySlice = ArrayProto.slice;
          var arrayToString = ArrayProto.toString;
          var arrayToLocaleString = ArrayProto.toLocaleString;
          var ITERATOR = wks("iterator");
          var TAG = wks("toStringTag");
          var TYPED_CONSTRUCTOR = uid("typed_constructor");
          var DEF_CONSTRUCTOR = uid("def_constructor");
          var ALL_CONSTRUCTORS = $typed.CONSTR;
          var TYPED_ARRAY = $typed.TYPED;
          var VIEW = $typed.VIEW;
          var WRONG_LENGTH = "Wrong length!";
          var $map = createArrayMethod(1, function (O, length) {
            return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
          });
          var LITTLE_ENDIAN = fails(function () {
            // eslint-disable-next-line no-undef
            return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
          });
          var FORCED_SET =
            !!Uint8Array &&
            !!Uint8Array[PROTOTYPE].set &&
            fails(function () {
              new Uint8Array(1).set({});
            });
          var toOffset = function (it, BYTES) {
            var offset = toInteger(it);
            if (offset < 0 || offset % BYTES) throw RangeError("Wrong offset!");
            return offset;
          };
          var validate = function (it) {
            if (isObject(it) && TYPED_ARRAY in it) return it;
            throw TypeError(it + " is not a typed array!");
          };
          var allocate = function (C, length) {
            if (!(isObject(C) && TYPED_CONSTRUCTOR in C))
              throw TypeError("It is not a typed array constructor!");
            return new C(length);
          };
          var speciesFromList = function (O, list) {
            return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
          };
          var fromList = function (C, list) {
            var index = 0;
            var length = list.length;
            var result = allocate(C, length);
            while (length > index) result[index] = list[index++];
            return result;
          };
          var addGetter = function (it, key, internal) {
            dP(it, key, {
              get: function () {
                return this._d[internal];
              },
            });
          };
          var $from = function from(source /* , mapfn, thisArg */) {
            var O = toObject(source);
            var aLen = arguments.length;
            var mapfn = aLen > 1 ? arguments[1] : undefined;
            var mapping = mapfn !== undefined;
            var iterFn = getIterFn(O);
            var i, length, values, result, step, iterator;
            if (iterFn != undefined && !isArrayIter(iterFn)) {
              for (
                iterator = iterFn.call(O), values = [], i = 0;
                !(step = iterator.next()).done;
                i++
              )
                values.push(step.value);
              O = values;
            }
            if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
            for (
              i = 0,
                length = toLength(O.length),
                result = allocate(this, length);
              length > i;
              i++
            )
              result[i] = mapping ? mapfn(O[i], i) : O[i];
            return result;
          };
          var $of = function of() {
            var index = 0;
            var length = arguments.length;
            var result = allocate(this, length);
            while (length > index) result[index] = arguments[index++];
            return result;
          };
          // iOS Safari 6.x fails here
          var TO_LOCALE_BUG =
            !!Uint8Array &&
            fails(function () {
              arrayToLocaleString.call(new Uint8Array(1));
            });
          var $toLocaleString = function toLocaleString() {
            return arrayToLocaleString.apply(
              TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this),
              arguments,
            );
          };
          var proto = {
            copyWithin: function copyWithin(target, start /* , end */) {
              return arrayCopyWithin.call(
                validate(this),
                target,
                start,
                arguments.length > 2 ? arguments[2] : undefined,
              );
            },
            every: function every(callbackfn /* , thisArg */) {
              return arrayEvery(
                validate(this),
                callbackfn,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            fill: function fill(value /* , start, end */) {
              return arrayFill.apply(validate(this), arguments);
            },
            filter: function filter(callbackfn /* , thisArg */) {
              return speciesFromList(
                this,
                arrayFilter(
                  validate(this),
                  callbackfn,
                  arguments.length > 1 ? arguments[1] : undefined,
                ),
              );
            },
            find: function find(predicate /* , thisArg */) {
              return arrayFind(
                validate(this),
                predicate,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            findIndex: function findIndex(predicate /* , thisArg */) {
              return arrayFindIndex(
                validate(this),
                predicate,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            forEach: function forEach(callbackfn /* , thisArg */) {
              arrayForEach(
                validate(this),
                callbackfn,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            indexOf: function indexOf(searchElement /* , fromIndex */) {
              return arrayIndexOf(
                validate(this),
                searchElement,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            includes: function includes(searchElement /* , fromIndex */) {
              return arrayIncludes(
                validate(this),
                searchElement,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            join: function join(separator) {
              return arrayJoin.apply(validate(this), arguments);
            },
            lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
              return arrayLastIndexOf.apply(validate(this), arguments);
            },
            map: function map(mapfn /* , thisArg */) {
              return $map(
                validate(this),
                mapfn,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            reduce: function reduce(callbackfn /* , initialValue */) {
              return arrayReduce.apply(validate(this), arguments);
            },
            reduceRight: function reduceRight(callbackfn /* , initialValue */) {
              return arrayReduceRight.apply(validate(this), arguments);
            },
            reverse: function reverse() {
              var that = this;
              var length = validate(that).length;
              var middle = Math.floor(length / 2);
              var index = 0;
              var value;
              while (index < middle) {
                value = that[index];
                that[index++] = that[--length];
                that[length] = value;
              }
              return that;
            },
            some: function some(callbackfn /* , thisArg */) {
              return arraySome(
                validate(this),
                callbackfn,
                arguments.length > 1 ? arguments[1] : undefined,
              );
            },
            sort: function sort(comparefn) {
              return arraySort.call(validate(this), comparefn);
            },
            subarray: function subarray(begin, end) {
              var O = validate(this);
              var length = O.length;
              var $begin = toAbsoluteIndex(begin, length);
              return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
                O.buffer,
                O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
                toLength(
                  (end === undefined ? length : toAbsoluteIndex(end, length)) -
                    $begin,
                ),
              );
            },
          };
          var $slice = function slice(start, end) {
            return speciesFromList(
              this,
              arraySlice.call(validate(this), start, end),
            );
          };
          var $set = function set(arrayLike /* , offset */) {
            validate(this);
            var offset = toOffset(arguments[1], 1);
            var length = this.length;
            var src = toObject(arrayLike);
            var len = toLength(src.length);
            var index = 0;
            if (len + offset > length) throw RangeError(WRONG_LENGTH);
            while (index < len) this[offset + index] = src[index++];
          };
          var $iterators = {
            entries: function entries() {
              return arrayEntries.call(validate(this));
            },
            keys: function keys() {
              return arrayKeys.call(validate(this));
            },
            values: function values() {
              return arrayValues.call(validate(this));
            },
          };
          var isTAIndex = function (target, key) {
            return (
              isObject(target) &&
              target[TYPED_ARRAY] &&
              typeof key != "symbol" &&
              key in target &&
              String(+key) == String(key)
            );
          };
          var $getDesc = function getOwnPropertyDescriptor(target, key) {
            return isTAIndex(target, (key = toPrimitive(key, true)))
              ? propertyDesc(2, target[key])
              : gOPD(target, key);
          };
          var $setDesc = function defineProperty(target, key, desc) {
            if (
              isTAIndex(target, (key = toPrimitive(key, true))) &&
              isObject(desc) &&
              has(desc, "value") &&
              !has(desc, "get") &&
              !has(desc, "set") &&
              !desc.configurable &&
              (!has(desc, "writable") || desc.writable) &&
              (!has(desc, "enumerable") || desc.enumerable)
            ) {
              target[key] = desc.value;
              return target;
            }
            return dP(target, key, desc);
          };
          if (!ALL_CONSTRUCTORS) {
            $GOPD.f = $getDesc;
            $DP.f = $setDesc;
          }
          $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
            getOwnPropertyDescriptor: $getDesc,
            defineProperty: $setDesc,
          });
          if (
            fails(function () {
              arrayToString.call({});
            })
          )
            arrayToString = arrayToLocaleString = function toString() {
              return arrayJoin.call(this);
            };
          var $TypedArrayPrototype$ = redefineAll({}, proto);
          redefineAll($TypedArrayPrototype$, $iterators);
          hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
          redefineAll($TypedArrayPrototype$, {
            slice: $slice,
            set: $set,
            constructor: function () {},
            toString: arrayToString,
            toLocaleString: $toLocaleString,
          });
          addGetter($TypedArrayPrototype$, "buffer", "b");
          addGetter($TypedArrayPrototype$, "byteOffset", "o");
          addGetter($TypedArrayPrototype$, "byteLength", "l");
          addGetter($TypedArrayPrototype$, "length", "e");
          dP($TypedArrayPrototype$, TAG, {
            get: function () {
              return this[TYPED_ARRAY];
            },
          });
          // eslint-disable-next-line max-statements
          module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
            CLAMPED = !!CLAMPED;
            var NAME = KEY + (CLAMPED ? "Clamped" : "") + "Array";
            var GETTER = "get" + KEY;
            var SETTER = "set" + KEY;
            var TypedArray = global[NAME];
            var Base = TypedArray || {};
            var TAC = TypedArray && getPrototypeOf(TypedArray);
            var FORCED = !TypedArray || !$typed.ABV;
            var O = {};
            var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
            var getter = function (that, index) {
              var data = that._d;
              return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
            };
            var setter = function (that, index, value) {
              var data = that._d;
              if (CLAMPED)
                value =
                  (value = Math.round(value)) < 0
                    ? 0
                    : value > 0xff
                    ? 0xff
                    : value & 0xff;
              data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
            };
            var addElement = function (that, index) {
              dP(that, index, {
                get: function () {
                  return getter(this, index);
                },
                set: function (value) {
                  return setter(this, index, value);
                },
                enumerable: true,
              });
            };
            if (FORCED) {
              TypedArray = wrapper(function (that, data, $offset, $length) {
                anInstance(that, TypedArray, NAME, "_d");
                var index = 0;
                var offset = 0;
                var buffer, byteLength, length, klass;
                if (!isObject(data)) {
                  length = toIndex(data);
                  byteLength = length * BYTES;
                  buffer = new $ArrayBuffer(byteLength);
                } else if (
                  data instanceof $ArrayBuffer ||
                  (klass = classof(data)) == ARRAY_BUFFER ||
                  klass == SHARED_BUFFER
                ) {
                  buffer = data;
                  offset = toOffset($offset, BYTES);
                  var $len = data.byteLength;
                  if ($length === undefined) {
                    if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                    byteLength = $len - offset;
                    if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                  } else {
                    byteLength = toLength($length) * BYTES;
                    if (byteLength + offset > $len)
                      throw RangeError(WRONG_LENGTH);
                  }
                  length = byteLength / BYTES;
                } else if (TYPED_ARRAY in data)
                  return fromList(TypedArray, data);
                else return $from.call(TypedArray, data);
                hide(that, "_d", {
                  b: buffer,
                  o: offset,
                  l: byteLength,
                  e: length,
                  v: new $DataView(buffer),
                });
                while (index < length) addElement(that, index++);
              });
              TypedArrayPrototype = TypedArray[PROTOTYPE] = create(
                $TypedArrayPrototype$,
              );
              hide(TypedArrayPrototype, "constructor", TypedArray);
            } else if (
              !fails(function () {
                TypedArray(1);
              }) ||
              !fails(function () {
                new TypedArray(-1); // eslint-disable-line no-new
              }) ||
              !$iterDetect(function (iter) {
                new TypedArray(); // eslint-disable-line no-new
                new TypedArray(null); // eslint-disable-line no-new
                new TypedArray(1.5); // eslint-disable-line no-new
                new TypedArray(iter); // eslint-disable-line no-new
              }, true)
            ) {
              TypedArray = wrapper(function (that, data, $offset, $length) {
                anInstance(that, TypedArray, NAME);
                var klass;
                // `ws` module bug, temporarily remove validation length for Uint8Array
                // https://github.com/websockets/ws/pull/645
                if (!isObject(data)) return new Base(toIndex(data));
                if (
                  data instanceof $ArrayBuffer ||
                  (klass = classof(data)) == ARRAY_BUFFER ||
                  klass == SHARED_BUFFER
                )
                  return $length !== undefined
                    ? new Base(data, toOffset($offset, BYTES), $length)
                    : $offset !== undefined
                    ? new Base(data, toOffset($offset, BYTES))
                    : new Base(data);
                if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                return $from.call(TypedArray, data);
              });
              arrayForEach(
                TAC !== Function.prototype
                  ? gOPN(Base).concat(gOPN(TAC))
                  : gOPN(Base),
                function (key) {
                  if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
                },
              );
              TypedArray[PROTOTYPE] = TypedArrayPrototype;
              if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
            }
            var $nativeIterator = TypedArrayPrototype[ITERATOR];
            var CORRECT_ITER_NAME =
              !!$nativeIterator &&
              ($nativeIterator.name == "values" ||
                $nativeIterator.name == undefined);
            var $iterator = $iterators.values;
            hide(TypedArray, TYPED_CONSTRUCTOR, true);
            hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
            hide(TypedArrayPrototype, VIEW, true);
            hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
            if (
              CLAMPED
                ? new TypedArray(1)[TAG] != NAME
                : !(TAG in TypedArrayPrototype)
            )
              dP(TypedArrayPrototype, TAG, {
                get: function () {
                  return NAME;
                },
              });
            O[NAME] = TypedArray;
            $export(
              $export.G + $export.W + $export.F * (TypedArray != Base),
              O,
            );
            $export($export.S, NAME, {
              BYTES_PER_ELEMENT: BYTES,
            });
            $export(
              $export.S +
                $export.F *
                  fails(function () {
                    Base.of.call(TypedArray, 1);
                  }),
              NAME,
              {
                from: $from,
                of: $of,
              },
            );
            if (!(BYTES_PER_ELEMENT in TypedArrayPrototype))
              hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
            $export($export.P, NAME, proto);
            setSpecies(NAME);
            $export($export.P + $export.F * FORCED_SET, NAME, {
              set: $set,
            });
            $export(
              $export.P + $export.F * !CORRECT_ITER_NAME,
              NAME,
              $iterators,
            );
            if (!LIBRARY && TypedArrayPrototype.toString != arrayToString)
              TypedArrayPrototype.toString = arrayToString;
            $export(
              $export.P +
                $export.F *
                  fails(function () {
                    new TypedArray(1).slice();
                  }),
              NAME,
              {
                slice: $slice,
              },
            );
            $export(
              $export.P +
                $export.F *
                  (fails(function () {
                    return (
                      [1, 2].toLocaleString() !=
                      new TypedArray([1, 2]).toLocaleString()
                    );
                  }) ||
                    !fails(function () {
                      TypedArrayPrototype.toLocaleString.call([1, 2]);
                    })),
              NAME,
              {
                toLocaleString: $toLocaleString,
              },
            );
            Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
            if (!LIBRARY && !CORRECT_ITER_NAME)
              hide(TypedArrayPrototype, ITERATOR, $iterator);
          };
        } else module.exports = function () {};
      },
      {
        "418d6dbd601a1b3": "4XHXy",
        f88452f9f264fdb3: "4YPyS",
        cc74c805d545f0a4: "c0KvC",
        "9f9fdb2e353295e3": "jYBY4",
        e11935fe09ccbe3b: "77Dy0",
        "6d7548fe459a3611": "2MCYO",
        "55b1a5ca3885e39d": "fROom",
        c4cba47146bdf959: "gpAgQ",
        "451a1affd9a94f32": "8csub",
        "54749f89e812537": "ciJKK",
        "6155f43e982a8fe3": "4uQIf",
        "6c19607a9dcacf8a": "6yUMJ",
        "1d8ebe72bb822ec3": "jmpId",
        "85fb73757d533cc0": "kGg3g",
        "83e05e96d27a018f": "2J48S",
        "4652bacef7467eee": "N3OwE",
        d0412817509b72f0: "9GXBY",
        bb18953b50715446: "jnyQA",
        "5ff3aa5e37f9850c": "hCCia",
        df90c642ac1b4fad: "joZov",
        "7a9f0193844a6e03": "dZ3od",
        ce0f67db3a56b4f2: "3BsWF",
        a1ea54349f1513dd: "2DOWX",
        "1a0b79728c31d88": "gQspV",
        f493bcb9a9a74de: "aij03",
        b28de14373bb016a: "3H2Vr",
        a4ae9b1a543d96da: "8b505",
        "1a6f624d253d26a5": "ea5XI",
        "65f81fde60e8afd3": "jpe03",
        f19db5e9d3cefd9b: "1pIJc",
        "5fad23f35e91c0ad": "c539Q",
        fbb2a4d39470f1c2: "cYJcA",
        "23a9b723266ad310": "6RAVz",
        ffe5a0d910559b5e: "iJ7Ec",
        "8823a083ef265c1f": "37abT",
        "71369c73c102e51f": "3pC37",
        ba06805985988de8: "5MnLe",
        f61d7396bf1e0518: "evkkn",
        "66234efc7bb0d74b": "jfoaU",
      },
    ],
    dUrzk: [
      function (require, module, exports) {
        require("1c1d7fa4a4a24790")("Uint8", 1, function (init) {
          return function Uint8Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "1c1d7fa4a4a24790": "3K7vj" },
    ],
    eOurR: [
      function (require, module, exports) {
        require("6f864eef97661b0c")(
          "Uint8",
          1,
          function (init) {
            return function Uint8ClampedArray(data, byteOffset, length) {
              return init(this, data, byteOffset, length);
            };
          },
          true,
        );
      },
      { "6f864eef97661b0c": "3K7vj" },
    ],
    "1XyL0": [
      function (require, module, exports) {
        require("6e2c9336a458e7f9")("Int16", 2, function (init) {
          return function Int16Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "6e2c9336a458e7f9": "3K7vj" },
    ],
    "6OpoX": [
      function (require, module, exports) {
        require("2225992d4a6bb9c7")("Uint16", 2, function (init) {
          return function Uint16Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "2225992d4a6bb9c7": "3K7vj" },
    ],
    ianWm: [
      function (require, module, exports) {
        require("b7e432ab14071d20")("Int32", 4, function (init) {
          return function Int32Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { b7e432ab14071d20: "3K7vj" },
    ],
    jxe5Y: [
      function (require, module, exports) {
        require("7ca59715ab051ef5")("Uint32", 4, function (init) {
          return function Uint32Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "7ca59715ab051ef5": "3K7vj" },
    ],
    cSLOG: [
      function (require, module, exports) {
        require("7e8e1ba7be410236")("Float32", 4, function (init) {
          return function Float32Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "7e8e1ba7be410236": "3K7vj" },
    ],
    kbXub: [
      function (require, module, exports) {
        require("3b2e2827b74cbda2")("Float64", 8, function (init) {
          return function Float64Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { "3b2e2827b74cbda2": "3K7vj" },
    ],
    "2pCox": [
      function (require, module, exports) {
        // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
        var $export = require("6e0d1e7b0f4a4024");
        var aFunction = require("a38ca490dd3a3177");
        var anObject = require("85d4e4aebb60742e");
        var rApply = (require("78000e3fea0586ed").Reflect || {}).apply;
        var fApply = Function.apply;
        // MS Edge argumentsList argument is optional
        $export(
          $export.S +
            $export.F *
              !require("7458a7c7f1218b71")(function () {
                rApply(function () {});
              }),
          "Reflect",
          {
            apply: function apply(target, thisArgument, argumentsList) {
              var T = aFunction(target);
              var L = anObject(argumentsList);
              return rApply
                ? rApply(T, thisArgument, L)
                : fApply.call(T, thisArgument, L);
            },
          },
        );
      },
      {
        "6e0d1e7b0f4a4024": "77Dy0",
        a38ca490dd3a3177: "7M8Zs",
        "85d4e4aebb60742e": "dkWKr",
        "78000e3fea0586ed": "c0KvC",
        "7458a7c7f1218b71": "jYBY4",
      },
    ],
    "7DZDZ": [
      function (require, module, exports) {
        // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
        var $export = require("99989eace3f0a14");
        var create = require("33d550882d1e2ad");
        var aFunction = require("d38ae56079749677");
        var anObject = require("afd6fd42d85b0d29");
        var isObject = require("911e6082bd5f2f8b");
        var fails = require("ac422be7b0d3950d");
        var bind = require("3d904f2f4c9166c3");
        var rConstruct = (require("26f94a727c99c8ca").Reflect || {}).construct;
        // MS Edge supports only 2 arguments and argumentsList argument is optional
        // FF Nightly sets third argument as `new.target`, but does not create `this` from it
        var NEW_TARGET_BUG = fails(function () {
          function F() {}
          return !(rConstruct(function () {}, [], F) instanceof F);
        });
        var ARGS_BUG = !fails(function () {
          rConstruct(function () {});
        });
        $export(
          $export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG),
          "Reflect",
          {
            construct: function construct(Target, args /* , newTarget */) {
              aFunction(Target);
              anObject(args);
              var newTarget =
                arguments.length < 3 ? Target : aFunction(arguments[2]);
              if (ARGS_BUG && !NEW_TARGET_BUG)
                return rConstruct(Target, args, newTarget);
              if (Target == newTarget) {
                // w/o altered newTarget, optimization for 0-4 arguments
                switch (args.length) {
                  case 0:
                    return new Target();
                  case 1:
                    return new Target(args[0]);
                  case 2:
                    return new Target(args[0], args[1]);
                  case 3:
                    return new Target(args[0], args[1], args[2]);
                  case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
                }
                // w/o altered newTarget, lot of arguments case
                var $args = [null];
                $args.push.apply($args, args);
                return new (bind.apply(Target, $args))();
              }
              // with altered newTarget, not support built-in constructors
              var proto = newTarget.prototype;
              var instance = create(isObject(proto) ? proto : Object.prototype);
              var result = Function.apply.call(Target, instance, args);
              return isObject(result) ? result : instance;
            },
          },
        );
      },
      {
        "99989eace3f0a14": "77Dy0",
        "33d550882d1e2ad": "2DOWX",
        d38ae56079749677: "7M8Zs",
        afd6fd42d85b0d29: "dkWKr",
        "911e6082bd5f2f8b": "joZov",
        ac422be7b0d3950d: "jYBY4",
        "3d904f2f4c9166c3": "7iPYO",
        "26f94a727c99c8ca": "c0KvC",
      },
    ],
    XkGHK: [
      function (require, module, exports) {
        // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
        var dP = require("82671e08a7e55408");
        var $export = require("e724e33bc3ba73f");
        var anObject = require("f75a5a924fe5a498");
        var toPrimitive = require("5b34e0487b80332");
        // MS Edge has broken Reflect.defineProperty - throwing instead of returning false
        $export(
          $export.S +
            $export.F *
              require("ed0512d2bc8f0808")(function () {
                // eslint-disable-next-line no-undef
                Reflect.defineProperty(
                  dP.f({}, 1, {
                    value: 1,
                  }),
                  1,
                  {
                    value: 2,
                  },
                );
              }),
          "Reflect",
          {
            defineProperty: function defineProperty(
              target,
              propertyKey,
              attributes,
            ) {
              anObject(target);
              propertyKey = toPrimitive(propertyKey, true);
              anObject(attributes);
              try {
                dP.f(target, propertyKey, attributes);
                return true;
              } catch (e) {
                return false;
              }
            },
          },
        );
      },
      {
        "82671e08a7e55408": "evkkn",
        e724e33bc3ba73f: "77Dy0",
        f75a5a924fe5a498: "dkWKr",
        "5b34e0487b80332": "9GXBY",
        ed0512d2bc8f0808: "jYBY4",
      },
    ],
    a9ovp: [
      function (require, module, exports) {
        // 26.1.4 Reflect.deleteProperty(target, propertyKey)
        var $export = require("e5aa2118c68daf51");
        var gOPD = require("59ce731b3409ea79").f;
        var anObject = require("922574eff7ef8349");
        $export($export.S, "Reflect", {
          deleteProperty: function deleteProperty(target, propertyKey) {
            var desc = gOPD(anObject(target), propertyKey);
            return desc && !desc.configurable
              ? false
              : delete target[propertyKey];
          },
        });
      },
      {
        e5aa2118c68daf51: "77Dy0",
        "59ce731b3409ea79": "jfoaU",
        "922574eff7ef8349": "dkWKr",
      },
    ],
    "2rcoi": [
      function (require, module, exports) {
        "use strict";
        // 26.1.5 Reflect.enumerate(target)
        var $export = require("8074b9c2be9af379");
        var anObject = require("9a44380310c2c68d");
        var Enumerate = function (iterated) {
          this._t = anObject(iterated); // target
          this._i = 0; // next index
          var keys = (this._k = []); // keys
          var key;
          for (key in iterated) keys.push(key);
        };
        require("e4d121e7ec5e596f")(Enumerate, "Object", function () {
          var that = this;
          var keys = that._k;
          var key;
          do {
            if (that._i >= keys.length)
              return {
                value: undefined,
                done: true,
              };
          } while (!((key = keys[that._i++]) in that._t));
          return {
            value: key,
            done: false,
          };
        });
        $export($export.S, "Reflect", {
          enumerate: function enumerate(target) {
            return new Enumerate(target);
          },
        });
      },
      {
        "8074b9c2be9af379": "77Dy0",
        "9a44380310c2c68d": "dkWKr",
        e4d121e7ec5e596f: "cX3VK",
      },
    ],
    JoWx5: [
      function (require, module, exports) {
        // 26.1.6 Reflect.get(target, propertyKey [, receiver])
        var gOPD = require("21c0f2934e16bc2b");
        var getPrototypeOf = require("808ea42574f2856");
        var has = require("fbe51fd452e0663a");
        var $export = require("23b5a120525cd5fd");
        var isObject = require("27af8abc0554f80f");
        var anObject = require("10f6164a86d97435");
        function get(target, propertyKey /* , receiver */) {
          var receiver = arguments.length < 3 ? target : arguments[2];
          var desc, proto;
          if (anObject(target) === receiver) return target[propertyKey];
          if ((desc = gOPD.f(target, propertyKey)))
            return has(desc, "value")
              ? desc.value
              : desc.get !== undefined
              ? desc.get.call(receiver)
              : undefined;
          if (isObject((proto = getPrototypeOf(target))))
            return get(proto, propertyKey, receiver);
        }
        $export($export.S, "Reflect", {
          get: get,
        });
      },
      {
        "21c0f2934e16bc2b": "jfoaU",
        "808ea42574f2856": "gQspV",
        fbe51fd452e0663a: "jnyQA",
        "23b5a120525cd5fd": "77Dy0",
        "27af8abc0554f80f": "joZov",
        "10f6164a86d97435": "dkWKr",
      },
    ],
    "9lT0r": [
      function (require, module, exports) {
        // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
        var gOPD = require("6330288bf985d3e9");
        var $export = require("4f2c6205b38e4f36");
        var anObject = require("82b9fad402ba4806");
        $export($export.S, "Reflect", {
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(
            target,
            propertyKey,
          ) {
            return gOPD.f(anObject(target), propertyKey);
          },
        });
      },
      {
        "6330288bf985d3e9": "jfoaU",
        "4f2c6205b38e4f36": "77Dy0",
        "82b9fad402ba4806": "dkWKr",
      },
    ],
    g1TgE: [
      function (require, module, exports) {
        // 26.1.8 Reflect.getPrototypeOf(target)
        var $export = require("6f4ca5789671f1c8");
        var getProto = require("b5ca3eb706d1549");
        var anObject = require("3df64cf45f2ebef8");
        $export($export.S, "Reflect", {
          getPrototypeOf: function getPrototypeOf(target) {
            return getProto(anObject(target));
          },
        });
      },
      {
        "6f4ca5789671f1c8": "77Dy0",
        b5ca3eb706d1549: "gQspV",
        "3df64cf45f2ebef8": "dkWKr",
      },
    ],
    "61FzT": [
      function (require, module, exports) {
        // 26.1.9 Reflect.has(target, propertyKey)
        var $export = require("f16cd54d8559d600");
        $export($export.S, "Reflect", {
          has: function has(target, propertyKey) {
            return propertyKey in target;
          },
        });
      },
      { f16cd54d8559d600: "77Dy0" },
    ],
    gkwW8: [
      function (require, module, exports) {
        // 26.1.10 Reflect.isExtensible(target)
        var $export = require("de31dd409ef6f454");
        var anObject = require("999deaa0ac17bc87");
        var $isExtensible = Object.isExtensible;
        $export($export.S, "Reflect", {
          isExtensible: function isExtensible(target) {
            anObject(target);
            return $isExtensible ? $isExtensible(target) : true;
          },
        });
      },
      { de31dd409ef6f454: "77Dy0", "999deaa0ac17bc87": "dkWKr" },
    ],
    lMGbj: [
      function (require, module, exports) {
        // 26.1.11 Reflect.ownKeys(target)
        var $export = require("4bd6480a9ee77d4f");
        $export($export.S, "Reflect", {
          ownKeys: require("2be80c895cce3b0f"),
        });
      },
      { "4bd6480a9ee77d4f": "77Dy0", "2be80c895cce3b0f": "a0L2d" },
    ],
    a0L2d: [
      function (require, module, exports) {
        // all object keys, includes non-enumerable and symbols
        var gOPN = require("fdd2524ef2064472");
        var gOPS = require("5fa30e47990471b9");
        var anObject = require("e3124bed7e4f3c9b");
        var Reflect = require("ce613d623ffecda5").Reflect;
        module.exports =
          (Reflect && Reflect.ownKeys) ||
          function ownKeys(it) {
            var keys = gOPN.f(anObject(it));
            var getSymbols = gOPS.f;
            return getSymbols ? keys.concat(getSymbols(it)) : keys;
          };
      },
      {
        fdd2524ef2064472: "aij03",
        "5fa30e47990471b9": "b0BO3",
        e3124bed7e4f3c9b: "dkWKr",
        ce613d623ffecda5: "c0KvC",
      },
    ],
    "2ukxk": [
      function (require, module, exports) {
        // 26.1.12 Reflect.preventExtensions(target)
        var $export = require("650b325f0ebe0dac");
        var anObject = require("34fb26a203325e7");
        var $preventExtensions = Object.preventExtensions;
        $export($export.S, "Reflect", {
          preventExtensions: function preventExtensions(target) {
            anObject(target);
            try {
              if ($preventExtensions) $preventExtensions(target);
              return true;
            } catch (e) {
              return false;
            }
          },
        });
      },
      { "650b325f0ebe0dac": "77Dy0", "34fb26a203325e7": "dkWKr" },
    ],
    lPRu7: [
      function (require, module, exports) {
        // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
        var dP = require("c9a3632fade6005d");
        var gOPD = require("cfb8a592a158b62c");
        var getPrototypeOf = require("2a44eb13bd5463e2");
        var has = require("bc42fb27839f65a6");
        var $export = require("b298fa714e36587");
        var createDesc = require("1d3159abe87fb3d0");
        var anObject = require("e9faef7e6c75ba17");
        var isObject = require("4ac1c1c122ac89a7");
        function set(target, propertyKey, V /* , receiver */) {
          var receiver = arguments.length < 4 ? target : arguments[3];
          var ownDesc = gOPD.f(anObject(target), propertyKey);
          var existingDescriptor, proto;
          if (!ownDesc) {
            if (isObject((proto = getPrototypeOf(target))))
              return set(proto, propertyKey, V, receiver);
            ownDesc = createDesc(0);
          }
          if (has(ownDesc, "value")) {
            if (ownDesc.writable === false || !isObject(receiver)) return false;
            if ((existingDescriptor = gOPD.f(receiver, propertyKey))) {
              if (
                existingDescriptor.get ||
                existingDescriptor.set ||
                existingDescriptor.writable === false
              )
                return false;
              existingDescriptor.value = V;
              dP.f(receiver, propertyKey, existingDescriptor);
            } else dP.f(receiver, propertyKey, createDesc(0, V));
            return true;
          }
          return ownDesc.set === undefined
            ? false
            : (ownDesc.set.call(receiver, V), true);
        }
        $export($export.S, "Reflect", {
          set: set,
        });
      },
      {
        c9a3632fade6005d: "evkkn",
        cfb8a592a158b62c: "jfoaU",
        "2a44eb13bd5463e2": "gQspV",
        bc42fb27839f65a6: "jnyQA",
        b298fa714e36587: "77Dy0",
        "1d3159abe87fb3d0": "ciJKK",
        e9faef7e6c75ba17: "dkWKr",
        "4ac1c1c122ac89a7": "joZov",
      },
    ],
    c9HUg: [
      function (require, module, exports) {
        // 26.1.14 Reflect.setPrototypeOf(target, proto)
        var $export = require("3cd65b859bca521c");
        var setProto = require("33ff3078b033de89");
        if (setProto)
          $export($export.S, "Reflect", {
            setPrototypeOf: function setPrototypeOf(target, proto) {
              setProto.check(target, proto);
              try {
                setProto.set(target, proto);
                return true;
              } catch (e) {
                return false;
              }
            },
          });
      },
      { "3cd65b859bca521c": "77Dy0", "33ff3078b033de89": "3XLh5" },
    ],
    "9TCAK": [
      function (require, module, exports) {
        require("4143bb95cfd73a31");
        module.exports = require("f0335002ec86a029").Array.includes;
      },
      { "4143bb95cfd73a31": "b32NI", f0335002ec86a029: "8jGrK" },
    ],
    b32NI: [
      function (require, module, exports) {
        "use strict";
        // https://github.com/tc39/Array.prototype.includes
        var $export = require("6c832416ebc9c4a3");
        var $includes = require("931780d564f097de")(true);
        $export($export.P, "Array", {
          includes: function includes(el /* , fromIndex = 0 */) {
            return $includes(
              this,
              el,
              arguments.length > 1 ? arguments[1] : undefined,
            );
          },
        });
        require("7fc20a5bc18ea2a6")("includes");
      },
      {
        "6c832416ebc9c4a3": "77Dy0",
        "931780d564f097de": "1pIJc",
        "7fc20a5bc18ea2a6": "9nItQ",
      },
    ],
    eqfjm: [
      function (require, module, exports) {
        require("1b5c191f3a8f0d03");
        module.exports = require("4571ff4cca403c26").Array.flatMap;
      },
      { "1b5c191f3a8f0d03": "8G0Uw", "4571ff4cca403c26": "8jGrK" },
    ],
    "8G0Uw": [
      function (require, module, exports) {
        "use strict";
        // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
        var $export = require("98f2d98ef784da90");
        var flattenIntoArray = require("8d7f542bef00771f");
        var toObject = require("103b20d95d9005d8");
        var toLength = require("ccedc4b3fb4c0c8e");
        var aFunction = require("633ffe253241f6c2");
        var arraySpeciesCreate = require("af8926f5b1f24bb9");
        $export($export.P, "Array", {
          flatMap: function flatMap(callbackfn /* , thisArg */) {
            var O = toObject(this);
            var sourceLen, A;
            aFunction(callbackfn);
            sourceLen = toLength(O.length);
            A = arraySpeciesCreate(O, 0);
            flattenIntoArray(
              A,
              O,
              O,
              sourceLen,
              0,
              1,
              callbackfn,
              arguments[1],
            );
            return A;
          },
        });
        require("ff23784a212a7343")("flatMap");
      },
      {
        "98f2d98ef784da90": "77Dy0",
        "8d7f542bef00771f": "7aZwW",
        "103b20d95d9005d8": "dZ3od",
        ccedc4b3fb4c0c8e: "kGg3g",
        "633ffe253241f6c2": "7M8Zs",
        af8926f5b1f24bb9: "cjpM0",
        ff23784a212a7343: "9nItQ",
      },
    ],
    "7aZwW": [
      function (require, module, exports) {
        "use strict";
        // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
        var isArray = require("dee83c070b231e11");
        var isObject = require("5687399cc8b4ca4c");
        var toLength = require("ce46b557f2150616");
        var ctx = require("10c53c5f5b98d07a");
        var IS_CONCAT_SPREADABLE =
          require("420a0351dc95c1c0")("isConcatSpreadable");
        function flattenIntoArray(
          target,
          original,
          source,
          sourceLen,
          start,
          depth,
          mapper,
          thisArg,
        ) {
          var targetIndex = start;
          var sourceIndex = 0;
          var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
          var element, spreadable;
          while (sourceIndex < sourceLen) {
            if (sourceIndex in source) {
              element = mapFn
                ? mapFn(source[sourceIndex], sourceIndex, original)
                : source[sourceIndex];
              spreadable = false;
              if (isObject(element)) {
                spreadable = element[IS_CONCAT_SPREADABLE];
                spreadable =
                  spreadable !== undefined ? !!spreadable : isArray(element);
              }
              if (spreadable && depth > 0)
                targetIndex =
                  flattenIntoArray(
                    target,
                    original,
                    element,
                    toLength(element.length),
                    targetIndex,
                    depth - 1,
                  ) - 1;
              else {
                if (targetIndex >= 0x1fffffffffffff) throw TypeError();
                target[targetIndex] = element;
              }
              targetIndex++;
            }
            sourceIndex++;
          }
          return targetIndex;
        }
        module.exports = flattenIntoArray;
      },
      {
        dee83c070b231e11: "3C2EA",
        "5687399cc8b4ca4c": "joZov",
        ce46b557f2150616: "kGg3g",
        "10c53c5f5b98d07a": "gpAgQ",
        "420a0351dc95c1c0": "ea5XI",
      },
    ],
    "95xbb": [
      function (require, module, exports) {
        require("6412308e23f81fc");
        module.exports = require("965d7aae4ccdabef").String.padStart;
      },
      { "6412308e23f81fc": "kDi1N", "965d7aae4ccdabef": "8jGrK" },
    ],
    kDi1N: [
      function (require, module, exports) {
        "use strict";
        // https://github.com/tc39/proposal-string-pad-start-end
        var $export = require("387f5e6a660468a2");
        var $pad = require("2f0f79ff1552e63d");
        var userAgent = require("d97e7319a2ca5643");
        // https://github.com/zloirock/core-js/issues/280
        var WEBKIT_BUG =
          /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
        $export($export.P + $export.F * WEBKIT_BUG, "String", {
          padStart: function padStart(maxLength /* , fillString = ' ' */) {
            return $pad(
              this,
              maxLength,
              arguments.length > 1 ? arguments[1] : undefined,
              true,
            );
          },
        });
      },
      {
        "387f5e6a660468a2": "77Dy0",
        "2f0f79ff1552e63d": "fAjgN",
        d97e7319a2ca5643: "8s6J7",
      },
    ],
    fAjgN: [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-string-pad-start-end
        var toLength = require("d34f653596f6bbb1");
        var repeat = require("b2103d55d6f4077e");
        var defined = require("fe7f02bd545cfcc2");
        module.exports = function (that, maxLength, fillString, left) {
          var S = String(defined(that));
          var stringLength = S.length;
          var fillStr = fillString === undefined ? " " : String(fillString);
          var intMaxLength = toLength(maxLength);
          if (intMaxLength <= stringLength || fillStr == "") return S;
          var fillLen = intMaxLength - stringLength;
          var stringFiller = repeat.call(
            fillStr,
            Math.ceil(fillLen / fillStr.length),
          );
          if (stringFiller.length > fillLen)
            stringFiller = stringFiller.slice(0, fillLen);
          return left ? stringFiller + S : S + stringFiller;
        };
      },
      {
        d34f653596f6bbb1: "kGg3g",
        b2103d55d6f4077e: "hUJ09",
        fe7f02bd545cfcc2: "ic3CF",
      },
    ],
    "9VEom": [
      function (require, module, exports) {
        require("d043d07a80c31bb7");
        module.exports = require("c0233209165c7b1f").String.padEnd;
      },
      { d043d07a80c31bb7: "7cKUe", c0233209165c7b1f: "8jGrK" },
    ],
    "7cKUe": [
      function (require, module, exports) {
        "use strict";
        // https://github.com/tc39/proposal-string-pad-start-end
        var $export = require("f4ce1114c1625515");
        var $pad = require("ddf1f3974cfde46a");
        var userAgent = require("6509a35595fafaf8");
        // https://github.com/zloirock/core-js/issues/280
        var WEBKIT_BUG =
          /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
        $export($export.P + $export.F * WEBKIT_BUG, "String", {
          padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
            return $pad(
              this,
              maxLength,
              arguments.length > 1 ? arguments[1] : undefined,
              false,
            );
          },
        });
      },
      {
        f4ce1114c1625515: "77Dy0",
        ddf1f3974cfde46a: "fAjgN",
        "6509a35595fafaf8": "8s6J7",
      },
    ],
    dKFZd: [
      function (require, module, exports) {
        require("cb512948fc2227d9");
        module.exports = require("7c89e9af85873f85").String.trimLeft;
      },
      { cb512948fc2227d9: "72Cn4", "7c89e9af85873f85": "8jGrK" },
    ],
    "72Cn4": [
      function (require, module, exports) {
        "use strict";
        // https://github.com/sebmarkbage/ecmascript-string-left-right-trim
        require("bc520900530e60f8")(
          "trimLeft",
          function ($trim) {
            return function trimLeft() {
              return $trim(this, 1);
            };
          },
          "trimStart",
        );
      },
      { bc520900530e60f8: "dkad2" },
    ],
    jAKR4: [
      function (require, module, exports) {
        require("c01e1a3d51efd4b");
        module.exports = require("49dca850d290df1f").String.trimRight;
      },
      { c01e1a3d51efd4b: "7HGPD", "49dca850d290df1f": "8jGrK" },
    ],
    "7HGPD": [
      function (require, module, exports) {
        "use strict";
        // https://github.com/sebmarkbage/ecmascript-string-left-right-trim
        require("f15cd7c67dd0c47a")(
          "trimRight",
          function ($trim) {
            return function trimRight() {
              return $trim(this, 2);
            };
          },
          "trimEnd",
        );
      },
      { f15cd7c67dd0c47a: "dkad2" },
    ],
    "20k8S": [
      function (require, module, exports) {
        require("8965912948e51878");
        module.exports = require("2e86006595ddd3f4").f("asyncIterator");
      },
      { "8965912948e51878": "dbXmf", "2e86006595ddd3f4": "fAFfy" },
    ],
    dbXmf: [
      function (require, module, exports) {
        require("9b4011c8d1f201d7")("asyncIterator");
      },
      { "9b4011c8d1f201d7": "fqXKV" },
    ],
    jRDnb: [
      function (require, module, exports) {
        require("a5b106eea5127ae5");
        module.exports =
          require("ebdafb0cf7baf809").Object.getOwnPropertyDescriptors;
      },
      { a5b106eea5127ae5: "dUIgZ", ebdafb0cf7baf809: "8jGrK" },
    ],
    dUIgZ: [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-object-getownpropertydescriptors
        var $export = require("89392be679ac2821");
        var ownKeys = require("63cbbf82f2260a80");
        var toIObject = require("308f514f3ea8a028");
        var gOPD = require("3edfeca2c1d3eda7");
        var createProperty = require("547c20acf78e3b71");
        $export($export.S, "Object", {
          getOwnPropertyDescriptors: function getOwnPropertyDescriptors(
            object,
          ) {
            var O = toIObject(object);
            var getDesc = gOPD.f;
            var keys = ownKeys(O);
            var result = {};
            var i = 0;
            var key, desc;
            while (keys.length > i) {
              desc = getDesc(O, (key = keys[i++]));
              if (desc !== undefined) createProperty(result, key, desc);
            }
            return result;
          },
        });
      },
      {
        "89392be679ac2821": "77Dy0",
        "63cbbf82f2260a80": "a0L2d",
        "308f514f3ea8a028": "ibyad",
        "3edfeca2c1d3eda7": "jfoaU",
        "547c20acf78e3b71": "6j6AZ",
      },
    ],
    "7ZBdl": [
      function (require, module, exports) {
        require("db731f3c711f7a87");
        module.exports = require("37ede6c089c6428e").Object.values;
      },
      { db731f3c711f7a87: "6iH9c", "37ede6c089c6428e": "8jGrK" },
    ],
    "6iH9c": [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-object-values-entries
        var $export = require("53873ee5bbc1579d");
        var $values = require("9f4c421687fe67dd")(false);
        $export($export.S, "Object", {
          values: function values(it) {
            return $values(it);
          },
        });
      },
      { "53873ee5bbc1579d": "77Dy0", "9f4c421687fe67dd": "c23SF" },
    ],
    c23SF: [
      function (require, module, exports) {
        var DESCRIPTORS = require("36fefc149556cf3c");
        var getKeys = require("f722462de8cb4638");
        var toIObject = require("c558e9af9ebaf9f0");
        var isEnum = require("d84e9389d32d292b").f;
        module.exports = function (isEntries) {
          return function (it) {
            var O = toIObject(it);
            var keys = getKeys(O);
            var length = keys.length;
            var i = 0;
            var result = [];
            var key;
            while (length > i) {
              key = keys[i++];
              if (!DESCRIPTORS || isEnum.call(O, key))
                result.push(isEntries ? [key, O[key]] : O[key]);
            }
            return result;
          };
        };
      },
      {
        "36fefc149556cf3c": "4XHXy",
        f722462de8cb4638: "ctfEa",
        c558e9af9ebaf9f0: "ibyad",
        d84e9389d32d292b: "aCVNF",
      },
    ],
    "58Rer": [
      function (require, module, exports) {
        require("12401a0787f6ab6");
        module.exports = require("54345c487db17b5").Object.entries;
      },
      { "12401a0787f6ab6": "gN56a", "54345c487db17b5": "8jGrK" },
    ],
    gN56a: [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-object-values-entries
        var $export = require("1022d424ebf2b086");
        var $entries = require("d399b8fe7d985836")(true);
        $export($export.S, "Object", {
          entries: function entries(it) {
            return $entries(it);
          },
        });
      },
      { "1022d424ebf2b086": "77Dy0", d399b8fe7d985836: "c23SF" },
    ],
    i4AUN: [
      function (require, module, exports) {
        "use strict";
        require("820027008aed74ec");
        require("e3afef65a0920f56");
        module.exports = require("71a017a3d8fce935").Promise["finally"];
      },
      {
        "820027008aed74ec": "xHtR0",
        e3afef65a0920f56: "3liTW",
        "71a017a3d8fce935": "8jGrK",
      },
    ],
    "3liTW": [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-promise-finally
        "use strict";
        var $export = require("8678978a95384f1");
        var core = require("684ba5f21a1a6059");
        var global = require("9ac57b8b4466ef95");
        var speciesConstructor = require("17333fa9a2acdb84");
        var promiseResolve = require("eee856cc45e0a9a7");
        $export($export.P + $export.R, "Promise", {
          finally: function (onFinally) {
            var C = speciesConstructor(this, core.Promise || global.Promise);
            var isFunction = typeof onFinally == "function";
            return this.then(
              isFunction
                ? function (x) {
                    return promiseResolve(C, onFinally()).then(function () {
                      return x;
                    });
                  }
                : onFinally,
              isFunction
                ? function (e) {
                    return promiseResolve(C, onFinally()).then(function () {
                      throw e;
                    });
                  }
                : onFinally,
            );
          },
        });
      },
      {
        "8678978a95384f1": "77Dy0",
        "684ba5f21a1a6059": "8jGrK",
        "9ac57b8b4466ef95": "c0KvC",
        "17333fa9a2acdb84": "c539Q",
        eee856cc45e0a9a7: "aKTpL",
      },
    ],
    bZzik: [
      function (require, module, exports) {
        require("24046694b6a8dea3");
        require("c3615083734c8b27");
        require("6938b01462f96c84");
        module.exports = require("8c948870e34e2a05");
      },
      {
        "24046694b6a8dea3": "4OcwX",
        c3615083734c8b27: "b0EW4",
        "6938b01462f96c84": "82RwK",
        "8c948870e34e2a05": "8jGrK",
      },
    ],
    "4OcwX": [
      function (require, module, exports) {
        // ie9- setTimeout & setInterval additional parameters fix
        var global = require("4db0e22e7bcd8028");
        var $export = require("1854e2032a6fdeed");
        var userAgent = require("736ffb547589d350");
        var slice = [].slice;
        var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
        var wrap = function (set) {
          return function (fn, time /* , ...args */) {
            var boundArgs = arguments.length > 2;
            var args = boundArgs ? slice.call(arguments, 2) : false;
            return set(
              boundArgs
                ? function () {
                    // eslint-disable-next-line no-new-func
                    (typeof fn == "function" ? fn : Function(fn)).apply(
                      this,
                      args,
                    );
                  }
                : fn,
              time,
            );
          };
        };
        $export($export.G + $export.B + $export.F * MSIE, {
          setTimeout: wrap(global.setTimeout),
          setInterval: wrap(global.setInterval),
        });
      },
      {
        "4db0e22e7bcd8028": "c0KvC",
        "1854e2032a6fdeed": "77Dy0",
        "736ffb547589d350": "8s6J7",
      },
    ],
    b0EW4: [
      function (require, module, exports) {
        var $export = require("af507ce87e41a20c");
        var $task = require("f3e37c42365e6105");
        $export($export.G + $export.B, {
          setImmediate: $task.set,
          clearImmediate: $task.clear,
        });
      },
      { af507ce87e41a20c: "77Dy0", f3e37c42365e6105: "a9IYo" },
    ],
    "82RwK": [
      function (require, module, exports) {
        var $iterators = require("5fe806b1e7f583c0");
        var getKeys = require("97646e462e98667a");
        var redefine = require("b2fc1f92ab5348f1");
        var global = require("ff5bc3a0e23bebd1");
        var hide = require("eb90d3b2d8d1b5b");
        var Iterators = require("f4eb5e7788345336");
        var wks = require("ba3590d81d843dbb");
        var ITERATOR = wks("iterator");
        var TO_STRING_TAG = wks("toStringTag");
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
          CSSRuleList: true,
          CSSStyleDeclaration: false,
          CSSValueList: false,
          ClientRectList: false,
          DOMRectList: false,
          DOMStringList: false,
          DOMTokenList: true,
          DataTransferItemList: false,
          FileList: false,
          HTMLAllCollection: false,
          HTMLCollection: false,
          HTMLFormElement: false,
          HTMLSelectElement: false,
          MediaList: true,
          MimeTypeArray: false,
          NamedNodeMap: false,
          NodeList: true,
          PaintRequestList: false,
          Plugin: false,
          PluginArray: false,
          SVGLengthList: false,
          SVGNumberList: false,
          SVGPathSegList: false,
          SVGPointList: false,
          SVGStringList: false,
          SVGTransformList: false,
          SourceBufferList: false,
          StyleSheetList: true,
          TextTrackCueList: false,
          TextTrackList: false,
          TouchList: false,
        };
        for (
          var collections = getKeys(DOMIterables), i = 0;
          i < collections.length;
          i++
        ) {
          var NAME = collections[i];
          var explicit = DOMIterables[NAME];
          var Collection = global[NAME];
          var proto = Collection && Collection.prototype;
          var key;
          if (proto) {
            if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
            if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
            Iterators[NAME] = ArrayValues;
            if (explicit) {
              for (key in $iterators)
                if (!proto[key]) redefine(proto, key, $iterators[key], true);
            }
          }
        }
      },
      {
        "5fe806b1e7f583c0": "cYJcA",
        "97646e462e98667a": "ctfEa",
        b2fc1f92ab5348f1: "kcOGE",
        ff5bc3a0e23bebd1: "c0KvC",
        eb90d3b2d8d1b5b: "4uQIf",
        f4eb5e7788345336: "6RAVz",
        ba3590d81d843dbb: "ea5XI",
      },
    ],
    "2TPpP": [
      function (require, module, exports) {
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */ var runtime = (function (exports) {
          "use strict";
          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var defineProperty =
            Object.defineProperty ||
            function (obj, key, desc) {
              obj[key] = desc.value;
            };
          var undefined; // More compressible than void 0.
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
          function define(obj, key, value) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true,
            });
            return obj[key];
          }
          try {
            // IE 8 has a broken Object.defineProperty that only works on DOM objects.
            define({}, "");
          } catch (err) {
            define = function (obj, key, value) {
              return (obj[key] = value);
            };
          }
          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator =
              outerFn && outerFn.prototype instanceof Generator
                ? outerFn
                : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);
            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            defineProperty(generator, "_invoke", {
              value: makeInvokeMethod(innerFn, self, context),
            });
            return generator;
          }
          exports.wrap = wrap;
          // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.
          function tryCatch(fn, obj, arg) {
            try {
              return {
                type: "normal",
                arg: fn.call(obj, arg),
              };
            } catch (err) {
              return {
                type: "throw",
                arg: err,
              };
            }
          }
          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";
          // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.
          var ContinueSentinel = {};
          // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.
          function Generator() {}
          function GeneratorFunction() {}
          function GeneratorFunctionPrototype() {}
          // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.
          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function () {
            return this;
          });
          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype =
            getProto && getProto(getProto(values([])));
          if (
            NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
          )
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
          var Gp =
            (GeneratorFunctionPrototype.prototype =
            Generator.prototype =
              Object.create(IteratorPrototype));
          GeneratorFunction.prototype = GeneratorFunctionPrototype;
          defineProperty(Gp, "constructor", {
            value: GeneratorFunctionPrototype,
            configurable: true,
          });
          defineProperty(GeneratorFunctionPrototype, "constructor", {
            value: GeneratorFunction,
            configurable: true,
          });
          GeneratorFunction.displayName = define(
            GeneratorFunctionPrototype,
            toStringTagSymbol,
            "GeneratorFunction",
          );
          // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              define(prototype, method, function (arg) {
                return this._invoke(method, arg);
              });
            });
          }
          exports.isGeneratorFunction = function (genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor
              ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
                  // do is to check its .name property.
                  (ctor.displayName || ctor.name) === "GeneratorFunction"
              : false;
          };
          exports.mark = function (genFun) {
            if (Object.setPrototypeOf)
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              define(genFun, toStringTagSymbol, "GeneratorFunction");
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };
          // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.
          exports.awrap = function (arg) {
            return {
              __await: arg,
            };
          };
          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") reject(record.arg);
              else {
                var result = record.arg;
                var value = result.value;
                if (
                  value &&
                  typeof value === "object" &&
                  hasOwn.call(value, "__await")
                )
                  return PromiseImpl.resolve(value.__await).then(
                    function (value) {
                      invoke("next", value, resolve, reject);
                    },
                    function (err) {
                      invoke("throw", err, resolve, reject);
                    },
                  );
                return PromiseImpl.resolve(value).then(
                  function (unwrapped) {
                    // When a yielded Promise is resolved, its final value becomes
                    // the .value of the Promise<{value,done}> result for the
                    // current iteration.
                    result.value = unwrapped;
                    resolve(result);
                  },
                  function (error) {
                    // If a rejected Promise was yielded, throw the rejection back
                    // into the async generator function so it can be handled there.
                    return invoke("throw", error, resolve, reject);
                  },
                );
              }
            }
            var previousPromise;
            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return (previousPromise = // If enqueue has been called before, then we want to wait until
                // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise
                  ? previousPromise.then(
                      callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
                      // invocations of the iterator.
                      callInvokeWithMethodAndArg,
                    )
                  : callInvokeWithMethodAndArg());
            }
            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            defineProperty(this, "_invoke", {
              value: enqueue,
            });
          }
          defineIteratorMethods(AsyncIterator.prototype);
          define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
            return this;
          });
          exports.AsyncIterator = AsyncIterator;
          // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.
          exports.async = function (
            innerFn,
            outerFn,
            self,
            tryLocsList,
            PromiseImpl,
          ) {
            if (PromiseImpl === void 0) PromiseImpl = Promise;
            var iter = new AsyncIterator(
              wrap(innerFn, outerFn, self, tryLocsList),
              PromiseImpl,
            );
            return exports.isGeneratorFunction(outerFn)
              ? iter // If outerFn is a generator, return the full iterator.
              : iter.next().then(function (result) {
                  return result.done ? result.value : iter.next();
                });
          };
          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;
            return function invoke(method, arg) {
              if (state === GenStateExecuting)
                throw new Error("Generator is already running");
              if (state === GenStateCompleted) {
                if (method === "throw") throw arg;
                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
              }
              context.method = method;
              context.arg = arg;
              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }
                if (context.method === "next")
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg;
                else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }
                  context.dispatchException(context.arg);
                } else if (context.method === "return")
                  context.abrupt("return", context.arg);
                state = GenStateExecuting;
                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done
                    ? GenStateCompleted
                    : GenStateSuspendedYield;
                  if (record.arg === ContinueSentinel) continue;
                  return {
                    value: record.arg,
                    done: context.done,
                  };
                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.
                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          }
          // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.
          function maybeInvokeDelegate(delegate, context) {
            var methodName = context.method;
            var method = delegate.iterator[methodName];
            if (method === undefined) {
              // A .throw or .return when the delegate iterator has no .throw
              // method, or a missing .next mehtod, always terminate the
              // yield* loop.
              context.delegate = null;
              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (methodName === "throw" && delegate.iterator["return"]) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = "return";
                context.arg = undefined;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw")
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel;
              }
              if (methodName !== "return") {
                context.method = "throw";
                context.arg = new TypeError(
                  "The iterator does not provide a '" + methodName + "' method",
                );
              }
              return ContinueSentinel;
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }
            var info = record.arg;
            if (!info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }
            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value;
              // Resume execution at the desired location (see delegateYield).
              context.next = delegate.nextLoc;
              // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.
              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined;
              }
            } // Re-yield the result returned by the delegate method.
            else return info;
            // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
          }
          // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.
          defineIteratorMethods(Gp);
          define(Gp, toStringTagSymbol, "Generator");
          // A Generator should always return itself as the iterator object when the
          // @@iterator function is called on it. Some browsers' implementations of the
          // iterator prototype chain incorrectly implement this, causing the Generator
          // object to not be returned from this call. This ensures that doesn't happen.
          // See https://github.com/facebook/regenerator/issues/274 for more details.
          define(Gp, iteratorSymbol, function () {
            return this;
          });
          define(Gp, "toString", function () {
            return "[object Generator]";
          });
          function pushTryEntry(locs) {
            var entry = {
              tryLoc: locs[0],
            };
            if (1 in locs) entry.catchLoc = locs[1];
            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }
            this.tryEntries.push(entry);
          }
          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }
          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [
              {
                tryLoc: "root",
              },
            ];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }
          exports.keys = function (val) {
            var object = Object(val);
            var keys = [];
            for (var key in object) keys.push(key);
            keys.reverse();
            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
              while (keys.length) {
                var key = keys.pop();
                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              }
              // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.
              next.done = true;
              return next;
            };
          };
          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) return iteratorMethod.call(iterable);
              if (typeof iterable.next === "function") return iterable;
              if (!isNaN(iterable.length)) {
                var i = -1,
                  next = function next() {
                    while (++i < iterable.length)
                      if (hasOwn.call(iterable, i)) {
                        next.value = iterable[i];
                        next.done = false;
                        return next;
                      }
                    next.value = undefined;
                    next.done = true;
                    return next;
                  };
                return (next.next = next);
              }
            }
            // Return an iterator with no values.
            return {
              next: doneResult,
            };
          }
          exports.values = values;
          function doneResult() {
            return {
              value: undefined,
              done: true,
            };
          }
          Context.prototype = {
            constructor: Context,
            reset: function (skipTempReset) {
              this.prev = 0;
              this.next = 0;
              // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.
              this.sent = this._sent = undefined;
              this.done = false;
              this.delegate = null;
              this.method = "next";
              this.arg = undefined;
              this.tryEntries.forEach(resetTryEntry);
              if (!skipTempReset) {
                for (var name in this) // Not sure about the optimal order of these conditions:
                  if (
                    name.charAt(0) === "t" &&
                    hasOwn.call(this, name) &&
                    !isNaN(+name.slice(1))
                  )
                    this[name] = undefined;
              }
            },
            stop: function () {
              this.done = true;
              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === "throw") throw rootRecord.arg;
              return this.rval;
            },
            dispatchException: function (exception) {
              if (this.done) throw exception;
              var context = this;
              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;
                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = "next";
                  context.arg = undefined;
                }
                return !!caught;
              }
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;
                if (entry.tryLoc === "root")
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle("end");
                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");
                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc)
                      return handle(entry.catchLoc, true);
                    else if (this.prev < entry.finallyLoc)
                      return handle(entry.finallyLoc);
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc)
                      return handle(entry.catchLoc, true);
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc)
                      return handle(entry.finallyLoc);
                  } else
                    throw new Error("try statement without catch or finally");
                }
              }
            },
            abrupt: function (type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (
                  entry.tryLoc <= this.prev &&
                  hasOwn.call(entry, "finallyLoc") &&
                  this.prev < entry.finallyLoc
                ) {
                  var finallyEntry = entry;
                  break;
                }
              }
              if (
                finallyEntry &&
                (type === "break" || type === "continue") &&
                finallyEntry.tryLoc <= arg &&
                arg <= finallyEntry.finallyLoc
              )
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;
              if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }
              return this.complete(record);
            },
            complete: function (record, afterLoc) {
              if (record.type === "throw") throw record.arg;
              if (record.type === "break" || record.type === "continue")
                this.next = record.arg;
              else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
              } else if (record.type === "normal" && afterLoc)
                this.next = afterLoc;
              return ContinueSentinel;
            },
            finish: function (finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },
            catch: function (tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }
              // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc,
              };
              if (this.method === "next")
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined;
              return ContinueSentinel;
            },
          };
          // Regardless of whether this script is executing as a CommonJS module
          // or not, return the runtime object so that we can declare the variable
          // regeneratorRuntime in the outer scope, which allows this module to be
          // injected easily by `bin/regenerator --include-runtime script.js`.
          return exports;
        })(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          (0, module.exports),
        );
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          // This module should not be running in strict mode, so the above
          // assignment should always work unless something is misconfigured. Just
          // in case runtime.js accidentally runs in strict mode, in modern engines
          // we can explicitly access globalThis. In older engines we can escape
          // strict mode using a global Function call. This could conceivably fail
          // if a Content Security Policy forbids using Function, but in that case
          // the proper solution is to fix the accidental strict mode problem. If
          // you've misconfigured your bundler to force strict mode and applied a
          // CSP to forbid Function, and you're not willing to fix either of those
          // problems, please detail your unique predicament in a GitHub issue.
          if (typeof globalThis === "object")
            globalThis.regeneratorRuntime = runtime;
          else Function("r", "regeneratorRuntime = r")(runtime);
        }
      },
      {},
    ],
    fuWG2: [
      function (require, module, exports) {
        require("e8bdcdeeb9c01d98");
        module.exports = require("c7e98027218dd649").global;
      },
      { e8bdcdeeb9c01d98: "fKIKS", c7e98027218dd649: "c8qKl" },
    ],
    fKIKS: [
      function (require, module, exports) {
        // https://github.com/tc39/proposal-global
        var $export = require("a9b772cbb880c7a0");
        $export($export.G, {
          global: require("d8353f45753b5c4a"),
        });
      },
      { a9b772cbb880c7a0: "hIkYo", d8353f45753b5c4a: "ejp65" },
    ],
    hIkYo: [
      function (require, module, exports) {
        var global = require("280d898477400d74");
        var core = require("675cdc75da15c6cc");
        var ctx = require("b3e02d951b36329c");
        var hide = require("ddc23a3c61502858");
        var has = require("918e8739fa09f494");
        var PROTOTYPE = "prototype";
        var $export = function (type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var IS_WRAP = type & $export.W;
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE];
          var target = IS_GLOBAL
            ? global
            : IS_STATIC
            ? global[name]
            : (global[name] || {})[PROTOTYPE];
          var key, own, out;
          if (IS_GLOBAL) source = name;
          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined;
            if (own && has(exports, key)) continue;
            // export native or passed
            out = own ? target[key] : source[key];
            // prevent global pollution for namespaces
            exports[key] =
              IS_GLOBAL && typeof target[key] != "function"
                ? source[key]
                : IS_BIND && own
                ? ctx(out, global)
                : IS_WRAP && target[key] == out
                ? (function (C) {
                    var F = function (a, b, c) {
                      if (this instanceof C) {
                        switch (arguments.length) {
                          case 0:
                            return new C();
                          case 1:
                            return new C(a);
                          case 2:
                            return new C(a, b);
                        }
                        return new C(a, b, c);
                      }
                      return C.apply(this, arguments);
                    };
                    F[PROTOTYPE] = C[PROTOTYPE];
                    return F;
                    // make static versions for prototype methods
                  })(out)
                : IS_PROTO && typeof out == "function"
                ? ctx(Function.call, out)
                : out;
            // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            if (IS_PROTO) {
              (exports.virtual || (exports.virtual = {}))[key] = out;
              // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
              if (type & $export.R && expProto && !expProto[key])
                hide(expProto, key, out);
            }
          }
        };
        // type bitmap
        $export.F = 1; // forced
        $export.G = 2; // global
        $export.S = 4; // static
        $export.P = 8; // proto
        $export.B = 16; // bind
        $export.W = 32; // wrap
        $export.U = 64; // safe
        $export.R = 128; // real proto method for `library`
        module.exports = $export;
      },
      {
        "280d898477400d74": "ejp65",
        "675cdc75da15c6cc": "c8qKl",
        b3e02d951b36329c: "nvyMo",
        ddc23a3c61502858: "cDbCZ",
        "918e8739fa09f494": "iEN9H",
      },
    ],
    ejp65: [
      function (require, module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = (module.exports =
          typeof window != "undefined" && window.Math == Math
            ? window
            : typeof self != "undefined" && self.Math == Math
            ? self
            : Function("return this")());
        if (typeof __g == "number") __g = global; // eslint-disable-line no-undef
      },
      {},
    ],
    c8qKl: [
      function (require, module, exports) {
        var core = (module.exports = {
          version: "2.6.12",
        });
        if (typeof __e == "number") __e = core; // eslint-disable-line no-undef
      },
      {},
    ],
    nvyMo: [
      function (require, module, exports) {
        // optional / simple context binding
        var aFunction = require("c33d1bc3a4957666");
        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };
            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function () {
            return fn.apply(that, arguments);
          };
        };
      },
      { c33d1bc3a4957666: "j33kY" },
    ],
    j33kY: [
      function (require, module, exports) {
        module.exports = function (it) {
          if (typeof it != "function")
            throw TypeError(it + " is not a function!");
          return it;
        };
      },
      {},
    ],
    cDbCZ: [
      function (require, module, exports) {
        var dP = require("b50b81010811f779");
        var createDesc = require("6ae41bf95c963be1");
        module.exports = require("aca69a30f8d97bbf")
          ? function (object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            }
          : function (object, key, value) {
              object[key] = value;
              return object;
            };
      },
      {
        b50b81010811f779: "iRBR4",
        "6ae41bf95c963be1": "ePVEg",
        aca69a30f8d97bbf: "4uE0p",
      },
    ],
    iRBR4: [
      function (require, module, exports) {
        var anObject = require("39c1614979b2c200");
        var IE8_DOM_DEFINE = require("81b6a1862b6bb3f4");
        var toPrimitive = require("23225402685cd00b");
        var dP = Object.defineProperty;
        exports.f = require("e768d3f130c18468")
          ? Object.defineProperty
          : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return dP(O, P, Attributes);
                } catch (e) {}
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
      },
      {
        "39c1614979b2c200": "5CGoe",
        "81b6a1862b6bb3f4": "ftllT",
        "23225402685cd00b": "d11Cl",
        e768d3f130c18468: "4uE0p",
      },
    ],
    "5CGoe": [
      function (require, module, exports) {
        var isObject = require("d1fa6c6d718b2af0");
        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + " is not an object!");
          return it;
        };
      },
      { d1fa6c6d718b2af0: "bPVy2" },
    ],
    bPVy2: [
      function (require, module, exports) {
        module.exports = function (it) {
          return typeof it === "object"
            ? it !== null
            : typeof it === "function";
        };
      },
      {},
    ],
    ftllT: [
      function (require, module, exports) {
        module.exports =
          !require("25e39c96b485a2d4") &&
          !require("841f8f7344d52e3c")(function () {
            return (
              Object.defineProperty(require("26ea8bab98f45102")("div"), "a", {
                get: function () {
                  return 7;
                },
              }).a != 7
            );
          });
      },
      {
        "25e39c96b485a2d4": "4uE0p",
        "841f8f7344d52e3c": "lf8WH",
        "26ea8bab98f45102": "42d8v",
      },
    ],
    "4uE0p": [
      function (require, module, exports) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !require("384e64392289cbf0")(function () {
          return (
            Object.defineProperty({}, "a", {
              get: function () {
                return 7;
              },
            }).a != 7
          );
        });
      },
      { "384e64392289cbf0": "lf8WH" },
    ],
    lf8WH: [
      function (require, module, exports) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
      },
      {},
    ],
    "42d8v": [
      function (require, module, exports) {
        var isObject = require("1c4f66d669be867c");
        var document = require("382f8de20d058e56").document;
        // typeof document.createElement is 'object' in old IE
        var is = isObject(document) && isObject(document.createElement);
        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };
      },
      { "1c4f66d669be867c": "bPVy2", "382f8de20d058e56": "ejp65" },
    ],
    d11Cl: [
      function (require, module, exports) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = require("bdd1a0adae2b9200");
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (
            S &&
            typeof (fn = it.toString) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          if (
            typeof (fn = it.valueOf) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          if (
            !S &&
            typeof (fn = it.toString) == "function" &&
            !isObject((val = fn.call(it)))
          )
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      { bdd1a0adae2b9200: "bPVy2" },
    ],
    ePVEg: [
      function (require, module, exports) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value,
          };
        };
      },
      {},
    ],
    iEN9H: [
      function (require, module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };
      },
      {},
    ],
    "6J3OJ": [
      function (require, module, exports) {
        /* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "login", () => login);
        parcelHelpers.export(exports, "logout", () => logout);
        var _axios = require("axios");
        var _axiosDefault = parcelHelpers.interopDefault(_axios);
        var _alertsJs = require("./alerts.js");
        var _alertsJsDefault = parcelHelpers.interopDefault(_alertsJs);
        const login = async (email, password) => {
          try {
            const res = await (0, _axiosDefault.default)({
              method: "POST",
              url: "http://localhost:3000/api/v1/users/login",
              data: {
                email,
                password,
              },
            });
            if (res.data.status === "success") {
              (0, _alertsJsDefault.default)(
                "success",
                "Logged in successfully!",
              );
              window.setTimeout(() => {
                location.assign("/");
              }, 1500);
            }
          } catch (err) {
            (0, _alertsJsDefault.default)("error", err.response.data.message);
          }
        };
        const logout = async () => {
          try {
            const res = await (0, _axiosDefault.default)({
              method: "GET",
              url: "http://localhost:3000/api/v1/users/logout",
            });
            if (res.data.status === "success") location.assign("/");
          } catch (e) {
            (0, _alertsJsDefault.default)(
              "error",
              "Error logging out! Try again.",
            );
          }
        };
      },
      {
        axios: "cNk7h",
        "./alerts.js": "2hU5S",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    cNk7h: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(
          exports,
          "default",
          () => (0, _axiosJsDefault.default),
        );
        parcelHelpers.export(exports, "Axios", () => Axios);
        parcelHelpers.export(exports, "AxiosError", () => AxiosError);
        parcelHelpers.export(exports, "CanceledError", () => CanceledError);
        parcelHelpers.export(exports, "isCancel", () => isCancel);
        parcelHelpers.export(exports, "CancelToken", () => CancelToken);
        parcelHelpers.export(exports, "VERSION", () => VERSION);
        parcelHelpers.export(exports, "all", () => all);
        parcelHelpers.export(exports, "Cancel", () => Cancel);
        parcelHelpers.export(exports, "isAxiosError", () => isAxiosError);
        parcelHelpers.export(exports, "spread", () => spread);
        parcelHelpers.export(exports, "toFormData", () => toFormData);
        parcelHelpers.export(exports, "AxiosHeaders", () => AxiosHeaders);
        parcelHelpers.export(exports, "HttpStatusCode", () => HttpStatusCode);
        parcelHelpers.export(exports, "formToJSON", () => formToJSON);
        parcelHelpers.export(exports, "getAdapter", () => getAdapter);
        parcelHelpers.export(exports, "mergeConfig", () => mergeConfig);
        var _axiosJs = require("./lib/axios.js");
        var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
        // This module is intended to unwrap Axios default export as named.
        // Keep top-level export same with static properties
        // so that it can keep same with es module or cjs
        const {
          Axios,
          AxiosError,
          CanceledError,
          isCancel,
          CancelToken,
          VERSION,
          all,
          Cancel,
          isAxiosError,
          spread,
          toFormData,
          AxiosHeaders,
          HttpStatusCode,
          formToJSON,
          getAdapter,
          mergeConfig,
        } = (0, _axiosJsDefault.default);
      },
      {
        "./lib/axios.js": "6jsie",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "6jsie": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _bindJs = require("./helpers/bind.js");
        var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
        var _axiosJs = require("./core/Axios.js");
        var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
        var _mergeConfigJs = require("./core/mergeConfig.js");
        var _mergeConfigJsDefault =
          parcelHelpers.interopDefault(_mergeConfigJs);
        var _indexJs = require("./defaults/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
        var _formDataToJSONJsDefault =
          parcelHelpers.interopDefault(_formDataToJSONJs);
        var _canceledErrorJs = require("./cancel/CanceledError.js");
        var _canceledErrorJsDefault =
          parcelHelpers.interopDefault(_canceledErrorJs);
        var _cancelTokenJs = require("./cancel/CancelToken.js");
        var _cancelTokenJsDefault =
          parcelHelpers.interopDefault(_cancelTokenJs);
        var _isCancelJs = require("./cancel/isCancel.js");
        var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
        var _dataJs = require("./env/data.js");
        var _toFormDataJs = require("./helpers/toFormData.js");
        var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
        var _axiosErrorJs = require("./core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        var _spreadJs = require("./helpers/spread.js");
        var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
        var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
        var _isAxiosErrorJsDefault =
          parcelHelpers.interopDefault(_isAxiosErrorJs);
        var _axiosHeadersJs = require("./core/AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        var _adaptersJs = require("./adapters/adapters.js");
        var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
        var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
        var _httpStatusCodeJsDefault =
          parcelHelpers.interopDefault(_httpStatusCodeJs);
        ("use strict");
        /**
         * Create an instance of Axios
         *
         * @param {Object} defaultConfig The default config for the instance
         *
         * @returns {Axios} A new instance of Axios
         */ function createInstance(defaultConfig) {
          const context = new (0, _axiosJsDefault.default)(defaultConfig);
          const instance = (0, _bindJsDefault.default)(
            (0, _axiosJsDefault.default).prototype.request,
            context,
          );
          // Copy axios.prototype to instance
          (0, _utilsJsDefault.default).extend(
            instance,
            (0, _axiosJsDefault.default).prototype,
            context,
            {
              allOwnKeys: true,
            },
          );
          // Copy context to instance
          (0, _utilsJsDefault.default).extend(instance, context, null, {
            allOwnKeys: true,
          });
          // Factory for creating new instances
          instance.create = function create(instanceConfig) {
            return createInstance(
              (0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig),
            );
          };
          return instance;
        }
        // Create the default instance to be exported
        const axios = createInstance((0, _indexJsDefault.default));
        // Expose Axios class to allow class inheritance
        axios.Axios = (0, _axiosJsDefault.default);
        // Expose Cancel & CancelToken
        axios.CanceledError = (0, _canceledErrorJsDefault.default);
        axios.CancelToken = (0, _cancelTokenJsDefault.default);
        axios.isCancel = (0, _isCancelJsDefault.default);
        axios.VERSION = (0, _dataJs.VERSION);
        axios.toFormData = (0, _toFormDataJsDefault.default);
        // Expose AxiosError class
        axios.AxiosError = (0, _axiosErrorJsDefault.default);
        // alias for CanceledError for backward compatibility
        axios.Cancel = axios.CanceledError;
        // Expose all/spread
        axios.all = function all(promises) {
          return Promise.all(promises);
        };
        axios.spread = (0, _spreadJsDefault.default);
        // Expose isAxiosError
        axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
        // Expose mergeConfig
        axios.mergeConfig = (0, _mergeConfigJsDefault.default);
        axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
        axios.formToJSON = (thing) =>
          (0, _formDataToJSONJsDefault.default)(
            (0, _utilsJsDefault.default).isHTMLForm(thing)
              ? new FormData(thing)
              : thing,
          );
        axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
        axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
        axios.default = axios;
        // this module should only have a default export
        exports.default = axios;
      },
      {
        "./utils.js": "gUZbi",
        "./helpers/bind.js": "iEIW4",
        "./core/Axios.js": "66aZv",
        "./core/mergeConfig.js": "lm9Dz",
        "./defaults/index.js": "iyLpu",
        "./helpers/formDataToJSON.js": "7NdDM",
        "./cancel/CanceledError.js": "5zKhr",
        "./cancel/CancelToken.js": "d1HJ6",
        "./cancel/isCancel.js": "7VE25",
        "./env/data.js": "kWtyc",
        "./helpers/toFormData.js": "8Si2N",
        "./core/AxiosError.js": "bJPKW",
        "./helpers/spread.js": "8aHr9",
        "./helpers/isAxiosError.js": "eQ07D",
        "./core/AxiosHeaders.js": "fUSSQ",
        "./adapters/adapters.js": "eOTbv",
        "./helpers/HttpStatusCode.js": "fZZiR",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    gUZbi: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _bindJs = require("./helpers/bind.js");
        var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
        var global = arguments[3];
        ("use strict");
        // utils is a library of generic helper functions non-specific to axios
        const { toString } = Object.prototype;
        const { getPrototypeOf } = Object;
        const kindOf = ((cache) => (thing) => {
          const str = toString.call(thing);
          return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
        })(Object.create(null));
        const kindOfTest = (type) => {
          type = type.toLowerCase();
          return (thing) => kindOf(thing) === type;
        };
        const typeOfTest = (type) => (thing) => typeof thing === type;
        /**
         * Determine if a value is an Array
         *
         * @param {Object} val The value to test
         *
         * @returns {boolean} True if value is an Array, otherwise false
         */ const { isArray } = Array;
        /**
         * Determine if a value is undefined
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if the value is undefined, otherwise false
         */ const isUndefined = typeOfTest("undefined");
        /**
         * Determine if a value is a Buffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Buffer, otherwise false
         */ function isBuffer(val) {
          return (
            val !== null &&
            !isUndefined(val) &&
            val.constructor !== null &&
            !isUndefined(val.constructor) &&
            isFunction(val.constructor.isBuffer) &&
            val.constructor.isBuffer(val)
          );
        }
        /**
         * Determine if a value is an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is an ArrayBuffer, otherwise false
         */ const isArrayBuffer = kindOfTest("ArrayBuffer");
        /**
         * Determine if a value is a view on an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
         */ function isArrayBufferView(val) {
          let result;
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView)
            result = ArrayBuffer.isView(val);
          else result = val && val.buffer && isArrayBuffer(val.buffer);
          return result;
        }
        /**
         * Determine if a value is a String
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a String, otherwise false
         */ const isString = typeOfTest("string");
        /**
         * Determine if a value is a Function
         *
         * @param {*} val The value to test
         * @returns {boolean} True if value is a Function, otherwise false
         */ const isFunction = typeOfTest("function");
        /**
         * Determine if a value is a Number
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Number, otherwise false
         */ const isNumber = typeOfTest("number");
        /**
         * Determine if a value is an Object
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an Object, otherwise false
         */ const isObject = (thing) =>
          thing !== null && typeof thing === "object";
        /**
         * Determine if a value is a Boolean
         *
         * @param {*} thing The value to test
         * @returns {boolean} True if value is a Boolean, otherwise false
         */ const isBoolean = (thing) => thing === true || thing === false;
        /**
         * Determine if a value is a plain Object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a plain Object, otherwise false
         */ const isPlainObject = (val) => {
          if (kindOf(val) !== "object") return false;
          const prototype = getPrototypeOf(val);
          return (
            (prototype === null ||
              prototype === Object.prototype ||
              Object.getPrototypeOf(prototype) === null) &&
            !(Symbol.toStringTag in val) &&
            !(Symbol.iterator in val)
          );
        };
        /**
         * Determine if a value is a Date
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Date, otherwise false
         */ const isDate = kindOfTest("Date");
        /**
         * Determine if a value is a File
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */ const isFile = kindOfTest("File");
        /**
         * Determine if a value is a Blob
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Blob, otherwise false
         */ const isBlob = kindOfTest("Blob");
        /**
         * Determine if a value is a FileList
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */ const isFileList = kindOfTest("FileList");
        /**
         * Determine if a value is a Stream
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Stream, otherwise false
         */ const isStream = (val) => isObject(val) && isFunction(val.pipe);
        /**
         * Determine if a value is a FormData
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an FormData, otherwise false
         */ const isFormData = (thing) => {
          let kind;
          return (
            thing &&
            ((typeof FormData === "function" && thing instanceof FormData) ||
              (isFunction(thing.append) &&
                ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
                  (kind === "object" &&
                    isFunction(thing.toString) &&
                    thing.toString() === "[object FormData]"))))
          );
        };
        /**
         * Determine if a value is a URLSearchParams object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a URLSearchParams object, otherwise false
         */ const isURLSearchParams = kindOfTest("URLSearchParams");
        /**
         * Trim excess whitespace off the beginning and end of a string
         *
         * @param {String} str The String to trim
         *
         * @returns {String} The String freed of excess whitespace
         */ const trim = (str) =>
          str.trim
            ? str.trim()
            : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        /**
         * Iterate over an Array or an Object invoking a function for each item.
         *
         * If `obj` is an Array callback will be called passing
         * the value, index, and complete array for each item.
         *
         * If 'obj' is an Object callback will be called passing
         * the value, key, and complete object for each property.
         *
         * @param {Object|Array} obj The object to iterate
         * @param {Function} fn The callback to invoke for each item
         *
         * @param {Boolean} [allOwnKeys = false]
         * @returns {any}
         */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
          // Don't bother if no value provided
          if (obj === null || typeof obj === "undefined") return;
          let i;
          let l;
          // Force an array if not already something iterable
          if (typeof obj !== "object")
            /*eslint no-param-reassign:0*/ obj = [obj];
          if (isArray(obj))
            // Iterate over array values
            for (i = 0, l = obj.length; i < l; i++)
              fn.call(null, obj[i], i, obj);
          else {
            // Iterate over object keys
            const keys = allOwnKeys
              ? Object.getOwnPropertyNames(obj)
              : Object.keys(obj);
            const len = keys.length;
            let key;
            for (i = 0; i < len; i++) {
              key = keys[i];
              fn.call(null, obj[key], key, obj);
            }
          }
        }
        function findKey(obj, key) {
          key = key.toLowerCase();
          const keys = Object.keys(obj);
          let i = keys.length;
          let _key;
          while (i-- > 0) {
            _key = keys[i];
            if (key === _key.toLowerCase()) return _key;
          }
          return null;
        }
        const _global = (() => {
          /*eslint no-undef:0*/ if (typeof globalThis !== "undefined")
            return globalThis;
          return typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : global;
        })();
        const isContextDefined = (context) =>
          !isUndefined(context) && context !== _global;
        /**
         * Accepts varargs expecting each argument to be an object, then
         * immutably merges the properties of each object and returns result.
         *
         * When multiple objects contain the same key the later object in
         * the arguments list will take precedence.
         *
         * Example:
         *
         * ```js
         * var result = merge({foo: 123}, {foo: 456});
         * console.log(result.foo); // outputs 456
         * ```
         *
         * @param {Object} obj1 Object to merge
         *
         * @returns {Object} Result of all merge properties
         */ function merge() {
          const { caseless } = (isContextDefined(this) && this) || {};
          const result = {};
          const assignValue = (val, key) => {
            const targetKey = (caseless && findKey(result, key)) || key;
            if (isPlainObject(result[targetKey]) && isPlainObject(val))
              result[targetKey] = merge(result[targetKey], val);
            else if (isPlainObject(val)) result[targetKey] = merge({}, val);
            else if (isArray(val)) result[targetKey] = val.slice();
            else result[targetKey] = val;
          };
          for (let i = 0, l = arguments.length; i < l; i++)
            arguments[i] && forEach(arguments[i], assignValue);
          return result;
        }
        /**
         * Extends object a by mutably adding to it the properties of object b.
         *
         * @param {Object} a The object to be extended
         * @param {Object} b The object to copy properties from
         * @param {Object} thisArg The object to bind function to
         *
         * @param {Boolean} [allOwnKeys]
         * @returns {Object} The resulting value of object a
         */ const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
          forEach(
            b,
            (val, key) => {
              if (thisArg && isFunction(val))
                a[key] = (0, _bindJsDefault.default)(val, thisArg);
              else a[key] = val;
            },
            {
              allOwnKeys,
            },
          );
          return a;
        };
        /**
         * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
         *
         * @param {string} content with BOM
         *
         * @returns {string} content value without BOM
         */ const stripBOM = (content) => {
          if (content.charCodeAt(0) === 0xfeff) content = content.slice(1);
          return content;
        };
        /**
         * Inherit the prototype methods from one constructor into another
         * @param {function} constructor
         * @param {function} superConstructor
         * @param {object} [props]
         * @param {object} [descriptors]
         *
         * @returns {void}
         */ const inherits = (
          constructor,
          superConstructor,
          props,
          descriptors,
        ) => {
          constructor.prototype = Object.create(
            superConstructor.prototype,
            descriptors,
          );
          constructor.prototype.constructor = constructor;
          Object.defineProperty(constructor, "super", {
            value: superConstructor.prototype,
          });
          props && Object.assign(constructor.prototype, props);
        };
        /**
         * Resolve object with deep prototype chain to a flat object
         * @param {Object} sourceObj source object
         * @param {Object} [destObj]
         * @param {Function|Boolean} [filter]
         * @param {Function} [propFilter]
         *
         * @returns {Object}
         */ const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
          let props;
          let i;
          let prop;
          const merged = {};
          destObj = destObj || {};
          // eslint-disable-next-line no-eq-null,eqeqeq
          if (sourceObj == null) return destObj;
          do {
            props = Object.getOwnPropertyNames(sourceObj);
            i = props.length;
            while (i-- > 0) {
              prop = props[i];
              if (
                (!propFilter || propFilter(prop, sourceObj, destObj)) &&
                !merged[prop]
              ) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
              }
            }
            sourceObj = filter !== false && getPrototypeOf(sourceObj);
          } while (
            sourceObj &&
            (!filter || filter(sourceObj, destObj)) &&
            sourceObj !== Object.prototype
          );
          return destObj;
        };
        /**
         * Determines whether a string ends with the characters of a specified string
         *
         * @param {String} str
         * @param {String} searchString
         * @param {Number} [position= 0]
         *
         * @returns {boolean}
         */ const endsWith = (str, searchString, position) => {
          str = String(str);
          if (position === undefined || position > str.length)
            position = str.length;
          position -= searchString.length;
          const lastIndex = str.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        };
        /**
         * Returns new array from array like object or null if failed
         *
         * @param {*} [thing]
         *
         * @returns {?Array}
         */ const toArray = (thing) => {
          if (!thing) return null;
          if (isArray(thing)) return thing;
          let i = thing.length;
          if (!isNumber(i)) return null;
          const arr = new Array(i);
          while (i-- > 0) arr[i] = thing[i];
          return arr;
        };
        /**
         * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
         * thing passed in is an instance of Uint8Array
         *
         * @param {TypedArray}
         *
         * @returns {Array}
         */ // eslint-disable-next-line func-names
        const isTypedArray = ((TypedArray) => {
          // eslint-disable-next-line func-names
          return (thing) => {
            return TypedArray && thing instanceof TypedArray;
          };
        })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
        /**
         * For each entry in the object, call the function with the key and value.
         *
         * @param {Object<any, any>} obj - The object to iterate over.
         * @param {Function} fn - The function to call for each entry.
         *
         * @returns {void}
         */ const forEachEntry = (obj, fn) => {
          const generator = obj && obj[Symbol.iterator];
          const iterator = generator.call(obj);
          let result;
          while ((result = iterator.next()) && !result.done) {
            const pair = result.value;
            fn.call(obj, pair[0], pair[1]);
          }
        };
        /**
         * It takes a regular expression and a string, and returns an array of all the matches
         *
         * @param {string} regExp - The regular expression to match against.
         * @param {string} str - The string to search.
         *
         * @returns {Array<boolean>}
         */ const matchAll = (regExp, str) => {
          let matches;
          const arr = [];
          while ((matches = regExp.exec(str)) !== null) arr.push(matches);
          return arr;
        };
        /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm =
          kindOfTest("HTMLFormElement");
        const toCamelCase = (str) => {
          return str
            .toLowerCase()
            .replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
              return p1.toUpperCase() + p2;
            });
        };
        /* Creating a function that will check if an object has a property. */ const hasOwnProperty =
          (
            ({ hasOwnProperty }) =>
            (obj, prop) =>
              hasOwnProperty.call(obj, prop)
          )(Object.prototype);
        /**
         * Determine if a value is a RegExp object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a RegExp object, otherwise false
         */ const isRegExp = kindOfTest("RegExp");
        const reduceDescriptors = (obj, reducer) => {
          const descriptors = Object.getOwnPropertyDescriptors(obj);
          const reducedDescriptors = {};
          forEach(descriptors, (descriptor, name) => {
            let ret;
            if ((ret = reducer(descriptor, name, obj)) !== false)
              reducedDescriptors[name] = ret || descriptor;
          });
          Object.defineProperties(obj, reducedDescriptors);
        };
        /**
         * Makes all methods read-only
         * @param {Object} obj
         */ const freezeMethods = (obj) => {
          reduceDescriptors(obj, (descriptor, name) => {
            // skip restricted props in strict mode
            if (
              isFunction(obj) &&
              ["arguments", "caller", "callee"].indexOf(name) !== -1
            )
              return false;
            const value = obj[name];
            if (!isFunction(value)) return;
            descriptor.enumerable = false;
            if ("writable" in descriptor) {
              descriptor.writable = false;
              return;
            }
            if (!descriptor.set)
              descriptor.set = () => {
                throw Error("Can not rewrite read-only method '" + name + "'");
              };
          });
        };
        const toObjectSet = (arrayOrString, delimiter) => {
          const obj = {};
          const define = (arr) => {
            arr.forEach((value) => {
              obj[value] = true;
            });
          };
          isArray(arrayOrString)
            ? define(arrayOrString)
            : define(String(arrayOrString).split(delimiter));
          return obj;
        };
        const noop = () => {};
        const toFiniteNumber = (value, defaultValue) => {
          value = +value;
          return Number.isFinite(value) ? value : defaultValue;
        };
        const ALPHA = "abcdefghijklmnopqrstuvwxyz";
        const DIGIT = "0123456789";
        const ALPHABET = {
          DIGIT,
          ALPHA,
          ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT,
        };
        const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
          let str = "";
          const { length } = alphabet;
          while (size--) str += alphabet[(Math.random() * length) | 0];
          return str;
        };
        /**
         * If the thing is a FormData object, return true, otherwise return false.
         *
         * @param {unknown} thing - The thing to check.
         *
         * @returns {boolean}
         */ function isSpecCompliantForm(thing) {
          return !!(
            thing &&
            isFunction(thing.append) &&
            thing[Symbol.toStringTag] === "FormData" &&
            thing[Symbol.iterator]
          );
        }
        const toJSONObject = (obj) => {
          const stack = new Array(10);
          const visit = (source, i) => {
            if (isObject(source)) {
              if (stack.indexOf(source) >= 0) return;
              if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key) => {
                  const reducedValue = visit(value, i + 1);
                  !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
              }
            }
            return source;
          };
          return visit(obj, 0);
        };
        const isAsyncFn = kindOfTest("AsyncFunction");
        const isThenable = (thing) =>
          thing &&
          (isObject(thing) || isFunction(thing)) &&
          isFunction(thing.then) &&
          isFunction(thing.catch);
        exports.default = {
          isArray,
          isArrayBuffer,
          isBuffer,
          isFormData,
          isArrayBufferView,
          isString,
          isNumber,
          isBoolean,
          isObject,
          isPlainObject,
          isUndefined,
          isDate,
          isFile,
          isBlob,
          isRegExp,
          isFunction,
          isStream,
          isURLSearchParams,
          isTypedArray,
          isFileList,
          forEach,
          merge,
          extend,
          trim,
          stripBOM,
          inherits,
          toFlatObject,
          kindOf,
          kindOfTest,
          endsWith,
          toArray,
          forEachEntry,
          matchAll,
          isHTMLForm,
          hasOwnProperty,
          hasOwnProp: hasOwnProperty,
          reduceDescriptors,
          freezeMethods,
          toObjectSet,
          toCamelCase,
          noop,
          toFiniteNumber,
          findKey,
          global: _global,
          isContextDefined,
          ALPHABET,
          generateString,
          isSpecCompliantForm,
          toJSONObject,
          isAsyncFn,
          isThenable,
        };
      },
      {
        "./helpers/bind.js": "iEIW4",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    iEIW4: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => bind);
        ("use strict");
        function bind(fn, thisArg) {
          return function wrap() {
            return fn.apply(thisArg, arguments);
          };
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    eOtu7: [
      function (require, module, exports) {
        exports.interopDefault = function (a) {
          return a && a.__esModule
            ? a
            : {
                default: a,
              };
        };
        exports.defineInteropFlag = function (a) {
          Object.defineProperty(a, "__esModule", {
            value: true,
          });
        };
        exports.exportAll = function (source, dest) {
          Object.keys(source).forEach(function (key) {
            if (
              key === "default" ||
              key === "__esModule" ||
              Object.prototype.hasOwnProperty.call(dest, key)
            )
              return;
            Object.defineProperty(dest, key, {
              enumerable: true,
              get: function () {
                return source[key];
              },
            });
          });
          return dest;
        };
        exports.export = function (dest, destName, get) {
          Object.defineProperty(dest, destName, {
            enumerable: true,
            get: get,
          });
        };
      },
      {},
    ],
    "66aZv": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _buildURLJs = require("../helpers/buildURL.js");
        var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
        var _interceptorManagerJs = require("./InterceptorManager.js");
        var _interceptorManagerJsDefault = parcelHelpers.interopDefault(
          _interceptorManagerJs,
        );
        var _dispatchRequestJs = require("./dispatchRequest.js");
        var _dispatchRequestJsDefault =
          parcelHelpers.interopDefault(_dispatchRequestJs);
        var _mergeConfigJs = require("./mergeConfig.js");
        var _mergeConfigJsDefault =
          parcelHelpers.interopDefault(_mergeConfigJs);
        var _buildFullPathJs = require("./buildFullPath.js");
        var _buildFullPathJsDefault =
          parcelHelpers.interopDefault(_buildFullPathJs);
        var _validatorJs = require("../helpers/validator.js");
        var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
        var _axiosHeadersJs = require("./AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        ("use strict");
        const validators = (0, _validatorJsDefault.default).validators;
        /**
         * Create a new instance of Axios
         *
         * @param {Object} instanceConfig The default config for the instance
         *
         * @return {Axios} A new instance of Axios
         */ class Axios {
          constructor(instanceConfig) {
            this.defaults = instanceConfig;
            this.interceptors = {
              request: new (0, _interceptorManagerJsDefault.default)(),
              response: new (0, _interceptorManagerJsDefault.default)(),
            };
          }
          /**
           * Dispatch a request
           *
           * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
           * @param {?Object} config
           *
           * @returns {Promise} The Promise to be fulfilled
           */ request(configOrUrl, config) {
            /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
            if (typeof configOrUrl === "string") {
              config = config || {};
              config.url = configOrUrl;
            } else config = configOrUrl || {};
            config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
            const { transitional, paramsSerializer, headers } = config;
            if (transitional !== undefined)
              (0, _validatorJsDefault.default).assertOptions(
                transitional,
                {
                  silentJSONParsing: validators.transitional(
                    validators.boolean,
                  ),
                  forcedJSONParsing: validators.transitional(
                    validators.boolean,
                  ),
                  clarifyTimeoutError: validators.transitional(
                    validators.boolean,
                  ),
                },
                false,
              );
            if (paramsSerializer != null) {
              if ((0, _utilsJsDefault.default).isFunction(paramsSerializer))
                config.paramsSerializer = {
                  serialize: paramsSerializer,
                };
              else
                (0, _validatorJsDefault.default).assertOptions(
                  paramsSerializer,
                  {
                    encode: validators.function,
                    serialize: validators.function,
                  },
                  true,
                );
            }
            // Set config.method
            config.method = (
              config.method ||
              this.defaults.method ||
              "get"
            ).toLowerCase();
            // Flatten headers
            let contextHeaders =
              headers &&
              (0, _utilsJsDefault.default).merge(
                headers.common,
                headers[config.method],
              );
            headers &&
              (0, _utilsJsDefault.default).forEach(
                ["delete", "get", "head", "post", "put", "patch", "common"],
                (method) => {
                  delete headers[method];
                },
              );
            config.headers = (0, _axiosHeadersJsDefault.default).concat(
              contextHeaders,
              headers,
            );
            // filter out skipped interceptors
            const requestInterceptorChain = [];
            let synchronousRequestInterceptors = true;
            this.interceptors.request.forEach(
              function unshiftRequestInterceptors(interceptor) {
                if (
                  typeof interceptor.runWhen === "function" &&
                  interceptor.runWhen(config) === false
                )
                  return;
                synchronousRequestInterceptors =
                  synchronousRequestInterceptors && interceptor.synchronous;
                requestInterceptorChain.unshift(
                  interceptor.fulfilled,
                  interceptor.rejected,
                );
              },
            );
            const responseInterceptorChain = [];
            this.interceptors.response.forEach(
              function pushResponseInterceptors(interceptor) {
                responseInterceptorChain.push(
                  interceptor.fulfilled,
                  interceptor.rejected,
                );
              },
            );
            let promise;
            let i = 0;
            let len;
            if (!synchronousRequestInterceptors) {
              const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined,
              ];
              chain.unshift.apply(chain, requestInterceptorChain);
              chain.push.apply(chain, responseInterceptorChain);
              len = chain.length;
              promise = Promise.resolve(config);
              while (i < len) promise = promise.then(chain[i++], chain[i++]);
              return promise;
            }
            len = requestInterceptorChain.length;
            let newConfig = config;
            i = 0;
            while (i < len) {
              const onFulfilled = requestInterceptorChain[i++];
              const onRejected = requestInterceptorChain[i++];
              try {
                newConfig = onFulfilled(newConfig);
              } catch (error) {
                onRejected.call(this, error);
                break;
              }
            }
            try {
              promise = (0, _dispatchRequestJsDefault.default).call(
                this,
                newConfig,
              );
            } catch (error) {
              return Promise.reject(error);
            }
            i = 0;
            len = responseInterceptorChain.length;
            while (i < len)
              promise = promise.then(
                responseInterceptorChain[i++],
                responseInterceptorChain[i++],
              );
            return promise;
          }
          getUri(config) {
            config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
            const fullPath = (0, _buildFullPathJsDefault.default)(
              config.baseURL,
              config.url,
            );
            return (0, _buildURLJsDefault.default)(
              fullPath,
              config.params,
              config.paramsSerializer,
            );
          }
        }
        // Provide aliases for supported request methods
        (0, _utilsJsDefault.default).forEach(
          ["delete", "get", "head", "options"],
          function forEachMethodNoData(method) {
            /*eslint func-names:0*/ Axios.prototype[method] = function (
              url,
              config,
            ) {
              return this.request(
                (0, _mergeConfigJsDefault.default)(config || {}, {
                  method,
                  url,
                  data: (config || {}).data,
                }),
              );
            };
          },
        );
        (0, _utilsJsDefault.default).forEach(
          ["post", "put", "patch"],
          function forEachMethodWithData(method) {
            /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
              return function httpMethod(url, data, config) {
                return this.request(
                  (0, _mergeConfigJsDefault.default)(config || {}, {
                    method,
                    headers: isForm
                      ? {
                          "Content-Type": "multipart/form-data",
                        }
                      : {},
                    url,
                    data,
                  }),
                );
              };
            }
            Axios.prototype[method] = generateHTTPMethod();
            Axios.prototype[method + "Form"] = generateHTTPMethod(true);
          },
        );
        exports.default = Axios;
      },
      {
        "./../utils.js": "gUZbi",
        "../helpers/buildURL.js": "ltNC5",
        "./InterceptorManager.js": "1AguR",
        "./dispatchRequest.js": "6kQbz",
        "./mergeConfig.js": "lm9Dz",
        "./buildFullPath.js": "gK1yS",
        "../helpers/validator.js": "1VZh4",
        "./AxiosHeaders.js": "fUSSQ",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    ltNC5: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => buildURL);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
        var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(
          _axiosURLSearchParamsJs,
        );
        ("use strict");
        /**
         * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
         * URI encoded counterparts
         *
         * @param {string} val The value to be encoded.
         *
         * @returns {string} The encoded value.
         */ function encode(val) {
          return encodeURIComponent(val)
            .replace(/%3A/gi, ":")
            .replace(/%24/g, "$")
            .replace(/%2C/gi, ",")
            .replace(/%20/g, "+")
            .replace(/%5B/gi, "[")
            .replace(/%5D/gi, "]");
        }
        function buildURL(url, params, options) {
          /*eslint no-param-reassign:0*/ if (!params) return url;
          const _encode = (options && options.encode) || encode;
          const serializeFn = options && options.serialize;
          let serializedParams;
          if (serializeFn) serializedParams = serializeFn(params, options);
          else
            serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(
              params,
            )
              ? params.toString()
              : new (0, _axiosURLSearchParamsJsDefault.default)(
                  params,
                  options,
                ).toString(_encode);
          if (serializedParams) {
            const hashmarkIndex = url.indexOf("#");
            if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
          }
          return url;
        }
      },
      {
        "../utils.js": "gUZbi",
        "../helpers/AxiosURLSearchParams.js": "8Prsk",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "8Prsk": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _toFormDataJs = require("./toFormData.js");
        var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
        ("use strict");
        /**
         * It encodes a string by replacing all characters that are not in the unreserved set with
         * their percent-encoded equivalents
         *
         * @param {string} str - The string to encode.
         *
         * @returns {string} The encoded string.
         */ function encode(str) {
          const charMap = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\x00",
          };
          return encodeURIComponent(str).replace(
            /[!'()~]|%20|%00/g,
            function replacer(match) {
              return charMap[match];
            },
          );
        }
        /**
         * It takes a params object and converts it to a FormData object
         *
         * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
         * @param {Object<string, any>} options - The options object passed to the Axios constructor.
         *
         * @returns {void}
         */ function AxiosURLSearchParams(params, options) {
          this._pairs = [];
          params && (0, _toFormDataJsDefault.default)(params, this, options);
        }
        const prototype = AxiosURLSearchParams.prototype;
        prototype.append = function append(name, value) {
          this._pairs.push([name, value]);
        };
        prototype.toString = function toString(encoder) {
          const _encode = encoder
            ? function (value) {
                return encoder.call(this, value, encode);
              }
            : encode;
          return this._pairs
            .map(function each(pair) {
              return _encode(pair[0]) + "=" + _encode(pair[1]);
            }, "")
            .join("&");
        };
        exports.default = AxiosURLSearchParams;
      },
      {
        "./toFormData.js": "8Si2N",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "8Si2N": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        // temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
        var _formDataJs = require("../platform/node/classes/FormData.js");
        var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
        var Buffer = require("adfd9b103875c2dd").Buffer;
        ("use strict");
        /**
         * Determines if the given thing is a array or js object.
         *
         * @param {string} thing - The object or array to be visited.
         *
         * @returns {boolean}
         */ function isVisitable(thing) {
          return (
            (0, _utilsJsDefault.default).isPlainObject(thing) ||
            (0, _utilsJsDefault.default).isArray(thing)
          );
        }
        /**
         * It removes the brackets from the end of a string
         *
         * @param {string} key - The key of the parameter.
         *
         * @returns {string} the key without the brackets.
         */ function removeBrackets(key) {
          return (0, _utilsJsDefault.default).endsWith(key, "[]")
            ? key.slice(0, -2)
            : key;
        }
        /**
         * It takes a path, a key, and a boolean, and returns a string
         *
         * @param {string} path - The path to the current key.
         * @param {string} key - The key of the current object being iterated over.
         * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
         *
         * @returns {string} The path to the current key.
         */ function renderKey(path, key, dots) {
          if (!path) return key;
          return path
            .concat(key)
            .map(function each(token, i) {
              // eslint-disable-next-line no-param-reassign
              token = removeBrackets(token);
              return !dots && i ? "[" + token + "]" : token;
            })
            .join(dots ? "." : "");
        }
        /**
         * If the array is an array and none of its elements are visitable, then it's a flat array.
         *
         * @param {Array<any>} arr - The array to check
         *
         * @returns {boolean}
         */ function isFlatArray(arr) {
          return (
            (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable)
          );
        }
        const predicates = (0, _utilsJsDefault.default).toFlatObject(
          (0, _utilsJsDefault.default),
          {},
          null,
          function filter(prop) {
            return /^is[A-Z]/.test(prop);
          },
        );
        /**
         * Convert a data object to FormData
         *
         * @param {Object} obj
         * @param {?Object} [formData]
         * @param {?Object} [options]
         * @param {Function} [options.visitor]
         * @param {Boolean} [options.metaTokens = true]
         * @param {Boolean} [options.dots = false]
         * @param {?Boolean} [options.indexes = false]
         *
         * @returns {Object}
         **/ /**
         * It converts an object into a FormData object
         *
         * @param {Object<any, any>} obj - The object to convert to form data.
         * @param {string} formData - The FormData object to append to.
         * @param {Object<string, any>} options
         *
         * @returns
         */ function toFormData(obj, formData, options) {
          if (!(0, _utilsJsDefault.default).isObject(obj))
            throw new TypeError("target must be an object");
          // eslint-disable-next-line no-param-reassign
          formData =
            formData || new ((0, _formDataJsDefault.default) || FormData)();
          // eslint-disable-next-line no-param-reassign
          options = (0, _utilsJsDefault.default).toFlatObject(
            options,
            {
              metaTokens: true,
              dots: false,
              indexes: false,
            },
            false,
            function defined(option, source) {
              // eslint-disable-next-line no-eq-null,eqeqeq
              return !(0, _utilsJsDefault.default).isUndefined(source[option]);
            },
          );
          const metaTokens = options.metaTokens;
          // eslint-disable-next-line no-use-before-define
          const visitor = options.visitor || defaultVisitor;
          const dots = options.dots;
          const indexes = options.indexes;
          const _Blob = options.Blob || (typeof Blob !== "undefined" && Blob);
          const useBlob =
            _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
          if (!(0, _utilsJsDefault.default).isFunction(visitor))
            throw new TypeError("visitor must be a function");
          function convertValue(value) {
            if (value === null) return "";
            if ((0, _utilsJsDefault.default).isDate(value))
              return value.toISOString();
            if (!useBlob && (0, _utilsJsDefault.default).isBlob(value))
              throw new (0, _axiosErrorJsDefault.default)(
                "Blob is not supported. Use a Buffer instead.",
              );
            if (
              (0, _utilsJsDefault.default).isArrayBuffer(value) ||
              (0, _utilsJsDefault.default).isTypedArray(value)
            )
              return useBlob && typeof Blob === "function"
                ? new Blob([value])
                : Buffer.from(value);
            return value;
          }
          /**
           * Default visitor.
           *
           * @param {*} value
           * @param {String|Number} key
           * @param {Array<String|Number>} path
           * @this {FormData}
           *
           * @returns {boolean} return true to visit the each prop of the value recursively
           */ function defaultVisitor(value, key, path) {
            let arr = value;
            if (value && !path && typeof value === "object") {
              if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
              } else if (
                ((0, _utilsJsDefault.default).isArray(value) &&
                  isFlatArray(value)) ||
                (((0, _utilsJsDefault.default).isFileList(value) ||
                  (0, _utilsJsDefault.default).endsWith(key, "[]")) &&
                  (arr = (0, _utilsJsDefault.default).toArray(value)))
              ) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                  !(
                    (0, _utilsJsDefault.default).isUndefined(el) || el === null
                  ) &&
                    formData.append(
                      // eslint-disable-next-line no-nested-ternary
                      indexes === true
                        ? renderKey([key], index, dots)
                        : indexes === null
                        ? key
                        : key + "[]",
                      convertValue(el),
                    );
                });
                return false;
              }
            }
            if (isVisitable(value)) return true;
            formData.append(renderKey(path, key, dots), convertValue(value));
            return false;
          }
          const stack = [];
          const exposedHelpers = Object.assign(predicates, {
            defaultVisitor,
            convertValue,
            isVisitable,
          });
          function build(value, path) {
            if ((0, _utilsJsDefault.default).isUndefined(value)) return;
            if (stack.indexOf(value) !== -1)
              throw Error("Circular reference detected in " + path.join("."));
            stack.push(value);
            (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
              const result =
                !(
                  (0, _utilsJsDefault.default).isUndefined(el) || el === null
                ) &&
                visitor.call(
                  formData,
                  el,
                  (0, _utilsJsDefault.default).isString(key) ? key.trim() : key,
                  path,
                  exposedHelpers,
                );
              if (result === true) build(el, path ? path.concat(key) : [key]);
            });
            stack.pop();
          }
          if (!(0, _utilsJsDefault.default).isObject(obj))
            throw new TypeError("data must be an object");
          build(obj);
          return formData;
        }
        exports.default = toFormData;
      },
      {
        adfd9b103875c2dd: "41332",
        "../utils.js": "gUZbi",
        "../core/AxiosError.js": "bJPKW",
        "../platform/node/classes/FormData.js": "1m7Fr",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    41332: [
      function (require, module, exports) {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */ /* eslint-disable no-proto */ "use strict";
        const base64 = require("9c62938f1dccc73c");
        const ieee754 = require("aceacb6a4531a9d2");
        const customInspectSymbol =
          typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
            ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
            : null;
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        const K_MAX_LENGTH = 0x7fffffff;
        exports.kMaxLength = K_MAX_LENGTH;
        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (
          !Buffer.TYPED_ARRAY_SUPPORT &&
          typeof console !== "undefined" &&
          typeof console.error === "function"
        )
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
          );
        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            const arr = new Uint8Array(1);
            const proto = {
              foo: function () {
                return 42;
              },
            };
            Object.setPrototypeOf(proto, Uint8Array.prototype);
            Object.setPrototypeOf(arr, proto);
            return arr.foo() === 42;
          } catch (e) {
            return false;
          }
        }
        Object.defineProperty(Buffer.prototype, "parent", {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined;
            return this.buffer;
          },
        });
        Object.defineProperty(Buffer.prototype, "offset", {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined;
            return this.byteOffset;
          },
        });
        function createBuffer(length) {
          if (length > K_MAX_LENGTH)
            throw new RangeError(
              'The value "' + length + '" is invalid for option "size"',
            );
          // Return an augmented `Uint8Array` instance
          const buf = new Uint8Array(length);
          Object.setPrototypeOf(buf, Buffer.prototype);
          return buf;
        }
        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */ function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string")
              throw new TypeError(
                'The "string" argument must be of type string. Received type number',
              );
            return allocUnsafe(arg);
          }
          return from(arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192; // not used by this implementation
        function from(value, encodingOrOffset, length) {
          if (typeof value === "string")
            return fromString(value, encodingOrOffset);
          if (ArrayBuffer.isView(value)) return fromArrayView(value);
          if (value == null)
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof value,
            );
          if (
            isInstance(value, ArrayBuffer) ||
            (value && isInstance(value.buffer, ArrayBuffer))
          )
            return fromArrayBuffer(value, encodingOrOffset, length);
          if (
            typeof SharedArrayBuffer !== "undefined" &&
            (isInstance(value, SharedArrayBuffer) ||
              (value && isInstance(value.buffer, SharedArrayBuffer)))
          )
            return fromArrayBuffer(value, encodingOrOffset, length);
          if (typeof value === "number")
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number',
            );
          const valueOf = value.valueOf && value.valueOf();
          if (valueOf != null && valueOf !== value)
            return Buffer.from(valueOf, encodingOrOffset, length);
          const b = fromObject(value);
          if (b) return b;
          if (
            typeof Symbol !== "undefined" &&
            Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === "function"
          )
            return Buffer.from(
              value[Symbol.toPrimitive]("string"),
              encodingOrOffset,
              length,
            );
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof value,
          );
        }
        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/ Buffer.from = function (value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length);
        };
        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Buffer, Uint8Array);
        function assertSize(size) {
          if (typeof size !== "number")
            throw new TypeError('"size" argument must be of type number');
          else if (size < 0)
            throw new RangeError(
              'The value "' + size + '" is invalid for option "size"',
            );
        }
        function alloc(size, fill, encoding) {
          assertSize(size);
          if (size <= 0) return createBuffer(size);
          if (fill !== undefined)
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpreted as a start offset.
            return typeof encoding === "string"
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill);
          return createBuffer(size);
        }
        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/ Buffer.alloc = function (size, fill, encoding) {
          return alloc(size, fill, encoding);
        };
        function allocUnsafe(size) {
          assertSize(size);
          return createBuffer(size < 0 ? 0 : checked(size) | 0);
        }
        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */ Buffer.allocUnsafe = function (size) {
          return allocUnsafe(size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */ Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(size);
        };
        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "")
            encoding = "utf8";
          if (!Buffer.isEncoding(encoding))
            throw new TypeError("Unknown encoding: " + encoding);
          const length = byteLength(string, encoding) | 0;
          let buf = createBuffer(length);
          const actual = buf.write(string, encoding);
          if (actual !== length)
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual);
          return buf;
        }
        function fromArrayLike(array) {
          const length = array.length < 0 ? 0 : checked(array.length) | 0;
          const buf = createBuffer(length);
          for (let i = 0; i < length; i += 1) buf[i] = array[i] & 255;
          return buf;
        }
        function fromArrayView(arrayView) {
          if (isInstance(arrayView, Uint8Array)) {
            const copy = new Uint8Array(arrayView);
            return fromArrayBuffer(
              copy.buffer,
              copy.byteOffset,
              copy.byteLength,
            );
          }
          return fromArrayLike(arrayView);
        }
        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (array.byteLength < byteOffset + (length || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          let buf;
          if (byteOffset === undefined && length === undefined)
            buf = new Uint8Array(array);
          else if (length === undefined)
            buf = new Uint8Array(array, byteOffset);
          else buf = new Uint8Array(array, byteOffset, length);
          // Return an augmented `Uint8Array` instance
          Object.setPrototypeOf(buf, Buffer.prototype);
          return buf;
        }
        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            const len = checked(obj.length) | 0;
            const buf = createBuffer(len);
            if (buf.length === 0) return buf;
            obj.copy(buf, 0, 0, len);
            return buf;
          }
          if (obj.length !== undefined) {
            if (typeof obj.length !== "number" || numberIsNaN(obj.length))
              return createBuffer(0);
            return fromArrayLike(obj);
          }
          if (obj.type === "Buffer" && Array.isArray(obj.data))
            return fromArrayLike(obj.data);
        }
        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH)
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum size: 0x" +
                K_MAX_LENGTH.toString(16) +
                " bytes",
            );
          return length | 0;
        }
        function SlowBuffer(length) {
          if (+length != length) length = 0;
          return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function isBuffer(b) {
          return (
            b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
          );
        };
        Buffer.compare = function compare(a, b) {
          if (isInstance(a, Uint8Array))
            a = Buffer.from(a, a.offset, a.byteLength);
          if (isInstance(b, Uint8Array))
            b = Buffer.from(b, b.offset, b.byteLength);
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
            );
          if (a === b) return 0;
          let x = a.length;
          let y = b.length;
          for (let i = 0, len = Math.min(x, y); i < len; ++i)
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (list.length === 0) return Buffer.alloc(0);
          let i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; ++i) length += list[i].length;
          }
          const buffer = Buffer.allocUnsafe(length);
          let pos = 0;
          for (i = 0; i < list.length; ++i) {
            let buf = list[i];
            if (isInstance(buf, Uint8Array)) {
              if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
              } else Uint8Array.prototype.set.call(buffer, buf, pos);
            } else if (!Buffer.isBuffer(buf))
              throw new TypeError(
                '"list" argument must be an Array of Buffers',
              );
            else buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) return string.length;
          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
            return string.byteLength;
          if (typeof string !== "string")
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof string,
            );
          const len = string.length;
          const mustMatch = arguments.length > 2 && arguments[2] === true;
          if (!mustMatch && len === 0) return 0;
          // Use a for loop to avoid recursion
          let loweredCase = false;
          for (;;)
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase)
                  return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          let loweredCase = false;
          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.
          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) start = 0;
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) return "";
          if (end === undefined || end > this.length) end = this.length;
          if (end <= 0) return "";
          // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0;
          start >>>= 0;
          if (end <= start) return "";
          if (!encoding) encoding = "utf8";
          while (true)
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
        }
        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
          const i = b[n];
          b[n] = b[m];
          b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
          const len = this.length;
          if (len % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let i = 0; i < len; i += 2) swap(this, i, i + 1);
          return this;
        };
        Buffer.prototype.swap32 = function swap32() {
          const len = this.length;
          if (len % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer.prototype.swap64 = function swap64() {
          const len = this.length;
          if (len % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer.prototype.toString = function toString() {
          const length = this.length;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer.prototype.toLocaleString = Buffer.prototype.toString;
        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
          let str = "";
          const max = exports.INSPECT_MAX_BYTES;
          str = this.toString("hex", 0, max)
            .replace(/(.{2})/g, "$1 ")
            .trim();
          if (this.length > max) str += " ... ";
          return "<Buffer " + str + ">";
        };
        if (customInspectSymbol)
          Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
        Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd,
        ) {
          if (isInstance(target, Uint8Array))
            target = Buffer.from(target, target.offset, target.byteLength);
          if (!Buffer.isBuffer(target))
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof target,
            );
          if (start === undefined) start = 0;
          if (end === undefined) end = target ? target.length : 0;
          if (thisStart === undefined) thisStart = 0;
          if (thisEnd === undefined) thisEnd = this.length;
          if (
            start < 0 ||
            end > target.length ||
            thisStart < 0 ||
            thisEnd > this.length
          )
            throw new RangeError("out of range index");
          if (thisStart >= thisEnd && start >= end) return 0;
          if (thisStart >= thisEnd) return -1;
          if (start >= end) return 1;
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          let x = thisEnd - thisStart;
          let y = end - start;
          const len = Math.min(x, y);
          const thisCopy = this.slice(thisStart, thisEnd);
          const targetCopy = target.slice(start, end);
          for (let i = 0; i < len; ++i)
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };
        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1;
          // Normalize byteOffset
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
          else if (byteOffset < -2147483648) byteOffset = -2147483648;
          byteOffset = +byteOffset; // Coerce to Number.
          if (numberIsNaN(byteOffset))
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;
            else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }
          // Normalize val
          if (typeof val === "string") val = Buffer.from(val, encoding);
          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) return -1;
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 0xff; // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir)
                return Uint8Array.prototype.indexOf.call(
                  buffer,
                  val,
                  byteOffset,
                );
              else
                return Uint8Array.prototype.lastIndexOf.call(
                  buffer,
                  val,
                  byteOffset,
                );
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          let indexSize = 1;
          let arrLength = arr.length;
          let valLength = val.length;
          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();
            if (
              encoding === "ucs2" ||
              encoding === "ucs-2" ||
              encoding === "utf16le" ||
              encoding === "utf-16le"
            ) {
              if (arr.length < 2 || val.length < 2) return -1;
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read(buf, i) {
            if (indexSize === 1) return buf[i];
            else return buf.readUInt16BE(i * indexSize);
          }
          let i;
          if (dir) {
            let foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++)
              if (
                read(arr, i) ===
                read(val, foundIndex === -1 ? 0 : i - foundIndex)
              ) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              let found = true;
              for (let j = 0; j < valLength; j++)
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              if (found) return i;
            }
          }
          return -1;
        }
        Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding,
        ) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding,
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          const remaining = buf.length - offset;
          if (!length) length = remaining;
          else {
            length = Number(length);
            if (length > remaining) length = remaining;
          }
          const strLen = string.length;
          if (length > strLen / 2) length = strLen / 2;
          let i;
          for (i = 0; i < length; ++i) {
            const parsed = parseInt(string.substr(i * 2, 2), 16);
            if (numberIsNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(
            utf8ToBytes(string, buf.length - offset),
            buf,
            offset,
            length,
          );
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(
            utf16leToBytes(string, buf.length - offset),
            buf,
            offset,
            length,
          );
        }
        Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding,
        ) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0;
            if (isFinite(length)) {
              length = length >>> 0;
              if (encoding === undefined) encoding = "utf8";
            } else {
              encoding = length;
              length = undefined;
            }
          } else
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported",
            );
          const remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;
          if (
            (string.length > 0 && (length < 0 || offset < 0)) ||
            offset > this.length
          )
            throw new RangeError("Attempt to write outside buffer bounds");
          if (!encoding) encoding = "utf8";
          let loweredCase = false;
          for (;;)
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
              case "latin1":
              case "binary":
                return asciiWrite(this, string, offset, length);
              case "base64":
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length)
            return base64.fromByteArray(buf);
          else return base64.fromByteArray(buf.slice(start, end));
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          const res = [];
          let i = start;
          while (i < end) {
            const firstByte = buf[i];
            let codePoint = null;
            let bytesPerSequence =
              firstByte > 0xef
                ? 4
                : firstByte > 0xdf
                ? 3
                : firstByte > 0xbf
                ? 2
                : 1;
            if (i + bytesPerSequence <= end) {
              let secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) codePoint = firstByte;
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                    if (tempCodePoint > 0x7f) codePoint = tempCodePoint;
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0xc) |
                      ((secondByte & 0x3f) << 0x6) |
                      (thirdByte & 0x3f);
                    if (
                      tempCodePoint > 0x7ff &&
                      (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                    )
                      codePoint = tempCodePoint;
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80 &&
                    (fourthByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f);
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000)
                      codePoint = tempCodePoint;
                  }
              }
            }
            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd;
              bytesPerSequence = 1;
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
              codePoint = 0xdc00 | (codePoint & 0x3ff);
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }
        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        const MAX_ARGUMENTS_LENGTH = 0x1000;
        function decodeCodePointsArray(codePoints) {
          const len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH)
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          // Decode in chunks to avoid "call stack size exceeded".
          let res = "";
          let i = 0;
          while (i < len)
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)),
            );
          return res;
        }
        function asciiSlice(buf, start, end) {
          let ret = "";
          end = Math.min(buf.length, end);
          for (let i = start; i < end; ++i)
            ret += String.fromCharCode(buf[i] & 0x7f);
          return ret;
        }
        function latin1Slice(buf, start, end) {
          let ret = "";
          end = Math.min(buf.length, end);
          for (let i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
          return ret;
        }
        function hexSlice(buf, start, end) {
          const len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          let out = "";
          for (let i = start; i < end; ++i) out += hexSliceLookupTable[buf[i]];
          return out;
        }
        function utf16leSlice(buf, start, end) {
          const bytes = buf.slice(start, end);
          let res = "";
          // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
          for (let i = 0; i < bytes.length - 1; i += 2)
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
          const len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) start = len;
          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) end = len;
          if (end < start) end = start;
          const newBuf = this.subarray(start, end);
          // Return an augmented `Uint8Array` instance
          Object.setPrototypeOf(newBuf, Buffer.prototype);
          return newBuf;
        };
        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */ function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint");
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE =
          function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset];
            let mul = 1;
            let i = 0;
            while (++i < byteLength && (mul *= 0x100))
              val += this[offset + i] * mul;
            return val;
          };
        Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE =
          function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset + --byteLength];
            let mul = 1;
            while (byteLength > 0 && (mul *= 0x100))
              val += this[offset + --byteLength] * mul;
            return val;
          };
        Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 =
          function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };
        Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE =
          function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | (this[offset + 1] << 8);
          };
        Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE =
          function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return (this[offset] << 8) | this[offset + 1];
          };
        Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE =
          function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              (this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
              this[offset + 3] * 0x1000000
            );
          };
        Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE =
          function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              this[offset] * 0x1000000 +
              ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            );
          };
        Buffer.prototype.readBigUInt64LE = defineBigIntMethod(
          function readBigUInt64LE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined)
              boundsError(offset, this.length - 8);
            const lo =
              first +
              this[++offset] * 256 +
              this[++offset] * 2 ** 16 +
              this[++offset] * 2 ** 24;
            const hi =
              this[++offset] +
              this[++offset] * 256 +
              this[++offset] * 2 ** 16 +
              last * 2 ** 24;
            return BigInt(lo) + (BigInt(hi) << BigInt(32));
          },
        );
        Buffer.prototype.readBigUInt64BE = defineBigIntMethod(
          function readBigUInt64BE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined)
              boundsError(offset, this.length - 8);
            const hi =
              first * 2 ** 24 +
              this[++offset] * 2 ** 16 +
              this[++offset] * 256 +
              this[++offset];
            const lo =
              this[++offset] * 2 ** 24 +
              this[++offset] * 2 ** 16 +
              this[++offset] * 256 +
              last;
            return (BigInt(hi) << BigInt(32)) + BigInt(lo);
          },
        );
        Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert,
        ) {
          offset = offset >>> 0;
          byteLength = byteLength >>> 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          let val = this[offset];
          let mul = 1;
          let i = 0;
          while (++i < byteLength && (mul *= 0x100))
            val += this[offset + i] * mul;
          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert,
        ) {
          offset = offset >>> 0;
          byteLength = byteLength >>> 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          let i = byteLength;
          let mul = 1;
          let val = this[offset + --i];
          while (i > 0 && (mul *= 0x100)) val += this[offset + --i] * mul;
          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          const val = this[offset] | (this[offset + 1] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          const val = this[offset + 1] | (this[offset] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (
            this[offset] |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
          );
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (
            (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3]
          );
        };
        Buffer.prototype.readBigInt64LE = defineBigIntMethod(
          function readBigInt64LE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined)
              boundsError(offset, this.length - 8);
            const val =
              this[offset + 4] +
              this[offset + 5] * 256 +
              this[offset + 6] * 2 ** 16 +
              (last << 24); // Overflow
            return (
              (BigInt(val) << BigInt(32)) +
              BigInt(
                first +
                  this[++offset] * 256 +
                  this[++offset] * 2 ** 16 +
                  this[++offset] * 2 ** 24,
              )
            );
          },
        );
        Buffer.prototype.readBigInt64BE = defineBigIntMethod(
          function readBigInt64BE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined)
              boundsError(offset, this.length - 8);
            const val =
              (first << 24) + // Overflow
              this[++offset] * 2 ** 16 +
              this[++offset] * 256 +
              this[++offset];
            return (
              (BigInt(val) << BigInt(32)) +
              BigInt(
                this[++offset] * 2 ** 24 +
                  this[++offset] * 2 ** 16 +
                  this[++offset] * 256 +
                  last,
              )
            );
          },
        );
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert,
        ) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert,
        ) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE =
          function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              const maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let mul = 1;
            let i = 0;
            this[offset] = value & 0xff;
            while (++i < byteLength && (mul *= 0x100))
              this[offset + i] = (value / mul) & 0xff;
            return offset + byteLength;
          };
        Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE =
          function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              const maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let i = byteLength - 1;
            let mul = 1;
            this[offset + i] = value & 0xff;
            while (--i >= 0 && (mul *= 0x100))
              this[offset + i] = (value / mul) & 0xff;
            return offset + byteLength;
          };
        Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 =
          function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };
        Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE =
          function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
        Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE =
          function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };
        Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE =
          function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };
        Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE =
          function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };
        function wrtBigUInt64LE(buf, value, offset, min, max) {
          checkIntBI(value, min, max, buf, offset, 7);
          let lo = Number(value & BigInt(0xffffffff));
          buf[offset++] = lo;
          lo = lo >> 8;
          buf[offset++] = lo;
          lo = lo >> 8;
          buf[offset++] = lo;
          lo = lo >> 8;
          buf[offset++] = lo;
          let hi = Number((value >> BigInt(32)) & BigInt(0xffffffff));
          buf[offset++] = hi;
          hi = hi >> 8;
          buf[offset++] = hi;
          hi = hi >> 8;
          buf[offset++] = hi;
          hi = hi >> 8;
          buf[offset++] = hi;
          return offset;
        }
        function wrtBigUInt64BE(buf, value, offset, min, max) {
          checkIntBI(value, min, max, buf, offset, 7);
          let lo = Number(value & BigInt(0xffffffff));
          buf[offset + 7] = lo;
          lo = lo >> 8;
          buf[offset + 6] = lo;
          lo = lo >> 8;
          buf[offset + 5] = lo;
          lo = lo >> 8;
          buf[offset + 4] = lo;
          let hi = Number((value >> BigInt(32)) & BigInt(0xffffffff));
          buf[offset + 3] = hi;
          hi = hi >> 8;
          buf[offset + 2] = hi;
          hi = hi >> 8;
          buf[offset + 1] = hi;
          hi = hi >> 8;
          buf[offset] = hi;
          return offset + 8;
        }
        Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(
          function writeBigUInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff"),
            );
          },
        );
        Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(
          function writeBigUInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff"),
            );
          },
        );
        Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            const limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }
          let i = 0;
          let mul = 1;
          let sub = 0;
          this[offset] = value & 0xff;
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            const limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }
          let i = byteLength - 1;
          let mul = 1;
          let sub = 0;
          this[offset + i] = value & 0xff;
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
          this[offset] = value & 0xff;
          this[offset + 1] = value >>> 8;
          return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
          this[offset] = value >>> 8;
          this[offset + 1] = value & 0xff;
          return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
          this[offset] = value & 0xff;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
          return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert,
        ) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
          if (value < 0) value = 0xffffffff + value + 1;
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 0xff;
          return offset + 4;
        };
        Buffer.prototype.writeBigInt64LE = defineBigIntMethod(
          function writeBigInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(
              this,
              value,
              offset,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff"),
            );
          },
        );
        Buffer.prototype.writeBigInt64BE = defineBigIntMethod(
          function writeBigInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(
              this,
              value,
              offset,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff"),
            );
          },
        );
        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
          if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkIEEE754(
              buf,
              value,
              offset,
              4,
              3.4028234663852886e38,
              -340282346638528860000000000000000000000,
            );
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert,
        ) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert,
        ) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkIEEE754(
              buf,
              value,
              offset,
              8,
              1.7976931348623157e308,
              -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            );
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert,
        ) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert,
        ) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer");
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          // Copy 0 bytes; we're done
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          // Fatal error conditions
          if (targetStart < 0)
            throw new RangeError("targetStart out of bounds");
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          // Are we oob?
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start)
            end = target.length - targetStart + start;
          const len = end - start;
          if (
            this === target &&
            typeof Uint8Array.prototype.copyWithin === "function"
          )
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end);
          else
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart,
            );
          return len;
        };
        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (encoding !== undefined && typeof encoding !== "string")
              throw new TypeError("encoding must be a string");
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding))
              throw new TypeError("Unknown encoding: " + encoding);
            if (val.length === 1) {
              const code = val.charCodeAt(0);
              if ((encoding === "utf8" && code < 128) || encoding === "latin1")
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code;
            }
          } else if (typeof val === "number") val = val & 255;
          else if (typeof val === "boolean") val = Number(val);
          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end)
            throw new RangeError("Out of range index");
          if (end <= start) return this;
          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;
          if (!val) val = 0;
          let i;
          if (typeof val === "number")
            for (i = start; i < end; ++i) this[i] = val;
          else {
            const bytes = Buffer.isBuffer(val)
              ? val
              : Buffer.from(val, encoding);
            const len = bytes.length;
            if (len === 0)
              throw new TypeError(
                'The value "' + val + '" is invalid for argument "value"',
              );
            for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
          }
          return this;
        };
        // CUSTOM ERRORS
        // =============
        // Simplified versions from Node, changed for Buffer-only usage
        const errors = {};
        function E(sym, getMessage, Base) {
          errors[sym] = class NodeError extends Base {
            constructor() {
              super();
              Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true,
              });
              // Add the error code to the name to include it in the stack trace.
              this.name = `${this.name} [${sym}]`;
              // Access the stack to generate the error message including the error code
              // from the name.
              this.stack; // eslint-disable-line no-unused-expressions
              // Reset the name to the actual name.
              delete this.name;
            }
            get code() {
              return sym;
            }
            set code(value) {
              Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true,
              });
            }
            toString() {
              return `${this.name} [${sym}]: ${this.message}`;
            }
          };
        }
        E(
          "ERR_BUFFER_OUT_OF_BOUNDS",
          function (name) {
            if (name) return `${name} is outside of buffer bounds`;
            return "Attempt to access memory outside buffer bounds";
          },
          RangeError,
        );
        E(
          "ERR_INVALID_ARG_TYPE",
          function (name, actual) {
            return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
          },
          TypeError,
        );
        E(
          "ERR_OUT_OF_RANGE",
          function (str, range, input) {
            let msg = `The value of "${str}" is out of range.`;
            let received = input;
            if (Number.isInteger(input) && Math.abs(input) > 2 ** 32)
              received = addNumericalSeparator(String(input));
            else if (typeof input === "bigint") {
              received = String(input);
              if (
                input > BigInt(2) ** BigInt(32) ||
                input < -(BigInt(2) ** BigInt(32))
              )
                received = addNumericalSeparator(received);
              received += "n";
            }
            msg += ` It must be ${range}. Received ${received}`;
            return msg;
          },
          RangeError,
        );
        function addNumericalSeparator(val) {
          let res = "";
          let i = val.length;
          const start = val[0] === "-" ? 1 : 0;
          for (; i >= start + 4; i -= 3) res = `_${val.slice(i - 3, i)}${res}`;
          return `${val.slice(0, i)}${res}`;
        }
        // CHECK FUNCTIONS
        // ===============
        function checkBounds(buf, offset, byteLength) {
          validateNumber(offset, "offset");
          if (
            buf[offset] === undefined ||
            buf[offset + byteLength] === undefined
          )
            boundsError(offset, buf.length - (byteLength + 1));
        }
        function checkIntBI(value, min, max, buf, offset, byteLength) {
          if (value > max || value < min) {
            const n = typeof min === "bigint" ? "n" : "";
            let range;
            if (byteLength > 3) {
              if (min === 0 || min === BigInt(0))
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
              else
                range =
                  `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                  `${(byteLength + 1) * 8 - 1}${n}`;
            } else range = `>= ${min}${n} and <= ${max}${n}`;
            throw new errors.ERR_OUT_OF_RANGE("value", range, value);
          }
          checkBounds(buf, offset, byteLength);
        }
        function validateNumber(value, name) {
          if (typeof value !== "number")
            throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        function boundsError(value, length, type) {
          if (Math.floor(value) !== value) {
            validateNumber(value, type);
            throw new errors.ERR_OUT_OF_RANGE(
              type || "offset",
              "an integer",
              value,
            );
          }
          if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new errors.ERR_OUT_OF_RANGE(
            type || "offset",
            `>= ${type ? 1 : 0} and <= ${length}`,
            value,
          );
        }
        // HELPER FUNCTIONS
        // ================
        const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split("=")[0];
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, "");
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return "";
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) str = str + "=";
          return str;
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          let codePoint;
          const length = string.length;
          let leadSurrogate = null;
          const bytes = [];
          for (let i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
              }
              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                leadSurrogate = codePoint;
                continue;
              }
              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
            }
            leadSurrogate = null;
            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push(
                (codePoint >> 0xc) | 0xe0,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80,
              );
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80,
              );
            } else throw new Error("Invalid code point");
          }
          return bytes;
        }
        function asciiToBytes(str) {
          const byteArray = [];
          for (
            let i = 0;
            i < str.length;
            ++i // Node's code seems to be doing this and not & 0x7F..
          )
            byteArray.push(str.charCodeAt(i) & 0xff);
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          let c, hi, lo;
          const byteArray = [];
          for (let i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          let i;
          for (i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
        // the `instanceof` check but they should be treated as of that type.
        // See: https://github.com/feross/buffer/issues/166
        function isInstance(obj, type) {
          return (
            obj instanceof type ||
            (obj != null &&
              obj.constructor != null &&
              obj.constructor.name != null &&
              obj.constructor.name === type.name)
          );
        }
        function numberIsNaN(obj) {
          // For IE11 support
          return (
            obj !== obj // eslint-disable-line no-self-compare
          );
        }
        // Create lookup table for `toString('hex')`
        // See: https://github.com/feross/buffer/issues/219
        const hexSliceLookupTable = (function () {
          const alphabet = "0123456789abcdef";
          const table = new Array(256);
          for (let i = 0; i < 16; ++i) {
            const i16 = i * 16;
            for (let j = 0; j < 16; ++j)
              table[i16 + j] = alphabet[i] + alphabet[j];
          }
          return table;
        })();
        // Return not function with Error if BigInt not supported
        function defineBigIntMethod(fn) {
          return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
        }
        function BufferBigIntNotDefined() {
          throw new Error("BigInt not supported");
        }
      },
      { "9c62938f1dccc73c": "93vGZ", aceacb6a4531a9d2: "4Lb7l" },
    ],
    "93vGZ": [
      function (require, module, exports) {
        "use strict";
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len = b64.length;
          if (len % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=");
          if (validLen === -1) validLen = len;
          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
          return [validLen, placeHoldersLen];
        }
        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i;
          for (i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }
          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
          }
          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          );
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
          var parts = [];
          var maxChunkLength = 16383; // must be multiple of 3
          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          )
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength,
              ),
            );
          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "=",
            );
          }
          return parts.join("");
        }
      },
      {},
    ],
    "4Lb7l": [
      function (require, module, exports) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read =
          function (buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << -nBits) - 1);
            s >>= -nBits;
            nBits += eLen;
            for (
              ;
              nBits > 0;
              e = e * 256 + buffer[offset + i], i += d, nBits -= 8
            );
            m = e & ((1 << -nBits) - 1);
            e >>= -nBits;
            nBits += mLen;
            for (
              ;
              nBits > 0;
              m = m * 256 + buffer[offset + i], i += d, nBits -= 8
            );
            if (e === 0) e = 1 - eBias;
            else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
            else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) value += rt / c;
            else value += rt * Math.pow(2, 1 - eBias);
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          );
          e = (e << mLen) | m;
          eLen += mLen;
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          );
          buffer[offset + i - d] |= s * 128;
        };
      },
      {},
    ],
    bJPKW: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        /**
         * Create an Error with the specified message, config, error code, request and response.
         *
         * @param {string} message The error message.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [config] The config.
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         *
         * @returns {Error} The created error.
         */ function AxiosError(message, code, config, request, response) {
          Error.call(this);
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, this.constructor);
          else this.stack = new Error().stack;
          this.message = message;
          this.name = "AxiosError";
          code && (this.code = code);
          config && (this.config = config);
          request && (this.request = request);
          response && (this.response = response);
        }
        (0, _utilsJsDefault.default).inherits(AxiosError, Error, {
          toJSON: function toJSON() {
            return {
              // Standard
              message: this.message,
              name: this.name,
              // Microsoft
              description: this.description,
              number: this.number,
              // Mozilla
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              // Axios
              config: (0, _utilsJsDefault.default).toJSONObject(this.config),
              code: this.code,
              status:
                this.response && this.response.status
                  ? this.response.status
                  : null,
            };
          },
        });
        const prototype = AxiosError.prototype;
        const descriptors = {};
        [
          "ERR_BAD_OPTION_VALUE",
          "ERR_BAD_OPTION",
          "ECONNABORTED",
          "ETIMEDOUT",
          "ERR_NETWORK",
          "ERR_FR_TOO_MANY_REDIRECTS",
          "ERR_DEPRECATED",
          "ERR_BAD_RESPONSE",
          "ERR_BAD_REQUEST",
          "ERR_CANCELED",
          "ERR_NOT_SUPPORT",
          "ERR_INVALID_URL",
        ].forEach((code) => {
          descriptors[code] = {
            value: code,
          };
        });
        Object.defineProperties(AxiosError, descriptors);
        Object.defineProperty(prototype, "isAxiosError", {
          value: true,
        });
        // eslint-disable-next-line func-names
        AxiosError.from = (
          error,
          code,
          config,
          request,
          response,
          customProps,
        ) => {
          const axiosError = Object.create(prototype);
          (0, _utilsJsDefault.default).toFlatObject(
            error,
            axiosError,
            function filter(obj) {
              return obj !== Error.prototype;
            },
            (prop) => {
              return prop !== "isAxiosError";
            },
          );
          AxiosError.call(
            axiosError,
            error.message,
            code,
            config,
            request,
            response,
          );
          axiosError.cause = error;
          axiosError.name = error.name;
          customProps && Object.assign(axiosError, customProps);
          return axiosError;
        };
        exports.default = AxiosError;
      },
      {
        "../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "1m7Fr": [
      function (require, module, exports) {
        // eslint-disable-next-line strict
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        exports.default = null;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "1AguR": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        class InterceptorManager {
          constructor() {
            this.handlers = [];
          }
          /**
           * Add a new interceptor to the stack
           *
           * @param {Function} fulfilled The function to handle `then` for a `Promise`
           * @param {Function} rejected The function to handle `reject` for a `Promise`
           *
           * @return {Number} An ID used to remove interceptor later
           */ use(fulfilled, rejected, options) {
            this.handlers.push({
              fulfilled,
              rejected,
              synchronous: options ? options.synchronous : false,
              runWhen: options ? options.runWhen : null,
            });
            return this.handlers.length - 1;
          }
          /**
           * Remove an interceptor from the stack
           *
           * @param {Number} id The ID that was returned by `use`
           *
           * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
           */ eject(id) {
            if (this.handlers[id]) this.handlers[id] = null;
          }
          /**
           * Clear all interceptors from the stack
           *
           * @returns {void}
           */ clear() {
            if (this.handlers) this.handlers = [];
          }
          /**
           * Iterate over all the registered interceptors
           *
           * This method is particularly useful for skipping over any
           * interceptors that may have become `null` calling `eject`.
           *
           * @param {Function} fn The function to call for each interceptor
           *
           * @returns {void}
           */ forEach(fn) {
            (0, _utilsJsDefault.default).forEach(
              this.handlers,
              function forEachHandler(h) {
                if (h !== null) fn(h);
              },
            );
          }
        }
        exports.default = InterceptorManager;
      },
      {
        "./../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "6kQbz": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => dispatchRequest);
        var _transformDataJs = require("./transformData.js");
        var _transformDataJsDefault =
          parcelHelpers.interopDefault(_transformDataJs);
        var _isCancelJs = require("../cancel/isCancel.js");
        var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
        var _indexJs = require("../defaults/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _canceledErrorJs = require("../cancel/CanceledError.js");
        var _canceledErrorJsDefault =
          parcelHelpers.interopDefault(_canceledErrorJs);
        var _axiosHeadersJs = require("../core/AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        var _adaptersJs = require("../adapters/adapters.js");
        var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
        ("use strict");
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         *
         * @param {Object} config The config that is to be used for the request
         *
         * @returns {void}
         */ function throwIfCancellationRequested(config) {
          if (config.cancelToken) config.cancelToken.throwIfRequested();
          if (config.signal && config.signal.aborted)
            throw new (0, _canceledErrorJsDefault.default)(null, config);
        }
        function dispatchRequest(config) {
          throwIfCancellationRequested(config);
          config.headers = (0, _axiosHeadersJsDefault.default).from(
            config.headers,
          );
          // Transform request data
          config.data = (0, _transformDataJsDefault.default).call(
            config,
            config.transformRequest,
          );
          if (["post", "put", "patch"].indexOf(config.method) !== -1)
            config.headers.setContentType(
              "application/x-www-form-urlencoded",
              false,
            );
          const adapter = (0, _adaptersJsDefault.default).getAdapter(
            config.adapter || (0, _indexJsDefault.default).adapter,
          );
          return adapter(config).then(
            function onAdapterResolution(response) {
              throwIfCancellationRequested(config);
              // Transform response data
              response.data = (0, _transformDataJsDefault.default).call(
                config,
                config.transformResponse,
                response,
              );
              response.headers = (0, _axiosHeadersJsDefault.default).from(
                response.headers,
              );
              return response;
            },
            function onAdapterRejection(reason) {
              if (!(0, _isCancelJsDefault.default)(reason)) {
                throwIfCancellationRequested(config);
                // Transform response data
                if (reason && reason.response) {
                  reason.response.data = (0,
                  _transformDataJsDefault.default).call(
                    config,
                    config.transformResponse,
                    reason.response,
                  );
                  reason.response.headers = (0,
                  _axiosHeadersJsDefault.default).from(reason.response.headers);
                }
              }
              return Promise.reject(reason);
            },
          );
        }
      },
      {
        "./transformData.js": "fDiTM",
        "../cancel/isCancel.js": "7VE25",
        "../defaults/index.js": "iyLpu",
        "../cancel/CanceledError.js": "5zKhr",
        "../core/AxiosHeaders.js": "fUSSQ",
        "../adapters/adapters.js": "eOTbv",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    fDiTM: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => transformData);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _indexJs = require("../defaults/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _axiosHeadersJs = require("../core/AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        ("use strict");
        function transformData(fns, response) {
          const config = this || (0, _indexJsDefault.default);
          const context = response || config;
          const headers = (0, _axiosHeadersJsDefault.default).from(
            context.headers,
          );
          let data = context.data;
          (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
            data = fn.call(
              config,
              data,
              headers.normalize(),
              response ? response.status : undefined,
            );
          });
          headers.normalize();
          return data;
        }
      },
      {
        "./../utils.js": "gUZbi",
        "../defaults/index.js": "iyLpu",
        "../core/AxiosHeaders.js": "fUSSQ",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    iyLpu: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        var _transitionalJs = require("./transitional.js");
        var _transitionalJsDefault =
          parcelHelpers.interopDefault(_transitionalJs);
        var _toFormDataJs = require("../helpers/toFormData.js");
        var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
        var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
        var _toURLEncodedFormJsDefault =
          parcelHelpers.interopDefault(_toURLEncodedFormJs);
        var _indexJs = require("../platform/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
        var _formDataToJSONJsDefault =
          parcelHelpers.interopDefault(_formDataToJSONJs);
        ("use strict");
        /**
         * It takes a string, tries to parse it, and if it fails, it returns the stringified version
         * of the input
         *
         * @param {any} rawValue - The value to be stringified.
         * @param {Function} parser - A function that parses a string into a JavaScript object.
         * @param {Function} encoder - A function that takes a value and returns a string.
         *
         * @returns {string} A stringified version of the rawValue.
         */ function stringifySafely(rawValue, parser, encoder) {
          if ((0, _utilsJsDefault.default).isString(rawValue))
            try {
              (parser || JSON.parse)(rawValue);
              return (0, _utilsJsDefault.default).trim(rawValue);
            } catch (e) {
              if (e.name !== "SyntaxError") throw e;
            }
          return (encoder || JSON.stringify)(rawValue);
        }
        const defaults = {
          transitional: (0, _transitionalJsDefault.default),
          adapter: ["xhr", "http"],
          transformRequest: [
            function transformRequest(data, headers) {
              const contentType = headers.getContentType() || "";
              const hasJSONContentType =
                contentType.indexOf("application/json") > -1;
              const isObjectPayload = (0, _utilsJsDefault.default).isObject(
                data,
              );
              if (
                isObjectPayload &&
                (0, _utilsJsDefault.default).isHTMLForm(data)
              )
                data = new FormData(data);
              const isFormData = (0, _utilsJsDefault.default).isFormData(data);
              if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType
                  ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data))
                  : data;
              }
              if (
                (0, _utilsJsDefault.default).isArrayBuffer(data) ||
                (0, _utilsJsDefault.default).isBuffer(data) ||
                (0, _utilsJsDefault.default).isStream(data) ||
                (0, _utilsJsDefault.default).isFile(data) ||
                (0, _utilsJsDefault.default).isBlob(data)
              )
                return data;
              if ((0, _utilsJsDefault.default).isArrayBufferView(data))
                return data.buffer;
              if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType(
                  "application/x-www-form-urlencoded;charset=utf-8",
                  false,
                );
                return data.toString();
              }
              let isFileList;
              if (isObjectPayload) {
                if (
                  contentType.indexOf("application/x-www-form-urlencoded") > -1
                )
                  return (0, _toURLEncodedFormJsDefault.default)(
                    data,
                    this.formSerializer,
                  ).toString();
                if (
                  (isFileList = (0, _utilsJsDefault.default).isFileList(
                    data,
                  )) ||
                  contentType.indexOf("multipart/form-data") > -1
                ) {
                  const _FormData = this.env && this.env.FormData;
                  return (0, _toFormDataJsDefault.default)(
                    isFileList
                      ? {
                          "files[]": data,
                        }
                      : data,
                    _FormData && new _FormData(),
                    this.formSerializer,
                  );
                }
              }
              if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
              }
              return data;
            },
          ],
          transformResponse: [
            function transformResponse(data) {
              const transitional = this.transitional || defaults.transitional;
              const forcedJSONParsing =
                transitional && transitional.forcedJSONParsing;
              const JSONRequested = this.responseType === "json";
              if (
                data &&
                (0, _utilsJsDefault.default).isString(data) &&
                ((forcedJSONParsing && !this.responseType) || JSONRequested)
              ) {
                const silentJSONParsing =
                  transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                  return JSON.parse(data);
                } catch (e) {
                  if (strictJSONParsing) {
                    if (e.name === "SyntaxError")
                      throw (0, _axiosErrorJsDefault.default).from(
                        e,
                        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE,
                        this,
                        null,
                        this.response,
                      );
                    throw e;
                  }
                }
              }
              return data;
            },
          ],
          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */ timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          env: {
            FormData: (0, _indexJsDefault.default).classes.FormData,
            Blob: (0, _indexJsDefault.default).classes.Blob,
          },
          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },
          headers: {
            common: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": undefined,
            },
          },
        };
        (0, _utilsJsDefault.default).forEach(
          ["delete", "get", "head", "post", "put", "patch"],
          (method) => {
            defaults.headers[method] = {};
          },
        );
        exports.default = defaults;
      },
      {
        "../utils.js": "gUZbi",
        "../core/AxiosError.js": "bJPKW",
        "./transitional.js": "ZEYqh",
        "../helpers/toFormData.js": "8Si2N",
        "../helpers/toURLEncodedForm.js": "78LdN",
        "../platform/index.js": "dDro7",
        "../helpers/formDataToJSON.js": "7NdDM",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    ZEYqh: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        ("use strict");
        exports.default = {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false,
        };
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "78LdN": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => toURLEncodedForm);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _toFormDataJs = require("./toFormData.js");
        var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
        var _indexJs = require("../platform/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        ("use strict");
        function toURLEncodedForm(data, options) {
          return (0, _toFormDataJsDefault.default)(
            data,
            new (0, _indexJsDefault.default).classes.URLSearchParams(),
            Object.assign(
              {
                visitor: function (value, key, path, helpers) {
                  if (
                    (0, _indexJsDefault.default).isNode &&
                    (0, _utilsJsDefault.default).isBuffer(value)
                  ) {
                    this.append(key, value.toString("base64"));
                    return false;
                  }
                  return helpers.defaultVisitor.apply(this, arguments);
                },
              },
              options,
            ),
          );
        }
      },
      {
        "../utils.js": "gUZbi",
        "./toFormData.js": "8Si2N",
        "../platform/index.js": "dDro7",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    dDro7: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _indexJs = require("./node/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _utilsJs = require("./common/utils.js");
        exports.default = {
          ..._utilsJs,
          ...(0, _indexJsDefault.default),
        };
      },
      {
        "./node/index.js": "r503U",
        "./common/utils.js": "D1joL",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    r503U: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
        var _urlsearchParamsJsDefault =
          parcelHelpers.interopDefault(_urlsearchParamsJs);
        var _formDataJs = require("./classes/FormData.js");
        var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
        var _blobJs = require("./classes/Blob.js");
        var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
        exports.default = {
          isBrowser: true,
          classes: {
            URLSearchParams: (0, _urlsearchParamsJsDefault.default),
            FormData: (0, _formDataJsDefault.default),
            Blob: (0, _blobJsDefault.default),
          },
          protocols: ["http", "https", "file", "blob", "url", "data"],
        };
      },
      {
        "./classes/URLSearchParams.js": "1wHq5",
        "./classes/FormData.js": "airCF",
        "./classes/Blob.js": "cW3UK",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "1wHq5": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
        var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(
          _axiosURLSearchParamsJs,
        );
        ("use strict");
        exports.default =
          typeof URLSearchParams !== "undefined"
            ? URLSearchParams
            : (0, _axiosURLSearchParamsJsDefault.default);
      },
      {
        "../../../helpers/AxiosURLSearchParams.js": "8Prsk",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    airCF: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        ("use strict");
        exports.default = typeof FormData !== "undefined" ? FormData : null;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    cW3UK: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        ("use strict");
        exports.default = typeof Blob !== "undefined" ? Blob : null;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    D1joL: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "hasBrowserEnv", () => hasBrowserEnv);
        parcelHelpers.export(
          exports,
          "hasStandardBrowserWebWorkerEnv",
          () => hasStandardBrowserWebWorkerEnv,
        );
        parcelHelpers.export(
          exports,
          "hasStandardBrowserEnv",
          () => hasStandardBrowserEnv,
        );
        const hasBrowserEnv =
          typeof window !== "undefined" && typeof document !== "undefined";
        /**
         * Determine if we're running in a standard browser environment
         *
         * This allows axios to run in a web worker, and react-native.
         * Both environments support XMLHttpRequest, but not fully standard globals.
         *
         * web workers:
         *  typeof window -> undefined
         *  typeof document -> undefined
         *
         * react-native:
         *  navigator.product -> 'ReactNative'
         * nativescript
         *  navigator.product -> 'NativeScript' or 'NS'
         *
         * @returns {boolean}
         */ const hasStandardBrowserEnv = ((product) => {
          return (
            hasBrowserEnv &&
            ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0
          );
        })(typeof navigator !== "undefined" && navigator.product);
        /**
         * Determine if we're running in a standard browser webWorker environment
         *
         * Although the `isStandardBrowserEnv` method indicates that
         * `allows axios to run in a web worker`, the WebWorker will still be
         * filtered out due to its judgment standard
         * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
         * This leads to a problem when axios post `FormData` in webWorker
         */ const hasStandardBrowserWebWorkerEnv = (() => {
          return (
            typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
            self instanceof WorkerGlobalScope &&
            typeof self.importScripts === "function"
          );
        })();
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "7NdDM": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        /**
         * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
         *
         * @param {string} name - The name of the property to get.
         *
         * @returns An array of strings.
         */ function parsePropPath(name) {
          // foo[x][y][z]
          // foo.x.y.z
          // foo-x-y-z
          // foo x y z
          return (0, _utilsJsDefault.default)
            .matchAll(/\w+|\[(\w*)]/g, name)
            .map((match) => {
              return match[0] === "[]" ? "" : match[1] || match[0];
            });
        }
        /**
         * Convert an array to an object.
         *
         * @param {Array<any>} arr - The array to convert to an object.
         *
         * @returns An object with the same keys and values as the array.
         */ function arrayToObject(arr) {
          const obj = {};
          const keys = Object.keys(arr);
          let i;
          const len = keys.length;
          let key;
          for (i = 0; i < len; i++) {
            key = keys[i];
            obj[key] = arr[key];
          }
          return obj;
        }
        /**
         * It takes a FormData object and returns a JavaScript object
         *
         * @param {string} formData The FormData object to convert to JSON.
         *
         * @returns {Object<string, any> | null} The converted object.
         */ function formDataToJSON(formData) {
          function buildPath(path, value, target, index) {
            let name = path[index++];
            if (name === "__proto__") return true;
            const isNumericKey = Number.isFinite(+name);
            const isLast = index >= path.length;
            name =
              !name && (0, _utilsJsDefault.default).isArray(target)
                ? target.length
                : name;
            if (isLast) {
              if ((0, _utilsJsDefault.default).hasOwnProp(target, name))
                target[name] = [target[name], value];
              else target[name] = value;
              return !isNumericKey;
            }
            if (
              !target[name] ||
              !(0, _utilsJsDefault.default).isObject(target[name])
            )
              target[name] = [];
            const result = buildPath(path, value, target[name], index);
            if (result && (0, _utilsJsDefault.default).isArray(target[name]))
              target[name] = arrayToObject(target[name]);
            return !isNumericKey;
          }
          if (
            (0, _utilsJsDefault.default).isFormData(formData) &&
            (0, _utilsJsDefault.default).isFunction(formData.entries)
          ) {
            const obj = {};
            (0, _utilsJsDefault.default).forEachEntry(
              formData,
              (name, value) => {
                buildPath(parsePropPath(name), value, obj, 0);
              },
            );
            return obj;
          }
          return null;
        }
        exports.default = formDataToJSON;
      },
      {
        "../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    fUSSQ: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _parseHeadersJs = require("../helpers/parseHeaders.js");
        var _parseHeadersJsDefault =
          parcelHelpers.interopDefault(_parseHeadersJs);
        ("use strict");
        const $internals = Symbol("internals");
        function normalizeHeader(header) {
          return header && String(header).trim().toLowerCase();
        }
        function normalizeValue(value) {
          if (value === false || value == null) return value;
          return (0, _utilsJsDefault.default).isArray(value)
            ? value.map(normalizeValue)
            : String(value);
        }
        function parseTokens(str) {
          const tokens = Object.create(null);
          const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
          let match;
          while ((match = tokensRE.exec(str))) tokens[match[1]] = match[2];
          return tokens;
        }
        const isValidHeaderName = (str) =>
          /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
        function matchHeaderValue(
          context,
          value,
          header,
          filter,
          isHeaderNameFilter,
        ) {
          if ((0, _utilsJsDefault.default).isFunction(filter))
            return filter.call(this, value, header);
          if (isHeaderNameFilter) value = header;
          if (!(0, _utilsJsDefault.default).isString(value)) return;
          if ((0, _utilsJsDefault.default).isString(filter))
            return value.indexOf(filter) !== -1;
          if ((0, _utilsJsDefault.default).isRegExp(filter))
            return filter.test(value);
        }
        function formatHeader(header) {
          return header
            .trim()
            .toLowerCase()
            .replace(/([a-z\d])(\w*)/g, (w, char, str) => {
              return char.toUpperCase() + str;
            });
        }
        function buildAccessors(obj, header) {
          const accessorName = (0, _utilsJsDefault.default).toCamelCase(
            " " + header,
          );
          ["get", "set", "has"].forEach((methodName) => {
            Object.defineProperty(obj, methodName + accessorName, {
              value: function (arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
              },
              configurable: true,
            });
          });
        }
        class AxiosHeaders {
          constructor(headers) {
            headers && this.set(headers);
          }
          set(header, valueOrRewrite, rewrite) {
            const self = this;
            function setHeader(_value, _header, _rewrite) {
              const lHeader = normalizeHeader(_header);
              if (!lHeader)
                throw new Error("header name must be a non-empty string");
              const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
              if (
                !key ||
                self[key] === undefined ||
                _rewrite === true ||
                (_rewrite === undefined && self[key] !== false)
              )
                self[key || _header] = normalizeValue(_value);
            }
            const setHeaders = (headers, _rewrite) =>
              (0, _utilsJsDefault.default).forEach(headers, (_value, _header) =>
                setHeader(_value, _header, _rewrite),
              );
            if (
              (0, _utilsJsDefault.default).isPlainObject(header) ||
              header instanceof this.constructor
            )
              setHeaders(header, valueOrRewrite);
            else if (
              (0, _utilsJsDefault.default).isString(header) &&
              (header = header.trim()) &&
              !isValidHeaderName(header)
            )
              setHeaders(
                (0, _parseHeadersJsDefault.default)(header),
                valueOrRewrite,
              );
            else header != null && setHeader(valueOrRewrite, header, rewrite);
            return this;
          }
          get(header, parser) {
            header = normalizeHeader(header);
            if (header) {
              const key = (0, _utilsJsDefault.default).findKey(this, header);
              if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser))
                  return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser))
                  return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
              }
            }
          }
          has(header, matcher) {
            header = normalizeHeader(header);
            if (header) {
              const key = (0, _utilsJsDefault.default).findKey(this, header);
              return !!(
                key &&
                this[key] !== undefined &&
                (!matcher || matchHeaderValue(this, this[key], key, matcher))
              );
            }
            return false;
          }
          delete(header, matcher) {
            const self = this;
            let deleted = false;
            function deleteHeader(_header) {
              _header = normalizeHeader(_header);
              if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (
                  key &&
                  (!matcher || matchHeaderValue(self, self[key], key, matcher))
                ) {
                  delete self[key];
                  deleted = true;
                }
              }
            }
            if ((0, _utilsJsDefault.default).isArray(header))
              header.forEach(deleteHeader);
            else deleteHeader(header);
            return deleted;
          }
          clear(matcher) {
            const keys = Object.keys(this);
            let i = keys.length;
            let deleted = false;
            while (i--) {
              const key = keys[i];
              if (
                !matcher ||
                matchHeaderValue(this, this[key], key, matcher, true)
              ) {
                delete this[key];
                deleted = true;
              }
            }
            return deleted;
          }
          normalize(format) {
            const self = this;
            const headers = {};
            (0, _utilsJsDefault.default).forEach(this, (value, header) => {
              const key = (0, _utilsJsDefault.default).findKey(headers, header);
              if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
              }
              const normalized = format
                ? formatHeader(header)
                : String(header).trim();
              if (normalized !== header) delete self[header];
              self[normalized] = normalizeValue(value);
              headers[normalized] = true;
            });
            return this;
          }
          concat(...targets) {
            return this.constructor.concat(this, ...targets);
          }
          toJSON(asStrings) {
            const obj = Object.create(null);
            (0, _utilsJsDefault.default).forEach(this, (value, header) => {
              value != null &&
                value !== false &&
                (obj[header] =
                  asStrings && (0, _utilsJsDefault.default).isArray(value)
                    ? value.join(", ")
                    : value);
            });
            return obj;
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON())
              .map(([header, value]) => header + ": " + value)
              .join("\n");
          }
          get [Symbol.toStringTag]() {
            return "AxiosHeaders";
          }
          static from(thing) {
            return thing instanceof this ? thing : new this(thing);
          }
          static concat(first, ...targets) {
            const computed = new this(first);
            targets.forEach((target) => computed.set(target));
            return computed;
          }
          static accessor(header) {
            const internals =
              (this[$internals] =
              this[$internals] =
                {
                  accessors: {},
                });
            const accessors = internals.accessors;
            const prototype = this.prototype;
            function defineAccessor(_header) {
              const lHeader = normalizeHeader(_header);
              if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
              }
            }
            (0, _utilsJsDefault.default).isArray(header)
              ? header.forEach(defineAccessor)
              : defineAccessor(header);
            return this;
          }
        }
        AxiosHeaders.accessor([
          "Content-Type",
          "Content-Length",
          "Accept",
          "Accept-Encoding",
          "User-Agent",
          "Authorization",
        ]);
        // reserved names hotfix
        (0, _utilsJsDefault.default).reduceDescriptors(
          AxiosHeaders.prototype,
          ({ value }, key) => {
            let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
            return {
              get: () => value,
              set(headerValue) {
                this[mapped] = headerValue;
              },
            };
          },
        );
        (0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
        exports.default = AxiosHeaders;
      },
      {
        "../utils.js": "gUZbi",
        "../helpers/parseHeaders.js": "3HyNv",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "3HyNv": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        // RawAxiosHeaders whose duplicates are ignored by node
        // c.f. https://nodejs.org/api/http.html#http_message_headers
        const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ]);
        /**
         * Parse headers into an object
         *
         * ```
         * Date: Wed, 27 Aug 2014 08:58:49 GMT
         * Content-Type: application/json
         * Connection: keep-alive
         * Transfer-Encoding: chunked
         * ```
         *
         * @param {String} rawHeaders Headers needing to be parsed
         *
         * @returns {Object} Headers parsed into an object
         */ exports.default = (rawHeaders) => {
          const parsed = {};
          let key;
          let val;
          let i;
          rawHeaders &&
            rawHeaders.split("\n").forEach(function parser(line) {
              i = line.indexOf(":");
              key = line.substring(0, i).trim().toLowerCase();
              val = line.substring(i + 1).trim();
              if (!key || (parsed[key] && ignoreDuplicateOf[key])) return;
              if (key === "set-cookie") {
                if (parsed[key]) parsed[key].push(val);
                else parsed[key] = [val];
              } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            });
          return parsed;
        };
      },
      {
        "./../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "7VE25": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => isCancel);
        ("use strict");
        function isCancel(value) {
          return !!(value && value.__CANCEL__);
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "5zKhr": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        /**
         * A `CanceledError` is an object that is thrown when an operation is canceled.
         *
         * @param {string=} message The message.
         * @param {Object=} config The config.
         * @param {Object=} request The request.
         *
         * @returns {CanceledError} The created error.
         */ function CanceledError(message, config, request) {
          // eslint-disable-next-line no-eq-null,eqeqeq
          (0, _axiosErrorJsDefault.default).call(
            this,
            message == null ? "canceled" : message,
            (0, _axiosErrorJsDefault.default).ERR_CANCELED,
            config,
            request,
          );
          this.name = "CanceledError";
        }
        (0, _utilsJsDefault.default).inherits(
          CanceledError,
          (0, _axiosErrorJsDefault.default),
          {
            __CANCEL__: true,
          },
        );
        exports.default = CanceledError;
      },
      {
        "../core/AxiosError.js": "bJPKW",
        "../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    eOTbv: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _httpJs = require("./http.js");
        var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
        var _xhrJs = require("./xhr.js");
        var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        const knownAdapters = {
          http: (0, _httpJsDefault.default),
          xhr: (0, _xhrJsDefault.default),
        };
        (0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value) => {
          if (fn) {
            try {
              Object.defineProperty(fn, "name", {
                value,
              });
            } catch (e) {
              // eslint-disable-next-line no-empty
            }
            Object.defineProperty(fn, "adapterName", {
              value,
            });
          }
        });
        const renderReason = (reason) => `- ${reason}`;
        const isResolvedHandle = (adapter) =>
          (0, _utilsJsDefault.default).isFunction(adapter) ||
          adapter === null ||
          adapter === false;
        exports.default = {
          getAdapter: (adapters) => {
            adapters = (0, _utilsJsDefault.default).isArray(adapters)
              ? adapters
              : [adapters];
            const { length } = adapters;
            let nameOrAdapter;
            let adapter;
            const rejectedReasons = {};
            for (let i = 0; i < length; i++) {
              nameOrAdapter = adapters[i];
              let id;
              adapter = nameOrAdapter;
              if (!isResolvedHandle(nameOrAdapter)) {
                adapter =
                  knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined)
                  throw new (0, _axiosErrorJsDefault.default)(
                    `Unknown adapter '${id}'`,
                  );
              }
              if (adapter) break;
              rejectedReasons[id || "#" + i] = adapter;
            }
            if (!adapter) {
              const reasons = Object.entries(rejectedReasons).map(
                ([id, state]) =>
                  `adapter ${id} ` +
                  (state === false
                    ? "is not supported by the environment"
                    : "is not available in the build"),
              );
              let s = length
                ? reasons.length > 1
                  ? "since :\n" + reasons.map(renderReason).join("\n")
                  : " " + renderReason(reasons[0])
                : "as no adapter specified";
              throw new (0, _axiosErrorJsDefault.default)(
                `There is no suitable adapter to dispatch the request ` + s,
                "ERR_NOT_SUPPORT",
              );
            }
            return adapter;
          },
          adapters: knownAdapters,
        };
      },
      {
        "../utils.js": "gUZbi",
        "./http.js": "1m7Fr",
        "./xhr.js": "as6im",
        "../core/AxiosError.js": "bJPKW",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    as6im: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _settleJs = require("./../core/settle.js");
        var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
        var _cookiesJs = require("./../helpers/cookies.js");
        var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
        var _buildURLJs = require("./../helpers/buildURL.js");
        var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
        var _buildFullPathJs = require("../core/buildFullPath.js");
        var _buildFullPathJsDefault =
          parcelHelpers.interopDefault(_buildFullPathJs);
        var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
        var _isURLSameOriginJsDefault =
          parcelHelpers.interopDefault(_isURLSameOriginJs);
        var _transitionalJs = require("../defaults/transitional.js");
        var _transitionalJsDefault =
          parcelHelpers.interopDefault(_transitionalJs);
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        var _canceledErrorJs = require("../cancel/CanceledError.js");
        var _canceledErrorJsDefault =
          parcelHelpers.interopDefault(_canceledErrorJs);
        var _parseProtocolJs = require("../helpers/parseProtocol.js");
        var _parseProtocolJsDefault =
          parcelHelpers.interopDefault(_parseProtocolJs);
        var _indexJs = require("../platform/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        var _axiosHeadersJs = require("../core/AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        var _speedometerJs = require("../helpers/speedometer.js");
        var _speedometerJsDefault =
          parcelHelpers.interopDefault(_speedometerJs);
        ("use strict");
        function progressEventReducer(listener, isDownloadStream) {
          let bytesNotified = 0;
          const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
          return (e) => {
            const loaded = e.loaded;
            const total = e.lengthComputable ? e.total : undefined;
            const progressBytes = loaded - bytesNotified;
            const rate = _speedometer(progressBytes);
            const inRange = loaded <= total;
            bytesNotified = loaded;
            const data = {
              loaded,
              total,
              progress: total ? loaded / total : undefined,
              bytes: progressBytes,
              rate: rate ? rate : undefined,
              estimated:
                rate && total && inRange ? (total - loaded) / rate : undefined,
              event: e,
            };
            data[isDownloadStream ? "download" : "upload"] = true;
            listener(data);
          };
        }
        const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
        exports.default =
          isXHRAdapterSupported &&
          function (config) {
            return new Promise(function dispatchXhrRequest(resolve, reject) {
              let requestData = config.data;
              const requestHeaders = (0, _axiosHeadersJsDefault.default)
                .from(config.headers)
                .normalize();
              let { responseType, withXSRFToken } = config;
              let onCanceled;
              function done() {
                if (config.cancelToken)
                  config.cancelToken.unsubscribe(onCanceled);
                if (config.signal)
                  config.signal.removeEventListener("abort", onCanceled);
              }
              let contentType;
              if ((0, _utilsJsDefault.default).isFormData(requestData)) {
                if (
                  (0, _indexJsDefault.default).hasStandardBrowserEnv ||
                  (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv
                )
                  requestHeaders.setContentType(
                    false,
                  ); // Let the browser set it
                else if (
                  (contentType = requestHeaders.getContentType()) !== false
                ) {
                  // fix semicolon duplication issue for ReactNative FormData implementation
                  const [type, ...tokens] = contentType
                    ? contentType
                        .split(";")
                        .map((token) => token.trim())
                        .filter(Boolean)
                    : [];
                  requestHeaders.setContentType(
                    [type || "multipart/form-data", ...tokens].join("; "),
                  );
                }
              }
              let request = new XMLHttpRequest();
              // HTTP basic authentication
              if (config.auth) {
                const username = config.auth.username || "";
                const password = config.auth.password
                  ? unescape(encodeURIComponent(config.auth.password))
                  : "";
                requestHeaders.set(
                  "Authorization",
                  "Basic " + btoa(username + ":" + password),
                );
              }
              const fullPath = (0, _buildFullPathJsDefault.default)(
                config.baseURL,
                config.url,
              );
              request.open(
                config.method.toUpperCase(),
                (0, _buildURLJsDefault.default)(
                  fullPath,
                  config.params,
                  config.paramsSerializer,
                ),
                true,
              );
              // Set the request timeout in MS
              request.timeout = config.timeout;
              function onloadend() {
                if (!request) return;
                // Prepare the response
                const responseHeaders = (0,
                _axiosHeadersJsDefault.default).from(
                  "getAllResponseHeaders" in request &&
                    request.getAllResponseHeaders(),
                );
                const responseData =
                  !responseType ||
                  responseType === "text" ||
                  responseType === "json"
                    ? request.responseText
                    : request.response;
                const response = {
                  data: responseData,
                  status: request.status,
                  statusText: request.statusText,
                  headers: responseHeaders,
                  config,
                  request,
                };
                (0, _settleJsDefault.default)(
                  function _resolve(value) {
                    resolve(value);
                    done();
                  },
                  function _reject(err) {
                    reject(err);
                    done();
                  },
                  response,
                );
                // Clean up request
                request = null;
              }
              if ("onloadend" in request)
                // Use onloadend if available
                request.onloadend = onloadend;
              // Listen for ready state to emulate onloadend
              else
                request.onreadystatechange = function handleLoad() {
                  if (!request || request.readyState !== 4) return;
                  // The request errored out and we didn't get a response, this will be
                  // handled by onerror instead
                  // With one exception: request that using file: protocol, most browsers
                  // will return status as 0 even though it's a successful request
                  if (
                    request.status === 0 &&
                    !(
                      request.responseURL &&
                      request.responseURL.indexOf("file:") === 0
                    )
                  )
                    return;
                  // readystate handler is calling before onerror or ontimeout handlers,
                  // so we should call onloadend on the next 'tick'
                  setTimeout(onloadend);
                };
              // Handle browser request cancellation (as opposed to a manual cancellation)
              request.onabort = function handleAbort() {
                if (!request) return;
                reject(
                  new (0, _axiosErrorJsDefault.default)(
                    "Request aborted",
                    (0, _axiosErrorJsDefault.default).ECONNABORTED,
                    config,
                    request,
                  ),
                );
                // Clean up request
                request = null;
              };
              // Handle low level network errors
              request.onerror = function handleError() {
                // Real errors are hidden from us by the browser
                // onerror should only fire if it's a network error
                reject(
                  new (0, _axiosErrorJsDefault.default)(
                    "Network Error",
                    (0, _axiosErrorJsDefault.default).ERR_NETWORK,
                    config,
                    request,
                  ),
                );
                // Clean up request
                request = null;
              };
              // Handle timeout
              request.ontimeout = function handleTimeout() {
                let timeoutErrorMessage = config.timeout
                  ? "timeout of " + config.timeout + "ms exceeded"
                  : "timeout exceeded";
                const transitional =
                  config.transitional || (0, _transitionalJsDefault.default);
                if (config.timeoutErrorMessage)
                  timeoutErrorMessage = config.timeoutErrorMessage;
                reject(
                  new (0, _axiosErrorJsDefault.default)(
                    timeoutErrorMessage,
                    transitional.clarifyTimeoutError
                      ? (0, _axiosErrorJsDefault.default).ETIMEDOUT
                      : (0, _axiosErrorJsDefault.default).ECONNABORTED,
                    config,
                    request,
                  ),
                );
                // Clean up request
                request = null;
              };
              // Add xsrf header
              // This is only done if running in a standard browser environment.
              // Specifically not if we're in a web worker, or react-native.
              if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
                withXSRFToken &&
                  (0, _utilsJsDefault.default).isFunction(withXSRFToken) &&
                  (withXSRFToken = withXSRFToken(config));
                if (
                  withXSRFToken ||
                  (withXSRFToken !== false &&
                    (0, _isURLSameOriginJsDefault.default)(fullPath))
                ) {
                  // Add xsrf header
                  const xsrfValue =
                    config.xsrfHeaderName &&
                    config.xsrfCookieName &&
                    (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
                  if (xsrfValue)
                    requestHeaders.set(config.xsrfHeaderName, xsrfValue);
                }
              }
              // Remove Content-Type if data is undefined
              requestData === undefined && requestHeaders.setContentType(null);
              // Add headers to the request
              if ("setRequestHeader" in request)
                (0, _utilsJsDefault.default).forEach(
                  requestHeaders.toJSON(),
                  function setRequestHeader(val, key) {
                    request.setRequestHeader(key, val);
                  },
                );
              // Add withCredentials to request if needed
              if (
                !(0, _utilsJsDefault.default).isUndefined(
                  config.withCredentials,
                )
              )
                request.withCredentials = !!config.withCredentials;
              // Add responseType to request if needed
              if (responseType && responseType !== "json")
                request.responseType = config.responseType;
              // Handle progress if needed
              if (typeof config.onDownloadProgress === "function")
                request.addEventListener(
                  "progress",
                  progressEventReducer(config.onDownloadProgress, true),
                );
              // Not all browsers support upload events
              if (
                typeof config.onUploadProgress === "function" &&
                request.upload
              )
                request.upload.addEventListener(
                  "progress",
                  progressEventReducer(config.onUploadProgress),
                );
              if (config.cancelToken || config.signal) {
                // Handle cancellation
                // eslint-disable-next-line func-names
                onCanceled = (cancel) => {
                  if (!request) return;
                  reject(
                    !cancel || cancel.type
                      ? new (0, _canceledErrorJsDefault.default)(
                          null,
                          config,
                          request,
                        )
                      : cancel,
                  );
                  request.abort();
                  request = null;
                };
                config.cancelToken && config.cancelToken.subscribe(onCanceled);
                if (config.signal)
                  config.signal.aborted
                    ? onCanceled()
                    : config.signal.addEventListener("abort", onCanceled);
              }
              const protocol = (0, _parseProtocolJsDefault.default)(fullPath);
              if (
                protocol &&
                (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1
              ) {
                reject(
                  new (0, _axiosErrorJsDefault.default)(
                    "Unsupported protocol " + protocol + ":",
                    (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
                    config,
                  ),
                );
                return;
              }
              // Send the request
              request.send(requestData || null);
            });
          };
      },
      {
        "./../utils.js": "gUZbi",
        "./../core/settle.js": "lsyyv",
        "./../helpers/cookies.js": "2y1XM",
        "./../helpers/buildURL.js": "ltNC5",
        "../core/buildFullPath.js": "gK1yS",
        "./../helpers/isURLSameOrigin.js": "bJAQ4",
        "../defaults/transitional.js": "ZEYqh",
        "../core/AxiosError.js": "bJPKW",
        "../cancel/CanceledError.js": "5zKhr",
        "../helpers/parseProtocol.js": "lAGvQ",
        "../platform/index.js": "dDro7",
        "../core/AxiosHeaders.js": "fUSSQ",
        "../helpers/speedometer.js": "hFaw2",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    lsyyv: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => settle);
        var _axiosErrorJs = require("./AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        ("use strict");
        function settle(resolve, reject, response) {
          const validateStatus = response.config.validateStatus;
          if (
            !response.status ||
            !validateStatus ||
            validateStatus(response.status)
          )
            resolve(response);
          else
            reject(
              new (0, _axiosErrorJsDefault.default)(
                "Request failed with status code " + response.status,
                [
                  (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
                  (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE,
                ][Math.floor(response.status / 100) - 4],
                response.config,
                response.request,
                response,
              ),
            );
        }
      },
      {
        "./AxiosError.js": "bJPKW",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "2y1XM": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _indexJs = require("../platform/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv // Standard browser envs support document.cookie
          ? {
              write(name, value, expires, path, domain, secure) {
                const cookie = [name + "=" + encodeURIComponent(value)];
                (0, _utilsJsDefault.default).isNumber(expires) &&
                  cookie.push("expires=" + new Date(expires).toGMTString());
                (0, _utilsJsDefault.default).isString(path) &&
                  cookie.push("path=" + path);
                (0, _utilsJsDefault.default).isString(domain) &&
                  cookie.push("domain=" + domain);
                secure === true && cookie.push("secure");
                document.cookie = cookie.join("; ");
              },
              read(name) {
                const match = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"),
                );
                return match ? decodeURIComponent(match[3]) : null;
              },
              remove(name) {
                this.write(name, "", Date.now() - 86400000);
              },
            } // Non-standard browser env (web workers, react-native) lack needed support.
          : {
              write() {},
              read() {
                return null;
              },
              remove() {},
            };
      },
      {
        "./../utils.js": "gUZbi",
        "../platform/index.js": "dDro7",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    gK1yS: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => buildFullPath);
        var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
        var _isAbsoluteURLJsDefault =
          parcelHelpers.interopDefault(_isAbsoluteURLJs);
        var _combineURLsJs = require("../helpers/combineURLs.js");
        var _combineURLsJsDefault =
          parcelHelpers.interopDefault(_combineURLsJs);
        ("use strict");
        function buildFullPath(baseURL, requestedURL) {
          if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL))
            return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
          return requestedURL;
        }
      },
      {
        "../helpers/isAbsoluteURL.js": "GvVZE",
        "../helpers/combineURLs.js": "5sEkK",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    GvVZE: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => isAbsoluteURL);
        ("use strict");
        function isAbsoluteURL(url) {
          // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
          // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
          // by any combination of letters, digits, plus, period, or hyphen.
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "5sEkK": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => combineURLs);
        ("use strict");
        function combineURLs(baseURL, relativeURL) {
          return relativeURL
            ? baseURL.replace(/\/?\/$/, "") +
                "/" +
                relativeURL.replace(/^\/+/, "")
            : baseURL;
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    bJAQ4: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _indexJs = require("../platform/index.js");
        var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
        ("use strict");
        exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv // Standard browser envs have full support of the APIs needed to test
          ? // whether the request URL is of the same origin as current location.
            (function standardBrowserEnv() {
              const msie = /(msie|trident)/i.test(navigator.userAgent);
              const urlParsingNode = document.createElement("a");
              let originURL;
              /**
               * Parse a URL to discover its components
               *
               * @param {String} url The URL to be parsed
               * @returns {Object}
               */ function resolveURL(url) {
                let href = url;
                if (msie) {
                  // IE needs attribute set twice to normalize properties
                  urlParsingNode.setAttribute("href", href);
                  href = urlParsingNode.href;
                }
                urlParsingNode.setAttribute("href", href);
                // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                return {
                  href: urlParsingNode.href,
                  protocol: urlParsingNode.protocol
                    ? urlParsingNode.protocol.replace(/:$/, "")
                    : "",
                  host: urlParsingNode.host,
                  search: urlParsingNode.search
                    ? urlParsingNode.search.replace(/^\?/, "")
                    : "",
                  hash: urlParsingNode.hash
                    ? urlParsingNode.hash.replace(/^#/, "")
                    : "",
                  hostname: urlParsingNode.hostname,
                  port: urlParsingNode.port,
                  pathname:
                    urlParsingNode.pathname.charAt(0) === "/"
                      ? urlParsingNode.pathname
                      : "/" + urlParsingNode.pathname,
                };
              }
              originURL = resolveURL(window.location.href);
              /**
               * Determine if a URL shares the same origin as the current location
               *
               * @param {String} requestURL The URL to test
               * @returns {boolean} True if URL shares the same origin, otherwise false
               */ return function isURLSameOrigin(requestURL) {
                const parsed = (0, _utilsJsDefault.default).isString(requestURL)
                  ? resolveURL(requestURL)
                  : requestURL;
                return (
                  parsed.protocol === originURL.protocol &&
                  parsed.host === originURL.host
                );
              };
            })() // Non standard browser envs (web workers, react-native) lack needed support.
          : (function nonStandardBrowserEnv() {
              return function isURLSameOrigin() {
                return true;
              };
            })();
      },
      {
        "./../utils.js": "gUZbi",
        "../platform/index.js": "dDro7",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    lAGvQ: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => parseProtocol);
        ("use strict");
        function parseProtocol(url) {
          const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
          return (match && match[1]) || "";
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    hFaw2: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        ("use strict");
        /**
         * Calculate data maxRate
         * @param {Number} [samplesCount= 10]
         * @param {Number} [min= 1000]
         * @returns {Function}
         */ function speedometer(samplesCount, min) {
          samplesCount = samplesCount || 10;
          const bytes = new Array(samplesCount);
          const timestamps = new Array(samplesCount);
          let head = 0;
          let tail = 0;
          let firstSampleTS;
          min = min !== undefined ? min : 1000;
          return function push(chunkLength) {
            const now = Date.now();
            const startedAt = timestamps[tail];
            if (!firstSampleTS) firstSampleTS = now;
            bytes[head] = chunkLength;
            timestamps[head] = now;
            let i = tail;
            let bytesCount = 0;
            while (i !== head) {
              bytesCount += bytes[i++];
              i = i % samplesCount;
            }
            head = (head + 1) % samplesCount;
            if (head === tail) tail = (tail + 1) % samplesCount;
            if (now - firstSampleTS < min) return;
            const passed = startedAt && now - startedAt;
            return passed
              ? Math.round((bytesCount * 1000) / passed)
              : undefined;
          };
        }
        exports.default = speedometer;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    lm9Dz: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => mergeConfig);
        var _utilsJs = require("../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        var _axiosHeadersJs = require("./AxiosHeaders.js");
        var _axiosHeadersJsDefault =
          parcelHelpers.interopDefault(_axiosHeadersJs);
        ("use strict");
        const headersToObject = (thing) =>
          thing instanceof (0, _axiosHeadersJsDefault.default)
            ? thing.toJSON()
            : thing;
        function mergeConfig(config1, config2) {
          // eslint-disable-next-line no-param-reassign
          config2 = config2 || {};
          const config = {};
          function getMergedValue(target, source, caseless) {
            if (
              (0, _utilsJsDefault.default).isPlainObject(target) &&
              (0, _utilsJsDefault.default).isPlainObject(source)
            )
              return (0, _utilsJsDefault.default).merge.call(
                {
                  caseless,
                },
                target,
                source,
              );
            else if ((0, _utilsJsDefault.default).isPlainObject(source))
              return (0, _utilsJsDefault.default).merge({}, source);
            else if ((0, _utilsJsDefault.default).isArray(source))
              return source.slice();
            return source;
          }
          // eslint-disable-next-line consistent-return
          function mergeDeepProperties(a, b, caseless) {
            if (!(0, _utilsJsDefault.default).isUndefined(b))
              return getMergedValue(a, b, caseless);
            else if (!(0, _utilsJsDefault.default).isUndefined(a))
              return getMergedValue(undefined, a, caseless);
          }
          // eslint-disable-next-line consistent-return
          function valueFromConfig2(a, b) {
            if (!(0, _utilsJsDefault.default).isUndefined(b))
              return getMergedValue(undefined, b);
          }
          // eslint-disable-next-line consistent-return
          function defaultToConfig2(a, b) {
            if (!(0, _utilsJsDefault.default).isUndefined(b))
              return getMergedValue(undefined, b);
            else if (!(0, _utilsJsDefault.default).isUndefined(a))
              return getMergedValue(undefined, a);
          }
          // eslint-disable-next-line consistent-return
          function mergeDirectKeys(a, b, prop) {
            if (prop in config2) return getMergedValue(a, b);
            else if (prop in config1) return getMergedValue(undefined, a);
          }
          const mergeMap = {
            url: valueFromConfig2,
            method: valueFromConfig2,
            data: valueFromConfig2,
            baseURL: defaultToConfig2,
            transformRequest: defaultToConfig2,
            transformResponse: defaultToConfig2,
            paramsSerializer: defaultToConfig2,
            timeout: defaultToConfig2,
            timeoutMessage: defaultToConfig2,
            withCredentials: defaultToConfig2,
            withXSRFToken: defaultToConfig2,
            adapter: defaultToConfig2,
            responseType: defaultToConfig2,
            xsrfCookieName: defaultToConfig2,
            xsrfHeaderName: defaultToConfig2,
            onUploadProgress: defaultToConfig2,
            onDownloadProgress: defaultToConfig2,
            decompress: defaultToConfig2,
            maxContentLength: defaultToConfig2,
            maxBodyLength: defaultToConfig2,
            beforeRedirect: defaultToConfig2,
            transport: defaultToConfig2,
            httpAgent: defaultToConfig2,
            httpsAgent: defaultToConfig2,
            cancelToken: defaultToConfig2,
            socketPath: defaultToConfig2,
            responseEncoding: defaultToConfig2,
            validateStatus: mergeDirectKeys,
            headers: (a, b) =>
              mergeDeepProperties(headersToObject(a), headersToObject(b), true),
          };
          (0, _utilsJsDefault.default).forEach(
            Object.keys(Object.assign({}, config1, config2)),
            function computeConfigValue(prop) {
              const merge = mergeMap[prop] || mergeDeepProperties;
              const configValue = merge(config1[prop], config2[prop], prop);
              ((0, _utilsJsDefault.default).isUndefined(configValue) &&
                merge !== mergeDirectKeys) ||
                (config[prop] = configValue);
            },
          );
          return config;
        }
      },
      {
        "../utils.js": "gUZbi",
        "./AxiosHeaders.js": "fUSSQ",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "1VZh4": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _dataJs = require("../env/data.js");
        var _axiosErrorJs = require("../core/AxiosError.js");
        var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
        ("use strict");
        const validators = {};
        // eslint-disable-next-line func-names
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(
          (type, i) => {
            validators[type] = function validator(thing) {
              return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
            };
          },
        );
        const deprecatedWarnings = {};
        /**
         * Transitional option validator
         *
         * @param {function|boolean?} validator - set to false if the transitional option has been removed
         * @param {string?} version - deprecated version / removed since version
         * @param {string?} message - some message with additional info
         *
         * @returns {function}
         */ validators.transitional = function transitional(
          validator,
          version,
          message,
        ) {
          function formatMessage(opt, desc) {
            return (
              "[Axios v" +
              (0, _dataJs.VERSION) +
              "] Transitional option '" +
              opt +
              "'" +
              desc +
              (message ? ". " + message : "")
            );
          }
          // eslint-disable-next-line func-names
          return (value, opt, opts) => {
            if (validator === false)
              throw new (0, _axiosErrorJsDefault.default)(
                formatMessage(
                  opt,
                  " has been removed" + (version ? " in " + version : ""),
                ),
                (0, _axiosErrorJsDefault.default).ERR_DEPRECATED,
              );
            if (version && !deprecatedWarnings[opt]) {
              deprecatedWarnings[opt] = true;
              // eslint-disable-next-line no-console
              console.warn(
                formatMessage(
                  opt,
                  " has been deprecated since v" +
                    version +
                    " and will be removed in the near future",
                ),
              );
            }
            return validator ? validator(value, opt, opts) : true;
          };
        };
        /**
         * Assert object's properties type
         *
         * @param {object} options
         * @param {object} schema
         * @param {boolean?} allowUnknown
         *
         * @returns {object}
         */ function assertOptions(options, schema, allowUnknown) {
          if (typeof options !== "object")
            throw new (0, _axiosErrorJsDefault.default)(
              "options must be an object",
              (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE,
            );
          const keys = Object.keys(options);
          let i = keys.length;
          while (i-- > 0) {
            const opt = keys[i];
            const validator = schema[opt];
            if (validator) {
              const value = options[opt];
              const result =
                value === undefined || validator(value, opt, options);
              if (result !== true)
                throw new (0, _axiosErrorJsDefault.default)(
                  "option " + opt + " must be " + result,
                  (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE,
                );
              continue;
            }
            if (allowUnknown !== true)
              throw new (0, _axiosErrorJsDefault.default)(
                "Unknown option " + opt,
                (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION,
              );
          }
        }
        exports.default = {
          assertOptions,
          validators,
        };
      },
      {
        "../env/data.js": "kWtyc",
        "../core/AxiosError.js": "bJPKW",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    kWtyc: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "VERSION", () => VERSION);
        const VERSION = "1.6.5";
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    d1HJ6: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _canceledErrorJs = require("./CanceledError.js");
        var _canceledErrorJsDefault =
          parcelHelpers.interopDefault(_canceledErrorJs);
        ("use strict");
        /**
         * A `CancelToken` is an object that can be used to request cancellation of an operation.
         *
         * @param {Function} executor The executor function.
         *
         * @returns {CancelToken}
         */ class CancelToken {
          constructor(executor) {
            if (typeof executor !== "function")
              throw new TypeError("executor must be a function.");
            let resolvePromise;
            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve;
            });
            const token = this;
            // eslint-disable-next-line func-names
            this.promise.then((cancel) => {
              if (!token._listeners) return;
              let i = token._listeners.length;
              while (i-- > 0) token._listeners[i](cancel);
              token._listeners = null;
            });
            // eslint-disable-next-line func-names
            this.promise.then = (onfulfilled) => {
              let _resolve;
              // eslint-disable-next-line func-names
              const promise = new Promise((resolve) => {
                token.subscribe(resolve);
                _resolve = resolve;
              }).then(onfulfilled);
              promise.cancel = function reject() {
                token.unsubscribe(_resolve);
              };
              return promise;
            };
            executor(function cancel(message, config, request) {
              if (token.reason)
                // Cancellation has already been requested
                return;
              token.reason = new (0, _canceledErrorJsDefault.default)(
                message,
                config,
                request,
              );
              resolvePromise(token.reason);
            });
          }
          /**
           * Throws a `CanceledError` if cancellation has been requested.
           */ throwIfRequested() {
            if (this.reason) throw this.reason;
          }
          /**
           * Subscribe to the cancel signal
           */ subscribe(listener) {
            if (this.reason) {
              listener(this.reason);
              return;
            }
            if (this._listeners) this._listeners.push(listener);
            else this._listeners = [listener];
          }
          /**
           * Unsubscribe from the cancel signal
           */ unsubscribe(listener) {
            if (!this._listeners) return;
            const index = this._listeners.indexOf(listener);
            if (index !== -1) this._listeners.splice(index, 1);
          }
          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */ static source() {
            let cancel;
            const token = new CancelToken(function executor(c) {
              cancel = c;
            });
            return {
              token,
              cancel,
            };
          }
        }
        exports.default = CancelToken;
      },
      {
        "./CanceledError.js": "5zKhr",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "8aHr9": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => spread);
        ("use strict");
        function spread(callback) {
          return function wrap(arr) {
            return callback.apply(null, arr);
          };
        }
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    eQ07D: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "default", () => isAxiosError);
        var _utilsJs = require("./../utils.js");
        var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
        ("use strict");
        function isAxiosError(payload) {
          return (
            (0, _utilsJsDefault.default).isObject(payload) &&
            payload.isAxiosError === true
          );
        }
      },
      {
        "./../utils.js": "gUZbi",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    fZZiR: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        const HttpStatusCode = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511,
        };
        Object.entries(HttpStatusCode).forEach(([key, value]) => {
          HttpStatusCode[value] = key;
        });
        exports.default = HttpStatusCode;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    "2hU5S": [
      function (require, module, exports) {
        /* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        const showAlert = (type, msg) => {
          hideAlert();
          const markup = `<div class="alert alert--${type}">${msg}</div>`;
          document
            .querySelector("body")
            .insertAdjacentHTML("afterbegin", markup);
          window.setTimeout(hideAlert, 5000);
        };
        const hideAlert = () => {
          const el = document.querySelector(".alert");
          if (el) el.parentElement.removeChild(el);
        };
        exports.default = showAlert;
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
    cfjWV: [
      function (require, module, exports) {
        /* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _mapboxGl = require("mapbox-gl");
        var _mapboxGlDefault = parcelHelpers.interopDefault(_mapboxGl);
        const displayMap = (locations) => {
          (0, _mapboxGlDefault.default).accessToken =
            "pk.eyJ1IjoiY3JpbXNvbjcyNSIsImEiOiJjbHJhNHY5NjYwYWx6MmxzNDFzZWx3YXZ2In0._YziQB9N2-pIPCK-SOTg_A";
          var map = new (0, _mapboxGlDefault.default).Map({
            container: "map",
            style: "mapbox://styles/crimson725/clra58mvq001q01rbeqt609ev",
            scrollZoom: false,
          });
          const bounds = new (0, _mapboxGlDefault.default).LngLatBounds();
          locations.forEach((loc) => {
            const el = document.createElement("div");
            el.className = "marker";
            new (0, _mapboxGlDefault.default).Marker({
              element: el,
              anchor: "bottom",
            })
              .setLngLat(loc.coordinates)
              .addTo(map);
            new (0, _mapboxGlDefault.default).Popup({
              offset: 30,
            })
              .setLngLat(loc.coordinates)
              .setHTML(`<p>Day ${loc.day}: ${loc.description}</p>`)
              .addTo(map);
            bounds.extend(loc.coordinates);
          });
          map.fitBounds(bounds, {
            padding: {
              top: 200,
              bottom: 150,
              left: 100,
              right: 100,
            },
          });
        };
        exports.default = displayMap;
      },
      {
        "mapbox-gl": "5M3zU",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    "5M3zU": [
      function (require, module, exports) {
        /* Mapbox GL JS is Copyright  2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function (
          global,
          factory,
        ) {
          module.exports = factory();
        })(this, function () {
          "use strict";
          /* eslint-disable */ var shared, worker, mapboxgl;
          // define gets called three times: one for each chunk. we rely on the order
          // they're imported to know which is which
          function define(_, chunk) {
            if (!shared) shared = chunk;
            else if (!worker) worker = chunk;
            else {
              var workerBundleString =
                "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" +
                shared +
                ")(sharedChunk); (" +
                worker +
                ")(sharedChunk); self.onerror = null;";
              var sharedChunk = {};
              shared(sharedChunk);
              mapboxgl = chunk(sharedChunk);
              if (
                typeof window !== "undefined" &&
                window &&
                window.URL &&
                window.URL.createObjectURL
              )
                mapboxgl.workerUrl = window.URL.createObjectURL(
                  new Blob([workerBundleString], {
                    type: "text/javascript",
                  }),
                );
            }
          }
          define(["exports"], function (e1) {
            "use strict";
            var t = "undefined" != typeof self ? self : {},
              i = "3.0.1";
            let r;
            const n = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                  if (null == r) {
                    const e1 =
                      /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                      r = e1;
                    } catch (t) {
                      r = e1;
                    }
                  }
                  return r;
                },
                get API_TILEJSON_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
                },
                get API_SPRITE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
                },
                get API_FONTS_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
                },
                get API_STYLE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
                },
                get API_CDN_URL_REGEX() {
                  return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
                },
                get EVENTS_URL() {
                  if (!n.API_URL) return null;
                  try {
                    const e1 = new URL(n.API_URL);
                    return "api.mapbox.cn" === e1.hostname
                      ? "https://events.mapbox.cn/events/v2"
                      : "api.mapbox.com" === e1.hostname
                      ? "https://events.mapbox.com/events/v2"
                      : null;
                  } catch (e1) {
                    return null;
                  }
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
                DRACO_URL:
                  "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
                GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
              },
              o = {
                supported: !1,
                testSupport: function (e1) {
                  !l && a && (c ? h(e1) : (s = e1));
                },
              };
            let s,
              a,
              l = !1,
              c = !1;
            function h(e1) {
              const t = e1.createTexture();
              e1.bindTexture(e1.TEXTURE_2D, t);
              try {
                if (
                  (e1.texImage2D(
                    e1.TEXTURE_2D,
                    0,
                    e1.RGBA,
                    e1.RGBA,
                    e1.UNSIGNED_BYTE,
                    a,
                  ),
                  e1.isContextLost())
                )
                  return;
                o.supported = !0;
              } catch (e1) {}
              e1.deleteTexture(t), (l = !0);
            }
            t.document &&
              ((a = t.document.createElement("img")),
              (a.onload = function () {
                s && h(s), (s = null), (c = !0);
              }),
              (a.onerror = function () {
                (l = !0), (s = null);
              }),
              (a.src =
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="));
            const u = "01";
            function d(e1) {
              return e1 &&
                e1.__esModule &&
                Object.prototype.hasOwnProperty.call(e1, "default")
                ? e1.default
                : e1;
            }
            var p = f;
            function f(e1, t, i, r) {
              (this.cx = 3 * e1),
                (this.bx = 3 * (i - e1) - this.cx),
                (this.ax = 1 - this.cx - this.bx),
                (this.cy = 3 * t),
                (this.by = 3 * (r - t) - this.cy),
                (this.ay = 1 - this.cy - this.by),
                (this.p1x = e1),
                (this.p1y = t),
                (this.p2x = i),
                (this.p2y = r);
            }
            f.prototype = {
              sampleCurveX: function (e1) {
                return ((this.ax * e1 + this.bx) * e1 + this.cx) * e1;
              },
              sampleCurveY: function (e1) {
                return ((this.ay * e1 + this.by) * e1 + this.cy) * e1;
              },
              sampleCurveDerivativeX: function (e1) {
                return (3 * this.ax * e1 + 2 * this.bx) * e1 + this.cx;
              },
              solveCurveX: function (e1, t) {
                if ((void 0 === t && (t = 1e-6), e1 < 0)) return 0;
                if (e1 > 1) return 1;
                for (var i = e1, r = 0; r < 8; r++) {
                  var n = this.sampleCurveX(i) - e1;
                  if (Math.abs(n) < t) return i;
                  var o = this.sampleCurveDerivativeX(i);
                  if (Math.abs(o) < 1e-6) break;
                  i -= n / o;
                }
                var s = 0,
                  a = 1;
                for (
                  i = e1, r = 0;
                  r < 20 &&
                  ((n = this.sampleCurveX(i)), !(Math.abs(n - e1) < t));
                  r++
                )
                  e1 > n ? (s = i) : (a = i), (i = 0.5 * (a - s) + s);
                return i;
              },
              solve: function (e1, t) {
                return this.sampleCurveY(this.solveCurveX(e1, t));
              },
            };
            var m = d(p),
              _ = g;
            function g(e1, t) {
              (this.x = e1), (this.y = t);
            }
            (g.prototype = {
              clone: function () {
                return new g(this.x, this.y);
              },
              add: function (e1) {
                return this.clone()._add(e1);
              },
              sub: function (e1) {
                return this.clone()._sub(e1);
              },
              multByPoint: function (e1) {
                return this.clone()._multByPoint(e1);
              },
              divByPoint: function (e1) {
                return this.clone()._divByPoint(e1);
              },
              mult: function (e1) {
                return this.clone()._mult(e1);
              },
              div: function (e1) {
                return this.clone()._div(e1);
              },
              rotate: function (e1) {
                return this.clone()._rotate(e1);
              },
              rotateAround: function (e1, t) {
                return this.clone()._rotateAround(e1, t);
              },
              matMult: function (e1) {
                return this.clone()._matMult(e1);
              },
              unit: function () {
                return this.clone()._unit();
              },
              perp: function () {
                return this.clone()._perp();
              },
              round: function () {
                return this.clone()._round();
              },
              mag: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              },
              equals: function (e1) {
                return this.x === e1.x && this.y === e1.y;
              },
              dist: function (e1) {
                return Math.sqrt(this.distSqr(e1));
              },
              distSqr: function (e1) {
                var t = e1.x - this.x,
                  i = e1.y - this.y;
                return t * t + i * i;
              },
              angle: function () {
                return Math.atan2(this.y, this.x);
              },
              angleTo: function (e1) {
                return Math.atan2(this.y - e1.y, this.x - e1.x);
              },
              angleWith: function (e1) {
                return this.angleWithSep(e1.x, e1.y);
              },
              angleWithSep: function (e1, t) {
                return Math.atan2(
                  this.x * t - this.y * e1,
                  this.x * e1 + this.y * t,
                );
              },
              _matMult: function (e1) {
                var t = e1[2] * this.x + e1[3] * this.y;
                return (
                  (this.x = e1[0] * this.x + e1[1] * this.y), (this.y = t), this
                );
              },
              _add: function (e1) {
                return (this.x += e1.x), (this.y += e1.y), this;
              },
              _sub: function (e1) {
                return (this.x -= e1.x), (this.y -= e1.y), this;
              },
              _mult: function (e1) {
                return (this.x *= e1), (this.y *= e1), this;
              },
              _div: function (e1) {
                return (this.x /= e1), (this.y /= e1), this;
              },
              _multByPoint: function (e1) {
                return (this.x *= e1.x), (this.y *= e1.y), this;
              },
              _divByPoint: function (e1) {
                return (this.x /= e1.x), (this.y /= e1.y), this;
              },
              _unit: function () {
                return this._div(this.mag()), this;
              },
              _perp: function () {
                var e1 = this.y;
                return (this.y = this.x), (this.x = -e1), this;
              },
              _rotate: function (e1) {
                var t = Math.cos(e1),
                  i = Math.sin(e1),
                  r = i * this.x + t * this.y;
                return (this.x = t * this.x - i * this.y), (this.y = r), this;
              },
              _rotateAround: function (e1, t) {
                var i = Math.cos(e1),
                  r = Math.sin(e1),
                  n = t.y + r * (this.x - t.x) + i * (this.y - t.y);
                return (
                  (this.x = t.x + i * (this.x - t.x) - r * (this.y - t.y)),
                  (this.y = n),
                  this
                );
              },
              _round: function () {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              },
            }),
              (g.convert = function (e1) {
                return e1 instanceof g
                  ? e1
                  : Array.isArray(e1)
                  ? new g(e1[0], e1[1])
                  : e1;
              });
            var y = d(_);
            function x(e1, t) {
              if (Array.isArray(e1)) {
                if (!Array.isArray(t) || e1.length !== t.length) return !1;
                for (let i = 0; i < e1.length; i++)
                  if (!x(e1[i], t[i])) return !1;
                return !0;
              }
              if ("object" == typeof e1 && null !== e1 && null !== t) {
                if ("object" != typeof t) return !1;
                if (Object.keys(e1).length !== Object.keys(t).length) return !1;
                for (const i in e1) if (!x(e1[i], t[i])) return !1;
                return !0;
              }
              return e1 === t;
            }
            const v = Math.PI / 180,
              b = 180 / Math.PI;
            function w(e1) {
              return e1 * v;
            }
            function T(e1) {
              return e1 * b;
            }
            const E = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            function M(e1) {
              if (e1 <= 0) return 0;
              if (e1 >= 1) return 1;
              const t = e1 * e1,
                i = t * e1;
              return 4 * (e1 < 0.5 ? i : 3 * (e1 - t) + i - 0.75);
            }
            function A(e1) {
              let t = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                n = -1 / 0;
              for (const o of e1)
                (t = Math.min(t, o.x)),
                  (i = Math.min(i, o.y)),
                  (r = Math.max(r, o.x)),
                  (n = Math.max(n, o.y));
              return {
                min: new y(t, i),
                max: new y(r, n),
              };
            }
            function S(e1, t, i = 0, r = !0) {
              const n = new y(i, i),
                o = e1.sub(n),
                s = t.add(n),
                a = [o, new y(s.x, o.y), s, new y(o.x, s.y)];
              return r && a.push(o.clone()), a;
            }
            function I(e1, t, i, r) {
              const n = new m(e1, t, i, r);
              return function (e1) {
                return n.solve(e1);
              };
            }
            const C = I(0.25, 0.1, 0.25, 1);
            function z(e1, t, i) {
              return Math.min(i, Math.max(t, e1));
            }
            function D(e1, t, i) {
              return (i = z((i - e1) / (t - e1), 0, 1)) * i * (3 - 2 * i);
            }
            function P(e1, t, i) {
              const r = i - t,
                n = ((((e1 - t) % r) + r) % r) + t;
              return n === t ? i : n;
            }
            function R(e1, t, i) {
              if (!e1.length) return i(null, []);
              let r = e1.length;
              const n = new Array(e1.length);
              let o = null;
              e1.forEach((e1, s) => {
                t(e1, (e1, t) => {
                  e1 && (o = e1), (n[s] = t), 0 == --r && i(o, n);
                });
              });
            }
            function L(e1) {
              const t = [];
              for (const i in e1) t.push(e1[i]);
              return t;
            }
            function k(e1, ...t) {
              for (const i of t) for (const t in i) e1[t] = i[t];
              return e1;
            }
            function O(e1, t) {
              const i = {};
              for (let r = 0; r < t.length; r++) {
                const n = t[r];
                n in e1 && (i[n] = e1[n]);
              }
              return i;
            }
            let B = 1;
            function F() {
              return B++;
            }
            function N() {
              return (function e1(t) {
                return t
                  ? (t ^ (Math.random() * (16 >> (t / 4)))).toString(16)
                  : ([1e7] + -[1e3] + -4000 + -8000 + -100000000000).replace(
                      /[018]/g,
                      e1,
                    );
              })();
            }
            function U(e1) {
              return e1 <= 1
                ? 1
                : Math.pow(2, Math.ceil(Math.log(e1) / Math.LN2));
            }
            function V(e1) {
              return (
                !!e1 &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                  e1,
                )
              );
            }
            function j(e1, t) {
              e1.forEach((e1) => {
                t[e1] && (t[e1] = t[e1].bind(t));
              });
            }
            function G(e1, t) {
              return -1 !== e1.indexOf(t, e1.length - t.length);
            }
            function q(e1, t, i) {
              const r = {};
              for (const n in e1) r[n] = t.call(i || this, e1[n], n, e1);
              return r;
            }
            function Z(e1, t, i) {
              const r = {};
              for (const n in e1)
                t.call(i || this, e1[n], n, e1) && (r[n] = e1[n]);
              return r;
            }
            function $(e1) {
              return Array.isArray(e1)
                ? e1.map($)
                : "object" == typeof e1 && e1
                ? q(e1, $)
                : e1;
            }
            const H = {};
            function W(e1) {
              H[e1] ||
                ("undefined" != typeof console && console.warn(e1),
                (H[e1] = !0));
            }
            function X(e1, t, i) {
              return (i.y - e1.y) * (t.x - e1.x) > (t.y - e1.y) * (i.x - e1.x);
            }
            function Y(e1) {
              let t = 0;
              for (let i, r, n = 0, o = e1.length, s = o - 1; n < o; s = n++)
                (i = e1[n]), (r = e1[s]), (t += (r.x - i.x) * (i.y + r.y));
              return t;
            }
            function K([e1, t, i]) {
              const r = w(t + 90),
                n = w(i);
              return {
                x: e1 * Math.cos(r) * Math.sin(n),
                y: e1 * Math.sin(r) * Math.sin(n),
                z: e1 * Math.cos(n),
                azimuthal: t,
                polar: i,
              };
            }
            function J(e1, t, i) {
              const r = Math.sqrt(e1 * e1 + t * t + i * i),
                n = r > 0 ? Math.acos(i / r) * b : 0;
              let o = 0 !== e1 || 0 !== t ? Math.atan2(-t, -e1) * b + 90 : 0;
              return o < 0 && (o += 360), [r, o, n];
            }
            function Q() {
              return (
                "undefined" != typeof WorkerGlobalScope &&
                "undefined" != typeof self &&
                self instanceof WorkerGlobalScope
              );
            }
            function ee(e1) {
              const t = {};
              if (
                (e1.replace(
                  /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                  (e1, i, r, n) => {
                    const o = r || n;
                    return (t[i] = !o || o.toLowerCase()), "";
                  },
                ),
                t["max-age"])
              ) {
                const e1 = parseInt(t["max-age"], 10);
                isNaN(e1) ? delete t["max-age"] : (t["max-age"] = e1);
              }
              return t;
            }
            let te = null;
            function ie() {
              return (
                !!t.document.fullscreenElement ||
                !!t.document.webkitFullscreenElement
              );
            }
            function re(e1) {
              try {
                const i = t[e1];
                return (
                  i.setItem("_mapbox_test_", 1),
                  i.removeItem("_mapbox_test_"),
                  !0
                );
              } catch (e1) {
                return !1;
              }
            }
            function ne(e1, t) {
              return [e1[4 * t], e1[4 * t + 1], e1[4 * t + 2], e1[4 * t + 3]];
            }
            function oe(e1, t, i) {
              (e1[4 * t + 0] = i[0]),
                (e1[4 * t + 1] = i[1]),
                (e1[4 * t + 2] = i[2]),
                (e1[4 * t + 3] = i[3]);
            }
            function se(e1, t) {
              return [
                Math.pow(e1[0], 2.2) * t,
                Math.pow(e1[1], 2.2) * t,
                Math.pow(e1[2], 2.2) * t,
              ];
            }
            function ae(e1) {
              return [
                Math.pow(e1[0], 1 / 2.2),
                Math.pow(e1[1], 1 / 2.2),
                Math.pow(e1[2], 1 / 2.2),
              ];
            }
            const le = "mapbox-tiles";
            let ce = 500,
              he = 50;
            let ue, de;
            function pe() {
              try {
                return t.caches;
              } catch (e1) {}
            }
            function fe() {
              pe() && !ue && (ue = t.caches.open(le));
            }
            function me(e1) {
              const t = e1.indexOf("?");
              if (t < 0) return e1;
              const i = (function (e1) {
                  const t = e1.indexOf("?");
                  return t > 0 ? e1.slice(t + 1).split("&") : [];
                })(e1),
                r = i.filter((e1) => {
                  const t = e1.split("=");
                  return "language" === t[0] || "worldview" === t[0];
                });
              return r.length
                ? `${e1.slice(0, t)}?${r.join("&")}`
                : e1.slice(0, t);
            }
            let _e = 1 / 0;
            function ge(e1) {
              _e++,
                _e > he &&
                  (e1.getActor().send("enforceCacheSizeLimit", ce), (_e = 0));
            }
            const ye = {
              Unknown: "Unknown",
              Style: "Style",
              Source: "Source",
              Tile: "Tile",
              Glyphs: "Glyphs",
              SpriteImage: "SpriteImage",
              SpriteJSON: "SpriteJSON",
              Image: "Image",
              Model: "Model",
            };
            "function" == typeof Object.freeze && Object.freeze(ye);
            class xe extends Error {
              constructor(e1, t, i) {
                401 === t &&
                  Pe(i) &&
                  (e1 +=
                    ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                  super(e1),
                  (this.status = t),
                  (this.url = i);
              }
              toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
              }
            }
            const ve = Q()
              ? () => self.worker && self.worker.referrer
              : () =>
                  ("blob:" === t.location.protocol ? t.parent : t).location
                    .href;
            const be = function (e1, i) {
                if (
                  !(
                    /^file:/.test((r = e1.url)) ||
                    (/^file:/.test(ve()) && !/^\w+:/.test(r))
                  )
                ) {
                  if (
                    t.fetch &&
                    t.Request &&
                    t.AbortController &&
                    t.Request.prototype.hasOwnProperty("signal")
                  )
                    return (function (e1, i) {
                      const r = new t.AbortController(),
                        n = new t.Request(e1.url, {
                          method: e1.method || "GET",
                          body: e1.body,
                          credentials: e1.credentials,
                          headers: e1.headers,
                          referrer: ve(),
                          referrerPolicy: e1.referrerPolicy,
                          signal: r.signal,
                        });
                      let o = !1,
                        s = !1;
                      const a = (l = n.url).indexOf("sku=") > 0 && Pe(l);
                      var l;
                      "json" === e1.type &&
                        n.headers.set("Accept", "application/json");
                      const c = (r, o, l) => {
                          if (s) return;
                          if (
                            (r &&
                              "SecurityError" !== r.message &&
                              W(r.toString()),
                            o && l)
                          )
                            return h(o);
                          const c = Date.now();
                          t.fetch(n)
                            .then((t) => {
                              if (t.ok) {
                                const e1 = a ? t.clone() : null;
                                return h(t, e1, c);
                              }
                              return i(new xe(t.statusText, t.status, e1.url));
                            })
                            .catch((t) => {
                              "AbortError" !== t.name &&
                                i(new Error(`${t.message} ${e1.url}`));
                            });
                        },
                        h = (r, a, l) => {
                          ("arrayBuffer" === e1.type
                            ? r.arrayBuffer()
                            : "json" === e1.type
                            ? r.json()
                            : r.text()
                          )
                            .then((e1) => {
                              s ||
                                (a &&
                                  l &&
                                  (function (e1, i, r) {
                                    if ((fe(), !ue)) return;
                                    const n = {
                                      status: i.status,
                                      statusText: i.statusText,
                                      headers: new t.Headers(),
                                    };
                                    i.headers.forEach((e1, t) =>
                                      n.headers.set(t, e1),
                                    );
                                    const o = ee(
                                      i.headers.get("Cache-Control") || "",
                                    );
                                    if (o["no-store"]) return;
                                    o["max-age"] &&
                                      n.headers.set(
                                        "Expires",
                                        new Date(
                                          r + 1e3 * o["max-age"],
                                        ).toUTCString(),
                                      );
                                    const s = n.headers.get("Expires");
                                    s &&
                                      (new Date(s).getTime() - r < 42e4 ||
                                        (function (e1, t) {
                                          if (void 0 === de)
                                            try {
                                              new Response(
                                                new ReadableStream(),
                                              ),
                                                (de = !0);
                                            } catch (e1) {
                                              de = !1;
                                            }
                                          de ? t(e1.body) : e1.blob().then(t);
                                        })(i, (i) => {
                                          const r = new t.Response(i, n);
                                          fe(),
                                            ue &&
                                              ue
                                                .then((t) =>
                                                  t.put(me(e1.url), r),
                                                )
                                                .catch((e1) => W(e1.message));
                                        }));
                                  })(n, a, l),
                                (o = !0),
                                i(
                                  null,
                                  e1,
                                  r.headers.get("Cache-Control"),
                                  r.headers.get("Expires"),
                                ));
                            })
                            .catch((e1) => {
                              s || i(new Error(e1.message));
                            });
                        };
                      return (
                        a
                          ? (function (e1, t) {
                              if ((fe(), !ue)) return t(null);
                              const i = me(e1.url);
                              ue.then((e1) => {
                                e1.match(i)
                                  .then((r) => {
                                    const n = (function (e1) {
                                      if (!e1) return !1;
                                      const t = new Date(
                                          e1.headers.get("Expires") || 0,
                                        ),
                                        i = ee(
                                          e1.headers.get("Cache-Control") || "",
                                        );
                                      return t > Date.now() && !i["no-cache"];
                                    })(r);
                                    e1.delete(i),
                                      n && e1.put(i, r.clone()),
                                      t(null, r, n);
                                  })
                                  .catch(t);
                              }).catch(t);
                            })(n, c)
                          : c(null, null),
                        {
                          cancel: () => {
                            (s = !0), o || r.abort();
                          },
                        }
                      );
                    })(e1, i);
                  if (Q() && self.worker && self.worker.actor)
                    return self.worker.actor.send(
                      "getResource",
                      e1,
                      i,
                      void 0,
                      !0,
                    );
                }
                var r;
                return (function (e1, i) {
                  const r = new t.XMLHttpRequest();
                  r.open(e1.method || "GET", e1.url, !0),
                    "arrayBuffer" === e1.type &&
                      (r.responseType = "arraybuffer");
                  for (const t in e1.headers)
                    r.setRequestHeader(t, e1.headers[t]);
                  return (
                    "json" === e1.type &&
                      ((r.responseType = "text"),
                      r.setRequestHeader("Accept", "application/json")),
                    (r.withCredentials = "include" === e1.credentials),
                    (r.onerror = () => {
                      i(new Error(r.statusText));
                    }),
                    (r.onload = () => {
                      if (
                        ((r.status >= 200 && r.status < 300) ||
                          0 === r.status) &&
                        null !== r.response
                      ) {
                        let t = r.response;
                        if ("json" === e1.type)
                          try {
                            t = JSON.parse(r.response);
                          } catch (e1) {
                            return i(e1);
                          }
                        i(
                          null,
                          t,
                          r.getResponseHeader("Cache-Control"),
                          r.getResponseHeader("Expires"),
                        );
                      } else i(new xe(r.statusText, r.status, e1.url));
                    }),
                    r.send(e1.body),
                    {
                      cancel: () => r.abort(),
                    }
                  );
                })(e1, i);
              },
              we = function (e1, t) {
                return be(
                  k(e1, {
                    type: "json",
                  }),
                  t,
                );
              },
              Te = function (e1, t) {
                return be(
                  k(e1, {
                    type: "arrayBuffer",
                  }),
                  t,
                );
              };
            function Ee(e1) {
              const i = t.document.createElement("a");
              return (
                (i.href = e1),
                i.protocol === t.document.location.protocol &&
                  i.host === t.document.location.host
              );
            }
            const Me =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let Ae, Se;
            (Ae = []), (Se = 0);
            const Ie = function (e1, i) {
                if (
                  (o.supported &&
                    (e1.headers || (e1.headers = {}),
                    (e1.headers.accept = "image/webp,*/*")),
                  Se >= n.MAX_PARALLEL_IMAGE_REQUESTS)
                ) {
                  const t = {
                    requestParameters: e1,
                    callback: i,
                    cancelled: !1,
                    cancel() {
                      this.cancelled = !0;
                    },
                  };
                  return Ae.push(t), t;
                }
                Se++;
                let r = !1;
                const s = () => {
                    if (!r)
                      for (
                        r = !0, Se--;
                        Ae.length && Se < n.MAX_PARALLEL_IMAGE_REQUESTS;

                      ) {
                        const e1 = Ae.shift(),
                          {
                            requestParameters: t,
                            callback: i,
                            cancelled: r,
                          } = e1;
                        r || (e1.cancel = Ie(t, i).cancel);
                      }
                  },
                  a = Te(e1, (e1, r, n, o) => {
                    s(),
                      e1
                        ? i(e1)
                        : r &&
                          (t.createImageBitmap
                            ? (function (e1, i) {
                                const r = new t.Blob([new Uint8Array(e1)], {
                                  type: "image/png",
                                });
                                t.createImageBitmap(r)
                                  .then((e1) => {
                                    i(null, e1);
                                  })
                                  .catch((e1) => {
                                    i(
                                      new Error(
                                        `Could not load image because of ${e1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`,
                                      ),
                                    );
                                  });
                              })(r, (e1, t) => i(e1, t, n, o))
                            : (function (e1, i) {
                                const r = new t.Image(),
                                  n = t.URL;
                                (r.onload = () => {
                                  i(null, r),
                                    n.revokeObjectURL(r.src),
                                    (r.onload = null),
                                    t.requestAnimationFrame(() => {
                                      r.src = Me;
                                    });
                                }),
                                  (r.onerror = () =>
                                    i(
                                      new Error(
                                        "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.",
                                      ),
                                    ));
                                const o = new t.Blob([new Uint8Array(e1)], {
                                  type: "image/png",
                                });
                                r.src = e1.byteLength
                                  ? n.createObjectURL(o)
                                  : Me;
                              })(r, (e1, t) => i(e1, t, n, o)));
                  });
                return {
                  cancel: () => {
                    a.cancel(), s();
                  },
                };
              },
              Ce = "NO_ACCESS_TOKEN";
            class ze {
              constructor(e1, t, i) {
                (this._transformRequestFn = e1),
                  (this._customAccessToken = t),
                  (this._silenceAuthErrors = !!i),
                  this._createSkuToken();
              }
              _createSkuToken() {
                const e1 = (function () {
                  let e1 = "";
                  for (let t = 0; t < 10; t++)
                    e1 +=
                      "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[
                        Math.floor(62 * Math.random())
                      ];
                  return {
                    token: ["1", u, e1].join(""),
                    tokenExpiresAt: Date.now() + 432e5,
                  };
                })();
                (this._skuToken = e1.token),
                  (this._skuTokenExpiresAt = e1.tokenExpiresAt);
              }
              _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
              }
              transformRequest(e1, t) {
                return (
                  (this._transformRequestFn &&
                    this._transformRequestFn(e1, t)) || {
                    url: e1,
                  }
                );
              }
              normalizeStyleURL(e1, t) {
                if (!De(e1)) return e1;
                const r = Be(e1);
                return (
                  r.params.push(`sdk=js-${i}`),
                  (r.path = `/styles/v1${r.path}`),
                  this._makeAPIURL(r, this._customAccessToken || t)
                );
              }
              normalizeGlyphsURL(e1, t) {
                if (!De(e1)) return e1;
                const i = Be(e1);
                return (
                  (i.path = `/fonts/v1${i.path}`),
                  this._makeAPIURL(i, this._customAccessToken || t)
                );
              }
              normalizeModelURL(e1, t) {
                if (!De(e1)) return e1;
                const i = Be(e1);
                return (
                  (i.path = `/models/v1${i.path}`),
                  this._makeAPIURL(i, this._customAccessToken || t)
                );
              }
              normalizeSourceURL(e1, t, i, r) {
                if (!De(e1)) return e1;
                const n = Be(e1);
                return (
                  (n.path = `/v4/${n.authority}.json`),
                  n.params.push("secure"),
                  i && n.params.push(`language=${i}`),
                  r && n.params.push(`worldview=${r}`),
                  this._makeAPIURL(n, this._customAccessToken || t)
                );
              }
              normalizeSpriteURL(e1, t, i, r) {
                const n = Be(e1);
                return De(e1)
                  ? ((n.path = `/styles/v1${n.path}/sprite${t}${i}`),
                    this._makeAPIURL(n, this._customAccessToken || r))
                  : ((n.path += `${t}${i}`), Fe(n));
              }
              normalizeTileURL(e1, t, i) {
                if (
                  (this._isSkuTokenExpired() && this._createSkuToken(),
                  e1 && !De(e1))
                )
                  return e1;
                const r = Be(e1);
                (r.path = r.path.replace(
                  /(\.(png|jpg)\d*)(?=$)/,
                  `${
                    t || (i && "raster" !== r.authority && 512 === i)
                      ? "@2x"
                      : ""
                  }${o.supported ? ".webp" : "$1"}`,
                )),
                  "raster" === r.authority
                    ? (r.path = `/${n.RASTER_URL_PREFIX}${r.path}`)
                    : ((r.path = r.path.replace(/^.+\/v4\//, "/")),
                      (r.path = `/${n.TILE_URL_VERSION}${r.path}`));
                const s =
                  this._customAccessToken ||
                  (function (e1) {
                    for (const t of e1) {
                      const e1 = t.match(/^access_token=(.*)$/);
                      if (e1) return e1[1];
                    }
                    return null;
                  })(r.params) ||
                  n.ACCESS_TOKEN;
                return (
                  n.REQUIRE_ACCESS_TOKEN &&
                    s &&
                    this._skuToken &&
                    r.params.push(`sku=${this._skuToken}`),
                  this._makeAPIURL(r, s)
                );
              }
              canonicalizeTileURL(e1, t) {
                const i = Be(e1);
                if (
                  !i.path.match(/^(\/v4\/|\/raster\/v1\/)/) ||
                  !i.path.match(/\.[\w]+$/)
                )
                  return e1;
                let r = "mapbox://";
                i.path.match(/^\/raster\/v1\//)
                  ? (r += `raster/${i.path.replace(
                      `/${n.RASTER_URL_PREFIX}/`,
                      "",
                    )}`)
                  : (r += `tiles/${i.path.replace(
                      `/${n.TILE_URL_VERSION}/`,
                      "",
                    )}`);
                let o = i.params;
                return (
                  t && (o = o.filter((e1) => !e1.match(/^access_token=/))),
                  o.length && (r += `?${o.join("&")}`),
                  r
                );
              }
              canonicalizeTileset(e1, t) {
                const i = !!t && De(t),
                  r = [];
                for (const t of e1.tiles || [])
                  Pe(t) ? r.push(this.canonicalizeTileURL(t, i)) : r.push(t);
                return r;
              }
              _makeAPIURL(e1, t) {
                const i =
                    "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                  r = Be(n.API_URL);
                if (
                  ((e1.protocol = r.protocol),
                  (e1.authority = r.authority),
                  "http" === e1.protocol)
                ) {
                  const t = e1.params.indexOf("secure");
                  t >= 0 && e1.params.splice(t, 1);
                }
                if (
                  ("/" !== r.path && (e1.path = `${r.path}${e1.path}`),
                  !n.REQUIRE_ACCESS_TOKEN)
                )
                  return Fe(e1);
                if (((t = t || n.ACCESS_TOKEN), !this._silenceAuthErrors)) {
                  if (!t)
                    throw new Error(
                      `An API access token is required to use Mapbox GL. ${i}`,
                    );
                  if ("s" === t[0])
                    throw new Error(
                      `Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i}`,
                    );
                }
                return (
                  (e1.params = e1.params.filter(
                    (e1) => -1 === e1.indexOf("access_token"),
                  )),
                  e1.params.push(`access_token=${t || ""}`),
                  Fe(e1)
                );
              }
            }
            function De(e1) {
              return 0 === e1.indexOf("mapbox:");
            }
            function Pe(e1) {
              return n.API_URL_REGEX.test(e1);
            }
            function Re(e1) {
              return n.API_CDN_URL_REGEX.test(e1);
            }
            function Le(e1) {
              return n.API_STYLE_REGEX.test(e1) && !ke(e1);
            }
            function ke(e1) {
              return n.API_SPRITE_REGEX.test(e1);
            }
            const Oe = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function Be(e1) {
              const t = e1.match(Oe);
              if (!t) throw new Error("Unable to parse URL object");
              return {
                protocol: t[1],
                authority: t[2],
                path: t[3] || "/",
                params: t[4] ? t[4].split("&") : [],
              };
            }
            function Fe(e1) {
              const t = e1.params.length ? `?${e1.params.join("&")}` : "";
              return `${e1.protocol}://${e1.authority}${e1.path}${t}`;
            }
            const Ne = "mapbox.eventData";
            function Ue(e1) {
              if (!e1) return null;
              const i = e1.split(".");
              if (!i || 3 !== i.length) return null;
              try {
                return JSON.parse(
                  decodeURIComponent(
                    t
                      .atob(i[1])
                      .split("")
                      .map(
                        (e1) =>
                          "%" +
                          ("00" + e1.charCodeAt(0).toString(16)).slice(-2),
                      )
                      .join(""),
                  ),
                );
              } catch (e1) {
                return null;
              }
            }
            class Ve {
              constructor(e1) {
                (this.type = e1),
                  (this.anonId = null),
                  (this.eventData = {}),
                  (this.queue = []),
                  (this.pendingRequest = null);
              }
              getStorageKey(e1) {
                const i = Ue(n.ACCESS_TOKEN);
                let r = "";
                return (
                  (r =
                    i && i.u
                      ? t.btoa(
                          encodeURIComponent(i.u).replace(
                            /%([0-9A-F]{2})/g,
                            (e1, t) => String.fromCharCode(Number("0x" + t)),
                          ),
                        )
                      : n.ACCESS_TOKEN || ""),
                  e1 ? `${Ne}.${e1}:${r}` : `${Ne}:${r}`
                );
              }
              fetchEventData() {
                const e1 = re("localStorage"),
                  i = this.getStorageKey(),
                  r = this.getStorageKey("uuid");
                if (e1)
                  try {
                    const e1 = t.localStorage.getItem(i);
                    e1 && (this.eventData = JSON.parse(e1));
                    const n = t.localStorage.getItem(r);
                    n && (this.anonId = n);
                  } catch (e1) {
                    W("Unable to read from LocalStorage");
                  }
              }
              saveEventData() {
                const e1 = re("localStorage"),
                  i = this.getStorageKey(),
                  r = this.getStorageKey("uuid");
                if (e1)
                  try {
                    t.localStorage.setItem(r, this.anonId),
                      Object.keys(this.eventData).length >= 1 &&
                        t.localStorage.setItem(
                          i,
                          JSON.stringify(this.eventData),
                        );
                  } catch (e1) {
                    W("Unable to write to LocalStorage");
                  }
              }
              processRequests(e1) {}
              postEvent(e1, t, i, r) {
                if (!n.EVENTS_URL) return;
                const o = Be(n.EVENTS_URL);
                o.params.push(`access_token=${r || n.ACCESS_TOKEN || ""}`);
                const s = {
                    event: this.type,
                    created: new Date(e1).toISOString(),
                  },
                  a = t ? k(s, t) : s,
                  l = {
                    url: Fe(o),
                    headers: {
                      "Content-Type": "text/plain",
                    },
                    body: JSON.stringify([a]),
                  };
                this.pendingRequest = (function (e1, t) {
                  return be(
                    k(e1, {
                      method: "POST",
                    }),
                    t,
                  );
                })(l, (e1) => {
                  (this.pendingRequest = null),
                    i(e1),
                    this.saveEventData(),
                    this.processRequests(r);
                });
              }
              queueRequest(e1, t) {
                this.queue.push(e1), this.processRequests(t);
              }
            }
            const je = new (class extends Ve {
                constructor(e1) {
                  super("appUserTurnstile"), (this._customAccessToken = e1);
                }
                postTurnstileEvent(e1, t) {
                  n.EVENTS_URL &&
                    n.ACCESS_TOKEN &&
                    Array.isArray(e1) &&
                    e1.some((e1) => De(e1) || Pe(e1)) &&
                    this.queueRequest(Date.now(), t);
                }
                processRequests(e1) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  (this.anonId &&
                    this.eventData.lastSuccess &&
                    this.eventData.tokenU) ||
                    this.fetchEventData();
                  const t = Ue(n.ACCESS_TOKEN),
                    r = t ? t.u : n.ACCESS_TOKEN;
                  let o = r !== this.eventData.tokenU;
                  V(this.anonId) || ((this.anonId = N()), (o = !0));
                  const s = this.queue.shift();
                  if (this.eventData.lastSuccess) {
                    const e1 = new Date(this.eventData.lastSuccess),
                      t = new Date(s),
                      i = (s - this.eventData.lastSuccess) / 864e5;
                    o = o || i >= 1 || i < -1 || e1.getDate() !== t.getDate();
                  } else o = !0;
                  o
                    ? this.postEvent(
                        s,
                        {
                          sdkIdentifier: "mapbox-gl-js",
                          sdkVersion: i,
                          skuId: u,
                          "enabled.telemetry": !1,
                          userId: this.anonId,
                        },
                        (e1) => {
                          e1 ||
                            ((this.eventData.lastSuccess = s),
                            (this.eventData.tokenU = r));
                        },
                        e1,
                      )
                    : this.processRequests();
                }
              })(),
              Ge = je.postTurnstileEvent.bind(je),
              qe = new (class extends Ve {
                constructor() {
                  super("map.load"), (this.success = {}), (this.skuToken = "");
                }
                postMapLoadEvent(e1, t, i, r) {
                  (this.skuToken = t),
                    (this.errorCb = r),
                    n.EVENTS_URL &&
                      (i || n.ACCESS_TOKEN
                        ? this.queueRequest(
                            {
                              id: e1,
                              timestamp: Date.now(),
                            },
                            i,
                          )
                        : this.errorCb(new Error(Ce)));
                }
                processRequests(e1) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: t, timestamp: r } = this.queue.shift();
                  (t && this.success[t]) ||
                    (this.anonId || this.fetchEventData(),
                    V(this.anonId) || (this.anonId = N()),
                    this.postEvent(
                      r,
                      {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: i,
                        skuId: u,
                        skuToken: this.skuToken,
                        userId: this.anonId,
                      },
                      (e1) => {
                        e1 ? this.errorCb(e1) : t && (this.success[t] = !0);
                      },
                      e1,
                    ));
                }
              })(),
              Ze = qe.postMapLoadEvent.bind(qe),
              $e = new (class extends Ve {
                constructor() {
                  super("gljs.performance");
                }
                postPerformanceEvent(e1, t) {
                  n.EVENTS_URL &&
                    (e1 || n.ACCESS_TOKEN) &&
                    this.queueRequest(
                      {
                        timestamp: Date.now(),
                        performanceData: t,
                      },
                      e1,
                    );
                }
                processRequests(e1) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { timestamp: r, performanceData: n } =
                      this.queue.shift(),
                    o = (function (e1) {
                      const r = t.performance.getEntriesByType("resource"),
                        n = t.performance.getEntriesByType("mark"),
                        o = (function (e1) {
                          const t = {};
                          if (e1) {
                            for (const i in e1)
                              if ("other" !== i)
                                for (const r of e1[i]) {
                                  const e1 = `${i}ResolveRangeMin`,
                                    n = `${i}ResolveRangeMax`,
                                    o = `${i}RequestCount`,
                                    s = `${i}RequestCachedCount`;
                                  (t[e1] = Math.min(
                                    t[e1] || 1 / 0,
                                    r.startTime,
                                  )),
                                    (t[n] = Math.max(
                                      t[n] || -1 / 0,
                                      r.responseEnd,
                                    ));
                                  const a = (e1) => {
                                    void 0 === t[e1] && (t[e1] = 0), ++t[e1];
                                  };
                                  void 0 !== r.transferSize &&
                                    0 === r.transferSize &&
                                    a(s),
                                    a(o);
                                }
                          }
                          return t;
                        })(
                          (function (e1, t) {
                            const i = {};
                            if (e1)
                              for (const r of e1) {
                                const e1 = t(r);
                                void 0 === i[e1] && (i[e1] = []), i[e1].push(r);
                              }
                            return i;
                          })(r, et),
                        ),
                        s = t.devicePixelRatio,
                        a =
                          t.navigator.connection ||
                          t.navigator.mozConnection ||
                          t.navigator.webkitConnection,
                        l = {
                          counters: [],
                          metadata: [],
                          attributes: [],
                        },
                        c = (e1, t, i) => {
                          null != i &&
                            e1.push({
                              name: t,
                              value: i.toString(),
                            });
                        };
                      for (const e1 in o) c(l.counters, e1, o[e1]);
                      if (
                        (e1.interactionRange[0] !== 1 / 0 &&
                          e1.interactionRange[1] !== -1 / 0 &&
                          (c(
                            l.counters,
                            "interactionRangeMin",
                            e1.interactionRange[0],
                          ),
                          c(
                            l.counters,
                            "interactionRangeMax",
                            e1.interactionRange[1],
                          )),
                        n)
                      )
                        for (const e1 of Object.keys(Je)) {
                          const t = Je[e1],
                            i = n.find((e1) => e1.name === t);
                          i && c(l.counters, t, i.startTime);
                        }
                      return (
                        c(l.counters, "visibilityHidden", e1.visibilityHidden),
                        c(
                          l.attributes,
                          "style",
                          (function (e1) {
                            if (e1)
                              for (const t of e1) {
                                const e1 = t.name.split("?")[0];
                                if (Le(e1)) {
                                  const t = e1.split("/").slice(-2);
                                  if (2 === t.length)
                                    return `mapbox://styles/${t[0]}/${t[1]}`;
                                }
                              }
                          })(r),
                        ),
                        c(
                          l.attributes,
                          "terrainEnabled",
                          e1.terrainEnabled ? "true" : "false",
                        ),
                        c(
                          l.attributes,
                          "fogEnabled",
                          e1.fogEnabled ? "true" : "false",
                        ),
                        c(l.attributes, "projection", e1.projection),
                        c(l.attributes, "zoom", e1.zoom),
                        c(l.metadata, "devicePixelRatio", s),
                        c(
                          l.metadata,
                          "connectionEffectiveType",
                          a ? a.effectiveType : void 0,
                        ),
                        c(
                          l.metadata,
                          "navigatorUserAgent",
                          t.navigator.userAgent,
                        ),
                        c(l.metadata, "screenWidth", t.screen.width),
                        c(l.metadata, "screenHeight", t.screen.height),
                        c(l.metadata, "windowWidth", t.innerWidth),
                        c(l.metadata, "windowHeight", t.innerHeight),
                        c(l.metadata, "mapWidth", e1.width / s),
                        c(l.metadata, "mapHeight", e1.height / s),
                        c(l.metadata, "webglRenderer", e1.renderer),
                        c(l.metadata, "webglVendor", e1.vendor),
                        c(l.metadata, "sdkVersion", i),
                        c(l.metadata, "sdkIdentifier", "mapbox-gl-js"),
                        l
                      );
                    })(n);
                  for (const e1 of o.metadata);
                  for (const e1 of o.counters);
                  for (const e1 of o.attributes);
                  this.postEvent(r, o, () => {}, e1);
                }
              })(),
              He = $e.postPerformanceEvent.bind($e),
              We = new (class extends Ve {
                constructor() {
                  super("map.auth"), (this.success = {}), (this.skuToken = "");
                }
                getSession(e1, t, i, r) {
                  if (!n.API_URL || !n.SESSION_PATH) return;
                  const o = Be(n.API_URL + n.SESSION_PATH);
                  o.params.push(`sku=${t || ""}`),
                    o.params.push(`access_token=${r || n.ACCESS_TOKEN || ""}`);
                  const s = {
                    url: Fe(o),
                    headers: {
                      "Content-Type": "text/plain",
                    },
                  };
                  this.pendingRequest = (function (e1, t) {
                    return be(
                      k(e1, {
                        method: "GET",
                      }),
                      t,
                    );
                  })(s, (e1) => {
                    (this.pendingRequest = null),
                      i(e1),
                      this.saveEventData(),
                      this.processRequests(r);
                  });
                }
                getSessionAPI(e1, t, i, r) {
                  (this.skuToken = t),
                    (this.errorCb = r),
                    n.SESSION_PATH &&
                      n.API_URL &&
                      (i || n.ACCESS_TOKEN
                        ? this.queueRequest(
                            {
                              id: e1,
                              timestamp: Date.now(),
                            },
                            i,
                          )
                        : this.errorCb(new Error(Ce)));
                }
                processRequests(e1) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: t, timestamp: i } = this.queue.shift();
                  (t && this.success[t]) ||
                    this.getSession(
                      i,
                      this.skuToken,
                      (e1) => {
                        e1 ? this.errorCb(e1) : t && (this.success[t] = !0);
                      },
                      e1,
                    );
                }
              })(),
              Xe = We.getSessionAPI.bind(We),
              Ye = new Set();
            function Ke(e1, t) {
              t ? Ye.add(e1) : Ye.delete(e1);
            }
            const Je = {
                create: "create",
                load: "load",
                fullLoad: "fullLoad",
              },
              Qe = {
                mark(e1) {
                  t.performance.mark(e1);
                },
                measure(e1, i, r) {
                  t.performance.measure(e1, i, r);
                },
              };
            function et(e1) {
              const t = e1.name.split("?")[0];
              return Re(t) && t.includes("mapbox-gl.js")
                ? "javascript"
                : Re(t) && t.includes("mapbox-gl.css")
                ? "css"
                : (function (e1) {
                    return n.API_FONTS_REGEX.test(e1);
                  })(t)
                ? "fontRange"
                : ke(t)
                ? "sprite"
                : Le(t)
                ? "style"
                : (function (e1) {
                    return n.API_TILEJSON_REGEX.test(e1);
                  })(t)
                ? "tilejson"
                : "other";
            }
            const tt = t.performance;
            function it(e1) {
              const t = e1 ? e1.url.toString() : void 0;
              return tt.getEntriesByName(t);
            }
            var rt = nt;
            function nt(e1) {
              return !(function (e1) {
                var t;
                return "undefined" == typeof window ||
                  "undefined" == typeof document
                  ? "not a browser"
                  : Array.prototype &&
                    Array.prototype.every &&
                    Array.prototype.filter &&
                    Array.prototype.forEach &&
                    Array.prototype.indexOf &&
                    Array.prototype.lastIndexOf &&
                    Array.prototype.map &&
                    Array.prototype.some &&
                    Array.prototype.reduce &&
                    Array.prototype.reduceRight &&
                    Array.isArray
                  ? Function.prototype && Function.prototype.bind
                    ? Object.keys &&
                      Object.create &&
                      Object.getPrototypeOf &&
                      Object.getOwnPropertyNames &&
                      Object.isSealed &&
                      Object.isFrozen &&
                      Object.isExtensible &&
                      Object.getOwnPropertyDescriptor &&
                      Object.defineProperty &&
                      Object.defineProperties &&
                      Object.seal &&
                      Object.freeze &&
                      Object.preventExtensions
                      ? "JSON" in window &&
                        "parse" in JSON &&
                        "stringify" in JSON
                        ? (function () {
                            if (
                              !(
                                "Worker" in window &&
                                "Blob" in window &&
                                "URL" in window
                              )
                            )
                              return !1;
                            var e1,
                              t,
                              i = new Blob([""], {
                                type: "text/javascript",
                              }),
                              r = URL.createObjectURL(i);
                            try {
                              (t = new Worker(r)), (e1 = !0);
                            } catch (t) {
                              e1 = !1;
                            }
                            return (
                              t && t.terminate(), URL.revokeObjectURL(r), e1
                            );
                          })()
                          ? "Uint8ClampedArray" in window
                            ? ArrayBuffer.isView
                              ? (function () {
                                  var e1 = document.createElement("canvas");
                                  e1.width = e1.height = 1;
                                  var t = e1.getContext("2d");
                                  if (!t) return !1;
                                  var i = t.getImageData(0, 0, 1, 1);
                                  return i && i.width === e1.width;
                                })()
                                ? (void 0 ===
                                    ot[
                                      (t =
                                        e1 && e1.failIfMajorPerformanceCaveat)
                                    ] &&
                                    (ot[t] = (function (e1) {
                                      var t,
                                        i = (function (e1) {
                                          var t =
                                              document.createElement("canvas"),
                                            i = Object.create(
                                              nt.webGLContextAttributes,
                                            );
                                          return (
                                            (i.failIfMajorPerformanceCaveat =
                                              e1),
                                            t.getContext("webgl", i) ||
                                              t.getContext(
                                                "experimental-webgl",
                                                i,
                                              )
                                          );
                                        })(e1);
                                      if (!i) return !1;
                                      try {
                                        t = i.createShader(i.VERTEX_SHADER);
                                      } catch (e1) {
                                        return !1;
                                      }
                                      return (
                                        !(!t || i.isContextLost()) &&
                                        (i.shaderSource(t, "void main() {}"),
                                        i.compileShader(t),
                                        !0 ===
                                          i.getShaderParameter(
                                            t,
                                            i.COMPILE_STATUS,
                                          ))
                                      );
                                    })(t)),
                                  ot[t]
                                    ? document.documentMode
                                      ? "insufficient ECMAScript 6 support"
                                      : void 0
                                    : "insufficient WebGL support")
                                : "insufficient Canvas/getImageData support"
                              : "insufficient ArrayBuffer support"
                            : "insufficient Uint8ClampedArray support"
                          : "insufficient worker support"
                        : "insufficient JSON support"
                      : "insufficient Object support"
                    : "insufficient Function support"
                  : "insufficent Array support";
              })(e1);
            }
            var ot = {};
            let st, at, lt, ct;
            nt.webGLContextAttributes = {
              antialias: !1,
              alpha: !0,
              stencil: !0,
              depth: !0,
            };
            const ht = {
              now: () => (void 0 !== lt ? lt : t.performance.now()),
              setNow(e1) {
                lt = e1;
              },
              restoreNow() {
                lt = void 0;
              },
              frame(e1) {
                const i = t.requestAnimationFrame(e1);
                return {
                  cancel: () => t.cancelAnimationFrame(i),
                };
              },
              getImageData(e1, i = 0) {
                const { width: r, height: n } = e1;
                ct || (ct = t.document.createElement("canvas"));
                const o = ct.getContext("2d", {
                  willReadFrequently: !0,
                });
                if (!o) throw new Error("failed to create canvas 2d context");
                return (
                  (r > ct.width || n > ct.height) &&
                    ((ct.width = r), (ct.height = n)),
                  o.clearRect(-i, -i, r + 2 * i, n + 2 * i),
                  o.drawImage(e1, 0, 0, r, n),
                  o.getImageData(-i, -i, r + 2 * i, n + 2 * i)
                );
              },
              resolveURL: (e1) => (
                st || (st = t.document.createElement("a")),
                (st.href = e1),
                st.href
              ),
              get devicePixelRatio() {
                return t.devicePixelRatio;
              },
              get prefersReducedMotion() {
                return (
                  !!t.matchMedia &&
                  (null == at &&
                    (at = t.matchMedia("(prefers-reduced-motion: reduce)")),
                  at.matches)
                );
              },
            };
            function ut(e1, i, r) {
              const n = t.document.createElement(e1);
              return (
                void 0 !== i && (n.className = i), r && r.appendChild(n), n
              );
            }
            function dt(e1, i, r) {
              const n = t.document.createElementNS(
                "http://www.w3.org/2000/svg",
                e1,
              );
              for (const e1 of Object.keys(i))
                n.setAttributeNS(null, e1, i[e1]);
              return r && r.appendChild(n), n;
            }
            const pt = t.document && t.document.documentElement.style,
              ft =
                pt && void 0 !== pt.userSelect
                  ? "userSelect"
                  : "WebkitUserSelect";
            let mt;
            function _t() {
              pt && ft && ((mt = pt[ft]), (pt[ft] = "none"));
            }
            function gt() {
              pt && ft && (pt[ft] = mt);
            }
            function yt(e1) {
              e1.preventDefault(),
                e1.stopPropagation(),
                t.removeEventListener("click", yt, !0);
            }
            function xt() {
              t.addEventListener("click", yt, !0),
                t.setTimeout(() => {
                  t.removeEventListener("click", yt, !0);
                }, 0);
            }
            function vt(e1, t) {
              const i = e1.getBoundingClientRect();
              return Tt(e1, i, t);
            }
            function bt(e1, t) {
              const i = e1.getBoundingClientRect(),
                r = [];
              for (let n = 0; n < t.length; n++) r.push(Tt(e1, i, t[n]));
              return r;
            }
            function wt(e1) {
              return void 0 !== t.InstallTrigger &&
                2 === e1.button &&
                e1.ctrlKey &&
                t.navigator.platform.toUpperCase().indexOf("MAC") >= 0
                ? 0
                : e1.button;
            }
            function Tt(e1, t, i) {
              const r =
                e1.offsetWidth === t.width ? 1 : e1.offsetWidth / t.width;
              return new y((i.clientX - t.left) * r, (i.clientY - t.top) * r);
            }
            function Et(e1, t, i) {
              (i[e1] && -1 !== i[e1].indexOf(t)) ||
                ((i[e1] = i[e1] || []), i[e1].push(t));
            }
            function Mt(e1, t, i) {
              if (i && i[e1]) {
                const r = i[e1].indexOf(t);
                -1 !== r && i[e1].splice(r, 1);
              }
            }
            class At {
              constructor(e1, t = {}) {
                k(this, t), (this.type = e1);
              }
            }
            class St extends At {
              constructor(e1, t = {}) {
                super(
                  "error",
                  k(
                    {
                      error: e1,
                    },
                    t,
                  ),
                );
              }
            }
            class It {
              on(e1, t) {
                return (
                  (this._listeners = this._listeners || {}),
                  Et(e1, t, this._listeners),
                  this
                );
              }
              off(e1, t) {
                return (
                  Mt(e1, t, this._listeners),
                  Mt(e1, t, this._oneTimeListeners),
                  this
                );
              }
              once(e1, t) {
                return t
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    Et(e1, t, this._oneTimeListeners),
                    this)
                  : new Promise((t) => this.once(e1, t));
              }
              fire(e1, t) {
                "string" == typeof e1 && (e1 = new At(e1, t || {}));
                const i = e1.type;
                if (this.listens(i)) {
                  e1.target = this;
                  const t =
                    this._listeners && this._listeners[i]
                      ? this._listeners[i].slice()
                      : [];
                  for (const i of t) i.call(this, e1);
                  const r =
                    this._oneTimeListeners && this._oneTimeListeners[i]
                      ? this._oneTimeListeners[i].slice()
                      : [];
                  for (const t of r)
                    Mt(i, t, this._oneTimeListeners), t.call(this, e1);
                  const n = this._eventedParent;
                  n &&
                    (k(
                      e1,
                      "function" == typeof this._eventedParentData
                        ? this._eventedParentData()
                        : this._eventedParentData,
                    ),
                    n.fire(e1));
                } else e1 instanceof St && console.error(e1.error);
                return this;
              }
              listens(e1) {
                return !!(
                  (this._listeners &&
                    this._listeners[e1] &&
                    this._listeners[e1].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[e1] &&
                    this._oneTimeListeners[e1].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(e1))
                );
              }
              setEventedParent(e1, t) {
                return (
                  (this._eventedParent = e1),
                  (this._eventedParentData = t),
                  this
                );
              }
            }
            var Ct = JSON.parse(
              '{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","default":[0,1],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}',
            );
            class zt {
              constructor(e1, t, i, r) {
                (this.message = (e1 ? `${e1}: ` : "") + i),
                  r && (this.identifier = r),
                  null != t && t.__line__ && (this.line = t.__line__);
              }
            }
            class Dt extends zt {}
            function Pt(e1, ...t) {
              for (const i of t) for (const t in i) e1[t] = i[t];
              return e1;
            }
            function Rt(e1) {
              return e1 instanceof Number ||
                e1 instanceof String ||
                e1 instanceof Boolean
                ? e1.valueOf()
                : e1;
            }
            function Lt(e1) {
              if (Array.isArray(e1)) return e1.map(Lt);
              if (
                e1 instanceof Object &&
                !(
                  e1 instanceof Number ||
                  e1 instanceof String ||
                  e1 instanceof Boolean
                )
              ) {
                const t = {};
                for (const i in e1) t[i] = Lt(e1[i]);
                return t;
              }
              return Rt(e1);
            }
            class kt extends Error {
              constructor(e1, t) {
                super(t), (this.message = t), (this.key = e1);
              }
            }
            var Ot = kt;
            class Bt {
              constructor(e1, t = []) {
                (this.parent = e1), (this.bindings = {});
                for (const [e1, i] of t) this.bindings[e1] = i;
              }
              concat(e1) {
                return new Bt(this, e1);
              }
              get(e1) {
                if (this.bindings[e1]) return this.bindings[e1];
                if (this.parent) return this.parent.get(e1);
                throw new Error(`${e1} not found in scope.`);
              }
              has(e1) {
                return (
                  !!this.bindings[e1] || (!!this.parent && this.parent.has(e1))
                );
              }
            }
            var Ft = Bt;
            const Nt = {
                kind: "null",
              },
              Ut = {
                kind: "number",
              },
              Vt = {
                kind: "string",
              },
              jt = {
                kind: "boolean",
              },
              Gt = {
                kind: "color",
              },
              qt = {
                kind: "object",
              },
              Zt = {
                kind: "value",
              },
              $t = {
                kind: "collator",
              },
              Ht = {
                kind: "formatted",
              },
              Wt = {
                kind: "resolvedImage",
              };
            function Xt(e1, t) {
              return {
                kind: "array",
                itemType: e1,
                N: t,
              };
            }
            function Yt(e1) {
              if ("array" === e1.kind) {
                const t = Yt(e1.itemType);
                return "number" == typeof e1.N
                  ? `array<${t}, ${e1.N}>`
                  : "value" === e1.itemType.kind
                  ? "array"
                  : `array<${t}>`;
              }
              return e1.kind;
            }
            const Kt = [Nt, Ut, Vt, jt, Gt, Ht, qt, Xt(Zt), Wt];
            function Jt(e1, t) {
              if ("error" === t.kind) return null;
              if ("array" === e1.kind) {
                if (
                  "array" === t.kind &&
                  ((0 === t.N && "value" === t.itemType.kind) ||
                    !Jt(e1.itemType, t.itemType)) &&
                  ("number" != typeof e1.N || e1.N === t.N)
                )
                  return null;
              } else {
                if (e1.kind === t.kind) return null;
                if ("value" === e1.kind) {
                  for (const e1 of Kt) if (!Jt(e1, t)) return null;
                }
              }
              return `Expected ${Yt(e1)} but found ${Yt(t)} instead.`;
            }
            function Qt(e1, t) {
              return t.some((t) => t.kind === e1.kind);
            }
            function ei(e1, t) {
              return t.some((t) =>
                "null" === t
                  ? null === e1
                  : "array" === t
                  ? Array.isArray(e1)
                  : "object" === t
                  ? e1 && !Array.isArray(e1) && "object" == typeof e1
                  : t === typeof e1,
              );
            }
            var ti,
              ii = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1],
              };
            function ri(e1) {
              return (e1 = Math.round(e1)) < 0 ? 0 : e1 > 255 ? 255 : e1;
            }
            function ni(e1) {
              return ri(
                "%" === e1[e1.length - 1]
                  ? (parseFloat(e1) / 100) * 255
                  : parseInt(e1),
              );
            }
            function oi(e1) {
              var t;
              return (t =
                "%" === e1[e1.length - 1]
                  ? parseFloat(e1) / 100
                  : parseFloat(e1)) < 0
                ? 0
                : t > 1
                ? 1
                : t;
            }
            function si(e1, t, i) {
              return (
                i < 0 ? (i += 1) : i > 1 && (i -= 1),
                6 * i < 1
                  ? e1 + (t - e1) * i * 6
                  : 2 * i < 1
                  ? t
                  : 3 * i < 2
                  ? e1 + (t - e1) * (2 / 3 - i) * 6
                  : e1
              );
            }
            try {
              ti = {}.parseCSSColor = function (e1) {
                var t,
                  i = e1.replace(/ /g, "").toLowerCase();
                if (i in ii) return ii[i].slice();
                if ("#" === i[0])
                  return 4 === i.length
                    ? (t = parseInt(i.substr(1), 16)) >= 0 && t <= 4095
                      ? [
                          ((3840 & t) >> 4) | ((3840 & t) >> 8),
                          (240 & t) | ((240 & t) >> 4),
                          (15 & t) | ((15 & t) << 4),
                          1,
                        ]
                      : null
                    : 7 === i.length &&
                      (t = parseInt(i.substr(1), 16)) >= 0 &&
                      t <= 16777215
                    ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1]
                    : null;
                var r = i.indexOf("("),
                  n = i.indexOf(")");
                if (-1 !== r && n + 1 === i.length) {
                  var o = i.substr(0, r),
                    s = i.substr(r + 1, n - (r + 1)).split(","),
                    a = 1;
                  switch (o) {
                    case "rgba":
                      if (4 !== s.length) return null;
                      a = oi(s.pop());
                    case "rgb":
                      return 3 !== s.length
                        ? null
                        : [ni(s[0]), ni(s[1]), ni(s[2]), a];
                    case "hsla":
                      if (4 !== s.length) return null;
                      a = oi(s.pop());
                    case "hsl":
                      if (3 !== s.length) return null;
                      var l = (((parseFloat(s[0]) % 360) + 360) % 360) / 360,
                        c = oi(s[1]),
                        h = oi(s[2]),
                        u = h <= 0.5 ? h * (c + 1) : h + c - h * c,
                        d = 2 * h - u;
                      return [
                        ri(255 * si(d, u, l + 1 / 3)),
                        ri(255 * si(d, u, l)),
                        ri(255 * si(d, u, l - 1 / 3)),
                        a,
                      ];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (e1) {}
            class ai {
              constructor(e1, t, i, r = 1) {
                (this.r = e1), (this.g = t), (this.b = i), (this.a = r);
              }
              static parse(e1) {
                if (!e1) return;
                if (e1 instanceof ai) return e1;
                if ("string" != typeof e1) return;
                const t = ti(e1);
                return t
                  ? new ai(
                      (t[0] / 255) * t[3],
                      (t[1] / 255) * t[3],
                      (t[2] / 255) * t[3],
                      t[3],
                    )
                  : void 0;
              }
              toString() {
                const [e1, t, i, r] = this.toArray();
                return `rgba(${Math.round(e1)},${Math.round(t)},${Math.round(
                  i,
                )},${r})`;
              }
              toArray() {
                const { r: e1, g: t, b: i, a: r } = this;
                return 0 === r
                  ? [0, 0, 0, 0]
                  : [(255 * e1) / r, (255 * t) / r, (255 * i) / r, r];
              }
              toArray01() {
                const { r: e1, g: t, b: i, a: r } = this;
                return 0 === r ? [0, 0, 0, 0] : [e1 / r, t / r, i / r, r];
              }
              toArray01Scaled(e1) {
                const { r: t, g: i, b: r, a: n } = this;
                return 0 === n
                  ? [0, 0, 0]
                  : [(t / n) * e1, (i / n) * e1, (r / n) * e1];
              }
              toArray01PremultipliedAlpha() {
                const { r: e1, g: t, b: i, a: r } = this;
                return [e1, t, i, r];
              }
              toArray01Linear() {
                const { r: e1, g: t, b: i, a: r } = this;
                return 0 === r
                  ? [0, 0, 0, 0]
                  : [
                      Math.pow(e1 / r, 2.2),
                      Math.pow(t / r, 2.2),
                      Math.pow(i / r, 2.2),
                      r,
                    ];
              }
            }
            (ai.black = new ai(0, 0, 0, 1)),
              (ai.white = new ai(1, 1, 1, 1)),
              (ai.transparent = new ai(0, 0, 0, 0)),
              (ai.red = new ai(1, 0, 0, 1)),
              (ai.blue = new ai(0, 0, 1, 1));
            var li = ai;
            class ci {
              constructor(e1, t, i) {
                (this.sensitivity = e1
                  ? t
                    ? "variant"
                    : "case"
                  : t
                  ? "accent"
                  : "base"),
                  (this.locale = i),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    {
                      sensitivity: this.sensitivity,
                      usage: "search",
                    },
                  ));
              }
              compare(e1, t) {
                return this.collator.compare(e1, t);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : [],
                ).resolvedOptions().locale;
              }
            }
            class hi {
              constructor(e1, t, i, r, n) {
                (this.text = e1.normalize ? e1.normalize() : e1),
                  (this.image = t),
                  (this.scale = i),
                  (this.fontStack = r),
                  (this.textColor = n);
              }
            }
            class ui {
              constructor(e1) {
                this.sections = e1;
              }
              static fromString(e1) {
                return new ui([new hi(e1, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  0 === this.sections.length ||
                  !this.sections.some(
                    (e1) =>
                      0 !== e1.text.length ||
                      (e1.image && 0 !== e1.image.namePrimary.length),
                  )
                );
              }
              static factory(e1) {
                return e1 instanceof ui ? e1 : ui.fromString(e1);
              }
              toString() {
                return 0 === this.sections.length
                  ? ""
                  : this.sections.map((e1) => e1.text).join("");
              }
              serialize() {
                const e1 = ["format"];
                for (const t of this.sections) {
                  if (t.image) {
                    e1.push(["image", t.image.namePrimary]);
                    continue;
                  }
                  e1.push(t.text);
                  const i = {};
                  t.fontStack &&
                    (i["text-font"] = ["literal", t.fontStack.split(",")]),
                    t.scale && (i["font-scale"] = t.scale),
                    t.textColor &&
                      (i["text-color"] = ["rgba"].concat(
                        t.textColor.toArray(),
                      )),
                    e1.push(i);
                }
                return e1;
              }
            }
            class di {
              constructor(e1) {
                (this.namePrimary = e1.namePrimary),
                  e1.nameSecondary && (this.nameSecondary = e1.nameSecondary),
                  (this.available = e1.available);
              }
              toString() {
                return this.nameSecondary
                  ? `[${this.namePrimary},${this.nameSecondary}]`
                  : this.namePrimary;
              }
              static fromString(e1, t) {
                return e1
                  ? new di({
                      namePrimary: e1,
                      nameSecondary: t,
                      available: !1,
                    })
                  : null;
              }
              serialize() {
                return this.nameSecondary
                  ? ["image", this.namePrimary, this.nameSecondary]
                  : ["image", this.namePrimary];
              }
            }
            function pi(e1, t, i, r) {
              return "number" == typeof e1 &&
                e1 >= 0 &&
                e1 <= 255 &&
                "number" == typeof t &&
                t >= 0 &&
                t <= 255 &&
                "number" == typeof i &&
                i >= 0 &&
                i <= 255
                ? void 0 === r || ("number" == typeof r && r >= 0 && r <= 1)
                  ? null
                  : `Invalid rgba value [${[e1, t, i, r].join(
                      ", ",
                    )}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${("number" == typeof r
                    ? [e1, t, i, r]
                    : [e1, t, i]
                  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function fi(e1) {
              if (null === e1) return !0;
              if ("string" == typeof e1) return !0;
              if ("boolean" == typeof e1) return !0;
              if ("number" == typeof e1) return !0;
              if (e1 instanceof li) return !0;
              if (e1 instanceof ci) return !0;
              if (e1 instanceof ui) return !0;
              if (e1 instanceof di) return !0;
              if (Array.isArray(e1)) {
                for (const t of e1) if (!fi(t)) return !1;
                return !0;
              }
              if ("object" == typeof e1) {
                for (const t in e1) if (!fi(e1[t])) return !1;
                return !0;
              }
              return !1;
            }
            function mi(e1) {
              if (null === e1) return Nt;
              if ("string" == typeof e1) return Vt;
              if ("boolean" == typeof e1) return jt;
              if ("number" == typeof e1) return Ut;
              if (e1 instanceof li) return Gt;
              if (e1 instanceof ci) return $t;
              if (e1 instanceof ui) return Ht;
              if (e1 instanceof di) return Wt;
              if (Array.isArray(e1)) {
                const t = e1.length;
                let i;
                for (const t of e1) {
                  const e1 = mi(t);
                  if (i) {
                    if (i === e1) continue;
                    i = Zt;
                    break;
                  }
                  i = e1;
                }
                return Xt(i || Zt, t);
              }
              return qt;
            }
            function _i(e1) {
              const t = typeof e1;
              return null === e1
                ? ""
                : "string" === t || "number" === t || "boolean" === t
                ? String(e1)
                : e1 instanceof li || e1 instanceof ui || e1 instanceof di
                ? e1.toString()
                : JSON.stringify(e1);
            }
            class gi {
              constructor(e1, t) {
                (this.type = e1), (this.value = t);
              }
              static parse(e1, t) {
                if (2 !== e1.length)
                  return t.error(
                    `'literal' expression requires exactly one argument, but found ${
                      e1.length - 1
                    } instead.`,
                  );
                if (!fi(e1[1])) return t.error("invalid value");
                const i = e1[1];
                let r = mi(i);
                const n = t.expectedType;
                return (
                  "array" !== r.kind ||
                    0 !== r.N ||
                    !n ||
                    "array" !== n.kind ||
                    ("number" == typeof n.N && 0 !== n.N) ||
                    (r = n),
                  new gi(r, i)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return "array" === this.type.kind || "object" === this.type.kind
                  ? ["literal", this.value]
                  : this.value instanceof li
                  ? ["rgba"].concat(this.value.toArray())
                  : this.value instanceof ui
                  ? this.value.serialize()
                  : this.value;
              }
            }
            var yi = gi,
              xi = class {
                constructor(e1) {
                  (this.name = "ExpressionEvaluationError"),
                    (this.message = e1);
                }
                toJSON() {
                  return this.message;
                }
              };
            const vi = {
              string: Vt,
              number: Ut,
              boolean: jt,
              object: qt,
            };
            class bi {
              constructor(e1, t) {
                (this.type = e1), (this.args = t);
              }
              static parse(e1, t) {
                if (e1.length < 2)
                  return t.error("Expected at least one argument.");
                let i,
                  r = 1;
                const n = e1[0];
                if ("array" === n) {
                  let n, o;
                  if (e1.length > 2) {
                    const i = e1[1];
                    if ("string" != typeof i || !(i in vi) || "object" === i)
                      return t.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1,
                      );
                    (n = vi[i]), r++;
                  } else n = Zt;
                  if (e1.length > 3) {
                    if (
                      null !== e1[2] &&
                      ("number" != typeof e1[2] ||
                        e1[2] < 0 ||
                        e1[2] !== Math.floor(e1[2]))
                    )
                      return t.error(
                        'The length argument to "array" must be a positive integer literal',
                        2,
                      );
                    (o = e1[2]), r++;
                  }
                  i = Xt(n, o);
                } else i = vi[n];
                const o = [];
                for (; r < e1.length; r++) {
                  const i = t.parse(e1[r], r, Zt);
                  if (!i) return null;
                  o.push(i);
                }
                return new bi(i, o);
              }
              evaluate(e1) {
                for (let t = 0; t < this.args.length; t++) {
                  const i = this.args[t].evaluate(e1);
                  if (!Jt(this.type, mi(i))) return i;
                  if (t === this.args.length - 1)
                    throw new xi(
                      `Expected value to be of type ${Yt(
                        this.type,
                      )}, but found ${Yt(mi(i))} instead.`,
                    );
                }
                return null;
              }
              eachChild(e1) {
                this.args.forEach(e1);
              }
              outputDefined() {
                return this.args.every((e1) => e1.outputDefined());
              }
              serialize() {
                const e1 = this.type,
                  t = [e1.kind];
                if ("array" === e1.kind) {
                  const i = e1.itemType;
                  if (
                    "string" === i.kind ||
                    "number" === i.kind ||
                    "boolean" === i.kind
                  ) {
                    t.push(i.kind);
                    const r = e1.N;
                    ("number" == typeof r || this.args.length > 1) && t.push(r);
                  }
                }
                return t.concat(this.args.map((e1) => e1.serialize()));
              }
            }
            var wi = bi;
            class Ti {
              constructor(e1) {
                (this.type = Ht), (this.sections = e1);
              }
              static parse(e1, t) {
                if (e1.length < 2)
                  return t.error("Expected at least one argument.");
                const i = e1[1];
                if (!Array.isArray(i) && "object" == typeof i)
                  return t.error(
                    "First argument must be an image or text section.",
                  );
                const r = [];
                let n = !1;
                for (let i = 1; i <= e1.length - 1; ++i) {
                  const o = e1[i];
                  if (n && "object" == typeof o && !Array.isArray(o)) {
                    n = !1;
                    let e1 = null;
                    if (
                      o["font-scale"] &&
                      ((e1 = t.parse(o["font-scale"], 1, Ut)), !e1)
                    )
                      return null;
                    let i = null;
                    if (
                      o["text-font"] &&
                      ((i = t.parse(o["text-font"], 1, Xt(Vt))), !i)
                    )
                      return null;
                    let s = null;
                    if (
                      o["text-color"] &&
                      ((s = t.parse(o["text-color"], 1, Gt)), !s)
                    )
                      return null;
                    const a = r[r.length - 1];
                    (a.scale = e1), (a.font = i), (a.textColor = s);
                  } else {
                    const o = t.parse(e1[i], 1, Zt);
                    if (!o) return null;
                    const s = o.type.kind;
                    if (
                      "string" !== s &&
                      "value" !== s &&
                      "null" !== s &&
                      "resolvedImage" !== s
                    )
                      return t.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'.",
                      );
                    (n = !0),
                      r.push({
                        content: o,
                        scale: null,
                        font: null,
                        textColor: null,
                      });
                  }
                }
                return new Ti(r);
              }
              evaluate(e1) {
                return new ui(
                  this.sections.map((t) => {
                    const i = t.content.evaluate(e1);
                    return mi(i) === Wt
                      ? new hi("", i, null, null, null)
                      : new hi(
                          _i(i),
                          null,
                          t.scale ? t.scale.evaluate(e1) : null,
                          t.font ? t.font.evaluate(e1).join(",") : null,
                          t.textColor ? t.textColor.evaluate(e1) : null,
                        );
                  }),
                );
              }
              eachChild(e1) {
                for (const t of this.sections)
                  e1(t.content),
                    t.scale && e1(t.scale),
                    t.font && e1(t.font),
                    t.textColor && e1(t.textColor);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e1 = ["format"];
                for (const t of this.sections) {
                  e1.push(t.content.serialize());
                  const i = {};
                  t.scale && (i["font-scale"] = t.scale.serialize()),
                    t.font && (i["text-font"] = t.font.serialize()),
                    t.textColor && (i["text-color"] = t.textColor.serialize()),
                    e1.push(i);
                }
                return e1;
              }
            }
            class Ei {
              constructor(e1, t) {
                (this.type = Wt),
                  (this.inputPrimary = e1),
                  (this.inputSecondary = t);
              }
              static parse(e1, t) {
                if (e1.length < 2)
                  return t.error("Expected two or more arguments.");
                const i = t.parse(e1[1], 1, Vt);
                if (!i) return t.error("No image name provided.");
                if (2 === e1.length) return new Ei(i);
                const r = t.parse(e1[2], 1, Vt);
                return r
                  ? new Ei(i, r)
                  : t.error("Secondary image variant is not a string.");
              }
              evaluate(e1) {
                const t = di.fromString(
                  this.inputPrimary.evaluate(e1),
                  this.inputSecondary
                    ? this.inputSecondary.evaluate(e1)
                    : void 0,
                );
                return (
                  t &&
                    e1.availableImages &&
                    ((t.available =
                      e1.availableImages.indexOf(t.namePrimary) > -1),
                    t.nameSecondary &&
                      t.available &&
                      e1.availableImages &&
                      (t.available =
                        e1.availableImages.indexOf(t.nameSecondary) > -1)),
                  t
                );
              }
              eachChild(e1) {
                e1(this.inputPrimary),
                  this.inputSecondary && e1(this.inputSecondary);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return this.inputSecondary
                  ? [
                      "image",
                      this.inputPrimary.serialize(),
                      this.inputSecondary.serialize(),
                    ]
                  : ["image", this.inputPrimary.serialize()];
              }
            }
            function Mi(e1) {
              return e1 instanceof Number
                ? "number"
                : e1 instanceof String
                ? "string"
                : e1 instanceof Boolean
                ? "boolean"
                : Array.isArray(e1)
                ? "array"
                : null === e1
                ? "null"
                : typeof e1;
            }
            const Ai = {
              "to-boolean": jt,
              "to-color": Gt,
              "to-number": Ut,
              "to-string": Vt,
            };
            class Si {
              constructor(e1, t) {
                (this.type = e1), (this.args = t);
              }
              static parse(e1, t) {
                if (e1.length < 2)
                  return t.error("Expected at least one argument.");
                const i = e1[0],
                  r = [];
                let n = Nt;
                if ("to-array" === i) {
                  if (!Array.isArray(e1[1])) return null;
                  const i = e1[1].length;
                  if (t.expectedType) {
                    if ("array" !== t.expectedType.kind)
                      return t.error(
                        `Expected ${t.expectedType.kind} but found array.`,
                      );
                    n = Xt(t.expectedType.itemType, i);
                  } else {
                    if (!(i > 0 && fi(e1[1][0]))) return null;
                    n = Xt(mi(e1[1][0]), i);
                  }
                  for (let o = 0; o < i; o++) {
                    const i = e1[1][o];
                    let s;
                    if ("array" === Mi(i)) s = t.parse(i, void 0, n.itemType);
                    else {
                      const e1 = Mi(i);
                      if (e1 !== n.itemType.kind)
                        return t.error(
                          `Expected ${n.itemType.kind} but found ${e1}.`,
                        );
                      s = t.registry.literal.parse(
                        ["literal", void 0 === i ? null : i],
                        t,
                      );
                    }
                    if (!s) return null;
                    r.push(s);
                  }
                } else {
                  if (
                    ("to-boolean" === i || "to-string" === i) &&
                    2 !== e1.length
                  )
                    return t.error("Expected one argument.");
                  n = Ai[i];
                  for (let i = 1; i < e1.length; i++) {
                    const n = t.parse(e1[i], i, Zt);
                    if (!n) return null;
                    r.push(n);
                  }
                }
                return new Si(n, r);
              }
              evaluate(e1) {
                if ("boolean" === this.type.kind)
                  return Boolean(this.args[0].evaluate(e1));
                if ("color" === this.type.kind) {
                  let t, i;
                  for (const r of this.args) {
                    if (((t = r.evaluate(e1)), (i = null), t instanceof li))
                      return t;
                    if ("string" == typeof t) {
                      const i = e1.parseColor(t);
                      if (i) return i;
                    } else if (
                      Array.isArray(t) &&
                      ((i =
                        t.length < 3 || t.length > 4
                          ? `Invalid rbga value ${JSON.stringify(
                              t,
                            )}: expected an array containing either three or four numeric values.`
                          : pi(t[0], t[1], t[2], t[3])),
                      !i)
                    )
                      return new li(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
                  }
                  throw new xi(
                    i ||
                      `Could not parse color from value '${
                        "string" == typeof t ? t : String(JSON.stringify(t))
                      }'`,
                  );
                }
                if ("number" === this.type.kind) {
                  let t = null;
                  for (const i of this.args) {
                    if (((t = i.evaluate(e1)), null === t)) return 0;
                    const r = Number(t);
                    if (!isNaN(r)) return r;
                  }
                  throw new xi(
                    `Could not convert ${JSON.stringify(t)} to number.`,
                  );
                }
                return "formatted" === this.type.kind
                  ? ui.fromString(_i(this.args[0].evaluate(e1)))
                  : "resolvedImage" === this.type.kind
                  ? di.fromString(_i(this.args[0].evaluate(e1)))
                  : "array" === this.type.kind
                  ? this.args.map((t) => t.evaluate(e1))
                  : _i(this.args[0].evaluate(e1));
              }
              eachChild(e1) {
                this.args.forEach(e1);
              }
              outputDefined() {
                return this.args.every((e1) => e1.outputDefined());
              }
              serialize() {
                if ("formatted" === this.type.kind)
                  return new Ti([
                    {
                      content: this.args[0],
                      scale: null,
                      font: null,
                      textColor: null,
                    },
                  ]).serialize();
                if ("resolvedImage" === this.type.kind)
                  return new Ei(this.args[0]).serialize();
                const e1 =
                  "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
                return (
                  this.eachChild((t) => {
                    e1.push(t.serialize());
                  }),
                  e1
                );
              }
            }
            var Ii = Si;
            const Ci = ["Unknown", "Point", "LineString", "Polygon"];
            var zi = class {
              constructor(e1) {
                (this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = {}),
                  (this.availableImages = null),
                  (this.canonical = null),
                  (this.featureTileCoord = null),
                  (this.featureDistanceData = null),
                  (this.options = e1);
              }
              id() {
                return this.feature && void 0 !== this.feature.id
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? "number" == typeof this.feature.type
                    ? Ci[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              measureLight(e1) {
                return this.globals.brightness || 0;
              }
              distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                  const e1 = this.featureDistanceData.center,
                    t = this.featureDistanceData.scale,
                    { x: i, y: r } = this.featureTileCoord;
                  return (
                    this.featureDistanceData.bearing[0] * (i * t - e1[0]) +
                    this.featureDistanceData.bearing[1] * (r * t - e1[1])
                  );
                }
                return 0;
              }
              parseColor(e1) {
                let t = this._parseColorCache[e1];
                return t || (t = this._parseColorCache[e1] = li.parse(e1)), t;
              }
              getConfig(e1) {
                return this.options ? this.options.get(e1) : null;
              }
            };
            class Di {
              constructor(e1, t, i, r) {
                (this.name = e1),
                  (this.type = t),
                  (this._evaluate = i),
                  (this.args = r);
              }
              evaluate(e1) {
                return this._evaluate(e1, this.args);
              }
              eachChild(e1) {
                this.args.forEach(e1);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [this.name].concat(
                  this.args.map((e1) => e1.serialize()),
                );
              }
              static parse(e1, t) {
                const i = e1[0],
                  r = Di.definitions[i];
                if (!r)
                  return t.error(
                    `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
                    0,
                  );
                const n = Array.isArray(r) ? r[0] : r.type,
                  o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads,
                  s = o.filter(
                    ([t]) => !Array.isArray(t) || t.length === e1.length - 1,
                  );
                let a = null;
                for (const [r, o] of s) {
                  a = new Gr(
                    t.registry,
                    t.path,
                    null,
                    t.scope,
                    void 0,
                    t.options,
                  );
                  const s = [];
                  let l = !1;
                  for (let t = 1; t < e1.length; t++) {
                    const i = e1[t],
                      n = Array.isArray(r) ? r[t - 1] : r.type,
                      o = a.parse(i, 1 + s.length, n);
                    if (!o) {
                      l = !0;
                      break;
                    }
                    s.push(o);
                  }
                  if (!l) {
                    if (Array.isArray(r) && r.length !== s.length)
                      a.error(
                        `Expected ${r.length} arguments, but found ${s.length} instead.`,
                      );
                    else {
                      for (let e1 = 0; e1 < s.length; e1++) {
                        const t = Array.isArray(r) ? r[e1] : r.type,
                          i = s[e1];
                        a.concat(e1 + 1).checkSubtype(t, i.type);
                      }
                      if (0 === a.errors.length) return new Di(i, n, o, s);
                    }
                  }
                }
                if (1 === s.length) t.errors.push(...a.errors);
                else {
                  const i = (s.length ? s : o)
                      .map(([e1]) => {
                        var t;
                        return (
                          (t = e1),
                          Array.isArray(t)
                            ? `(${t.map(Yt).join(", ")})`
                            : `(${Yt(t.type)}...)`
                        );
                      })
                      .join(" | "),
                    r = [];
                  for (let i = 1; i < e1.length; i++) {
                    const n = t.parse(e1[i], 1 + r.length);
                    if (!n) return null;
                    r.push(Yt(n.type));
                  }
                  t.error(
                    `Expected arguments of type ${i}, but found (${r.join(
                      ", ",
                    )}) instead.`,
                  );
                }
                return null;
              }
              static register(e1, t) {
                Di.definitions = t;
                for (const i in t) e1[i] = Di;
              }
            }
            var Pi = Di;
            class Ri {
              constructor(e1, t, i) {
                (this.type = $t),
                  (this.locale = i),
                  (this.caseSensitive = e1),
                  (this.diacriticSensitive = t);
              }
              static parse(e1, t) {
                if (2 !== e1.length) return t.error("Expected one argument.");
                const i = e1[1];
                if ("object" != typeof i || Array.isArray(i))
                  return t.error(
                    "Collator options argument must be an object.",
                  );
                const r = t.parse(
                  void 0 !== i["case-sensitive"] && i["case-sensitive"],
                  1,
                  jt,
                );
                if (!r) return null;
                const n = t.parse(
                  void 0 !== i["diacritic-sensitive"] &&
                    i["diacritic-sensitive"],
                  1,
                  jt,
                );
                if (!n) return null;
                let o = null;
                return i.locale && ((o = t.parse(i.locale, 1, Vt)), !o)
                  ? null
                  : new Ri(r, n, o);
              }
              evaluate(e1) {
                return new ci(
                  this.caseSensitive.evaluate(e1),
                  this.diacriticSensitive.evaluate(e1),
                  this.locale ? this.locale.evaluate(e1) : null,
                );
              }
              eachChild(e1) {
                e1(this.caseSensitive),
                  e1(this.diacriticSensitive),
                  this.locale && e1(this.locale);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e1 = {};
                return (
                  (e1["case-sensitive"] = this.caseSensitive.serialize()),
                  (e1["diacritic-sensitive"] =
                    this.diacriticSensitive.serialize()),
                  this.locale && (e1.locale = this.locale.serialize()),
                  ["collator", e1]
                );
              }
            }
            var Li = {
              exports: {},
            };
            Li.exports = (function () {
              function e1(i, r, n, o, s) {
                for (; o > n; ) {
                  if (o - n > 600) {
                    var a = o - n + 1,
                      l = r - n + 1,
                      c = Math.log(a),
                      h = 0.5 * Math.exp((2 * c) / 3),
                      u =
                        0.5 *
                        Math.sqrt((c * h * (a - h)) / a) *
                        (l - a / 2 < 0 ? -1 : 1);
                    e1(
                      i,
                      r,
                      Math.max(n, Math.floor(r - (l * h) / a + u)),
                      Math.min(o, Math.floor(r + ((a - l) * h) / a + u)),
                      s,
                    );
                  }
                  var d = i[r],
                    p = n,
                    f = o;
                  for (t(i, n, r), s(i[o], d) > 0 && t(i, n, o); p < f; ) {
                    for (t(i, p, f), p++, f--; s(i[p], d) < 0; ) p++;
                    for (; s(i[f], d) > 0; ) f--;
                  }
                  0 === s(i[n], d) ? t(i, n, f) : t(i, ++f, o),
                    f <= r && (n = f + 1),
                    r <= f && (o = f - 1);
                }
              }
              function t(e1, t, i) {
                var r = e1[t];
                (e1[t] = e1[i]), (e1[i] = r);
              }
              function i(e1, t) {
                return e1 < t ? -1 : e1 > t ? 1 : 0;
              }
              return function (t, r, n, o, s) {
                e1(t, r, n || 0, o || t.length - 1, s || i);
              };
            })();
            var ki = d(Li.exports);
            function Oi(e1) {
              let t = 0;
              for (let i, r, n = 0, o = e1.length, s = o - 1; n < o; s = n++)
                (i = e1[n]), (r = e1[s]), (t += (r.x - i.x) * (i.y + r.y));
              return t;
            }
            function Bi(e1, t) {
              (e1[0] = Math.min(e1[0], t[0])),
                (e1[1] = Math.min(e1[1], t[1])),
                (e1[2] = Math.max(e1[2], t[0])),
                (e1[3] = Math.max(e1[3], t[1]));
            }
            function Fi(e1, t) {
              return !(
                e1[0] <= t[0] ||
                e1[2] >= t[2] ||
                e1[1] <= t[1] ||
                e1[3] >= t[3]
              );
            }
            function Ni(e1, t, i) {
              const r = e1[0] - t[0],
                n = e1[1] - t[1],
                o = e1[0] - i[0],
                s = e1[1] - i[1];
              return r * s - o * n == 0 && r * o <= 0 && n * s <= 0;
            }
            function Ui(e1, t, i = !1) {
              let r = !1;
              for (let a = 0, l = t.length; a < l; a++) {
                const l = t[a];
                for (let t = 0, a = l.length, c = a - 1; t < a; c = t++) {
                  const a = l[c],
                    h = l[t];
                  if (Ni(e1, a, h)) return i;
                  (o = a)[1] > (n = e1)[1] != (s = h)[1] > n[1] &&
                    n[0] <
                      ((s[0] - o[0]) * (n[1] - o[1])) / (s[1] - o[1]) + o[0] &&
                    (r = !r);
                }
              }
              var n, o, s;
              return r;
            }
            function Vi(e1, t, i, r) {
              const n = r[0] - i[0],
                o = r[1] - i[1],
                s = (e1[0] - i[0]) * o - n * (e1[1] - i[1]),
                a = (t[0] - i[0]) * o - n * (t[1] - i[1]);
              return (s > 0 && a < 0) || (s < 0 && a > 0);
            }
            function ji(e1, t, i, r) {
              var n, o;
              return (
                0 !=
                  (n = [r[0] - i[0], r[1] - i[1]])[0] *
                    (o = [t[0] - e1[0], t[1] - e1[1]])[1] -
                    n[1] * o[0] && !(!Vi(e1, t, i, r) || !Vi(i, r, e1, t))
              );
            }
            const Gi = 8192;
            function qi(e1, t) {
              const i = (180 + e1[0]) / 360,
                r =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (e1[1] * Math.PI) / 360),
                      )) /
                  360,
                n = Math.pow(2, t.z);
              return [Math.round(i * n * Gi), Math.round(r * n * Gi)];
            }
            function Zi(e1, t) {
              for (let i = 0; i < t.length; i++) if (Ui(e1, t[i])) return !0;
              return !1;
            }
            function $i(e1, t, i) {
              for (const r of i)
                for (let i = 0, n = r.length, o = n - 1; i < n; o = i++)
                  if (ji(e1, t, r[o], r[i])) return !0;
              return !1;
            }
            function Hi(e1, t) {
              for (let i = 0; i < e1.length; ++i) if (!Ui(e1[i], t)) return !1;
              for (let i = 0; i < e1.length - 1; ++i)
                if ($i(e1[i], e1[i + 1], t)) return !1;
              return !0;
            }
            function Wi(e1, t) {
              for (let i = 0; i < t.length; i++) if (Hi(e1, t[i])) return !0;
              return !1;
            }
            function Xi(e1, t, i) {
              const r = [];
              for (let n = 0; n < e1.length; n++) {
                const o = [];
                for (let r = 0; r < e1[n].length; r++) {
                  const s = qi(e1[n][r], i);
                  Bi(t, s), o.push(s);
                }
                r.push(o);
              }
              return r;
            }
            function Yi(e1, t, i) {
              const r = [];
              for (let n = 0; n < e1.length; n++) {
                const o = Xi(e1[n], t, i);
                r.push(o);
              }
              return r;
            }
            function Ki(e1, t, i, r) {
              if (e1[0] < i[0] || e1[0] > i[2]) {
                const t = 0.5 * r;
                let n = e1[0] - i[0] > t ? -r : i[0] - e1[0] > t ? r : 0;
                0 === n &&
                  (n = e1[0] - i[2] > t ? -r : i[2] - e1[0] > t ? r : 0),
                  (e1[0] += n);
              }
              Bi(t, e1);
            }
            function Ji(e1, t, i, r) {
              const n = Math.pow(2, r.z) * Gi,
                o = [r.x * Gi, r.y * Gi],
                s = [];
              if (!e1) return s;
              for (const r of e1)
                for (const e1 of r) {
                  const r = [e1.x + o[0], e1.y + o[1]];
                  Ki(r, t, i, n), s.push(r);
                }
              return s;
            }
            function Qi(e1, t, i, r) {
              const n = Math.pow(2, r.z) * Gi,
                o = [r.x * Gi, r.y * Gi],
                s = [];
              if (!e1) return s;
              for (const i of e1) {
                const e1 = [];
                for (const r of i) {
                  const i = [r.x + o[0], r.y + o[1]];
                  Bi(t, i), e1.push(i);
                }
                s.push(e1);
              }
              if (t[2] - t[0] <= n / 2) {
                ((a = t)[0] = a[1] = 1 / 0), (a[2] = a[3] = -1 / 0);
                for (const e1 of s) for (const r of e1) Ki(r, t, i, n);
              }
              var a;
              return s;
            }
            class er {
              constructor(e1, t) {
                (this.type = jt), (this.geojson = e1), (this.geometries = t);
              }
              static parse(e1, t) {
                if (2 !== e1.length)
                  return t.error(
                    `'within' expression requires exactly one argument, but found ${
                      e1.length - 1
                    } instead.`,
                  );
                if (fi(e1[1])) {
                  const t = e1[1];
                  if ("FeatureCollection" === t.type)
                    for (let e1 = 0; e1 < t.features.length; ++e1) {
                      const i = t.features[e1].geometry.type;
                      if ("Polygon" === i || "MultiPolygon" === i)
                        return new er(t, t.features[e1].geometry);
                    }
                  else if ("Feature" === t.type) {
                    const e1 = t.geometry.type;
                    if ("Polygon" === e1 || "MultiPolygon" === e1)
                      return new er(t, t.geometry);
                  } else if ("Polygon" === t.type || "MultiPolygon" === t.type)
                    return new er(t, t);
                }
                return t.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type.",
                );
              }
              evaluate(e1) {
                if (null != e1.geometry() && null != e1.canonicalID()) {
                  if ("Point" === e1.geometryType())
                    return (function (e1, t) {
                      const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        n = e1.canonicalID();
                      if (!n) return !1;
                      if ("Polygon" === t.type) {
                        const o = Xi(t.coordinates, r, n),
                          s = Ji(e1.geometry(), i, r, n);
                        if (!Fi(i, r)) return !1;
                        for (const e1 of s) if (!Ui(e1, o)) return !1;
                      }
                      if ("MultiPolygon" === t.type) {
                        const o = Yi(t.coordinates, r, n),
                          s = Ji(e1.geometry(), i, r, n);
                        if (!Fi(i, r)) return !1;
                        for (const e1 of s) if (!Zi(e1, o)) return !1;
                      }
                      return !0;
                    })(e1, this.geometries);
                  if ("LineString" === e1.geometryType())
                    return (function (e1, t) {
                      const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        n = e1.canonicalID();
                      if (!n) return !1;
                      if ("Polygon" === t.type) {
                        const o = Xi(t.coordinates, r, n),
                          s = Qi(e1.geometry(), i, r, n);
                        if (!Fi(i, r)) return !1;
                        for (const e1 of s) if (!Hi(e1, o)) return !1;
                      }
                      if ("MultiPolygon" === t.type) {
                        const o = Yi(t.coordinates, r, n),
                          s = Qi(e1.geometry(), i, r, n);
                        if (!Fi(i, r)) return !1;
                        for (const e1 of s) if (!Wi(e1, o)) return !1;
                      }
                      return !0;
                    })(e1, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["within", this.geojson];
              }
            }
            var tr = er,
              ir = {
                exports: {},
              };
            ir.exports = (function () {
              var e1 = {
                  kilometers: 1,
                  miles: 1e3 / 1609.344,
                  nauticalmiles: 1e3 / 1852,
                  meters: 1e3,
                  metres: 1e3,
                  yards: 1e3 / 0.9144,
                  feet: 1e3 / 0.3048,
                  inches: 1e3 / 0.0254,
                },
                t = 1 / 298.257223563,
                i = t * (2 - t),
                r = Math.PI / 180,
                n = function (t, n) {
                  if (void 0 === t) throw new Error("No latitude given.");
                  if (n && !e1[n])
                    throw new Error(
                      "Unknown unit " +
                        n +
                        ". Use one of: " +
                        Object.keys(e1).join(", "),
                    );
                  var o = 6378.137 * r * (n ? e1[n] : 1),
                    s = Math.cos(t * r),
                    a = 1 / (1 - i * (1 - s * s)),
                    l = Math.sqrt(a);
                  (this.kx = o * l * s), (this.ky = o * l * a * (1 - i));
                },
                o = {
                  units: {
                    configurable: !0,
                  },
                };
              function s(e1, t) {
                return e1[0] === t[0] && e1[1] === t[1];
              }
              function a(e1, t, i) {
                var r = l(t[0] - e1[0]);
                return [e1[0] + r * i, e1[1] + (t[1] - e1[1]) * i];
              }
              function l(e1) {
                for (; e1 < -180; ) e1 += 360;
                for (; e1 > 180; ) e1 -= 360;
                return e1;
              }
              return (
                (n.fromTile = function (e1, t, i) {
                  var o = Math.PI * (1 - (2 * (e1 + 0.5)) / Math.pow(2, t)),
                    s = Math.atan(0.5 * (Math.exp(o) - Math.exp(-o))) / r;
                  return new n(s, i);
                }),
                (o.units.get = function () {
                  return e1;
                }),
                (n.prototype.distance = function (e1, t) {
                  var i = l(e1[0] - t[0]) * this.kx,
                    r = (e1[1] - t[1]) * this.ky;
                  return Math.sqrt(i * i + r * r);
                }),
                (n.prototype.bearing = function (e1, t) {
                  var i = l(t[0] - e1[0]) * this.kx;
                  return Math.atan2(i, (t[1] - e1[1]) * this.ky) / r;
                }),
                (n.prototype.destination = function (e1, t, i) {
                  var n = i * r;
                  return this.offset(e1, Math.sin(n) * t, Math.cos(n) * t);
                }),
                (n.prototype.offset = function (e1, t, i) {
                  return [e1[0] + t / this.kx, e1[1] + i / this.ky];
                }),
                (n.prototype.lineDistance = function (e1) {
                  for (var t = 0, i = 0; i < e1.length - 1; i++)
                    t += this.distance(e1[i], e1[i + 1]);
                  return t;
                }),
                (n.prototype.area = function (e1) {
                  for (var t = 0, i = 0; i < e1.length; i++)
                    for (
                      var r = e1[i], n = 0, o = r.length, s = o - 1;
                      n < o;
                      s = n++
                    )
                      t +=
                        l(r[n][0] - r[s][0]) *
                        (r[n][1] + r[s][1]) *
                        (i ? -1 : 1);
                  return (Math.abs(t) / 2) * this.kx * this.ky;
                }),
                (n.prototype.along = function (e1, t) {
                  var i = 0;
                  if (t <= 0) return e1[0];
                  for (var r = 0; r < e1.length - 1; r++) {
                    var n = e1[r],
                      o = e1[r + 1],
                      s = this.distance(n, o);
                    if ((i += s) > t) return a(n, o, (t - (i - s)) / s);
                  }
                  return e1[e1.length - 1];
                }),
                (n.prototype.pointToSegmentDistance = function (e1, t, i) {
                  var r = t[0],
                    n = t[1],
                    o = l(i[0] - r) * this.kx,
                    s = (i[1] - n) * this.ky,
                    a = 0;
                  return (
                    (0 === o && 0 === s) ||
                      ((a =
                        (l(e1[0] - r) * this.kx * o +
                          (e1[1] - n) * this.ky * s) /
                        (o * o + s * s)) > 1
                        ? ((r = i[0]), (n = i[1]))
                        : a > 0 &&
                          ((r += (o / this.kx) * a), (n += (s / this.ky) * a))),
                    (o = l(e1[0] - r) * this.kx),
                    (s = (e1[1] - n) * this.ky),
                    Math.sqrt(o * o + s * s)
                  );
                }),
                (n.prototype.pointOnLine = function (e1, t) {
                  for (
                    var i, r, n, o, s = 1 / 0, a = 0;
                    a < e1.length - 1;
                    a++
                  ) {
                    var c = e1[a][0],
                      h = e1[a][1],
                      u = l(e1[a + 1][0] - c) * this.kx,
                      d = (e1[a + 1][1] - h) * this.ky,
                      p = 0;
                    (0 === u && 0 === d) ||
                      ((p =
                        (l(t[0] - c) * this.kx * u + (t[1] - h) * this.ky * d) /
                        (u * u + d * d)) > 1
                        ? ((c = e1[a + 1][0]), (h = e1[a + 1][1]))
                        : p > 0 &&
                          ((c += (u / this.kx) * p), (h += (d / this.ky) * p)));
                    var f =
                      (u = l(t[0] - c) * this.kx) * u +
                      (d = (t[1] - h) * this.ky) * d;
                    f < s && ((s = f), (i = c), (r = h), (n = a), (o = p));
                  }
                  return {
                    point: [i, r],
                    index: n,
                    t: Math.max(0, Math.min(1, o)),
                  };
                }),
                (n.prototype.lineSlice = function (e1, t, i) {
                  var r = this.pointOnLine(i, e1),
                    n = this.pointOnLine(i, t);
                  if (r.index > n.index || (r.index === n.index && r.t > n.t)) {
                    var o = r;
                    (r = n), (n = o);
                  }
                  var a = [r.point],
                    l = r.index + 1,
                    c = n.index;
                  !s(i[l], a[0]) && l <= c && a.push(i[l]);
                  for (var h = l + 1; h <= c; h++) a.push(i[h]);
                  return s(i[c], n.point) || a.push(n.point), a;
                }),
                (n.prototype.lineSliceAlong = function (e1, t, i) {
                  for (var r = 0, n = [], o = 0; o < i.length - 1; o++) {
                    var s = i[o],
                      l = i[o + 1],
                      c = this.distance(s, l);
                    if (
                      ((r += c) > e1 &&
                        0 === n.length &&
                        n.push(a(s, l, (e1 - (r - c)) / c)),
                      r >= t)
                    )
                      return n.push(a(s, l, (t - (r - c)) / c)), n;
                    r > e1 && n.push(l);
                  }
                  return n;
                }),
                (n.prototype.bufferPoint = function (e1, t) {
                  var i = t / this.ky,
                    r = t / this.kx;
                  return [e1[0] - r, e1[1] - i, e1[0] + r, e1[1] + i];
                }),
                (n.prototype.bufferBBox = function (e1, t) {
                  var i = t / this.ky,
                    r = t / this.kx;
                  return [e1[0] - r, e1[1] - i, e1[2] + r, e1[3] + i];
                }),
                (n.prototype.insideBBox = function (e1, t) {
                  return (
                    l(e1[0] - t[0]) >= 0 &&
                    l(e1[0] - t[2]) <= 0 &&
                    e1[1] >= t[1] &&
                    e1[1] <= t[3]
                  );
                }),
                Object.defineProperties(n, o),
                n
              );
            })();
            var rr = d(ir.exports),
              nr = {
                exports: {},
              };
            nr.exports = (function () {
              var e1 = function (e1, i) {
                if (
                  (void 0 === e1 && (e1 = []),
                  void 0 === i && (i = t),
                  (this.data = e1),
                  (this.length = this.data.length),
                  (this.compare = i),
                  this.length > 0)
                )
                  for (var r = (this.length >> 1) - 1; r >= 0; r--)
                    this._down(r);
              };
              function t(e1, t) {
                return e1 < t ? -1 : e1 > t ? 1 : 0;
              }
              return (
                (e1.prototype.push = function (e1) {
                  this.data.push(e1), this.length++, this._up(this.length - 1);
                }),
                (e1.prototype.pop = function () {
                  if (0 !== this.length) {
                    var e1 = this.data[0],
                      t = this.data.pop();
                    return (
                      this.length--,
                      this.length > 0 && ((this.data[0] = t), this._down(0)),
                      e1
                    );
                  }
                }),
                (e1.prototype.peek = function () {
                  return this.data[0];
                }),
                (e1.prototype._up = function (e1) {
                  for (
                    var t = this.data, i = this.compare, r = t[e1];
                    e1 > 0;

                  ) {
                    var n = (e1 - 1) >> 1,
                      o = t[n];
                    if (i(r, o) >= 0) break;
                    (t[e1] = o), (e1 = n);
                  }
                  t[e1] = r;
                }),
                (e1.prototype._down = function (e1) {
                  for (
                    var t = this.data,
                      i = this.compare,
                      r = this.length >> 1,
                      n = t[e1];
                    e1 < r;

                  ) {
                    var o = 1 + (e1 << 1),
                      s = t[o],
                      a = o + 1;
                    if (
                      (a < this.length &&
                        i(t[a], s) < 0 &&
                        ((o = a), (s = t[a])),
                      i(s, n) >= 0)
                    )
                      break;
                    (t[e1] = s), (e1 = o);
                  }
                  t[e1] = n;
                }),
                e1
              );
            })();
            var or = d(nr.exports),
              sr = 8192;
            function ar(e1, t) {
              return t.dist - e1.dist;
            }
            const lr = 100,
              cr = 50;
            function hr(e1) {
              const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              if (t.length !== e1.length) return !1;
              for (let i = 0; i < t.length; i++) if (t[i] !== e1[i]) return !1;
              return !0;
            }
            function ur(e1) {
              return e1[1] - e1[0] + 1;
            }
            function dr(e1, t) {
              const i = e1[1] >= e1[0] && e1[1] < t;
              return (
                i || console.warn("Distance Expression: Index is out of range"),
                i
              );
            }
            function pr(e1, t) {
              if (e1[0] > e1[1]) return [null, null];
              const i = ur(e1);
              if (t) {
                if (2 === i) return [e1, null];
                const t = Math.floor(i / 2);
                return [
                  [e1[0], e1[0] + t],
                  [e1[0] + t, e1[1]],
                ];
              }
              {
                if (1 === i) return [e1, null];
                const t = Math.floor(i / 2) - 1;
                return [
                  [e1[0], e1[0] + t],
                  [e1[0] + t + 1, e1[1]],
                ];
              }
            }
            function fr(e1, t) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              if (!dr(t, e1.length)) return i;
              for (let r = t[0]; r <= t[1]; ++r) Bi(i, e1[r]);
              return i;
            }
            function mr(e1) {
              const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let i = 0; i < e1.length; ++i)
                for (let r = 0; r < e1[i].length; ++r) Bi(t, e1[i][r]);
              return t;
            }
            function _r(e1, t, i) {
              if (hr(e1) || hr(t)) return NaN;
              let r = 0,
                n = 0;
              return (
                e1[2] < t[0] && (r = t[0] - e1[2]),
                e1[0] > t[2] && (r = e1[0] - t[2]),
                e1[1] > t[3] && (n = e1[1] - t[3]),
                e1[3] < t[1] && (n = t[1] - e1[3]),
                i.distance([0, 0], [r, n])
              );
            }
            function gr(e1, t) {
              const i = Math.pow(2, t.z);
              var r, n;
              return [
                ((n = (e1.x / sr + t.x) / i), 360 * n - 180),
                ((r = (e1.y / sr + t.y) / i),
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) -
                  90),
              ];
            }
            function yr(e1, t) {
              const i = [];
              for (let r = 0; r < e1.length; ++r) i.push(gr(e1[r], t));
              return i;
            }
            function xr(e1, t, i) {
              const r = i.pointOnLine(t, e1).point;
              return i.distance(e1, r);
            }
            function vr(e1, t, i, r, n) {
              const o = i.slice(r[0], r[1] + 1);
              let s = 1 / 0;
              for (let i = t[0]; i <= t[1]; ++i)
                if (0 === (s = Math.min(s, xr(e1[i], o, n)))) return 0;
              return s;
            }
            function br(e1, t, i, r, n) {
              const o = Math.min(
                  n.pointToSegmentDistance(e1, i, r),
                  n.pointToSegmentDistance(t, i, r),
                ),
                s = Math.min(
                  n.pointToSegmentDistance(i, e1, t),
                  n.pointToSegmentDistance(r, e1, t),
                );
              return Math.min(o, s);
            }
            function wr(e1, t, i, r, n) {
              if (!dr(t, e1.length) || !dr(r, i.length)) return NaN;
              let o = 1 / 0;
              for (let s = t[0]; s < t[1]; ++s)
                for (let t = r[0]; t < r[1]; ++t) {
                  if (ji(e1[s], e1[s + 1], i[t], i[t + 1])) return 0;
                  o = Math.min(o, br(e1[s], e1[s + 1], i[t], i[t + 1], n));
                }
              return o;
            }
            function Tr(e1, t, i, r, n) {
              if (!dr(t, e1.length) || !dr(r, i.length)) return NaN;
              let o = 1 / 0;
              for (let s = t[0]; s <= t[1]; ++s)
                for (let t = r[0]; t <= r[1]; ++t)
                  if (0 === (o = Math.min(o, n.distance(e1[s], i[t]))))
                    return o;
              return o;
            }
            function Er(e1, t, i) {
              if (Ui(e1, t, !0)) return 0;
              let r = 1 / 0;
              for (const n of t) {
                const t = n.length;
                if (t < 2)
                  return (
                    console.warn("Distance Expression: Invalid polygon!"), NaN
                  );
                if (
                  n[0] !== n[t - 1] &&
                  0 ===
                    (r = Math.min(
                      r,
                      i.pointToSegmentDistance(e1, n[t - 1], n[0]),
                    ))
                )
                  return r;
                if (0 === (r = Math.min(r, xr(e1, n, i)))) return r;
              }
              return r;
            }
            function Mr(e1, t, i, r) {
              if (!dr(t, e1.length)) return NaN;
              for (let r = t[0]; r <= t[1]; ++r) if (Ui(e1[r], i, !0)) return 0;
              let n = 1 / 0;
              for (let o = t[0]; o < t[1]; ++o)
                for (const t of i)
                  for (let i = 0, s = t.length, a = s - 1; i < s; a = i++) {
                    if (ji(e1[o], e1[o + 1], t[a], t[i])) return 0;
                    n = Math.min(n, br(e1[o], e1[o + 1], t[a], t[i], r));
                  }
              return n;
            }
            function Ar(e1, t) {
              for (const i of e1)
                for (let e1 = 0; e1 <= i.length - 1; ++e1)
                  if (Ui(i[e1], t, !0)) return !0;
              return !1;
            }
            function Sr(e1, t, i, r = 1 / 0) {
              const n = mr(e1),
                o = mr(t);
              if (r !== 1 / 0 && _r(n, o, i) >= r) return r;
              if (Fi(n, o)) {
                if (Ar(e1, t)) return 0;
              } else if (Ar(t, e1)) return 0;
              let s = r;
              for (const r of e1)
                for (let e1 = 0, n = r.length, o = n - 1; e1 < n; o = e1++)
                  for (const n of t)
                    for (let t = 0, a = n.length, l = a - 1; t < a; l = t++) {
                      if (ji(r[o], r[e1], n[l], n[t])) return 0;
                      s = Math.min(s, br(r[o], r[e1], n[l], n[t], i));
                    }
              return s;
            }
            function Ir(e1, t, i, r, n, o, s) {
              if (null === o || null === s) return;
              const a = _r(fr(r, o), fr(n, s), i);
              a < t &&
                e1.push({
                  dist: a,
                  range1: o,
                  range2: s,
                });
            }
            function Cr(e1, t, i, r, n = 1 / 0) {
              let o = Math.min(r.distance(e1[0], i[0][0]), n);
              if (0 === o) return o;
              const s = new or(
                  [
                    {
                      dist: 0,
                      range1: [0, e1.length - 1],
                      range2: [0, 0],
                    },
                  ],
                  ar,
                ),
                a = t ? cr : lr,
                l = mr(i);
              for (; s.length; ) {
                const n = s.pop();
                if (n.dist >= o) continue;
                const c = n.range1;
                if (ur(c) <= a) {
                  if (!dr(c, e1.length)) return NaN;
                  if (t) {
                    const t = Mr(e1, c, i, r);
                    if (0 === (o = Math.min(o, t))) return o;
                  } else
                    for (let t = c[0]; t <= c[1]; ++t) {
                      const n = Er(e1[t], i, r);
                      if (0 === (o = Math.min(o, n))) return o;
                    }
                } else {
                  const i = pr(c, t);
                  if (null !== i[0]) {
                    const t = _r(fr(e1, i[0]), l, r);
                    t < o &&
                      s.push({
                        dist: t,
                        range1: i[0],
                        range2: [0, 0],
                      });
                  }
                  if (null !== i[1]) {
                    const t = _r(fr(e1, i[1]), l, r);
                    t < o &&
                      s.push({
                        dist: t,
                        range1: i[1],
                        range2: [0, 0],
                      });
                  }
                }
              }
              return o;
            }
            function zr(e1, t, i, r, n, o = 1 / 0) {
              let s = Math.min(o, n.distance(e1[0], i[0]));
              if (0 === s) return s;
              const a = new or(
                  [
                    {
                      dist: 0,
                      range1: [0, e1.length - 1],
                      range2: [0, i.length - 1],
                    },
                  ],
                  ar,
                ),
                l = t ? cr : lr,
                c = r ? cr : lr;
              for (; a.length; ) {
                const o = a.pop();
                if (o.dist >= s) continue;
                const h = o.range1,
                  u = o.range2;
                if (ur(h) <= l && ur(u) <= c) {
                  if (!dr(h, e1.length) || !dr(u, i.length)) return NaN;
                  if (
                    (t && r
                      ? (s = Math.min(s, wr(e1, h, i, u, n)))
                      : t || r
                      ? t && !r
                        ? (s = Math.min(s, vr(i, u, e1, h, n)))
                        : !t && r && (s = Math.min(s, vr(e1, h, i, u, n)))
                      : (s = Math.min(s, Tr(e1, h, i, u, n))),
                    0 === s)
                  )
                    return s;
                } else {
                  const o = pr(h, t),
                    l = pr(u, r);
                  Ir(a, s, n, e1, i, o[0], l[0]),
                    Ir(a, s, n, e1, i, o[0], l[1]),
                    Ir(a, s, n, e1, i, o[1], l[0]),
                    Ir(a, s, n, e1, i, o[1], l[1]);
                }
              }
              return s;
            }
            function Dr(e1, t, i, r, n = 1 / 0) {
              let o = n;
              const s = fr(e1, [0, e1.length - 1]);
              for (const n of i)
                if (
                  !(o !== 1 / 0 && _r(s, fr(n, [0, n.length - 1]), r) >= o) &&
                  ((o = Math.min(o, zr(e1, t, n, !0, r, o))), 0 === o)
                )
                  return o;
              return o;
            }
            function Pr(e1, t, i, r, n = 1 / 0) {
              let o = n;
              const s = fr(e1, [0, e1.length - 1]);
              for (const n of i) {
                if (o !== 1 / 0 && _r(s, mr(n), r) >= o) continue;
                const i = Cr(e1, t, n, r, o);
                if (isNaN(i)) return i;
                if (0 === (o = Math.min(o, i))) return o;
              }
              return o;
            }
            function Rr(e1) {
              return (
                "Point" === e1 ||
                "MultiPoint" === e1 ||
                "LineString" === e1 ||
                "MultiLineString" === e1 ||
                "Polygon" === e1 ||
                "MultiPolygon" === e1
              );
            }
            class Lr {
              constructor(e1, t) {
                (this.type = Ut), (this.geojson = e1), (this.geometries = t);
              }
              static parse(e1, t) {
                if (2 !== e1.length)
                  return t.error(
                    `'distance' expression requires either one argument, but found ' ${
                      e1.length - 1
                    } instead.`,
                  );
                if (fi(e1[1])) {
                  const t = e1[1];
                  if ("FeatureCollection" === t.type) {
                    for (let e1 = 0; e1 < t.features.length; ++e1)
                      if (Rr(t.features[e1].geometry.type))
                        return new Lr(t, t.features[e1].geometry);
                  } else if ("Feature" === t.type) {
                    if (Rr(t.geometry.type)) return new Lr(t, t.geometry);
                  } else if (Rr(t.type)) return new Lr(t, t);
                }
                return t.error(
                  "'distance' expression needs to be an array with format ['Distance', GeoJSONObj].",
                );
              }
              evaluate(e1) {
                const t = e1.geometry(),
                  i = e1.canonicalID();
                if (null != t && null != i) {
                  if ("Point" === e1.geometryType())
                    return (function (e1, t, i) {
                      const r = [];
                      for (const i of e1) for (const e1 of i) r.push(gr(e1, t));
                      const n = new rr(r[0][1], "meters");
                      return "Point" === i.type ||
                        "MultiPoint" === i.type ||
                        "LineString" === i.type
                        ? zr(
                            r,
                            !1,
                            "Point" === i.type
                              ? [i.coordinates]
                              : i.coordinates,
                            "LineString" === i.type,
                            n,
                          )
                        : "MultiLineString" === i.type
                        ? Dr(r, !1, i.coordinates, n)
                        : "Polygon" === i.type || "MultiPolygon" === i.type
                        ? Pr(
                            r,
                            !1,
                            "Polygon" === i.type
                              ? [i.coordinates]
                              : i.coordinates,
                            n,
                          )
                        : null;
                    })(t, i, this.geometries);
                  if ("LineString" === e1.geometryType())
                    return (function (e1, t, i) {
                      const r = [];
                      for (const i of e1) {
                        const e1 = [];
                        for (const r of i) e1.push(gr(r, t));
                        r.push(e1);
                      }
                      const n = new rr(r[0][0][1], "meters");
                      if (
                        "Point" === i.type ||
                        "MultiPoint" === i.type ||
                        "LineString" === i.type
                      )
                        return Dr(
                          "Point" === i.type ? [i.coordinates] : i.coordinates,
                          "LineString" === i.type,
                          r,
                          n,
                        );
                      if ("MultiLineString" === i.type) {
                        let e1 = 1 / 0;
                        for (let t = 0; t < i.coordinates.length; t++) {
                          const o = Dr(i.coordinates[t], !0, r, n, e1);
                          if (isNaN(o)) return o;
                          if (0 === (e1 = Math.min(e1, o))) return e1;
                        }
                        return e1;
                      }
                      if ("Polygon" === i.type || "MultiPolygon" === i.type) {
                        let e1 = 1 / 0;
                        for (let t = 0; t < r.length; t++) {
                          const o = Pr(
                            r[t],
                            !0,
                            "Polygon" === i.type
                              ? [i.coordinates]
                              : i.coordinates,
                            n,
                            e1,
                          );
                          if (isNaN(o)) return o;
                          if (0 === (e1 = Math.min(e1, o))) return e1;
                        }
                        return e1;
                      }
                      return null;
                    })(t, i, this.geometries);
                  if ("Polygon" === e1.geometryType())
                    return (function (e1, t, i) {
                      const r = [];
                      for (const i of (function (e1, t) {
                        const i = e1.length;
                        if (i <= 1) return [e1];
                        const r = [];
                        let n, o;
                        for (let t = 0; t < i; t++) {
                          const i = Oi(e1[t]);
                          0 !== i &&
                            ((e1[t].area = Math.abs(i)),
                            void 0 === o && (o = i < 0),
                            o === i < 0
                              ? (n && r.push(n), (n = [e1[t]]))
                              : n.push(e1[t]));
                        }
                        return n && r.push(n), r;
                      })(e1)) {
                        const e1 = [];
                        for (let r = 0; r < i.length; ++r) e1.push(yr(i[r], t));
                        r.push(e1);
                      }
                      const n = new rr(r[0][0][0][1], "meters");
                      if (
                        "Point" === i.type ||
                        "MultiPoint" === i.type ||
                        "LineString" === i.type
                      )
                        return Pr(
                          "Point" === i.type ? [i.coordinates] : i.coordinates,
                          "LineString" === i.type,
                          r,
                          n,
                        );
                      if ("MultiLineString" === i.type) {
                        let e1 = 1 / 0;
                        for (let t = 0; t < i.coordinates.length; t++) {
                          const o = Pr(i.coordinates[t], !0, r, n, e1);
                          if (isNaN(o)) return o;
                          if (0 === (e1 = Math.min(e1, o))) return e1;
                        }
                        return e1;
                      }
                      return "Polygon" === i.type || "MultiPolygon" === i.type
                        ? (function (e1, t, i) {
                            let r = 1 / 0;
                            for (const n of e1)
                              for (const e1 of t) {
                                const t = Sr(n, e1, i, r);
                                if (isNaN(t)) return t;
                                if (0 === (r = Math.min(r, t))) return r;
                              }
                            return r;
                          })(
                            "Polygon" === i.type
                              ? [i.coordinates]
                              : i.coordinates,
                            r,
                            n,
                          )
                        : null;
                    })(t, i, this.geometries);
                  console.warn(
                    "Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.",
                  );
                } else
                  console.warn(
                    "Distance Expression: requirs valid feature and canonical information.",
                  );
                return null;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["distance", this.geojson];
              }
            }
            var kr = Lr;
            function Or(e1) {
              if (e1 instanceof Pi) {
                if ("get" === e1.name && 1 === e1.args.length) return !1;
                if ("feature-state" === e1.name) return !1;
                if ("has" === e1.name && 1 === e1.args.length) return !1;
                if (
                  "properties" === e1.name ||
                  "geometry-type" === e1.name ||
                  "id" === e1.name
                )
                  return !1;
                if (/^filter-/.test(e1.name)) return !1;
              }
              if (e1 instanceof tr) return !1;
              if (e1 instanceof kr) return !1;
              let t = !0;
              return (
                e1.eachChild((e1) => {
                  t && !Or(e1) && (t = !1);
                }),
                t
              );
            }
            function Br(e1) {
              if (e1 instanceof Pi && "feature-state" === e1.name) return !1;
              let t = !0;
              return (
                e1.eachChild((e1) => {
                  t && !Br(e1) && (t = !1);
                }),
                t
              );
            }
            function Fr(e1) {
              if (e1 instanceof Pi && "config" === e1.name) return !1;
              let t = !0;
              return (
                e1.eachChild((e1) => {
                  t && !Fr(e1) && (t = !1);
                }),
                t
              );
            }
            function Nr(e1, t) {
              if (e1 instanceof Pi && t.indexOf(e1.name) >= 0) return !1;
              let i = !0;
              return (
                e1.eachChild((e1) => {
                  i && !Nr(e1, t) && (i = !1);
                }),
                i
              );
            }
            class Ur {
              constructor(e1, t) {
                (this.type = t.type),
                  (this.name = e1),
                  (this.boundExpression = t);
              }
              static parse(e1, t) {
                if (2 !== e1.length || "string" != typeof e1[1])
                  return t.error(
                    "'var' expression requires exactly one string literal argument.",
                  );
                const i = e1[1];
                return t.scope.has(i)
                  ? new Ur(i, t.scope.get(i))
                  : t.error(
                      `Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`,
                      1,
                    );
              }
              evaluate(e1) {
                return this.boundExpression.evaluate(e1);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["var", this.name];
              }
            }
            var Vr = Ur;
            class jr {
              constructor(e1, t = [], i, r = new Ft(), n = [], o) {
                (this.registry = e1),
                  (this.path = t),
                  (this.key = t.map((e1) => `[${e1}]`).join("")),
                  (this.scope = r),
                  (this.errors = n),
                  (this.expectedType = i),
                  (this.options = o);
              }
              parse(e1, t, i, r, n = {}) {
                return t || i
                  ? this.concat(t, i, r)._parse(e1, n)
                  : this._parse(e1, n);
              }
              _parse(e1, t) {
                function i(e1, t, i) {
                  return "assert" === i
                    ? new wi(t, [e1])
                    : "coerce" === i
                    ? new Ii(t, [e1])
                    : e1;
                }
                if (
                  ((null !== e1 &&
                    "string" != typeof e1 &&
                    "boolean" != typeof e1 &&
                    "number" != typeof e1) ||
                    (e1 = ["literal", e1]),
                  Array.isArray(e1))
                ) {
                  if (0 === e1.length)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].',
                    );
                  const r =
                    "string" == typeof e1[0] ? this.registry[e1[0]] : void 0;
                  if (r) {
                    let n = r.parse(e1, this);
                    if (!n) return null;
                    if (this.expectedType) {
                      const e1 = this.expectedType,
                        r = n.type;
                      if (
                        ("string" !== e1.kind &&
                          "number" !== e1.kind &&
                          "boolean" !== e1.kind &&
                          "object" !== e1.kind &&
                          "array" !== e1.kind) ||
                        "value" !== r.kind
                      ) {
                        if (
                          ("color" !== e1.kind &&
                            "formatted" !== e1.kind &&
                            "resolvedImage" !== e1.kind) ||
                          ("value" !== r.kind && "string" !== r.kind)
                        ) {
                          if (this.checkSubtype(e1, r)) return null;
                        } else n = i(n, e1, t.typeAnnotation || "coerce");
                      } else n = i(n, e1, t.typeAnnotation || "assert");
                    }
                    if (
                      !(n instanceof yi) &&
                      "resolvedImage" !== n.type.kind &&
                      qr(n)
                    ) {
                      const e1 = new zi(this.options);
                      try {
                        n = new yi(n.type, n.evaluate(e1));
                      } catch (e1) {
                        return this.error(e1.message), null;
                      }
                    }
                    return n;
                  }
                  return Ii.parse(["to-array", e1], this);
                }
                return this.error(
                  void 0 === e1
                    ? "'undefined' value invalid. Use null instead."
                    : "object" == typeof e1
                    ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                    : `Expected an array, but found ${typeof e1} instead.`,
                );
              }
              concat(e1, t, i) {
                const r =
                    "number" == typeof e1 ? this.path.concat(e1) : this.path,
                  n = i ? this.scope.concat(i) : this.scope;
                return new jr(
                  this.registry,
                  r,
                  t || null,
                  n,
                  this.errors,
                  this.options,
                );
              }
              error(e1, ...t) {
                const i = `${this.key}${t.map((e1) => `[${e1}]`).join("")}`;
                this.errors.push(new Ot(i, e1));
              }
              checkSubtype(e1, t) {
                const i = Jt(e1, t);
                return i && this.error(i), i;
              }
            }
            var Gr = jr;
            function qr(e1) {
              if (e1 instanceof Vr) return qr(e1.boundExpression);
              if (e1 instanceof Pi && "error" === e1.name) return !1;
              if (e1 instanceof Pi && "config" === e1.name) return !1;
              if (e1 instanceof Ri) return !1;
              if (e1 instanceof tr) return !1;
              if (e1 instanceof kr) return !1;
              const t = e1 instanceof Ii || e1 instanceof wi;
              let i = !0;
              return (
                e1.eachChild((e1) => {
                  i = t ? i && qr(e1) : i && e1 instanceof yi;
                }),
                !!i &&
                  Or(e1) &&
                  Nr(e1, [
                    "zoom",
                    "heatmap-density",
                    "line-progress",
                    "raster-value",
                    "sky-radial-progress",
                    "accumulated",
                    "is-supported-script",
                    "pitch",
                    "distance-from-center",
                    "measure-light",
                  ])
              );
            }
            function Zr(e1, t) {
              const i = e1.length - 1;
              let r,
                n,
                o = 0,
                s = i,
                a = 0;
              for (; o <= s; )
                if (
                  ((a = Math.floor((o + s) / 2)),
                  (r = e1[a]),
                  (n = e1[a + 1]),
                  r <= t)
                ) {
                  if (a === i || t < n) return a;
                  o = a + 1;
                } else {
                  if (!(r > t)) throw new xi("Input is not a number.");
                  s = a - 1;
                }
              return 0;
            }
            class $r {
              constructor(e1, t, i) {
                (this.type = e1),
                  (this.input = t),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [e1, t] of i)
                  this.labels.push(e1), this.outputs.push(t);
              }
              static parse(e1, t) {
                if (e1.length - 1 < 4)
                  return t.error(
                    `Expected at least 4 arguments, but found only ${
                      e1.length - 1
                    }.`,
                  );
                if ((e1.length - 1) % 2 != 0)
                  return t.error("Expected an even number of arguments.");
                const i = t.parse(e1[1], 1, Ut);
                if (!i) return null;
                const r = [];
                let n = null;
                t.expectedType &&
                  "value" !== t.expectedType.kind &&
                  (n = t.expectedType);
                for (let i = 1; i < e1.length; i += 2) {
                  const o = 1 === i ? -1 / 0 : e1[i],
                    s = e1[i + 1],
                    a = i,
                    l = i + 1;
                  if ("number" != typeof o)
                    return t.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      a,
                    );
                  if (r.length && r[r.length - 1][0] >= o)
                    return t.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      a,
                    );
                  const c = t.parse(s, l, n);
                  if (!c) return null;
                  (n = n || c.type), r.push([o, c]);
                }
                return new $r(n, i, r);
              }
              evaluate(e1) {
                const t = this.labels,
                  i = this.outputs;
                if (1 === t.length) return i[0].evaluate(e1);
                const r = this.input.evaluate(e1);
                if (r <= t[0]) return i[0].evaluate(e1);
                const n = t.length;
                return r >= t[n - 1]
                  ? i[n - 1].evaluate(e1)
                  : i[Zr(t, r)].evaluate(e1);
              }
              eachChild(e1) {
                e1(this.input);
                for (const t of this.outputs) e1(t);
              }
              outputDefined() {
                return this.outputs.every((e1) => e1.outputDefined());
              }
              serialize() {
                const e1 = ["step", this.input.serialize()];
                for (let t = 0; t < this.labels.length; t++)
                  t > 0 && e1.push(this.labels[t]),
                    e1.push(this.outputs[t].serialize());
                return e1;
              }
            }
            var Hr = $r;
            function Wr(e1, t, i) {
              return e1 * (1 - i) + t * i;
            }
            function Xr(e1, t, i) {
              return e1.map((e1, r) => Wr(e1, t[r], i));
            }
            var Yr = Object.freeze({
              __proto__: null,
              array: Xr,
              color: function (e1, t, i) {
                return new li(
                  Wr(e1.r, t.r, i),
                  Wr(e1.g, t.g, i),
                  Wr(e1.b, t.b, i),
                  Wr(e1.a, t.a, i),
                );
              },
              number: Wr,
            });
            const Kr = 0.95047,
              Jr = 1.08883,
              Qr = 4 / 29,
              en = 6 / 29,
              tn = 3 * en * en,
              rn = en * en * en,
              nn = Math.PI / 180,
              on = 180 / Math.PI;
            function sn(e1) {
              return e1 > rn ? Math.pow(e1, 1 / 3) : e1 / tn + Qr;
            }
            function an(e1) {
              return e1 > en ? e1 * e1 * e1 : tn * (e1 - Qr);
            }
            function ln(e1) {
              return (
                255 *
                (e1 <= 0.0031308
                  ? 12.92 * e1
                  : 1.055 * Math.pow(e1, 1 / 2.4) - 0.055)
              );
            }
            function cn(e1) {
              return (e1 /= 255) <= 0.04045
                ? e1 / 12.92
                : Math.pow((e1 + 0.055) / 1.055, 2.4);
            }
            function hn(e1) {
              const t = cn(e1.r),
                i = cn(e1.g),
                r = cn(e1.b),
                n = sn((0.4124564 * t + 0.3575761 * i + 0.1804375 * r) / Kr),
                o = sn((0.2126729 * t + 0.7151522 * i + 0.072175 * r) / 1);
              return {
                l: 116 * o - 16,
                a: 500 * (n - o),
                b:
                  200 *
                  (o - sn((0.0193339 * t + 0.119192 * i + 0.9503041 * r) / Jr)),
                alpha: e1.a,
              };
            }
            function un(e1) {
              let t = (e1.l + 16) / 116,
                i = isNaN(e1.a) ? t : t + e1.a / 500,
                r = isNaN(e1.b) ? t : t - e1.b / 200;
              return (
                (t = 1 * an(t)),
                (i = Kr * an(i)),
                (r = Jr * an(r)),
                new li(
                  ln(3.2404542 * i - 1.5371385 * t - 0.4985314 * r),
                  ln(-0.969266 * i + 1.8760108 * t + 0.041556 * r),
                  ln(0.0556434 * i - 0.2040259 * t + 1.0572252 * r),
                  e1.alpha,
                )
              );
            }
            function dn(e1, t, i) {
              const r = t - e1;
              return (
                e1 +
                i * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r)
              );
            }
            const pn = {
                forward: hn,
                reverse: un,
                interpolate: function (e1, t, i) {
                  return {
                    l: Wr(e1.l, t.l, i),
                    a: Wr(e1.a, t.a, i),
                    b: Wr(e1.b, t.b, i),
                    alpha: Wr(e1.alpha, t.alpha, i),
                  };
                },
              },
              fn = {
                forward: function (e1) {
                  const { l: t, a: i, b: r } = hn(e1),
                    n = Math.atan2(r, i) * on;
                  return {
                    h: n < 0 ? n + 360 : n,
                    c: Math.sqrt(i * i + r * r),
                    l: t,
                    alpha: e1.a,
                  };
                },
                reverse: function (e1) {
                  const t = e1.h * nn,
                    i = e1.c;
                  return un({
                    l: e1.l,
                    a: Math.cos(t) * i,
                    b: Math.sin(t) * i,
                    alpha: e1.alpha,
                  });
                },
                interpolate: function (e1, t, i) {
                  return {
                    h: dn(e1.h, t.h, i),
                    c: Wr(e1.c, t.c, i),
                    l: Wr(e1.l, t.l, i),
                    alpha: Wr(e1.alpha, t.alpha, i),
                  };
                },
              };
            var mn = Object.freeze({
              __proto__: null,
              hcl: fn,
              lab: pn,
            });
            class _n {
              constructor(e1, t, i, r, n) {
                (this.type = e1),
                  (this.operator = t),
                  (this.interpolation = i),
                  (this.input = r),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [e1, t] of n)
                  this.labels.push(e1), this.outputs.push(t);
              }
              static interpolationFactor(e1, t, i, r) {
                let n = 0;
                if ("exponential" === e1.name) n = gn(t, e1.base, i, r);
                else if ("linear" === e1.name) n = gn(t, 1, i, r);
                else if ("cubic-bezier" === e1.name) {
                  const o = e1.controlPoints;
                  n = new m(o[0], o[1], o[2], o[3]).solve(gn(t, 1, i, r));
                }
                return n;
              }
              static parse(e1, t) {
                let [i, r, n, ...o] = e1;
                if (!Array.isArray(r) || 0 === r.length)
                  return t.error(
                    "Expected an interpolation type expression.",
                    1,
                  );
                if ("linear" === r[0])
                  r = {
                    name: "linear",
                  };
                else if ("exponential" === r[0]) {
                  const e1 = r[1];
                  if ("number" != typeof e1)
                    return t.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1,
                    );
                  r = {
                    name: "exponential",
                    base: e1,
                  };
                } else {
                  if ("cubic-bezier" !== r[0])
                    return t.error(
                      `Unknown interpolation type ${String(r[0])}`,
                      1,
                      0,
                    );
                  {
                    const e1 = r.slice(1);
                    if (
                      4 !== e1.length ||
                      e1.some((e1) => "number" != typeof e1 || e1 < 0 || e1 > 1)
                    )
                      return t.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1,
                      );
                    r = {
                      name: "cubic-bezier",
                      controlPoints: e1,
                    };
                  }
                }
                if (e1.length - 1 < 4)
                  return t.error(
                    `Expected at least 4 arguments, but found only ${
                      e1.length - 1
                    }.`,
                  );
                if ((e1.length - 1) % 2 != 0)
                  return t.error("Expected an even number of arguments.");
                if (((n = t.parse(n, 2, Ut)), !n)) return null;
                const s = [];
                let a = null;
                "interpolate-hcl" === i || "interpolate-lab" === i
                  ? (a = Gt)
                  : t.expectedType &&
                    "value" !== t.expectedType.kind &&
                    (a = t.expectedType);
                for (let e1 = 0; e1 < o.length; e1 += 2) {
                  const i = o[e1],
                    r = o[e1 + 1],
                    n = e1 + 3,
                    l = e1 + 4;
                  if ("number" != typeof i)
                    return t.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      n,
                    );
                  if (s.length && s[s.length - 1][0] >= i)
                    return t.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      n,
                    );
                  const c = t.parse(r, l, a);
                  if (!c) return null;
                  (a = a || c.type), s.push([i, c]);
                }
                return "number" === a.kind ||
                  "color" === a.kind ||
                  ("array" === a.kind &&
                    "number" === a.itemType.kind &&
                    "number" == typeof a.N)
                  ? new _n(a, i, r, n, s)
                  : t.error(`Type ${Yt(a)} is not interpolatable.`);
              }
              evaluate(e1) {
                const t = this.labels,
                  i = this.outputs;
                if (1 === t.length) return i[0].evaluate(e1);
                const r = this.input.evaluate(e1);
                if (r <= t[0]) return i[0].evaluate(e1);
                const n = t.length;
                if (r >= t[n - 1]) return i[n - 1].evaluate(e1);
                const o = Zr(t, r),
                  s = _n.interpolationFactor(
                    this.interpolation,
                    r,
                    t[o],
                    t[o + 1],
                  ),
                  a = i[o].evaluate(e1),
                  l = i[o + 1].evaluate(e1);
                return "interpolate" === this.operator
                  ? Yr[this.type.kind.toLowerCase()](a, l, s)
                  : "interpolate-hcl" === this.operator
                  ? fn.reverse(fn.interpolate(fn.forward(a), fn.forward(l), s))
                  : pn.reverse(pn.interpolate(pn.forward(a), pn.forward(l), s));
              }
              eachChild(e1) {
                e1(this.input);
                for (const t of this.outputs) e1(t);
              }
              outputDefined() {
                return this.outputs.every((e1) => e1.outputDefined());
              }
              serialize() {
                let e1;
                e1 =
                  "linear" === this.interpolation.name
                    ? ["linear"]
                    : "exponential" === this.interpolation.name
                    ? 1 === this.interpolation.base
                      ? ["linear"]
                      : ["exponential", this.interpolation.base]
                    : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const t = [this.operator, e1, this.input.serialize()];
                for (let e1 = 0; e1 < this.labels.length; e1++)
                  t.push(this.labels[e1], this.outputs[e1].serialize());
                return t;
              }
            }
            function gn(e1, t, i, r) {
              const n = r - i,
                o = e1 - i;
              return 0 === n
                ? 0
                : 1 === t
                ? o / n
                : (Math.pow(t, o) - 1) / (Math.pow(t, n) - 1);
            }
            var yn = _n;
            class xn {
              constructor(e1, t) {
                (this.type = e1), (this.args = t);
              }
              static parse(e1, t) {
                if (e1.length < 2)
                  return t.error("Expectected at least one argument.");
                let i = null;
                const r = t.expectedType;
                r && "value" !== r.kind && (i = r);
                const n = [];
                for (const r of e1.slice(1)) {
                  const e1 = t.parse(r, 1 + n.length, i, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!e1) return null;
                  (i = i || e1.type), n.push(e1);
                }
                const o = r && n.some((e1) => Jt(r, e1.type));
                return new xn(o ? Zt : i, n);
              }
              evaluate(e1) {
                let t,
                  i = null,
                  r = 0;
                for (const n of this.args) {
                  if (
                    (r++,
                    (i = n.evaluate(e1)),
                    i &&
                      i instanceof di &&
                      !i.available &&
                      (t || (t = i), (i = null), r === this.args.length))
                  )
                    return t;
                  if (null !== i) break;
                }
                return i;
              }
              eachChild(e1) {
                this.args.forEach(e1);
              }
              outputDefined() {
                return this.args.every((e1) => e1.outputDefined());
              }
              serialize() {
                const e1 = ["coalesce"];
                return (
                  this.eachChild((t) => {
                    e1.push(t.serialize());
                  }),
                  e1
                );
              }
            }
            var vn = xn;
            class bn {
              constructor(e1, t) {
                (this.type = t.type),
                  (this.bindings = [].concat(e1)),
                  (this.result = t);
              }
              evaluate(e1) {
                return this.result.evaluate(e1);
              }
              eachChild(e1) {
                for (const t of this.bindings) e1(t[1]);
                e1(this.result);
              }
              static parse(e1, t) {
                if (e1.length < 4)
                  return t.error(
                    `Expected at least 3 arguments, but found ${
                      e1.length - 1
                    } instead.`,
                  );
                const i = [];
                for (let r = 1; r < e1.length - 1; r += 2) {
                  const n = e1[r];
                  if ("string" != typeof n)
                    return t.error(
                      `Expected string, but found ${typeof n} instead.`,
                      r,
                    );
                  if (/[^a-zA-Z0-9_]/.test(n))
                    return t.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      r,
                    );
                  const o = t.parse(e1[r + 1], r + 1);
                  if (!o) return null;
                  i.push([n, o]);
                }
                const r = t.parse(
                  e1[e1.length - 1],
                  e1.length - 1,
                  t.expectedType,
                  i,
                );
                return r ? new bn(i, r) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
              serialize() {
                const e1 = ["let"];
                for (const [t, i] of this.bindings) e1.push(t, i.serialize());
                return e1.push(this.result.serialize()), e1;
              }
            }
            var wn = bn;
            class Tn {
              constructor(e1, t, i) {
                (this.type = e1), (this.index = t), (this.input = i);
              }
              static parse(e1, t) {
                if (3 !== e1.length)
                  return t.error(
                    `Expected 2 arguments, but found ${e1.length - 1} instead.`,
                  );
                const i = t.parse(e1[1], 1, Ut),
                  r = t.parse(e1[2], 2, Xt(t.expectedType || Zt));
                return i && r ? new Tn(r.type.itemType, i, r) : null;
              }
              evaluate(e1) {
                const t = this.index.evaluate(e1),
                  i = this.input.evaluate(e1);
                if (t < 0) throw new xi(`Array index out of bounds: ${t} < 0.`);
                if (t >= i.length)
                  throw new xi(
                    `Array index out of bounds: ${t} > ${i.length - 1}.`,
                  );
                if (t !== Math.floor(t))
                  throw new xi(
                    `Array index must be an integer, but found ${t} instead.`,
                  );
                return i[t];
              }
              eachChild(e1) {
                e1(this.index), e1(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
              }
            }
            var En = Tn;
            class Mn {
              constructor(e1, t) {
                (this.type = jt), (this.needle = e1), (this.haystack = t);
              }
              static parse(e1, t) {
                if (3 !== e1.length)
                  return t.error(
                    `Expected 2 arguments, but found ${e1.length - 1} instead.`,
                  );
                const i = t.parse(e1[1], 1, Zt),
                  r = t.parse(e1[2], 2, Zt);
                return i && r
                  ? Qt(i.type, [jt, Vt, Ut, Nt, Zt])
                    ? new Mn(i, r)
                    : t.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${Yt(
                          i.type,
                        )} instead`,
                      )
                  : null;
              }
              evaluate(e1) {
                const t = this.needle.evaluate(e1),
                  i = this.haystack.evaluate(e1);
                if (null == i) return !1;
                if (!ei(t, ["boolean", "string", "number", "null"]))
                  throw new xi(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Yt(
                      mi(t),
                    )} instead.`,
                  );
                if (!ei(i, ["string", "array"]))
                  throw new xi(
                    `Expected second argument to be of type array or string, but found ${Yt(
                      mi(i),
                    )} instead.`,
                  );
                return i.indexOf(t) >= 0;
              }
              eachChild(e1) {
                e1(this.needle), e1(this.haystack);
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                return [
                  "in",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var An = Mn;
            class Sn {
              constructor(e1, t, i) {
                (this.type = Ut),
                  (this.needle = e1),
                  (this.haystack = t),
                  (this.fromIndex = i);
              }
              static parse(e1, t) {
                if (e1.length <= 2 || e1.length >= 5)
                  return t.error(
                    `Expected 3 or 4 arguments, but found ${
                      e1.length - 1
                    } instead.`,
                  );
                const i = t.parse(e1[1], 1, Zt),
                  r = t.parse(e1[2], 2, Zt);
                if (!i || !r) return null;
                if (!Qt(i.type, [jt, Vt, Ut, Nt, Zt]))
                  return t.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Yt(
                      i.type,
                    )} instead`,
                  );
                if (4 === e1.length) {
                  const n = t.parse(e1[3], 3, Ut);
                  return n ? new Sn(i, r, n) : null;
                }
                return new Sn(i, r);
              }
              evaluate(e1) {
                const t = this.needle.evaluate(e1),
                  i = this.haystack.evaluate(e1);
                if (!ei(t, ["boolean", "string", "number", "null"]))
                  throw new xi(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Yt(
                      mi(t),
                    )} instead.`,
                  );
                if (!ei(i, ["string", "array"]))
                  throw new xi(
                    `Expected second argument to be of type array or string, but found ${Yt(
                      mi(i),
                    )} instead.`,
                  );
                if (this.fromIndex) {
                  const r = this.fromIndex.evaluate(e1);
                  return i.indexOf(t, r);
                }
                return i.indexOf(t);
              }
              eachChild(e1) {
                e1(this.needle),
                  e1(this.haystack),
                  this.fromIndex && e1(this.fromIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                  const e1 = this.fromIndex.serialize();
                  return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    e1,
                  ];
                }
                return [
                  "index-of",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var In = Sn;
            class Cn {
              constructor(e1, t, i, r, n, o) {
                (this.inputType = e1),
                  (this.type = t),
                  (this.input = i),
                  (this.cases = r),
                  (this.outputs = n),
                  (this.otherwise = o);
              }
              static parse(e1, t) {
                if (e1.length < 5)
                  return t.error(
                    `Expected at least 4 arguments, but found only ${
                      e1.length - 1
                    }.`,
                  );
                if (e1.length % 2 != 1)
                  return t.error("Expected an even number of arguments.");
                let i, r;
                t.expectedType &&
                  "value" !== t.expectedType.kind &&
                  (r = t.expectedType);
                const n = {},
                  o = [];
                for (let s = 2; s < e1.length - 1; s += 2) {
                  let a = e1[s];
                  const l = e1[s + 1];
                  Array.isArray(a) || (a = [a]);
                  const c = t.concat(s);
                  if (0 === a.length)
                    return c.error("Expected at least one branch label.");
                  for (const e1 of a) {
                    if ("number" != typeof e1 && "string" != typeof e1)
                      return c.error(
                        "Branch labels must be numbers or strings.",
                      );
                    if (
                      "number" == typeof e1 &&
                      Math.abs(e1) > Number.MAX_SAFE_INTEGER
                    )
                      return c.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`,
                      );
                    if ("number" == typeof e1 && Math.floor(e1) !== e1)
                      return c.error(
                        "Numeric branch labels must be integer values.",
                      );
                    if (i) {
                      if (c.checkSubtype(i, mi(e1))) return null;
                    } else i = mi(e1);
                    if (void 0 !== n[String(e1)])
                      return c.error("Branch labels must be unique.");
                    n[String(e1)] = o.length;
                  }
                  const h = t.parse(l, s, r);
                  if (!h) return null;
                  (r = r || h.type), o.push(h);
                }
                const s = t.parse(e1[1], 1, Zt);
                if (!s) return null;
                const a = t.parse(e1[e1.length - 1], e1.length - 1, r);
                return a
                  ? "value" !== s.type.kind &&
                    t.concat(1).checkSubtype(i, s.type)
                    ? null
                    : new Cn(i, r, s, n, o, a)
                  : null;
              }
              evaluate(e1) {
                const t = this.input.evaluate(e1);
                return (
                  (mi(t) === this.inputType && this.outputs[this.cases[t]]) ||
                  this.otherwise
                ).evaluate(e1);
              }
              eachChild(e1) {
                e1(this.input), this.outputs.forEach(e1), e1(this.otherwise);
              }
              outputDefined() {
                return (
                  this.outputs.every((e1) => e1.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const e1 = ["match", this.input.serialize()],
                  t = Object.keys(this.cases).sort(),
                  i = [],
                  r = {};
                for (const e1 of t) {
                  const t = r[this.cases[e1]];
                  void 0 === t
                    ? ((r[this.cases[e1]] = i.length),
                      i.push([this.cases[e1], [e1]]))
                    : i[t][1].push(e1);
                }
                const n = (e1) =>
                  "number" === this.inputType.kind ? Number(e1) : e1;
                for (const [t, r] of i)
                  e1.push(1 === r.length ? n(r[0]) : r.map(n)),
                    e1.push(this.outputs[t].serialize());
                return e1.push(this.otherwise.serialize()), e1;
              }
            }
            var zn = Cn;
            class Dn {
              constructor(e1, t, i) {
                (this.type = e1), (this.branches = t), (this.otherwise = i);
              }
              static parse(e1, t) {
                if (e1.length < 4)
                  return t.error(
                    `Expected at least 3 arguments, but found only ${
                      e1.length - 1
                    }.`,
                  );
                if (e1.length % 2 != 0)
                  return t.error("Expected an odd number of arguments.");
                let i;
                t.expectedType &&
                  "value" !== t.expectedType.kind &&
                  (i = t.expectedType);
                const r = [];
                for (let n = 1; n < e1.length - 1; n += 2) {
                  const o = t.parse(e1[n], n, jt);
                  if (!o) return null;
                  const s = t.parse(e1[n + 1], n + 1, i);
                  if (!s) return null;
                  r.push([o, s]), (i = i || s.type);
                }
                const n = t.parse(e1[e1.length - 1], e1.length - 1, i);
                return n ? new Dn(i, r, n) : null;
              }
              evaluate(e1) {
                for (const [t, i] of this.branches)
                  if (t.evaluate(e1)) return i.evaluate(e1);
                return this.otherwise.evaluate(e1);
              }
              eachChild(e1) {
                for (const [t, i] of this.branches) e1(t), e1(i);
                e1(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([e1, t]) => t.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const e1 = ["case"];
                return (
                  this.eachChild((t) => {
                    e1.push(t.serialize());
                  }),
                  e1
                );
              }
            }
            var Pn = Dn;
            class Rn {
              constructor(e1, t, i, r) {
                (this.type = e1),
                  (this.input = t),
                  (this.beginIndex = i),
                  (this.endIndex = r);
              }
              static parse(e1, t) {
                if (e1.length <= 2 || e1.length >= 5)
                  return t.error(
                    `Expected 3 or 4 arguments, but found ${
                      e1.length - 1
                    } instead.`,
                  );
                const i = t.parse(e1[1], 1, Zt),
                  r = t.parse(e1[2], 2, Ut);
                if (!i || !r) return null;
                if (!Qt(i.type, [Xt(Zt), Vt, Zt]))
                  return t.error(
                    `Expected first argument to be of type array or string, but found ${Yt(
                      i.type,
                    )} instead`,
                  );
                if (4 === e1.length) {
                  const n = t.parse(e1[3], 3, Ut);
                  return n ? new Rn(i.type, i, r, n) : null;
                }
                return new Rn(i.type, i, r);
              }
              evaluate(e1) {
                const t = this.input.evaluate(e1),
                  i = this.beginIndex.evaluate(e1);
                if (!ei(t, ["string", "array"]))
                  throw new xi(
                    `Expected first argument to be of type array or string, but found ${Yt(
                      mi(t),
                    )} instead.`,
                  );
                if (this.endIndex) {
                  const r = this.endIndex.evaluate(e1);
                  return t.slice(i, r);
                }
                return t.slice(i);
              }
              eachChild(e1) {
                e1(this.input),
                  e1(this.beginIndex),
                  this.endIndex && e1(this.endIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                  const e1 = this.endIndex.serialize();
                  return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    e1,
                  ];
                }
                return [
                  "slice",
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                ];
              }
            }
            var Ln = Rn;
            function kn(e1, t) {
              return "==" === e1 || "!=" === e1
                ? "boolean" === t.kind ||
                    "string" === t.kind ||
                    "number" === t.kind ||
                    "null" === t.kind ||
                    "value" === t.kind
                : "string" === t.kind ||
                    "number" === t.kind ||
                    "value" === t.kind;
            }
            function On(e1, t, i, r) {
              return 0 === r.compare(t, i);
            }
            function Bn(e1, t, i) {
              const r = "==" !== e1 && "!=" !== e1;
              return class n {
                constructor(e1, t, i) {
                  (this.type = jt),
                    (this.lhs = e1),
                    (this.rhs = t),
                    (this.collator = i),
                    (this.hasUntypedArgument =
                      "value" === e1.type.kind || "value" === t.type.kind);
                }
                static parse(e1, t) {
                  if (3 !== e1.length && 4 !== e1.length)
                    return t.error("Expected two or three arguments.");
                  const i = e1[0];
                  let o = t.parse(e1[1], 1, Zt);
                  if (!o) return null;
                  if (!kn(i, o.type))
                    return t
                      .concat(1)
                      .error(
                        `"${i}" comparisons are not supported for type '${Yt(
                          o.type,
                        )}'.`,
                      );
                  let s = t.parse(e1[2], 2, Zt);
                  if (!s) return null;
                  if (!kn(i, s.type))
                    return t
                      .concat(2)
                      .error(
                        `"${i}" comparisons are not supported for type '${Yt(
                          s.type,
                        )}'.`,
                      );
                  if (
                    o.type.kind !== s.type.kind &&
                    "value" !== o.type.kind &&
                    "value" !== s.type.kind
                  )
                    return t.error(
                      `Cannot compare types '${Yt(o.type)}' and '${Yt(
                        s.type,
                      )}'.`,
                    );
                  r &&
                    ("value" === o.type.kind && "value" !== s.type.kind
                      ? (o = new wi(s.type, [o]))
                      : "value" !== o.type.kind &&
                        "value" === s.type.kind &&
                        (s = new wi(o.type, [s])));
                  let a = null;
                  if (4 === e1.length) {
                    if (
                      "string" !== o.type.kind &&
                      "string" !== s.type.kind &&
                      "value" !== o.type.kind &&
                      "value" !== s.type.kind
                    )
                      return t.error(
                        "Cannot use collator to compare non-string types.",
                      );
                    if (((a = t.parse(e1[3], 3, $t)), !a)) return null;
                  }
                  return new n(o, s, a);
                }
                evaluate(n) {
                  const o = this.lhs.evaluate(n),
                    s = this.rhs.evaluate(n);
                  if (r && this.hasUntypedArgument) {
                    const t = mi(o),
                      i = mi(s);
                    if (
                      t.kind !== i.kind ||
                      ("string" !== t.kind && "number" !== t.kind)
                    )
                      throw new xi(
                        `Expected arguments for "${e1}" to be (string, string) or (number, number), but found (${t.kind}, ${i.kind}) instead.`,
                      );
                  }
                  if (this.collator && !r && this.hasUntypedArgument) {
                    const e1 = mi(o),
                      i = mi(s);
                    if ("string" !== e1.kind || "string" !== i.kind)
                      return t(n, o, s);
                  }
                  return this.collator
                    ? i(n, o, s, this.collator.evaluate(n))
                    : t(n, o, s);
                }
                eachChild(e1) {
                  e1(this.lhs),
                    e1(this.rhs),
                    this.collator && e1(this.collator);
                }
                outputDefined() {
                  return !0;
                }
                serialize() {
                  const t = [e1];
                  return (
                    this.eachChild((e1) => {
                      t.push(e1.serialize());
                    }),
                    t
                  );
                }
              };
            }
            const Fn = Bn(
                "==",
                function (e1, t, i) {
                  return t === i;
                },
                On,
              ),
              Nn = Bn(
                "!=",
                function (e1, t, i) {
                  return t !== i;
                },
                function (e1, t, i, r) {
                  return !On(0, t, i, r);
                },
              ),
              Un = Bn(
                "<",
                function (e1, t, i) {
                  return t < i;
                },
                function (e1, t, i, r) {
                  return r.compare(t, i) < 0;
                },
              ),
              Vn = Bn(
                ">",
                function (e1, t, i) {
                  return t > i;
                },
                function (e1, t, i, r) {
                  return r.compare(t, i) > 0;
                },
              ),
              jn = Bn(
                "<=",
                function (e1, t, i) {
                  return t <= i;
                },
                function (e1, t, i, r) {
                  return r.compare(t, i) <= 0;
                },
              ),
              Gn = Bn(
                ">=",
                function (e1, t, i) {
                  return t >= i;
                },
                function (e1, t, i, r) {
                  return r.compare(t, i) >= 0;
                },
              );
            class qn {
              constructor(e1, t, i, r, n, o) {
                (this.type = Vt),
                  (this.number = e1),
                  (this.locale = t),
                  (this.currency = i),
                  (this.unit = r),
                  (this.minFractionDigits = n),
                  (this.maxFractionDigits = o);
              }
              static parse(e1, t) {
                if (3 !== e1.length) return t.error("Expected two arguments.");
                const i = t.parse(e1[1], 1, Ut);
                if (!i) return null;
                const r = e1[2];
                if ("object" != typeof r || Array.isArray(r))
                  return t.error(
                    "NumberFormat options argument must be an object.",
                  );
                let n = null;
                if (r.locale && ((n = t.parse(r.locale, 1, Vt)), !n))
                  return null;
                let o = null;
                if (r.currency && ((o = t.parse(r.currency, 1, Vt)), !o))
                  return null;
                let s = null;
                if (r.unit && ((s = t.parse(r.unit, 1, Vt)), !s)) return null;
                let a = null;
                if (
                  r["min-fraction-digits"] &&
                  ((a = t.parse(r["min-fraction-digits"], 1, Ut)), !a)
                )
                  return null;
                let l = null;
                return r["max-fraction-digits"] &&
                  ((l = t.parse(r["max-fraction-digits"], 1, Ut)), !l)
                  ? null
                  : new qn(i, n, o, s, a, l);
              }
              evaluate(e1) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(e1) : [],
                  {
                    style:
                      (this.currency ? "currency" : this.unit && "unit") ||
                      "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(e1)
                      : void 0,
                    unit: this.unit ? this.unit.evaluate(e1) : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(e1)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(e1)
                      : void 0,
                  },
                ).format(this.number.evaluate(e1));
              }
              eachChild(e1) {
                e1(this.number),
                  this.locale && e1(this.locale),
                  this.currency && e1(this.currency),
                  this.unit && e1(this.unit),
                  this.minFractionDigits && e1(this.minFractionDigits),
                  this.maxFractionDigits && e1(this.maxFractionDigits);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e1 = {};
                return (
                  this.locale && (e1.locale = this.locale.serialize()),
                  this.currency && (e1.currency = this.currency.serialize()),
                  this.unit && (e1.unit = this.unit.serialize()),
                  this.minFractionDigits &&
                    (e1["min-fraction-digits"] =
                      this.minFractionDigits.serialize()),
                  this.maxFractionDigits &&
                    (e1["max-fraction-digits"] =
                      this.maxFractionDigits.serialize()),
                  ["number-format", this.number.serialize(), e1]
                );
              }
            }
            class Zn {
              constructor(e1) {
                (this.type = Ut), (this.input = e1);
              }
              static parse(e1, t) {
                if (2 !== e1.length)
                  return t.error(
                    `Expected 1 argument, but found ${e1.length - 1} instead.`,
                  );
                const i = t.parse(e1[1], 1);
                return i
                  ? "array" !== i.type.kind &&
                    "string" !== i.type.kind &&
                    "value" !== i.type.kind
                    ? t.error(
                        `Expected argument of type string or array, but found ${Yt(
                          i.type,
                        )} instead.`,
                      )
                    : new Zn(i)
                  : null;
              }
              evaluate(e1) {
                const t = this.input.evaluate(e1);
                if ("string" == typeof t) return t.length;
                if (Array.isArray(t)) return t.length;
                throw new xi(
                  `Expected value to be of type string or array, but found ${Yt(
                    mi(t),
                  )} instead.`,
                );
              }
              eachChild(e1) {
                e1(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e1 = ["length"];
                return (
                  this.eachChild((t) => {
                    e1.push(t.serialize());
                  }),
                  e1
                );
              }
            }
            function $n(e1) {
              return function () {
                e1 = (1831565813 + (e1 |= 0)) | 0;
                let t = Math.imul(e1 ^ (e1 >>> 15), 1 | e1);
                return (
                  (t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t),
                  ((t ^ (t >>> 14)) >>> 0) / 4294967296
                );
              };
            }
            const Hn = {
              "==": Fn,
              "!=": Nn,
              ">": Vn,
              "<": Un,
              ">=": Gn,
              "<=": jn,
              array: wi,
              at: En,
              boolean: wi,
              case: Pn,
              coalesce: vn,
              collator: Ri,
              format: Ti,
              image: Ei,
              in: An,
              "index-of": In,
              interpolate: yn,
              "interpolate-hcl": yn,
              "interpolate-lab": yn,
              length: Zn,
              let: wn,
              literal: yi,
              match: zn,
              number: wi,
              "number-format": qn,
              object: wi,
              slice: Ln,
              step: Hr,
              string: wi,
              "to-boolean": Ii,
              "to-color": Ii,
              "to-number": Ii,
              "to-string": Ii,
              var: Vr,
              within: tr,
              distance: kr,
            };
            function Wn(e1, [t, i, r, n]) {
              (t = t.evaluate(e1)), (i = i.evaluate(e1)), (r = r.evaluate(e1));
              const o = n ? n.evaluate(e1) : 1,
                s = pi(t, i, r, o);
              if (s) throw new xi(s);
              return new li((t / 255) * o, (i / 255) * o, (r / 255) * o, o);
            }
            function Xn(e1, [t, i, r, n]) {
              (t = t.evaluate(e1)), (i = i.evaluate(e1)), (r = r.evaluate(e1));
              const o = n ? n.evaluate(e1) : 1,
                s = (function (e1, t, i, r) {
                  return "number" == typeof e1 && e1 >= 0 && e1 <= 360
                    ? "number" == typeof t &&
                      t >= 0 &&
                      t <= 100 &&
                      "number" == typeof i &&
                      i >= 0 &&
                      i <= 100
                      ? void 0 === r ||
                        ("number" == typeof r && r >= 0 && r <= 1)
                        ? null
                        : `Invalid hsla value [${[e1, t, i, r].join(
                            ", ",
                          )}]: 'a' must be between 0 and 1.`
                      : `Invalid hsla value [${("number" == typeof r
                          ? [e1, t, i, r]
                          : [e1, t, i]
                        ).join(", ")}]: 's', and 'l' must be between 0 and 100.`
                    : `Invalid hsla value [${("number" == typeof r
                        ? [e1, t, i, r]
                        : [e1, t, i]
                      ).join(", ")}]: 'h' must be between 0 and 360.`;
                })(t, i, r, o);
              if (s) throw new xi(s);
              const a = `hsla(${t}, ${i}%, ${r}%, ${o})`,
                l = li.parse(a);
              if (!l) throw new xi(`Failed to parse HSLA color: ${a}`);
              return l;
            }
            function Yn(e1, t) {
              return e1 in t;
            }
            function Kn(e1, t) {
              const i = t[e1];
              return void 0 === i ? null : i;
            }
            function Jn(e1, t, i) {
              i.length && (t += `${i}`);
              const r = e1.getConfig(t);
              return r ? r.evaluate(e1) : null;
            }
            function Qn(e1) {
              return {
                type: e1,
              };
            }
            Pi.register(Hn, {
              error: [
                {
                  kind: "error",
                },
                [Vt],
                (e1, [t]) => {
                  throw new xi(t.evaluate(e1));
                },
              ],
              typeof: [Vt, [Zt], (e1, [t]) => Yt(mi(t.evaluate(e1)))],
              "to-rgba": [
                Xt(Ut, 4),
                [Gt],
                (e1, [t]) => t.evaluate(e1).toArray(),
              ],
              rgb: [Gt, [Ut, Ut, Ut], Wn],
              rgba: [Gt, [Ut, Ut, Ut, Ut], Wn],
              hsl: [Gt, [Ut, Ut, Ut], Xn],
              hsla: [Gt, [Ut, Ut, Ut, Ut], Xn],
              has: {
                type: jt,
                overloads: [
                  [[Vt], (e1, [t]) => Yn(t.evaluate(e1), e1.properties())],
                  [
                    [Vt, qt],
                    (e1, [t, i]) => Yn(t.evaluate(e1), i.evaluate(e1)),
                  ],
                ],
              },
              get: {
                type: Zt,
                overloads: [
                  [[Vt], (e1, [t]) => Kn(t.evaluate(e1), e1.properties())],
                  [
                    [Vt, qt],
                    (e1, [t, i]) => Kn(t.evaluate(e1), i.evaluate(e1)),
                  ],
                ],
              },
              config: {
                type: Zt,
                overloads: [
                  [[Vt], (e1, [t]) => Jn(e1, t.evaluate(e1), "")],
                  [
                    [Vt, Vt],
                    (e1, [t, i]) => Jn(e1, t.evaluate(e1), i.evaluate(e1)),
                  ],
                ],
              },
              "feature-state": [
                Zt,
                [Vt],
                (e1, [t]) => Kn(t.evaluate(e1), e1.featureState || {}),
              ],
              properties: [qt, [], (e1) => e1.properties()],
              "geometry-type": [Vt, [], (e1) => e1.geometryType()],
              id: [Zt, [], (e1) => e1.id()],
              zoom: [Ut, [], (e1) => e1.globals.zoom],
              pitch: [Ut, [], (e1) => e1.globals.pitch || 0],
              "distance-from-center": [Ut, [], (e1) => e1.distanceFromCenter()],
              "measure-light": [
                Ut,
                [Vt],
                (e1, [t]) => e1.measureLight(t.evaluate(e1)),
              ],
              "heatmap-density": [
                Ut,
                [],
                (e1) => e1.globals.heatmapDensity || 0,
              ],
              "line-progress": [Ut, [], (e1) => e1.globals.lineProgress || 0],
              "raster-value": [Ut, [], (e1) => e1.globals.rasterValue || 0],
              "sky-radial-progress": [
                Ut,
                [],
                (e1) => e1.globals.skyRadialProgress || 0,
              ],
              accumulated: [
                Zt,
                [],
                (e1) =>
                  void 0 === e1.globals.accumulated
                    ? null
                    : e1.globals.accumulated,
              ],
              "+": [
                Ut,
                Qn(Ut),
                (e1, t) => {
                  let i = 0;
                  for (const r of t) i += r.evaluate(e1);
                  return i;
                },
              ],
              "*": [
                Ut,
                Qn(Ut),
                (e1, t) => {
                  let i = 1;
                  for (const r of t) i *= r.evaluate(e1);
                  return i;
                },
              ],
              "-": {
                type: Ut,
                overloads: [
                  [[Ut, Ut], (e1, [t, i]) => t.evaluate(e1) - i.evaluate(e1)],
                  [[Ut], (e1, [t]) => -t.evaluate(e1)],
                ],
              },
              "/": [
                Ut,
                [Ut, Ut],
                (e1, [t, i]) => t.evaluate(e1) / i.evaluate(e1),
              ],
              "%": [
                Ut,
                [Ut, Ut],
                (e1, [t, i]) => t.evaluate(e1) % i.evaluate(e1),
              ],
              ln2: [Ut, [], () => Math.LN2],
              pi: [Ut, [], () => Math.PI],
              e: [Ut, [], () => Math.E],
              "^": [
                Ut,
                [Ut, Ut],
                (e1, [t, i]) => Math.pow(t.evaluate(e1), i.evaluate(e1)),
              ],
              sqrt: [Ut, [Ut], (e1, [t]) => Math.sqrt(t.evaluate(e1))],
              log10: [
                Ut,
                [Ut],
                (e1, [t]) => Math.log(t.evaluate(e1)) / Math.LN10,
              ],
              ln: [Ut, [Ut], (e1, [t]) => Math.log(t.evaluate(e1))],
              log2: [
                Ut,
                [Ut],
                (e1, [t]) => Math.log(t.evaluate(e1)) / Math.LN2,
              ],
              sin: [Ut, [Ut], (e1, [t]) => Math.sin(t.evaluate(e1))],
              cos: [Ut, [Ut], (e1, [t]) => Math.cos(t.evaluate(e1))],
              tan: [Ut, [Ut], (e1, [t]) => Math.tan(t.evaluate(e1))],
              asin: [Ut, [Ut], (e1, [t]) => Math.asin(t.evaluate(e1))],
              acos: [Ut, [Ut], (e1, [t]) => Math.acos(t.evaluate(e1))],
              atan: [Ut, [Ut], (e1, [t]) => Math.atan(t.evaluate(e1))],
              min: [
                Ut,
                Qn(Ut),
                (e1, t) => Math.min(...t.map((t) => t.evaluate(e1))),
              ],
              max: [
                Ut,
                Qn(Ut),
                (e1, t) => Math.max(...t.map((t) => t.evaluate(e1))),
              ],
              abs: [Ut, [Ut], (e1, [t]) => Math.abs(t.evaluate(e1))],
              round: [
                Ut,
                [Ut],
                (e1, [t]) => {
                  const i = t.evaluate(e1);
                  return i < 0 ? -Math.round(-i) : Math.round(i);
                },
              ],
              floor: [Ut, [Ut], (e1, [t]) => Math.floor(t.evaluate(e1))],
              ceil: [Ut, [Ut], (e1, [t]) => Math.ceil(t.evaluate(e1))],
              "filter-==": [
                jt,
                [Vt, Zt],
                (e1, [t, i]) => e1.properties()[t.value] === i.value,
              ],
              "filter-id-==": [jt, [Zt], (e1, [t]) => e1.id() === t.value],
              "filter-type-==": [
                jt,
                [Vt],
                (e1, [t]) => e1.geometryType() === t.value,
              ],
              "filter-<": [
                jt,
                [Vt, Zt],
                (e1, [t, i]) => {
                  const r = e1.properties()[t.value],
                    n = i.value;
                  return typeof r == typeof n && r < n;
                },
              ],
              "filter-id-<": [
                jt,
                [Zt],
                (e1, [t]) => {
                  const i = e1.id(),
                    r = t.value;
                  return typeof i == typeof r && i < r;
                },
              ],
              "filter->": [
                jt,
                [Vt, Zt],
                (e1, [t, i]) => {
                  const r = e1.properties()[t.value],
                    n = i.value;
                  return typeof r == typeof n && r > n;
                },
              ],
              "filter-id->": [
                jt,
                [Zt],
                (e1, [t]) => {
                  const i = e1.id(),
                    r = t.value;
                  return typeof i == typeof r && i > r;
                },
              ],
              "filter-<=": [
                jt,
                [Vt, Zt],
                (e1, [t, i]) => {
                  const r = e1.properties()[t.value],
                    n = i.value;
                  return typeof r == typeof n && r <= n;
                },
              ],
              "filter-id-<=": [
                jt,
                [Zt],
                (e1, [t]) => {
                  const i = e1.id(),
                    r = t.value;
                  return typeof i == typeof r && i <= r;
                },
              ],
              "filter->=": [
                jt,
                [Vt, Zt],
                (e1, [t, i]) => {
                  const r = e1.properties()[t.value],
                    n = i.value;
                  return typeof r == typeof n && r >= n;
                },
              ],
              "filter-id->=": [
                jt,
                [Zt],
                (e1, [t]) => {
                  const i = e1.id(),
                    r = t.value;
                  return typeof i == typeof r && i >= r;
                },
              ],
              "filter-has": [jt, [Zt], (e1, [t]) => t.value in e1.properties()],
              "filter-has-id": [
                jt,
                [],
                (e1) => null !== e1.id() && void 0 !== e1.id(),
              ],
              "filter-type-in": [
                jt,
                [Xt(Vt)],
                (e1, [t]) => t.value.indexOf(e1.geometryType()) >= 0,
              ],
              "filter-id-in": [
                jt,
                [Xt(Zt)],
                (e1, [t]) => t.value.indexOf(e1.id()) >= 0,
              ],
              "filter-in-small": [
                jt,
                [Vt, Xt(Zt)],
                (e1, [t, i]) => i.value.indexOf(e1.properties()[t.value]) >= 0,
              ],
              "filter-in-large": [
                jt,
                [Vt, Xt(Zt)],
                (e1, [t, i]) =>
                  (function (e1, t, i, r) {
                    for (; i <= r; ) {
                      const n = (i + r) >> 1;
                      if (t[n] === e1) return !0;
                      t[n] > e1 ? (r = n - 1) : (i = n + 1);
                    }
                    return !1;
                  })(e1.properties()[t.value], i.value, 0, i.value.length - 1),
              ],
              all: {
                type: jt,
                overloads: [
                  [[jt, jt], (e1, [t, i]) => t.evaluate(e1) && i.evaluate(e1)],
                  [
                    Qn(jt),
                    (e1, t) => {
                      for (const i of t) if (!i.evaluate(e1)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: jt,
                overloads: [
                  [[jt, jt], (e1, [t, i]) => t.evaluate(e1) || i.evaluate(e1)],
                  [
                    Qn(jt),
                    (e1, t) => {
                      for (const i of t) if (i.evaluate(e1)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [jt, [jt], (e1, [t]) => !t.evaluate(e1)],
              "is-supported-script": [
                jt,
                [Vt],
                (e1, [t]) => {
                  const i = e1.globals && e1.globals.isSupportedScript;
                  return !i || i(t.evaluate(e1));
                },
              ],
              upcase: [Vt, [Vt], (e1, [t]) => t.evaluate(e1).toUpperCase()],
              downcase: [Vt, [Vt], (e1, [t]) => t.evaluate(e1).toLowerCase()],
              concat: [
                Vt,
                Qn(Zt),
                (e1, t) => t.map((t) => _i(t.evaluate(e1))).join(""),
              ],
              "resolved-locale": [
                Vt,
                [$t],
                (e1, [t]) => t.evaluate(e1).resolvedLocale(),
              ],
              random: [
                Ut,
                [Ut, Ut, Zt],
                (e1, t) => {
                  const [i, r, n] = t.map((t) => t.evaluate(e1));
                  if (i > r) return i;
                  if (i === r) return i;
                  let o;
                  if ("string" == typeof n)
                    o = (function (e1) {
                      let t = 0;
                      if (0 === e1.length) return t;
                      for (let i = 0; i < e1.length; i++)
                        (t = (t << 5) - t + e1.charCodeAt(i)), (t &= t);
                      return t;
                    })(n);
                  else {
                    if ("number" != typeof n)
                      throw new xi(`Invalid seed input: ${n}`);
                    o = n;
                  }
                  return i + $n(o)() * (r - i);
                },
              ],
            });
            var eo = Hn;
            function to(e1) {
              return {
                result: "success",
                value: e1,
              };
            }
            function io(e1) {
              return {
                result: "error",
                value: e1,
              };
            }
            function ro(e1, t) {
              return !!e1 && !!e1.parameters && e1.parameters.indexOf(t) > -1;
            }
            function no(e1) {
              return "data-driven" === e1["property-type"];
            }
            function oo(e1) {
              return ro(e1.expression, "measure-light");
            }
            function so(e1) {
              return ro(e1.expression, "zoom");
            }
            function ao(e1) {
              return !!e1.expression && e1.expression.interpolated;
            }
            function lo(e1) {
              return "object" == typeof e1 && null !== e1 && !Array.isArray(e1);
            }
            function co(e1) {
              return e1;
            }
            function ho(e1, t) {
              const i = "color" === t.type,
                r = e1.stops && "object" == typeof e1.stops[0][0],
                n = r || !(r || void 0 !== e1.property),
                o = e1.type || (ao(t) ? "exponential" : "interval");
              if (
                (i &&
                  ((e1 = Pt({}, e1)).stops &&
                    (e1.stops = e1.stops.map((e1) => [e1[0], li.parse(e1[1])])),
                  (e1.default = li.parse(e1.default ? e1.default : t.default))),
                e1.colorSpace && "rgb" !== e1.colorSpace && !mn[e1.colorSpace])
              )
                throw new Error(`Unknown color space: ${e1.colorSpace}`);
              let s, a, l;
              if ("exponential" === o) s = mo;
              else if ("interval" === o) s = fo;
              else if ("categorical" === o) {
                (s = po), (a = Object.create(null));
                for (const t of e1.stops) a[t[0]] = t[1];
                l = typeof e1.stops[0][0];
              } else {
                if ("identity" !== o)
                  throw new Error(`Unknown function type "${o}"`);
                s = _o;
              }
              if (r) {
                const i = {},
                  r = [];
                for (let t = 0; t < e1.stops.length; t++) {
                  const n = e1.stops[t],
                    o = n[0].zoom;
                  void 0 === i[o] &&
                    ((i[o] = {
                      zoom: o,
                      type: e1.type,
                      property: e1.property,
                      default: e1.default,
                      stops: [],
                    }),
                    r.push(o)),
                    i[o].stops.push([n[0].value, n[1]]);
                }
                const n = [];
                for (const e1 of r) n.push([i[e1].zoom, ho(i[e1], t)]);
                const o = {
                  name: "linear",
                };
                return {
                  kind: "composite",
                  interpolationType: o,
                  interpolationFactor: yn.interpolationFactor.bind(void 0, o),
                  zoomStops: n.map((e1) => e1[0]),
                  evaluate: ({ zoom: i }, r) =>
                    mo(
                      {
                        stops: n,
                        base: e1.base,
                      },
                      t,
                      i,
                    ).evaluate(i, r),
                };
              }
              if (n) {
                const i =
                  "exponential" === o
                    ? {
                        name: "exponential",
                        base: void 0 !== e1.base ? e1.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: i,
                  interpolationFactor: yn.interpolationFactor.bind(void 0, i),
                  zoomStops: e1.stops.map((e1) => e1[0]),
                  evaluate: ({ zoom: i }) => s(e1, t, i, a, l),
                };
              }
              return {
                kind: "source",
                evaluate(i, r) {
                  const n =
                    r && r.properties ? r.properties[e1.property] : void 0;
                  return void 0 === n
                    ? uo(e1.default, t.default)
                    : s(e1, t, n, a, l);
                },
              };
            }
            function uo(e1, t, i) {
              return void 0 !== e1
                ? e1
                : void 0 !== t
                ? t
                : void 0 !== i
                ? i
                : void 0;
            }
            function po(e1, t, i, r, n) {
              return uo(typeof i === n ? r[i] : void 0, e1.default, t.default);
            }
            function fo(e1, t, i) {
              if ("number" !== Mi(i)) return uo(e1.default, t.default);
              const r = e1.stops.length;
              if (1 === r) return e1.stops[0][1];
              if (i <= e1.stops[0][0]) return e1.stops[0][1];
              if (i >= e1.stops[r - 1][0]) return e1.stops[r - 1][1];
              const n = Zr(
                e1.stops.map((e1) => e1[0]),
                i,
              );
              return e1.stops[n][1];
            }
            function mo(e1, t, i) {
              const r = void 0 !== e1.base ? e1.base : 1;
              if ("number" !== Mi(i)) return uo(e1.default, t.default);
              const n = e1.stops.length;
              if (1 === n) return e1.stops[0][1];
              if (i <= e1.stops[0][0]) return e1.stops[0][1];
              if (i >= e1.stops[n - 1][0]) return e1.stops[n - 1][1];
              const o = Zr(
                  e1.stops.map((e1) => e1[0]),
                  i,
                ),
                s = (function (e1, t, i, r) {
                  const n = r - i,
                    o = e1 - i;
                  return 0 === n
                    ? 0
                    : 1 === t
                    ? o / n
                    : (Math.pow(t, o) - 1) / (Math.pow(t, n) - 1);
                })(i, r, e1.stops[o][0], e1.stops[o + 1][0]),
                a = e1.stops[o][1],
                l = e1.stops[o + 1][1];
              let c = Yr[t.type] || co;
              if (e1.colorSpace && "rgb" !== e1.colorSpace) {
                const t = mn[e1.colorSpace];
                c = (e1, i) =>
                  t.reverse(t.interpolate(t.forward(e1), t.forward(i), s));
              }
              return "function" == typeof a.evaluate
                ? {
                    evaluate(...e1) {
                      const t = a.evaluate.apply(void 0, e1),
                        i = l.evaluate.apply(void 0, e1);
                      if (void 0 !== t && void 0 !== i) return c(t, i, s);
                    },
                  }
                : c(a, l, s);
            }
            function _o(e1, t, i) {
              return (
                "color" === t.type
                  ? (i = li.parse(i))
                  : "formatted" === t.type
                  ? (i = ui.fromString(i.toString()))
                  : "resolvedImage" === t.type
                  ? (i = di.fromString(i.toString()))
                  : Mi(i) === t.type ||
                    ("enum" === t.type && t.values[i]) ||
                    (i = void 0),
                uo(i, e1.default, t.default)
              );
            }
            class go {
              constructor(e1, t, i) {
                (this.expression = e1),
                  (this._warningHistory = {}),
                  (this._evaluator = new zi(i)),
                  (this._defaultValue = t
                    ? (function (e1) {
                        return "color" === e1.type &&
                          (lo(e1.default) || Array.isArray(e1.default))
                          ? new li(0, 0, 0, 0)
                          : "color" === e1.type
                          ? li.parse(e1.default) || null
                          : void 0 === e1.default
                          ? null
                          : e1.default;
                      })(t)
                    : null),
                  (this._enumValues = t && "enum" === t.type ? t.values : null);
              }
              evaluateWithoutErrorHandling(e1, t, i, r, n, o, s, a) {
                return (
                  (this._evaluator.globals = e1),
                  (this._evaluator.feature = t),
                  (this._evaluator.featureState = i),
                  (this._evaluator.canonical = r || null),
                  (this._evaluator.availableImages = n || null),
                  (this._evaluator.formattedSection = o),
                  (this._evaluator.featureTileCoord = s || null),
                  (this._evaluator.featureDistanceData = a || null),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(e1, t, i, r, n, o, s, a) {
                (this._evaluator.globals = e1),
                  (this._evaluator.feature = t || null),
                  (this._evaluator.featureState = i || null),
                  (this._evaluator.canonical = r || null),
                  (this._evaluator.availableImages = n || null),
                  (this._evaluator.formattedSection = o || null),
                  (this._evaluator.featureTileCoord = s || null),
                  (this._evaluator.featureDistanceData = a || null);
                try {
                  const e1 = this.expression.evaluate(this._evaluator);
                  if (null == e1 || ("number" == typeof e1 && e1 != e1))
                    return this._defaultValue;
                  if (this._enumValues && !(e1 in this._enumValues))
                    throw new xi(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues,
                      )
                        .map((e1) => JSON.stringify(e1))
                        .join(", ")}, but found ${JSON.stringify(e1)} instead.`,
                    );
                  return e1;
                } catch (e1) {
                  return (
                    this._warningHistory[e1.message] ||
                      ((this._warningHistory[e1.message] = !0),
                      "undefined" != typeof console &&
                        console.warn(e1.message)),
                    this._defaultValue
                  );
                }
              }
            }
            function yo(e1) {
              return (
                Array.isArray(e1) &&
                e1.length > 0 &&
                "string" == typeof e1[0] &&
                e1[0] in eo
              );
            }
            function xo(e1, t, i) {
              const r = new Gr(
                  eo,
                  [],
                  t
                    ? (function (e1) {
                        const t = {
                          color: Gt,
                          string: Vt,
                          number: Ut,
                          enum: Vt,
                          boolean: jt,
                          formatted: Ht,
                          resolvedImage: Wt,
                        };
                        return "array" === e1.type
                          ? Xt(t[e1.value] || Zt, e1.length)
                          : t[e1.type];
                      })(t)
                    : void 0,
                  void 0,
                  void 0,
                  i,
                ),
                n = r.parse(
                  e1,
                  void 0,
                  void 0,
                  void 0,
                  t && "string" === t.type
                    ? {
                        typeAnnotation: "coerce",
                      }
                    : void 0,
                );
              return n ? to(new go(n, t, i)) : io(r.errors);
            }
            class vo {
              constructor(e1, t, i) {
                (this.kind = e1),
                  (this._styleExpression = t),
                  (this.isLightConstant = i),
                  (this.isStateDependent =
                    "constant" !== e1 && !Br(t.expression)),
                  (this.isConfigDependent = !Fr(t.expression));
              }
              evaluateWithoutErrorHandling(e1, t, i, r, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  e1,
                  t,
                  i,
                  r,
                  n,
                  o,
                );
              }
              evaluate(e1, t, i, r, n, o) {
                return this._styleExpression.evaluate(e1, t, i, r, n, o);
              }
            }
            class bo {
              constructor(e1, t, i, r, n) {
                (this.kind = e1),
                  (this.zoomStops = i),
                  (this._styleExpression = t),
                  (this.isStateDependent =
                    "camera" !== e1 && !Br(t.expression)),
                  (this.isLightConstant = n),
                  (this.isConfigDependent = !Fr(t.expression)),
                  (this.interpolationType = r);
              }
              evaluateWithoutErrorHandling(e1, t, i, r, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  e1,
                  t,
                  i,
                  r,
                  n,
                  o,
                );
              }
              evaluate(e1, t, i, r, n, o) {
                return this._styleExpression.evaluate(e1, t, i, r, n, o);
              }
              interpolationFactor(e1, t, i) {
                return this.interpolationType
                  ? yn.interpolationFactor(this.interpolationType, e1, t, i)
                  : 0;
              }
            }
            function wo(e1, t, i) {
              if ("error" === (e1 = xo(e1, t, i)).result) return e1;
              const r = e1.value.expression,
                n = Or(r);
              if (!n && !no(t))
                return io([new Ot("", "data expressions not supported")]);
              const o = Nr(r, ["zoom", "pitch", "distance-from-center"]);
              if (!o && !so(t))
                return io([new Ot("", "zoom expressions not supported")]);
              const s = Nr(r, ["measure-light"]);
              if (!s && !oo(t))
                return io([
                  new Ot("", "measure-light expression not supported"),
                ]);
              const a = t.expression && t.expression.relaxZoomRestriction,
                l = Eo(r);
              return l || o || a
                ? l instanceof Ot
                  ? io([l])
                  : l instanceof yn && !ao(t)
                  ? io([
                      new Ot(
                        "",
                        '"interpolate" expressions cannot be used with this property',
                      ),
                    ])
                  : to(
                      l
                        ? new bo(
                            n ? "camera" : "composite",
                            e1.value,
                            l.labels,
                            l instanceof yn ? l.interpolation : void 0,
                            s,
                          )
                        : new vo(n ? "constant" : "source", e1.value, s),
                    )
                : io([
                    new Ot(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.',
                    ),
                  ]);
            }
            class To {
              constructor(e1, t) {
                (this._parameters = e1),
                  (this._specification = t),
                  Pt(this, ho(this._parameters, this._specification));
              }
              static deserialize(e1) {
                return new To(e1._parameters, e1._specification);
              }
              static serialize(e1) {
                return {
                  _parameters: e1._parameters,
                  _specification: e1._specification,
                };
              }
            }
            function Eo(e1) {
              let t = null;
              if (e1 instanceof wn) t = Eo(e1.result);
              else if (e1 instanceof vn) {
                for (const i of e1.args) if (((t = Eo(i)), t)) break;
              } else
                (e1 instanceof Hr || e1 instanceof yn) &&
                  e1.input instanceof Pi &&
                  "zoom" === e1.input.name &&
                  (t = e1);
              return (
                t instanceof Ot ||
                  e1.eachChild((e1) => {
                    const i = Eo(e1);
                    i instanceof Ot
                      ? (t = i)
                      : t &&
                        i &&
                        t !== i &&
                        (t = new Ot(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.',
                        ));
                  }),
                t
              );
            }
            function Mo(e1) {
              const t = e1.key,
                i = e1.value,
                r = e1.valueSpec || {},
                n = e1.objectElementValidators || {},
                o = e1.style,
                s = e1.styleSpec;
              let a = [];
              const l = Mi(i);
              if ("object" !== l)
                return [new zt(t, i, `object expected, ${l} found`)];
              for (const e1 in i) {
                const l = e1.split(".")[0];
                let c;
                n[l]
                  ? (c = n[l])
                  : r[l]
                  ? (c = as)
                  : n["*"]
                  ? (c = n["*"])
                  : r["*"] && (c = as),
                  c
                    ? (a = a.concat(
                        c(
                          {
                            key: (t ? `${t}.` : t) + e1,
                            value: i[e1],
                            valueSpec: r[l] || r["*"],
                            style: o,
                            styleSpec: s,
                            object: i,
                            objectKey: e1,
                          },
                          i,
                        ),
                      ))
                    : a.push(new Dt(t, i[e1], `unknown property "${e1}"`));
              }
              for (const e1 in r)
                n[e1] ||
                  (r[e1].required &&
                    void 0 === r[e1].default &&
                    void 0 === i[e1] &&
                    a.push(new zt(t, i, `missing required property "${e1}"`)));
              return a;
            }
            function Ao(e1) {
              const t = e1.value,
                i = e1.valueSpec,
                r = e1.style,
                n = e1.styleSpec,
                o = e1.key,
                s = e1.arrayElementValidator || as;
              if ("array" !== Mi(t))
                return [new zt(o, t, `array expected, ${Mi(t)} found`)];
              if (i.length && t.length !== i.length)
                return [
                  new zt(
                    o,
                    t,
                    `array length ${i.length} expected, length ${t.length} found`,
                  ),
                ];
              if (i["min-length"] && t.length < i["min-length"])
                return [
                  new zt(
                    o,
                    t,
                    `array length at least ${i["min-length"]} expected, length ${t.length} found`,
                  ),
                ];
              let a = {
                type: i.value,
                values: i.values,
                minimum: i.minimum,
                maximum: i.maximum,
                function: void 0,
              };
              n.$version < 7 && (a.function = i.function),
                "object" === Mi(i.value) && (a = i.value);
              let l = [];
              for (let e1 = 0; e1 < t.length; e1++)
                l = l.concat(
                  s(
                    {
                      array: t,
                      arrayIndex: e1,
                      value: t[e1],
                      valueSpec: a,
                      style: r,
                      styleSpec: n,
                      key: `${o}[${e1}]`,
                    },
                    !0,
                  ),
                );
              return l;
            }
            function So(e1) {
              const t = e1.key,
                i = e1.value,
                r = e1.valueSpec;
              let n = Mi(i);
              if (("number" === n && i != i && (n = "NaN"), "number" !== n))
                return [new zt(t, i, `number expected, ${n} found`)];
              if ("minimum" in r) {
                let n = r.minimum;
                if (
                  ("array" === Mi(r.minimum) && (n = r.minimum[e1.arrayIndex]),
                  i < n)
                )
                  return [
                    new zt(t, i, `${i} is less than the minimum value ${n}`),
                  ];
              }
              if ("maximum" in r) {
                let n = r.maximum;
                if (
                  ("array" === Mi(r.maximum) && (n = r.maximum[e1.arrayIndex]),
                  i > n)
                )
                  return [
                    new zt(t, i, `${i} is greater than the maximum value ${n}`),
                  ];
              }
              return [];
            }
            function Io(e1) {
              const t = e1.valueSpec,
                i = Rt(e1.value.type);
              let r,
                n,
                o,
                s = {};
              const a = "categorical" !== i && void 0 === e1.value.property,
                l = !a,
                c =
                  "array" === Mi(e1.value.stops) &&
                  "array" === Mi(e1.value.stops[0]) &&
                  "object" === Mi(e1.value.stops[0][0]),
                h = Mo({
                  key: e1.key,
                  value: e1.value,
                  valueSpec: e1.styleSpec.function,
                  style: e1.style,
                  styleSpec: e1.styleSpec,
                  objectElementValidators: {
                    stops: function (e1) {
                      if ("identity" === i)
                        return [
                          new zt(
                            e1.key,
                            e1.value,
                            'identity function may not have a "stops" property',
                          ),
                        ];
                      let t = [];
                      const r = e1.value;
                      return (
                        (t = t.concat(
                          Ao({
                            key: e1.key,
                            value: r,
                            valueSpec: e1.valueSpec,
                            style: e1.style,
                            styleSpec: e1.styleSpec,
                            arrayElementValidator: u,
                          }),
                        )),
                        "array" === Mi(r) &&
                          0 === r.length &&
                          t.push(
                            new zt(
                              e1.key,
                              r,
                              "array must have at least one stop",
                            ),
                          ),
                        t
                      );
                    },
                    default: function (e1) {
                      return as({
                        key: e1.key,
                        value: e1.value,
                        valueSpec: t,
                        style: e1.style,
                        styleSpec: e1.styleSpec,
                      });
                    },
                  },
                });
              return (
                "identity" === i &&
                  a &&
                  h.push(
                    new zt(
                      e1.key,
                      e1.value,
                      'missing required property "property"',
                    ),
                  ),
                "identity" === i ||
                  e1.value.stops ||
                  h.push(
                    new zt(
                      e1.key,
                      e1.value,
                      'missing required property "stops"',
                    ),
                  ),
                "exponential" === i &&
                  e1.valueSpec.expression &&
                  !ao(e1.valueSpec) &&
                  h.push(
                    new zt(
                      e1.key,
                      e1.value,
                      "exponential functions not supported",
                    ),
                  ),
                e1.styleSpec.$version >= 8 &&
                  (l && !no(e1.valueSpec)
                    ? h.push(
                        new zt(
                          e1.key,
                          e1.value,
                          "property functions not supported",
                        ),
                      )
                    : a &&
                      !so(e1.valueSpec) &&
                      h.push(
                        new zt(
                          e1.key,
                          e1.value,
                          "zoom functions not supported",
                        ),
                      )),
                ("categorical" !== i && !c) ||
                  void 0 !== e1.value.property ||
                  h.push(
                    new zt(e1.key, e1.value, '"property" property is required'),
                  ),
                h
              );
              function u(e1) {
                let i = [];
                const r = e1.value,
                  a = e1.key;
                if ("array" !== Mi(r))
                  return [new zt(a, r, `array expected, ${Mi(r)} found`)];
                if (2 !== r.length)
                  return [
                    new zt(
                      a,
                      r,
                      `array length 2 expected, length ${r.length} found`,
                    ),
                  ];
                if (c) {
                  if ("object" !== Mi(r[0]))
                    return [new zt(a, r, `object expected, ${Mi(r[0])} found`)];
                  if (void 0 === r[0].zoom)
                    return [new zt(a, r, "object stop key must have zoom")];
                  if (void 0 === r[0].value)
                    return [new zt(a, r, "object stop key must have value")];
                  const t = Rt(r[0].zoom);
                  if ("number" != typeof t)
                    return [
                      new zt(a, r[0].zoom, "stop zoom values must be numbers"),
                    ];
                  if (o && o > t)
                    return [
                      new zt(
                        a,
                        r[0].zoom,
                        "stop zoom values must appear in ascending order",
                      ),
                    ];
                  t !== o && ((o = t), (n = void 0), (s = {})),
                    (i = i.concat(
                      Mo({
                        key: `${a}[0]`,
                        value: r[0],
                        valueSpec: {
                          zoom: {},
                        },
                        style: e1.style,
                        styleSpec: e1.styleSpec,
                        objectElementValidators: {
                          zoom: So,
                          value: d,
                        },
                      }),
                    ));
                } else
                  i = i.concat(
                    d(
                      {
                        key: `${a}[0]`,
                        value: r[0],
                        valueSpec: {},
                        style: e1.style,
                        styleSpec: e1.styleSpec,
                      },
                      r,
                    ),
                  );
                return yo(Lt(r[1]))
                  ? i.concat([
                      new zt(
                        `${a}[1]`,
                        r[1],
                        "expressions are not allowed in function stops.",
                      ),
                    ])
                  : i.concat(
                      as({
                        key: `${a}[1]`,
                        value: r[1],
                        valueSpec: t,
                        style: e1.style,
                        styleSpec: e1.styleSpec,
                      }),
                    );
              }
              function d(e1, o) {
                const a = Mi(e1.value),
                  l = Rt(e1.value),
                  c = null !== e1.value ? e1.value : o;
                if (r) {
                  if (a !== r)
                    return [
                      new zt(
                        e1.key,
                        c,
                        `${a} stop domain type must match previous stop domain type ${r}`,
                      ),
                    ];
                } else r = a;
                if (
                  "number" !== a &&
                  "string" !== a &&
                  "boolean" !== a &&
                  "number" != typeof l &&
                  "string" != typeof l &&
                  "boolean" != typeof l
                )
                  return [
                    new zt(
                      e1.key,
                      c,
                      "stop domain value must be a number, string, or boolean",
                    ),
                  ];
                if ("number" !== a && "categorical" !== i) {
                  let r = `number expected, ${a} found`;
                  return (
                    no(t) &&
                      void 0 === i &&
                      (r +=
                        '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new zt(e1.key, c, r)]
                  );
                }
                return "categorical" !== i ||
                  "number" !== a ||
                  ("number" == typeof l && isFinite(l) && Math.floor(l) === l)
                  ? "categorical" !== i &&
                    "number" === a &&
                    "number" == typeof l &&
                    "number" == typeof n &&
                    void 0 !== n &&
                    l < n
                    ? [
                        new zt(
                          e1.key,
                          c,
                          "stop domain values must appear in ascending order",
                        ),
                      ]
                    : ((n = l),
                      "categorical" === i && l in s
                        ? [
                            new zt(
                              e1.key,
                              c,
                              "stop domain values must be unique",
                            ),
                          ]
                        : ((s[l] = !0), []))
                  : [new zt(e1.key, c, `integer expected, found ${String(l)}`)];
              }
            }
            function Co(e1) {
              const t = ("property" === e1.expressionContext ? wo : xo)(
                Lt(e1.value),
                e1.valueSpec,
              );
              if ("error" === t.result)
                return t.value.map(
                  (t) => new zt(`${e1.key}${t.key}`, e1.value, t.message),
                );
              const i =
                t.value.expression || t.value._styleExpression.expression;
              if (
                "property" === e1.expressionContext &&
                "text-font" === e1.propertyKey &&
                !i.outputDefined()
              )
                return [
                  new zt(
                    e1.key,
                    e1.value,
                    `Invalid data expression for "${e1.propertyKey}". Output values must be contained as literals within the expression.`,
                  ),
                ];
              if (
                "property" === e1.expressionContext &&
                "layout" === e1.propertyType &&
                !Br(i)
              )
                return [
                  new zt(
                    e1.key,
                    e1.value,
                    '"feature-state" data expressions are not supported with layout properties.',
                  ),
                ];
              if ("filter" === e1.expressionContext) return zo(i, e1);
              if (
                e1.expressionContext &&
                0 === e1.expressionContext.indexOf("cluster")
              ) {
                if (!Nr(i, ["zoom", "feature-state"]))
                  return [
                    new zt(
                      e1.key,
                      e1.value,
                      '"zoom" and "feature-state" expressions are not supported with cluster properties.',
                    ),
                  ];
                if ("cluster-initial" === e1.expressionContext && !Or(i))
                  return [
                    new zt(
                      e1.key,
                      e1.value,
                      "Feature data expressions are not supported with initial expression part of cluster properties.",
                    ),
                  ];
              }
              return [];
            }
            function zo(e1, t) {
              const i = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center",
              ]);
              if (t.valueSpec && t.valueSpec.expression)
                for (const e1 of t.valueSpec.expression.parameters)
                  i.delete(e1);
              if (0 === i.size) return [];
              const r = [];
              return e1 instanceof Pi && i.has(e1.name)
                ? [
                    new zt(
                      t.key,
                      t.value,
                      `["${e1.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`,
                    ),
                  ]
                : (e1.eachChild((e1) => {
                    r.push(...zo(e1, t));
                  }),
                  r);
            }
            function Do(e1) {
              const t = e1.key,
                i = e1.value,
                r = e1.valueSpec,
                n = [];
              return (
                Array.isArray(r.values)
                  ? -1 === r.values.indexOf(Rt(i)) &&
                    n.push(
                      new zt(
                        t,
                        i,
                        `expected one of [${r.values.join(
                          ", ",
                        )}], ${JSON.stringify(i)} found`,
                      ),
                    )
                  : -1 === Object.keys(r.values).indexOf(Rt(i)) &&
                    n.push(
                      new zt(
                        t,
                        i,
                        `expected one of [${Object.keys(r.values).join(
                          ", ",
                        )}], ${JSON.stringify(i)} found`,
                      ),
                    ),
                n
              );
            }
            function Po(e1) {
              if (!0 === e1 || !1 === e1) return !0;
              if (!Array.isArray(e1) || 0 === e1.length) return !1;
              switch (e1[0]) {
                case "has":
                  return e1.length >= 2 && "$id" !== e1[1] && "$type" !== e1[1];
                case "in":
                  return (
                    e1.length >= 3 &&
                    ("string" != typeof e1[1] || Array.isArray(e1[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    3 !== e1.length ||
                    Array.isArray(e1[1]) ||
                    Array.isArray(e1[2])
                  );
                case "any":
                case "all":
                  for (const t of e1.slice(1))
                    if (!Po(t) && "boolean" != typeof t) return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            function Ro(e1, t = "fill") {
              if (null == e1)
                return {
                  filter: () => !0,
                  needGeometry: !1,
                  needFeature: !1,
                };
              Po(e1) || (e1 = Uo(e1));
              const i = e1;
              let r = !0;
              try {
                r = (function (e1) {
                  if (!Oo(e1)) return e1;
                  let t = Lt(e1);
                  return ko(t), (t = Lo(t)), t;
                })(i);
              } catch (e1) {
                console.warn(
                  `Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(
                    i,
                    null,
                    2,
                  )}\n        `,
                );
              }
              const n = Ct[`filter_${t}`],
                o = xo(r, n);
              let s = null;
              if ("error" === o.result)
                throw new Error(
                  o.value.map((e1) => `${e1.key}: ${e1.message}`).join(", "),
                );
              s = (e1, t, i) => o.value.evaluate(e1, t, {}, i);
              let a = null,
                l = null;
              if (r !== i) {
                const e1 = xo(i, n);
                if ("error" === e1.result)
                  throw new Error(
                    e1.value.map((e1) => `${e1.key}: ${e1.message}`).join(", "),
                  );
                (a = (t, i, r, n, o) =>
                  e1.value.evaluate(t, i, {}, r, void 0, void 0, n, o)),
                  (l = !Or(e1.value.expression));
              }
              return {
                filter: s,
                dynamicFilter: a || void 0,
                needGeometry: No(r),
                needFeature: !!l,
              };
            }
            function Lo(e1) {
              if (!Array.isArray(e1)) return e1;
              const t = (function (e1) {
                if (Bo.has(e1[0])) {
                  for (let t = 1; t < e1.length; t++) if (Oo(e1[t])) return !0;
                }
                return e1;
              })(e1);
              return !0 === t ? t : t.map((e1) => Lo(e1));
            }
            function ko(e1) {
              let t = !1;
              const i = [];
              if ("case" === e1[0]) {
                for (let r = 1; r < e1.length - 1; r += 2)
                  (t = t || Oo(e1[r])), i.push(e1[r + 1]);
                i.push(e1[e1.length - 1]);
              } else if ("match" === e1[0]) {
                t = t || Oo(e1[1]);
                for (let t = 2; t < e1.length - 1; t += 2) i.push(e1[t + 1]);
                i.push(e1[e1.length - 1]);
              } else if ("step" === e1[0]) {
                t = t || Oo(e1[1]);
                for (let t = 1; t < e1.length - 1; t += 2) i.push(e1[t + 1]);
              }
              t && ((e1.length = 0), e1.push("any", ...i));
              for (let t = 1; t < e1.length; t++) ko(e1[t]);
            }
            function Oo(e1) {
              if (!Array.isArray(e1)) return !1;
              if ("pitch" === (t = e1[0]) || "distance-from-center" === t)
                return !0;
              var t;
              for (let t = 1; t < e1.length; t++) if (Oo(e1[t])) return !0;
              return !1;
            }
            const Bo = new Set([
              "in",
              "==",
              "!=",
              ">",
              ">=",
              "<",
              "<=",
              "to-boolean",
            ]);
            function Fo(e1, t) {
              return e1 < t ? -1 : e1 > t ? 1 : 0;
            }
            function No(e1) {
              if (!Array.isArray(e1)) return !1;
              if ("within" === e1[0] || "distance" === e1[0]) return !0;
              for (let t = 1; t < e1.length; t++) if (No(e1[t])) return !0;
              return !1;
            }
            function Uo(e1) {
              if (!e1) return !0;
              const t = e1[0];
              var i;
              return e1.length <= 1
                ? "any" !== t
                : "==" === t
                ? Vo(e1[1], e1[2], "==")
                : "!=" === t
                ? qo(Vo(e1[1], e1[2], "=="))
                : "<" === t || ">" === t || "<=" === t || ">=" === t
                ? Vo(e1[1], e1[2], t)
                : "any" === t
                ? ((i = e1.slice(1)), ["any"].concat(i.map(Uo)))
                : "all" === t
                ? ["all"].concat(e1.slice(1).map(Uo))
                : "none" === t
                ? ["all"].concat(e1.slice(1).map(Uo).map(qo))
                : "in" === t
                ? jo(e1[1], e1.slice(2))
                : "!in" === t
                ? qo(jo(e1[1], e1.slice(2)))
                : "has" === t
                ? Go(e1[1])
                : "!has" !== t || qo(Go(e1[1]));
            }
            function Vo(e1, t, i) {
              switch (e1) {
                case "$type":
                  return [`filter-type-${i}`, t];
                case "$id":
                  return [`filter-id-${i}`, t];
                default:
                  return [`filter-${i}`, e1, t];
              }
            }
            function jo(e1, t) {
              if (0 === t.length) return !1;
              switch (e1) {
                case "$type":
                  return ["filter-type-in", ["literal", t]];
                case "$id":
                  return ["filter-id-in", ["literal", t]];
                default:
                  return t.length > 200 &&
                    !t.some((e1) => typeof e1 != typeof t[0])
                    ? ["filter-in-large", e1, ["literal", t.sort(Fo)]]
                    : ["filter-in-small", e1, ["literal", t]];
              }
            }
            function Go(e1) {
              switch (e1) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", e1];
              }
            }
            function qo(e1) {
              return ["!", e1];
            }
            function Zo(e1) {
              return Po(Lt(e1.value))
                ? Co(
                    Pt({}, e1, {
                      expressionContext: "filter",
                      valueSpec:
                        e1.styleSpec[`filter_${e1.layerType || "fill"}`],
                    }),
                  )
                : $o(e1);
            }
            function $o(e1) {
              const t = e1.value,
                i = e1.key;
              if ("array" !== Mi(t))
                return [new zt(i, t, `array expected, ${Mi(t)} found`)];
              const r = e1.styleSpec;
              let n,
                o = [];
              if (t.length < 1)
                return [
                  new zt(i, t, "filter array must have at least 1 element"),
                ];
              switch (
                ((o = o.concat(
                  Do({
                    key: `${i}[0]`,
                    value: t[0],
                    valueSpec: r.filter_operator,
                    style: e1.style,
                    styleSpec: e1.styleSpec,
                  }),
                )),
                Rt(t[0]))
              ) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  t.length >= 2 &&
                    "$type" === Rt(t[1]) &&
                    o.push(
                      new zt(
                        i,
                        t,
                        `"$type" cannot be use with operator "${t[0]}"`,
                      ),
                    );
                case "==":
                case "!=":
                  3 !== t.length &&
                    o.push(
                      new zt(
                        i,
                        t,
                        `filter array for operator "${t[0]}" must have 3 elements`,
                      ),
                    );
                case "in":
                case "!in":
                  t.length >= 2 &&
                    ((n = Mi(t[1])),
                    "string" !== n &&
                      o.push(
                        new zt(`${i}[1]`, t[1], `string expected, ${n} found`),
                      ));
                  for (let s = 2; s < t.length; s++)
                    (n = Mi(t[s])),
                      "$type" === Rt(t[1])
                        ? (o = o.concat(
                            Do({
                              key: `${i}[${s}]`,
                              value: t[s],
                              valueSpec: r.geometry_type,
                              style: e1.style,
                              styleSpec: e1.styleSpec,
                            }),
                          ))
                        : "string" !== n &&
                          "number" !== n &&
                          "boolean" !== n &&
                          o.push(
                            new zt(
                              `${i}[${s}]`,
                              t[s],
                              `string, number, or boolean expected, ${n} found`,
                            ),
                          );
                  break;
                case "any":
                case "all":
                case "none":
                  for (let r = 1; r < t.length; r++)
                    o = o.concat(
                      $o({
                        key: `${i}[${r}]`,
                        value: t[r],
                        style: e1.style,
                        styleSpec: e1.styleSpec,
                      }),
                    );
                  break;
                case "has":
                case "!has":
                  (n = Mi(t[1])),
                    2 !== t.length
                      ? o.push(
                          new zt(
                            i,
                            t,
                            `filter array for "${t[0]}" operator must have 2 elements`,
                          ),
                        )
                      : "string" !== n &&
                        o.push(
                          new zt(
                            `${i}[1]`,
                            t[1],
                            `string expected, ${n} found`,
                          ),
                        );
              }
              return o;
            }
            function Ho(e1, t) {
              const i = e1.key,
                r = e1.style,
                n = e1.layer,
                o = e1.styleSpec,
                s = e1.value,
                a = e1.objectKey,
                l = o[`${t}_${e1.layerType}`];
              if (!l) return [];
              const c = a.match(/^(.*)-transition$/);
              if ("paint" === t && c && l[c[1]] && l[c[1]].transition)
                return as({
                  key: i,
                  value: s,
                  valueSpec: o.transition,
                  style: r,
                  styleSpec: o,
                });
              const h = e1.valueSpec || l[a];
              if (!h) return [new Dt(i, s, `unknown property "${a}"`)];
              let u;
              if (
                "string" === Mi(s) &&
                no(h) &&
                !h.tokens &&
                (u = /^{([^}]+)}$/.exec(s))
              ) {
                const e1 = `\`{ "type": "identity", "property": ${
                  u ? JSON.stringify(u[1]) : '"_"'
                } }\``;
                return [
                  new zt(
                    i,
                    s,
                    `"${a}" does not support interpolation syntax\nUse an identity property function instead: ${e1}.`,
                  ),
                ];
              }
              const d = [];
              if ("symbol" === e1.layerType)
                "text-field" !== a ||
                  !r ||
                  r.glyphs ||
                  r.imports ||
                  d.push(
                    new zt(
                      i,
                      s,
                      'use of "text-field" requires a style "glyphs" property',
                    ),
                  ),
                  "text-font" === a &&
                    lo(Lt(s)) &&
                    "identity" === Rt(s.type) &&
                    d.push(
                      new zt(
                        i,
                        s,
                        '"text-font" does not support identity functions',
                      ),
                    );
              else if (
                "model" === e1.layerType &&
                "paint" === t &&
                n &&
                n.layout &&
                n.layout.hasOwnProperty("model-id") &&
                no(h) &&
                (oo(h) || so(h))
              ) {
                const e1 = wo(Lt(s), h),
                  t =
                    e1.value.expression || e1.value._styleExpression.expression;
                t &&
                  !Nr(t, ["measure-light"]) &&
                  d.push(
                    new zt(
                      i,
                      s,
                      `${a} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`,
                    ),
                  );
              }
              return d.concat(
                as({
                  key: e1.key,
                  value: s,
                  valueSpec: h,
                  style: r,
                  styleSpec: o,
                  expressionContext: "property",
                  propertyType: t,
                  propertyKey: a,
                }),
              );
            }
            function Wo(e1) {
              return Ho(e1, "paint");
            }
            function Xo(e1) {
              return Ho(e1, "layout");
            }
            function Yo(e1) {
              let t = [];
              const i = e1.value,
                r = e1.key,
                n = e1.style,
                o = e1.styleSpec;
              i.type ||
                i.ref ||
                t.push(new zt(r, i, 'either "type" or "ref" is required'));
              let s = Rt(i.type);
              const a = Rt(i.ref);
              if (i.id) {
                const o = Rt(i.id);
                for (let s = 0; s < e1.arrayIndex; s++) {
                  const e1 = n.layers[s];
                  Rt(e1.id) === o &&
                    t.push(
                      new zt(
                        r,
                        i.id,
                        `duplicate layer id "${i.id}", previously used at line ${e1.id.__line__}`,
                      ),
                    );
                }
              }
              if ("ref" in i) {
                let e1;
                ["type", "source", "source-layer", "filter", "layout"].forEach(
                  (e1) => {
                    e1 in i &&
                      t.push(
                        new zt(
                          r,
                          i[e1],
                          `"${e1}" is prohibited for ref layers`,
                        ),
                      );
                  },
                ),
                  n.layers.forEach((t) => {
                    Rt(t.id) === a && (e1 = t);
                  }),
                  e1
                    ? e1.ref
                      ? t.push(
                          new zt(
                            r,
                            i.ref,
                            "ref cannot reference another ref layer",
                          ),
                        )
                      : (s = Rt(e1.type))
                    : "string" == typeof a &&
                      t.push(new zt(r, i.ref, `ref layer "${a}" not found`));
              } else if ("background" !== s && "sky" !== s && "slot" !== s) {
                if (i.source) {
                  const e1 = n.sources && n.sources[i.source],
                    o = e1 && Rt(e1.type);
                  e1
                    ? "vector" === o && "raster" === s
                      ? t.push(
                          new zt(
                            r,
                            i.source,
                            `layer "${i.id}" requires a raster source`,
                          ),
                        )
                      : "raster" === o && "raster" !== s
                      ? t.push(
                          new zt(
                            r,
                            i.source,
                            `layer "${i.id}" requires a vector source`,
                          ),
                        )
                      : "vector" !== o || i["source-layer"]
                      ? "raster-dem" === o && "hillshade" !== s
                        ? t.push(
                            new zt(
                              r,
                              i.source,
                              "raster-dem source can only be used with layer type 'hillshade'.",
                            ),
                          )
                        : "line" !== s ||
                          !i.paint ||
                          (!i.paint["line-gradient"] &&
                            !i.paint["line-trim-offset"]) ||
                          ("geojson" === o && e1.lineMetrics) ||
                          t.push(
                            new zt(
                              r,
                              i,
                              `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`,
                            ),
                          )
                      : t.push(
                          new zt(
                            r,
                            i,
                            `layer "${i.id}" must specify a "source-layer"`,
                          ),
                        )
                    : t.push(
                        new zt(r, i.source, `source "${i.source}" not found`),
                      );
                } else
                  t.push(new zt(r, i, 'missing required property "source"'));
              }
              return (
                (t = t.concat(
                  Mo({
                    key: r,
                    value: i,
                    valueSpec: o.layer,
                    style: e1.style,
                    styleSpec: e1.styleSpec,
                    objectElementValidators: {
                      "*": () => [],
                      type: () =>
                        as({
                          key: `${r}.type`,
                          value: i.type,
                          valueSpec: o.layer.type,
                          style: e1.style,
                          styleSpec: e1.styleSpec,
                          object: i,
                          objectKey: "type",
                        }),
                      filter: (e1) =>
                        Zo(
                          Pt(
                            {
                              layerType: s,
                            },
                            e1,
                          ),
                        ),
                      layout: (e1) =>
                        Mo({
                          layer: i,
                          key: e1.key,
                          value: e1.value,
                          valueSpec: {},
                          style: e1.style,
                          styleSpec: e1.styleSpec,
                          objectElementValidators: {
                            "*": (e1) =>
                              Xo(
                                Pt(
                                  {
                                    layerType: s,
                                  },
                                  e1,
                                ),
                              ),
                          },
                        }),
                      paint: (e1) =>
                        Mo({
                          layer: i,
                          key: e1.key,
                          value: e1.value,
                          valueSpec: {},
                          style: e1.style,
                          styleSpec: e1.styleSpec,
                          objectElementValidators: {
                            "*": (e1) =>
                              Wo(
                                Pt(
                                  {
                                    layerType: s,
                                    layer: i,
                                  },
                                  e1,
                                ),
                              ),
                          },
                        }),
                    },
                  }),
                )),
                t
              );
            }
            function Ko(e1) {
              const t = e1.value,
                i = e1.key,
                r = Mi(t);
              return "string" !== r
                ? [new zt(i, t, `string expected, ${r} found`)]
                : [];
            }
            const Jo = {
              promoteId: function ({ key: e1, value: t }) {
                if ("string" === Mi(t))
                  return Ko({
                    key: e1,
                    value: t,
                  });
                {
                  const i = [];
                  for (const r in t)
                    i.push(
                      ...Ko({
                        key: `${e1}.${r}`,
                        value: t[r],
                      }),
                    );
                  return i;
                }
              },
            };
            function Qo(e1) {
              const t = e1.value,
                i = e1.key,
                r = e1.styleSpec,
                n = e1.style;
              if (!t.type) return [new zt(i, t, '"type" is required')];
              const o = Rt(t.type);
              let s;
              switch (o) {
                case "vector":
                case "raster":
                case "raster-dem":
                  return (
                    (s = Mo({
                      key: i,
                      value: t,
                      valueSpec: r[`source_${o.replace("-", "_")}`],
                      style: e1.style,
                      styleSpec: r,
                      objectElementValidators: Jo,
                    })),
                    s
                  );
                case "geojson":
                  if (
                    ((s = Mo({
                      key: i,
                      value: t,
                      valueSpec: r.source_geojson,
                      style: n,
                      styleSpec: r,
                      objectElementValidators: Jo,
                    })),
                    t.cluster)
                  )
                    for (const e1 in t.clusterProperties) {
                      const [r, n] = t.clusterProperties[e1],
                        o =
                          "string" == typeof r
                            ? [r, ["accumulated"], ["get", e1]]
                            : r;
                      s.push(
                        ...Co({
                          key: `${i}.${e1}.map`,
                          value: n,
                          expressionContext: "cluster-map",
                        }),
                      ),
                        s.push(
                          ...Co({
                            key: `${i}.${e1}.reduce`,
                            value: o,
                            expressionContext: "cluster-reduce",
                          }),
                        );
                    }
                  return s;
                case "video":
                  return Mo({
                    key: i,
                    value: t,
                    valueSpec: r.source_video,
                    style: n,
                    styleSpec: r,
                  });
                case "image":
                  return Mo({
                    key: i,
                    value: t,
                    valueSpec: r.source_image,
                    style: n,
                    styleSpec: r,
                  });
                case "canvas":
                  return [
                    new zt(
                      i,
                      null,
                      "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                      "source.canvas",
                    ),
                  ];
                default:
                  return Do({
                    key: `${i}.type`,
                    value: t.type,
                    valueSpec: {
                      values: es(r),
                    },
                    style: n,
                    styleSpec: r,
                  });
              }
            }
            function es(e1) {
              return e1.source.reduce((t, i) => {
                const r = e1[i];
                return (
                  "enum" === r.type.type &&
                    (t = t.concat(Object.keys(r.type.values))),
                  t
                );
              }, []);
            }
            function ts(e1) {
              const t = e1.value;
              let i = [];
              if (!t) return i;
              const r = Mi(t);
              return "string" !== r
                ? ((i = i.concat([
                    new zt(e1.key, t, `string expected, "${r}" found`),
                  ])),
                  i)
                : ((function (e1) {
                    const t = -1 === e1.indexOf("://");
                    try {
                      return new URL(e1, t ? "http://example.com" : void 0), !0;
                    } catch (e1) {
                      return !1;
                    }
                  })(t) ||
                    (i = i.concat([new zt(e1.key, t, `invalid url "${t}"`)])),
                  i);
            }
            function is(e1) {
              const t = e1.value,
                i = e1.styleSpec,
                r = i.light,
                n = e1.style;
              let o = [];
              const s = Mi(t);
              if (void 0 === t) return o;
              if ("object" !== s)
                return (
                  (o = o.concat([
                    new zt("light", t, `object expected, ${s} found`),
                  ])),
                  o
                );
              for (const e1 in t) {
                const s = e1.match(/^(.*)-transition$/);
                o = o.concat(
                  s && r[s[1]] && r[s[1]].transition
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: i.transition,
                        style: n,
                        styleSpec: i,
                      })
                    : r[e1]
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: r[e1],
                        style: n,
                        styleSpec: i,
                      })
                    : [new zt(e1, t[e1], `unknown property "${e1}"`)],
                );
              }
              return o;
            }
            function rs(e1) {
              const t = e1.value;
              let i = [];
              if (!t) return i;
              const r = Mi(t);
              if ("object" !== r)
                return (
                  (i = i.concat([
                    new zt("light-3d", t, `object expected, ${r} found`),
                  ])),
                  i
                );
              const n = e1.styleSpec,
                o = n["light-3d"],
                s = e1.key,
                a = e1.style,
                l = e1.style.lights;
              for (const e1 of ["type", "id"])
                if (!(e1 in t))
                  return (
                    (i = i.concat([
                      new zt("light-3d", t, `missing property ${e1} on light`),
                    ])),
                    i
                  );
              if (t.type && l)
                for (let r = 0; r < e1.arrayIndex; r++) {
                  const e1 = Rt(t.type),
                    n = l[r];
                  Rt(n.type) === e1 &&
                    i.push(
                      new zt(
                        s,
                        t.id,
                        `duplicate light type "${t.type}", previously defined at line ${n.id.__line__}`,
                      ),
                    );
                }
              const c = `properties_light_${t.type}`;
              if (!(c in n))
                return (
                  (i = i.concat([
                    new zt("light-3d", t, `Invalid light type ${t.type}`),
                  ])),
                  i
                );
              const h = n[c];
              for (const r in t)
                if ("properties" === r) {
                  const o = t[r],
                    s = Mi(o);
                  if ("object" !== s)
                    return (
                      (i = i.concat([
                        new zt("properties", o, `object expected, ${s} found`),
                      ])),
                      i
                    );
                  for (const t in o)
                    i = i.concat(
                      h[t]
                        ? as({
                            key: t,
                            value: o[t],
                            valueSpec: h[t],
                            style: a,
                            styleSpec: n,
                          })
                        : [new Dt(e1.key, o[t], `unknown property "${t}"`)],
                    );
                } else {
                  const e1 = r.match(/^(.*)-transition$/);
                  i = i.concat(
                    e1 && o[e1[1]] && o[e1[1]].transition
                      ? as({
                          key: r,
                          value: t[r],
                          valueSpec: n.transition,
                          style: a,
                          styleSpec: n,
                        })
                      : o[r]
                      ? as({
                          key: r,
                          value: t[r],
                          valueSpec: o[r],
                          style: a,
                          styleSpec: n,
                        })
                      : [new Dt(r, t[r], `unknown property "${r}"`)],
                  );
                }
              return i;
            }
            function ns(e1) {
              const t = e1.value,
                i = e1.key,
                r = e1.style,
                n = e1.styleSpec,
                o = n.terrain;
              let s = [];
              const a = Mi(t);
              if (void 0 === t) return s;
              if ("object" !== a)
                return (
                  (s = s.concat([
                    new zt("terrain", t, `object expected, ${a} found`),
                  ])),
                  s
                );
              for (const e1 in t) {
                const i = e1.match(/^(.*)-transition$/);
                s = s.concat(
                  i && o[i[1]] && o[i[1]].transition
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: n.transition,
                        style: r,
                        styleSpec: n,
                      })
                    : o[e1]
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: o[e1],
                        style: r,
                        styleSpec: n,
                      })
                    : [new Dt(e1, t[e1], `unknown property "${e1}"`)],
                );
              }
              if (t.source) {
                const e1 = r.sources && r.sources[t.source],
                  n = e1 && Rt(e1.type);
                e1
                  ? "raster-dem" !== n &&
                    s.push(
                      new zt(
                        i,
                        t.source,
                        `terrain cannot be used with a source of type ${String(
                          n,
                        )}, it only be used with a "raster-dem" source type`,
                      ),
                    )
                  : s.push(
                      new zt(i, t.source, `source "${t.source}" not found`),
                    );
              } else
                s.push(
                  new zt(i, t, 'terrain is missing required property "source"'),
                );
              return s;
            }
            function os(e1) {
              const t = e1.value,
                i = e1.style,
                r = e1.styleSpec,
                n = r.fog;
              let o = [];
              const s = Mi(t);
              if (void 0 === t) return o;
              if ("object" !== s)
                return (
                  (o = o.concat([
                    new zt("fog", t, `object expected, ${s} found`),
                  ])),
                  o
                );
              for (const e1 in t) {
                const s = e1.match(/^(.*)-transition$/);
                o = o.concat(
                  s && n[s[1]] && n[s[1]].transition
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: r.transition,
                        style: i,
                        styleSpec: r,
                      })
                    : n[e1]
                    ? as({
                        key: e1,
                        value: t[e1],
                        valueSpec: n[e1],
                        style: i,
                        styleSpec: r,
                      })
                    : [new Dt(e1, t[e1], `unknown property "${e1}"`)],
                );
              }
              return o;
            }
            const ss = {
              "*": () => [],
              array: Ao,
              boolean: function (e1) {
                const t = e1.value,
                  i = e1.key,
                  r = Mi(t);
                return "boolean" !== r
                  ? [new zt(i, t, `boolean expected, ${r} found`)]
                  : [];
              },
              number: So,
              color: function (e1) {
                const t = e1.key,
                  i = e1.value,
                  r = Mi(i);
                return "string" !== r
                  ? [new zt(t, i, `color expected, ${r} found`)]
                  : null === ti(i)
                  ? [new zt(t, i, `color expected, "${i}" found`)]
                  : [];
              },
              enum: Do,
              filter: Zo,
              function: Io,
              layer: Yo,
              object: Mo,
              source: Qo,
              model: ts,
              light: is,
              "light-3d": rs,
              terrain: ns,
              fog: os,
              string: Ko,
              formatted: function (e1) {
                return 0 === Ko(e1).length ? [] : Co(e1);
              },
              resolvedImage: function (e1) {
                return 0 === Ko(e1).length ? [] : Co(e1);
              },
              projection: function (e1) {
                const t = e1.value,
                  i = e1.styleSpec,
                  r = i.projection,
                  n = e1.style;
                let o = [];
                const s = Mi(t);
                if ("object" === s)
                  for (const e1 in t)
                    o = o.concat(
                      as({
                        key: e1,
                        value: t[e1],
                        valueSpec: r[e1],
                        style: n,
                        styleSpec: i,
                      }),
                    );
                else
                  "string" !== s &&
                    (o = o.concat([
                      new zt(
                        "projection",
                        t,
                        `object or string expected, ${s} found`,
                      ),
                    ]));
                return o;
              },
              import: function (e1) {
                const { value: t, styleSpec: i } = e1,
                  { data: r, ...n } = t;
                Object.defineProperty(n, "__line__", {
                  value: t.__line__,
                  enumerable: !1,
                });
                let o = Mo(
                  Pt({}, e1, {
                    value: n,
                    valueSpec: i.import,
                  }),
                );
                return (
                  "" === Rt(n.id) &&
                    o.push(
                      new zt(
                        `${e1.key}.id`,
                        n,
                        "import id can't be an empty string",
                      ),
                    ),
                  r &&
                    (o = o.concat(
                      cs(r, i, {
                        key: `${e1.key}.data`,
                      }),
                    )),
                  o
                );
              },
            };
            function as(e1, t = !1) {
              const i = e1.value,
                r = e1.valueSpec,
                n = e1.styleSpec;
              if (r.expression && lo(Rt(i))) return Io(e1);
              if (r.expression && yo(Lt(i))) return Co(e1);
              if (r.type && ss[r.type]) {
                const i = ss[r.type](e1);
                return !0 === t && i.length > 0 && "array" === Mi(e1.value)
                  ? Co(e1)
                  : i;
              }
              return Mo(
                Pt({}, e1, {
                  valueSpec: r.type ? n[r.type] : r,
                }),
              );
            }
            function ls(e1) {
              const t = e1.value,
                i = e1.key,
                r = Ko(e1);
              return (
                r.length ||
                  (-1 === t.indexOf("{fontstack}") &&
                    r.push(
                      new zt(
                        i,
                        t,
                        '"glyphs" url must include a "{fontstack}" token',
                      ),
                    ),
                  -1 === t.indexOf("{range}") &&
                    r.push(
                      new zt(
                        i,
                        t,
                        '"glyphs" url must include a "{range}" token',
                      ),
                    )),
                r
              );
            }
            function cs(e1, t = Ct, i = {}) {
              return as({
                key: i.key || "",
                value: e1,
                valueSpec: t.$root,
                styleSpec: t,
                style: e1,
                objectElementValidators: {
                  glyphs: ls,
                  "*": () => [],
                },
              });
            }
            function hs(e1, t = Ct) {
              return bs(cs(e1, t));
            }
            const us = (e1) => bs(Qo(e1)),
              ds = (e1) => bs(is(e1)),
              ps = (e1) => bs(rs(e1)),
              fs = (e1) => bs(ns(e1)),
              ms = (e1) => bs(os(e1)),
              _s = (e1) => bs(Yo(e1)),
              gs = (e1) => bs(Zo(e1)),
              ys = (e1) => bs(Wo(e1)),
              xs = (e1) => bs(Xo(e1)),
              vs = (e1) => bs(ts(e1));
            function bs(e1) {
              return e1
                .slice()
                .sort((e1, t) => (e1.line && t.line ? e1.line - t.line : 0));
            }
            function ws(e1, t) {
              let i = !1;
              if (t && t.length)
                for (const r of t)
                  r instanceof Dt
                    ? W(r.message)
                    : (e1.fire(new St(new Error(r.message))), (i = !0));
              return i;
            }
            var Ts = Ms,
              Es = 3;
            function Ms(e1, t, i) {
              var r = (this.cells = []);
              if (e1 instanceof ArrayBuffer) {
                this.arrayBuffer = e1;
                var n = new Int32Array(this.arrayBuffer);
                (e1 = n[0]), (this.d = (t = n[1]) + 2 * (i = n[2]));
                for (var o = 0; o < this.d * this.d; o++) {
                  var s = n[Es + o],
                    a = n[Es + o + 1];
                  r.push(s === a ? null : n.subarray(s, a));
                }
                var l = n[Es + r.length + 1];
                (this.keys = n.subarray(n[Es + r.length], l)),
                  (this.bboxes = n.subarray(l)),
                  (this.insert = this._insertReadonly);
              } else {
                this.d = t + 2 * i;
                for (var c = 0; c < this.d * this.d; c++) r.push([]);
                (this.keys = []), (this.bboxes = []);
              }
              (this.n = t),
                (this.extent = e1),
                (this.padding = i),
                (this.scale = t / e1),
                (this.uid = 0);
              var h = (i / t) * e1;
              (this.min = -h), (this.max = e1 + h);
            }
            (Ms.prototype.insert = function (e1, t, i, r, n) {
              this._forEachCell(t, i, r, n, this._insertCell, this.uid++),
                this.keys.push(e1),
                this.bboxes.push(t),
                this.bboxes.push(i),
                this.bboxes.push(r),
                this.bboxes.push(n);
            }),
              (Ms.prototype._insertReadonly = function () {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
              }),
              (Ms.prototype._insertCell = function (e1, t, i, r, n, o) {
                this.cells[n].push(o);
              }),
              (Ms.prototype.query = function (e1, t, i, r, n) {
                var o = this.min,
                  s = this.max;
                if (e1 <= o && t <= o && s <= i && s <= r && !n)
                  return Array.prototype.slice.call(this.keys);
                var a = [];
                return (
                  this._forEachCell(e1, t, i, r, this._queryCell, a, {}, n), a
                );
              }),
              (Ms.prototype._queryCell = function (e1, t, i, r, n, o, s, a) {
                var l = this.cells[n];
                if (null !== l)
                  for (
                    var c = this.keys, h = this.bboxes, u = 0;
                    u < l.length;
                    u++
                  ) {
                    var d = l[u];
                    if (void 0 === s[d]) {
                      var p = 4 * d;
                      (
                        a
                          ? a(h[p + 0], h[p + 1], h[p + 2], h[p + 3])
                          : e1 <= h[p + 2] &&
                            t <= h[p + 3] &&
                            i >= h[p + 0] &&
                            r >= h[p + 1]
                      )
                        ? ((s[d] = !0), o.push(c[d]))
                        : (s[d] = !1);
                    }
                  }
              }),
              (Ms.prototype._forEachCell = function (e1, t, i, r, n, o, s, a) {
                for (
                  var l = this._convertToCellCoord(e1),
                    c = this._convertToCellCoord(t),
                    h = this._convertToCellCoord(i),
                    u = this._convertToCellCoord(r),
                    d = l;
                  d <= h;
                  d++
                )
                  for (var p = c; p <= u; p++) {
                    var f = this.d * p + d;
                    if (
                      (!a ||
                        a(
                          this._convertFromCellCoord(d),
                          this._convertFromCellCoord(p),
                          this._convertFromCellCoord(d + 1),
                          this._convertFromCellCoord(p + 1),
                        )) &&
                      n.call(this, e1, t, i, r, f, o, s, a)
                    )
                      return;
                  }
              }),
              (Ms.prototype._convertFromCellCoord = function (e1) {
                return (e1 - this.padding) / this.scale;
              }),
              (Ms.prototype._convertToCellCoord = function (e1) {
                return Math.max(
                  0,
                  Math.min(
                    this.d - 1,
                    Math.floor(e1 * this.scale) + this.padding,
                  ),
                );
              }),
              (Ms.prototype.toArrayBuffer = function () {
                if (this.arrayBuffer) return this.arrayBuffer;
                for (
                  var e1 = this.cells,
                    t = Es + this.cells.length + 1 + 1,
                    i = 0,
                    r = 0;
                  r < this.cells.length;
                  r++
                )
                  i += this.cells[r].length;
                var n = new Int32Array(
                  t + i + this.keys.length + this.bboxes.length,
                );
                (n[0] = this.extent), (n[1] = this.n), (n[2] = this.padding);
                for (var o = t, s = 0; s < e1.length; s++) {
                  var a = e1[s];
                  (n[Es + s] = o), n.set(a, o), (o += a.length);
                }
                return (
                  (n[Es + e1.length] = o),
                  n.set(this.keys, o),
                  (n[Es + e1.length + 1] = o += this.keys.length),
                  n.set(this.bboxes, o),
                  (o += this.bboxes.length),
                  n.buffer
                );
              });
            var As = d(Ts);
            const Ss = {};
            function Is(e1, t, i = {}) {
              Object.defineProperty(e1, "_classRegistryKey", {
                value: t,
                writeable: !1,
              }),
                (Ss[t] = {
                  klass: e1,
                  omit: i.omit || [],
                });
            }
            Is(Object, "Object"),
              (As.serialize = function (e1, t) {
                const i = e1.toArrayBuffer();
                return (
                  t && t.add(i),
                  {
                    buffer: i,
                  }
                );
              }),
              (As.deserialize = function (e1) {
                return new As(e1.buffer);
              }),
              Object.defineProperty(As, "name", {
                value: "Grid",
              }),
              Is(As, "Grid"),
              Is(li, "Color"),
              Is(Error, "Error"),
              Is(xe, "AJAXError"),
              Is(di, "ResolvedImage"),
              Is(To, "StylePropertyFunction"),
              Is(go, "StyleExpression", {
                omit: ["_evaluator"],
              }),
              Is(bo, "ZoomDependentExpression"),
              Is(vo, "ZoomConstantExpression"),
              Is(Pi, "CompoundExpression", {
                omit: ["_evaluate"],
              });
            for (const e1 in eo)
              Ss[eo[e1]._classRegistryKey] || Is(eo[e1], `Expression${e1}`);
            function Cs(e1) {
              return (
                e1 &&
                "undefined" != typeof ArrayBuffer &&
                (e1 instanceof ArrayBuffer ||
                  (e1.constructor && "ArrayBuffer" === e1.constructor.name))
              );
            }
            function zs(e1) {
              return t.ImageBitmap && e1 instanceof t.ImageBitmap;
            }
            function Ds(e1, i) {
              if (
                null == e1 ||
                "boolean" == typeof e1 ||
                "number" == typeof e1 ||
                "string" == typeof e1 ||
                e1 instanceof Boolean ||
                e1 instanceof Number ||
                e1 instanceof String ||
                e1 instanceof Date ||
                e1 instanceof RegExp
              )
                return e1;
              if (Cs(e1) || zs(e1)) return i && i.add(e1), e1;
              if (ArrayBuffer.isView(e1)) {
                const t = e1;
                return i && i.add(t.buffer), t;
              }
              if (e1 instanceof t.ImageData)
                return i && i.add(e1.data.buffer), e1;
              if (Array.isArray(e1)) {
                const t = [];
                for (const r of e1) t.push(Ds(r, i));
                return t;
              }
              if (e1 instanceof Map) {
                const t = {
                  $name: "Map",
                };
                for (const [i, r] of e1.entries()) t[i] = Ds(r);
                return t;
              }
              if ("object" == typeof e1) {
                const t = e1.constructor,
                  r = t._classRegistryKey;
                if (!r)
                  throw new Error(
                    `can't serialize object of unregistered class ${r}`,
                  );
                const n = t.serialize ? t.serialize(e1, i) : {};
                if (!t.serialize) {
                  for (const t in e1)
                    e1.hasOwnProperty(t) &&
                      (Ss[r].omit.indexOf(t) >= 0 || (n[t] = Ds(e1[t], i)));
                  e1 instanceof Error && (n.message = e1.message);
                }
                if (n.$name)
                  throw new Error(
                    "$name property is reserved for worker serialization logic.",
                  );
                return "Object" !== r && (n.$name = r), n;
              }
              throw new Error("can't serialize object of type " + typeof e1);
            }
            function Ps(e1) {
              if (
                null == e1 ||
                "boolean" == typeof e1 ||
                "number" == typeof e1 ||
                "string" == typeof e1 ||
                e1 instanceof Boolean ||
                e1 instanceof Number ||
                e1 instanceof String ||
                e1 instanceof Date ||
                e1 instanceof RegExp ||
                Cs(e1) ||
                zs(e1) ||
                ArrayBuffer.isView(e1) ||
                e1 instanceof t.ImageData
              )
                return e1;
              if (Array.isArray(e1)) return e1.map(Ps);
              if ("object" == typeof e1) {
                const t = e1.$name || "Object";
                if ("Map" === t) {
                  const t = new Map();
                  for (const i of Object.keys(e1))
                    "$name" !== i && t.set(i, Ps(e1[i]));
                  return t;
                }
                const { klass: i } = Ss[t];
                if (!i)
                  throw new Error(`can't deserialize unregistered class ${t}`);
                if (i.deserialize) return i.deserialize(e1);
                const r = Object.create(i.prototype);
                for (const t of Object.keys(e1))
                  "$name" !== t && (r[t] = Ps(e1[t]));
                return r;
              }
              throw new Error("can't deserialize object of type " + typeof e1);
            }
            const Rs = {
              "Latin-1 Supplement": (e1) => e1 >= 128 && e1 <= 255,
              Arabic: (e1) => e1 >= 1536 && e1 <= 1791,
              "Arabic Supplement": (e1) => e1 >= 1872 && e1 <= 1919,
              "Arabic Extended-A": (e1) => e1 >= 2208 && e1 <= 2303,
              "Hangul Jamo": (e1) => e1 >= 4352 && e1 <= 4607,
              "Unified Canadian Aboriginal Syllabics": (e1) =>
                e1 >= 5120 && e1 <= 5759,
              Khmer: (e1) => e1 >= 6016 && e1 <= 6143,
              "Unified Canadian Aboriginal Syllabics Extended": (e1) =>
                e1 >= 6320 && e1 <= 6399,
              "General Punctuation": (e1) => e1 >= 8192 && e1 <= 8303,
              "Letterlike Symbols": (e1) => e1 >= 8448 && e1 <= 8527,
              "Number Forms": (e1) => e1 >= 8528 && e1 <= 8591,
              "Miscellaneous Technical": (e1) => e1 >= 8960 && e1 <= 9215,
              "Control Pictures": (e1) => e1 >= 9216 && e1 <= 9279,
              "Optical Character Recognition": (e1) => e1 >= 9280 && e1 <= 9311,
              "Enclosed Alphanumerics": (e1) => e1 >= 9312 && e1 <= 9471,
              "Geometric Shapes": (e1) => e1 >= 9632 && e1 <= 9727,
              "Miscellaneous Symbols": (e1) => e1 >= 9728 && e1 <= 9983,
              "Miscellaneous Symbols and Arrows": (e1) =>
                e1 >= 11008 && e1 <= 11263,
              "CJK Radicals Supplement": (e1) => e1 >= 11904 && e1 <= 12031,
              "Kangxi Radicals": (e1) => e1 >= 12032 && e1 <= 12255,
              "Ideographic Description Characters": (e1) =>
                e1 >= 12272 && e1 <= 12287,
              "CJK Symbols and Punctuation": (e1) => e1 >= 12288 && e1 <= 12351,
              Hiragana: (e1) => e1 >= 12352 && e1 <= 12447,
              Katakana: (e1) => e1 >= 12448 && e1 <= 12543,
              Bopomofo: (e1) => e1 >= 12544 && e1 <= 12591,
              "Hangul Compatibility Jamo": (e1) => e1 >= 12592 && e1 <= 12687,
              Kanbun: (e1) => e1 >= 12688 && e1 <= 12703,
              "Bopomofo Extended": (e1) => e1 >= 12704 && e1 <= 12735,
              "CJK Strokes": (e1) => e1 >= 12736 && e1 <= 12783,
              "Katakana Phonetic Extensions": (e1) =>
                e1 >= 12784 && e1 <= 12799,
              "Enclosed CJK Letters and Months": (e1) =>
                e1 >= 12800 && e1 <= 13055,
              "CJK Compatibility": (e1) => e1 >= 13056 && e1 <= 13311,
              "CJK Unified Ideographs Extension A": (e1) =>
                e1 >= 13312 && e1 <= 19903,
              "Yijing Hexagram Symbols": (e1) => e1 >= 19904 && e1 <= 19967,
              "CJK Unified Ideographs": (e1) => e1 >= 19968 && e1 <= 40959,
              "Yi Syllables": (e1) => e1 >= 40960 && e1 <= 42127,
              "Yi Radicals": (e1) => e1 >= 42128 && e1 <= 42191,
              "Hangul Jamo Extended-A": (e1) => e1 >= 43360 && e1 <= 43391,
              "Hangul Syllables": (e1) => e1 >= 44032 && e1 <= 55215,
              "Hangul Jamo Extended-B": (e1) => e1 >= 55216 && e1 <= 55295,
              "Private Use Area": (e1) => e1 >= 57344 && e1 <= 63743,
              "CJK Compatibility Ideographs": (e1) =>
                e1 >= 63744 && e1 <= 64255,
              "Arabic Presentation Forms-A": (e1) => e1 >= 64336 && e1 <= 65023,
              "Vertical Forms": (e1) => e1 >= 65040 && e1 <= 65055,
              "CJK Compatibility Forms": (e1) => e1 >= 65072 && e1 <= 65103,
              "Small Form Variants": (e1) => e1 >= 65104 && e1 <= 65135,
              "Arabic Presentation Forms-B": (e1) => e1 >= 65136 && e1 <= 65279,
              "Halfwidth and Fullwidth Forms": (e1) =>
                e1 >= 65280 && e1 <= 65519,
              "CJK Unified Ideographs Extension B": (e1) =>
                e1 >= 131072 && e1 <= 173791,
            };
            function Ls(e1) {
              for (const t of e1) if (Bs(t.charCodeAt(0))) return !0;
              return !1;
            }
            function ks(e1) {
              for (const t of e1) if (!Os(t.charCodeAt(0))) return !1;
              return !0;
            }
            function Os(e1) {
              return !(
                Rs.Arabic(e1) ||
                Rs["Arabic Supplement"](e1) ||
                Rs["Arabic Extended-A"](e1) ||
                Rs["Arabic Presentation Forms-A"](e1) ||
                Rs["Arabic Presentation Forms-B"](e1)
              );
            }
            function Bs(e1) {
              return !(
                746 !== e1 &&
                747 !== e1 &&
                (e1 < 4352 ||
                  !(
                    Rs["Bopomofo Extended"](e1) ||
                    Rs.Bopomofo(e1) ||
                    (Rs["CJK Compatibility Forms"](e1) &&
                      !(e1 >= 65097 && e1 <= 65103)) ||
                    Rs["CJK Compatibility Ideographs"](e1) ||
                    Rs["CJK Compatibility"](e1) ||
                    Rs["CJK Radicals Supplement"](e1) ||
                    Rs["CJK Strokes"](e1) ||
                    !(
                      !Rs["CJK Symbols and Punctuation"](e1) ||
                      (e1 >= 12296 && e1 <= 12305) ||
                      (e1 >= 12308 && e1 <= 12319) ||
                      12336 === e1
                    ) ||
                    Rs["CJK Unified Ideographs Extension A"](e1) ||
                    Rs["CJK Unified Ideographs"](e1) ||
                    Rs["Enclosed CJK Letters and Months"](e1) ||
                    Rs["Hangul Compatibility Jamo"](e1) ||
                    Rs["Hangul Jamo Extended-A"](e1) ||
                    Rs["Hangul Jamo Extended-B"](e1) ||
                    Rs["Hangul Jamo"](e1) ||
                    Rs["Hangul Syllables"](e1) ||
                    Rs.Hiragana(e1) ||
                    Rs["Ideographic Description Characters"](e1) ||
                    Rs.Kanbun(e1) ||
                    Rs["Kangxi Radicals"](e1) ||
                    Rs["Katakana Phonetic Extensions"](e1) ||
                    (Rs.Katakana(e1) && 12540 !== e1) ||
                    !(
                      !Rs["Halfwidth and Fullwidth Forms"](e1) ||
                      65288 === e1 ||
                      65289 === e1 ||
                      65293 === e1 ||
                      (e1 >= 65306 && e1 <= 65310) ||
                      65339 === e1 ||
                      65341 === e1 ||
                      65343 === e1 ||
                      (e1 >= 65371 && e1 <= 65503) ||
                      65507 === e1 ||
                      (e1 >= 65512 && e1 <= 65519)
                    ) ||
                    !(
                      !Rs["Small Form Variants"](e1) ||
                      (e1 >= 65112 && e1 <= 65118) ||
                      (e1 >= 65123 && e1 <= 65126)
                    ) ||
                    Rs["Unified Canadian Aboriginal Syllabics"](e1) ||
                    Rs["Unified Canadian Aboriginal Syllabics Extended"](e1) ||
                    Rs["Vertical Forms"](e1) ||
                    Rs["Yijing Hexagram Symbols"](e1) ||
                    Rs["Yi Syllables"](e1) ||
                    Rs["Yi Radicals"](e1)
                  ))
              );
            }
            function Fs(e1) {
              return !(
                Bs(e1) ||
                (function (e1) {
                  return !!(
                    (Rs["Latin-1 Supplement"](e1) &&
                      (167 === e1 ||
                        169 === e1 ||
                        174 === e1 ||
                        177 === e1 ||
                        188 === e1 ||
                        189 === e1 ||
                        190 === e1 ||
                        215 === e1 ||
                        247 === e1)) ||
                    (Rs["General Punctuation"](e1) &&
                      (8214 === e1 ||
                        8224 === e1 ||
                        8225 === e1 ||
                        8240 === e1 ||
                        8241 === e1 ||
                        8251 === e1 ||
                        8252 === e1 ||
                        8258 === e1 ||
                        8263 === e1 ||
                        8264 === e1 ||
                        8265 === e1 ||
                        8273 === e1)) ||
                    Rs["Letterlike Symbols"](e1) ||
                    Rs["Number Forms"](e1) ||
                    (Rs["Miscellaneous Technical"](e1) &&
                      ((e1 >= 8960 && e1 <= 8967) ||
                        (e1 >= 8972 && e1 <= 8991) ||
                        (e1 >= 8996 && e1 <= 9e3) ||
                        9003 === e1 ||
                        (e1 >= 9085 && e1 <= 9114) ||
                        (e1 >= 9150 && e1 <= 9165) ||
                        9167 === e1 ||
                        (e1 >= 9169 && e1 <= 9179) ||
                        (e1 >= 9186 && e1 <= 9215))) ||
                    (Rs["Control Pictures"](e1) && 9251 !== e1) ||
                    Rs["Optical Character Recognition"](e1) ||
                    Rs["Enclosed Alphanumerics"](e1) ||
                    Rs["Geometric Shapes"](e1) ||
                    (Rs["Miscellaneous Symbols"](e1) &&
                      !(e1 >= 9754 && e1 <= 9759)) ||
                    (Rs["Miscellaneous Symbols and Arrows"](e1) &&
                      ((e1 >= 11026 && e1 <= 11055) ||
                        (e1 >= 11088 && e1 <= 11097) ||
                        (e1 >= 11192 && e1 <= 11243))) ||
                    Rs["CJK Symbols and Punctuation"](e1) ||
                    Rs.Katakana(e1) ||
                    Rs["Private Use Area"](e1) ||
                    Rs["CJK Compatibility Forms"](e1) ||
                    Rs["Small Form Variants"](e1) ||
                    Rs["Halfwidth and Fullwidth Forms"](e1) ||
                    8734 === e1 ||
                    8756 === e1 ||
                    8757 === e1 ||
                    (e1 >= 9984 && e1 <= 10087) ||
                    (e1 >= 10102 && e1 <= 10131) ||
                    65532 === e1 ||
                    65533 === e1
                  );
                })(e1)
              );
            }
            function Ns(e1) {
              return (
                (e1 >= 1424 && e1 <= 2303) ||
                Rs["Arabic Presentation Forms-A"](e1) ||
                Rs["Arabic Presentation Forms-B"](e1)
              );
            }
            function Us(e1, t) {
              return !(
                (!t && Ns(e1)) ||
                (e1 >= 2304 && e1 <= 3583) ||
                (e1 >= 3840 && e1 <= 4255) ||
                Rs.Khmer(e1)
              );
            }
            function Vs(e1) {
              for (const t of e1) if (Ns(t.charCodeAt(0))) return !0;
              return !1;
            }
            const js = "deferred",
              Gs = "loading",
              qs = "loaded";
            let Zs = null,
              $s = "unavailable",
              Hs = null;
            const Ws = function (e1) {
              e1 &&
                "string" == typeof e1 &&
                e1.indexOf("NetworkError") > -1 &&
                ($s = "error"),
                Zs && Zs(e1);
            };
            function Xs() {
              Ys.fire(
                new At("pluginStateChange", {
                  pluginStatus: $s,
                  pluginURL: Hs,
                }),
              );
            }
            const Ys = new It(),
              Ks = function () {
                return $s;
              },
              Js = function () {
                if ($s !== js || !Hs)
                  throw new Error(
                    "rtl-text-plugin cannot be downloaded unless a pluginURL is specified",
                  );
                ($s = Gs),
                  Xs(),
                  Hs &&
                    Te(
                      {
                        url: Hs,
                      },
                      (e1) => {
                        e1 ? Ws(e1) : (($s = qs), Xs());
                      },
                    );
              },
              Qs = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => $s === qs || null != Qs.applyArabicShaping,
                isLoading: () => $s === Gs,
                setState(e1) {
                  ($s = e1.pluginStatus), (Hs = e1.pluginURL);
                },
                isParsed: () =>
                  null != Qs.applyArabicShaping &&
                  null != Qs.processBidirectionalText &&
                  null != Qs.processStyledBidirectionalText,
                getPluginURL: () => Hs,
              };
            class ea {
              constructor(e1, t) {
                (this.zoom = e1),
                  t
                    ? ((this.now = t.now),
                      (this.fadeDuration = t.fadeDuration),
                      (this.transition = t.transition),
                      (this.pitch = t.pitch),
                      (this.brightness = t.brightness))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.transition = {}),
                      (this.pitch = 0),
                      (this.brightness = 0));
              }
              isSupportedScript(e1) {
                return (function (e1, t) {
                  for (const i of e1) if (!Us(i.charCodeAt(0), t)) return !1;
                  return !0;
                })(e1, Qs.isLoaded());
              }
            }
            class ta {
              constructor(e1, t, i) {
                (this.property = e1),
                  (this.value = t),
                  (this.expression = (function (e1, t, i) {
                    if (lo(e1)) return new To(e1, t);
                    if (yo(e1) || (Array.isArray(e1) && e1.length > 0)) {
                      const r = wo(e1, t, i);
                      if ("error" === r.result)
                        throw new Error(
                          r.value
                            .map((e1) => `${e1.key}: ${e1.message}`)
                            .join(", "),
                        );
                      return r.value;
                    }
                    {
                      let i = e1;
                      return (
                        "string" == typeof e1 &&
                          "color" === t.type &&
                          (i = li.parse(e1)),
                        {
                          kind: "constant",
                          isConfigDependent: !1,
                          evaluate: () => i,
                        }
                      );
                    }
                  })(
                    void 0 === t ? e1.specification.default : t,
                    e1.specification,
                    i,
                  ));
              }
              isDataDriven() {
                return (
                  "source" === this.expression.kind ||
                  "composite" === this.expression.kind
                );
              }
              possiblyEvaluate(e1, t, i) {
                return this.property.possiblyEvaluate(this, e1, t, i);
              }
            }
            class ia {
              constructor(e1, t) {
                (this.property = e1), (this.value = new ta(e1, void 0, t));
              }
              transitioned(e1, t) {
                return new na(
                  this.property,
                  this.value,
                  t,
                  k({}, e1.transition, this.transition),
                  e1.now,
                );
              }
              untransitioned() {
                return new na(this.property, this.value, null, {}, 0);
              }
            }
            class ra {
              constructor(e1, t) {
                (this._properties = e1),
                  (this._values = Object.create(
                    e1.defaultTransitionablePropertyValues,
                  )),
                  (this._options = t),
                  (this.isConfigDependent = !1);
              }
              getValue(e1) {
                return $(this._values[e1].value.value);
              }
              setValue(e1, t) {
                this._values.hasOwnProperty(e1) ||
                  (this._values[e1] = new ia(
                    this._values[e1].property,
                    this._options,
                  )),
                  (this._values[e1].value = new ta(
                    this._values[e1].property,
                    null === t ? void 0 : $(t),
                    this._options,
                  )),
                  (this.isConfigDependent =
                    this.isConfigDependent ||
                    this._values[e1].value.expression.isConfigDependent);
              }
              setTransitionOrValue(e1, t) {
                t && (this._options = t);
                const i = this._properties.properties;
                if (e1)
                  for (const t in e1) {
                    const r = e1[t];
                    if (G(t, "-transition")) {
                      const e1 = t.slice(0, -11);
                      i[e1] && this.setTransition(e1, r);
                    } else i[t] && this.setValue(t, r);
                  }
              }
              getTransition(e1) {
                return $(this._values[e1].transition);
              }
              setTransition(e1, t) {
                this._values.hasOwnProperty(e1) ||
                  (this._values[e1] = new ia(this._values[e1].property)),
                  (this._values[e1].transition = $(t) || void 0);
              }
              serialize() {
                const e1 = {};
                for (const t of Object.keys(this._values)) {
                  const i = this.getValue(t);
                  void 0 !== i && (e1[t] = i);
                  const r = this.getTransition(t);
                  void 0 !== r && (e1[`${t}-transition`] = r);
                }
                return e1;
              }
              transitioned(e1, t) {
                const i = new oa(this._properties);
                for (const r of Object.keys(this._values))
                  i._values[r] = this._values[r].transitioned(e1, t._values[r]);
                return i;
              }
              untransitioned() {
                const e1 = new oa(this._properties);
                for (const t of Object.keys(this._values))
                  e1._values[t] = this._values[t].untransitioned();
                return e1;
              }
            }
            class na {
              constructor(e1, t, i, r, n) {
                const o = r.delay || 0,
                  s = r.duration || 0;
                (n = n || 0),
                  (this.property = e1),
                  (this.value = t),
                  (this.begin = n + o),
                  (this.end = this.begin + s),
                  e1.specification.transition &&
                    (r.delay || r.duration) &&
                    (this.prior = i);
              }
              possiblyEvaluate(e1, t, i) {
                const r = e1.now || 0,
                  n = this.value.possiblyEvaluate(e1, t, i),
                  o = this.prior;
                if (o) {
                  if (r > this.end) return (this.prior = null), n;
                  if (this.value.isDataDriven()) return (this.prior = null), n;
                  if (r < this.begin) return o.possiblyEvaluate(e1, t, i);
                  {
                    const s = (r - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      o.possiblyEvaluate(e1, t, i),
                      n,
                      M(s),
                    );
                  }
                }
                return n;
              }
            }
            class oa {
              constructor(e1) {
                (this._properties = e1),
                  (this._values = Object.create(
                    e1.defaultTransitioningPropertyValues,
                  ));
              }
              possiblyEvaluate(e1, t, i) {
                const r = new la(this._properties);
                for (const n of Object.keys(this._values))
                  r._values[n] = this._values[n].possiblyEvaluate(e1, t, i);
                return r;
              }
              hasTransition() {
                for (const e1 of Object.keys(this._values))
                  if (this._values[e1].prior) return !0;
                return !1;
              }
            }
            class sa {
              constructor(e1, t) {
                (this._properties = e1),
                  (this._values = Object.create(e1.defaultPropertyValues)),
                  (this._options = t),
                  (this.isConfigDependent = !1);
              }
              getValue(e1) {
                return $(this._values[e1].value);
              }
              setValue(e1, t) {
                (this._values[e1] = new ta(
                  this._values[e1].property,
                  null === t ? void 0 : $(t),
                  this._options,
                )),
                  (this.isConfigDependent =
                    this.isConfigDependent ||
                    this._values[e1].expression.isConfigDependent);
              }
              serialize() {
                const e1 = {};
                for (const t of Object.keys(this._values)) {
                  const i = this.getValue(t);
                  void 0 !== i && (e1[t] = i);
                }
                return e1;
              }
              possiblyEvaluate(e1, t, i) {
                const r = new la(this._properties);
                for (const n of Object.keys(this._values))
                  r._values[n] = this._values[n].possiblyEvaluate(e1, t, i);
                return r;
              }
            }
            class aa {
              constructor(e1, t, i) {
                (this.property = e1), (this.value = t), (this.parameters = i);
              }
              isConstant() {
                return "constant" === this.value.kind;
              }
              constantOr(e1) {
                return "constant" === this.value.kind ? this.value.value : e1;
              }
              evaluate(e1, t, i, r) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  e1,
                  t,
                  i,
                  r,
                );
              }
            }
            class la {
              constructor(e1) {
                (this._properties = e1),
                  (this._values = Object.create(
                    e1.defaultPossiblyEvaluatedValues,
                  ));
              }
              get(e1) {
                return this._values[e1];
              }
            }
            class ca {
              constructor(e1) {
                this.specification = e1;
              }
              possiblyEvaluate(e1, t) {
                return e1.expression.evaluate(t);
              }
              interpolate(e1, t, i) {
                const r = Yr[this.specification.type];
                return r ? r(e1, t, i) : e1;
              }
            }
            class ha {
              constructor(e1, t) {
                (this.specification = e1), (this.overrides = t);
              }
              possiblyEvaluate(e1, t, i, r) {
                return new aa(
                  this,
                  "constant" === e1.expression.kind ||
                  "camera" === e1.expression.kind
                    ? {
                        kind: "constant",
                        value: e1.expression.evaluate(t, null, {}, i, r),
                      }
                    : e1.expression,
                  t,
                );
              }
              interpolate(e1, t, i) {
                if ("constant" !== e1.value.kind || "constant" !== t.value.kind)
                  return e1;
                if (void 0 === e1.value.value || void 0 === t.value.value)
                  return new aa(
                    this,
                    {
                      kind: "constant",
                      value: void 0,
                    },
                    e1.parameters,
                  );
                const r = Yr[this.specification.type];
                return r
                  ? new aa(
                      this,
                      {
                        kind: "constant",
                        value: r(e1.value.value, t.value.value, i),
                      },
                      e1.parameters,
                    )
                  : e1;
              }
              evaluate(e1, t, i, r, n, o) {
                return "constant" === e1.kind
                  ? e1.value
                  : e1.evaluate(t, i, r, n, o);
              }
            }
            class ua {
              constructor(e1) {
                this.specification = e1;
              }
              possiblyEvaluate(e1, t, i, r) {
                return !!e1.expression.evaluate(t, null, {}, i, r);
              }
              interpolate() {
                return !1;
              }
            }
            class da {
              constructor(e1) {
                (this.properties = e1),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []);
                const t = new ea(0, {});
                for (const i in e1) {
                  const r = e1[i];
                  r.specification.overridable &&
                    this.overridableProperties.push(i);
                  const n = (this.defaultPropertyValues[i] = new ta(r, void 0)),
                    o = (this.defaultTransitionablePropertyValues[i] = new ia(
                      r,
                    ));
                  (this.defaultTransitioningPropertyValues[i] =
                    o.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[i] =
                      n.possiblyEvaluate(t));
                }
              }
            }
            function pa(e1, t) {
              return t ? `${e1}${t}` : e1;
            }
            function fa(e1) {
              const t = e1.indexOf("\x1f");
              return t >= 0 ? e1.slice(0, t) : e1;
            }
            Is(ha, "DataDrivenProperty"),
              Is(ca, "DataConstantProperty"),
              Is(ua, "ColorRampProperty");
            const ma = "-transition";
            class _a extends It {
              constructor(e1, t, i) {
                if (
                  (super(),
                  (this.id = e1.id),
                  (this.type = e1.type),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1,
                  }),
                  (this._filterCompiled = !1),
                  (this.isConfigDependent = !1),
                  "custom" !== e1.type &&
                    ((this.metadata = e1.metadata),
                    (this.minzoom = e1.minzoom),
                    (this.maxzoom = e1.maxzoom),
                    "background" !== e1.type &&
                      "sky" !== e1.type &&
                      "slot" !== e1.type &&
                      ((this.source = e1.source),
                      (this.sourceLayer = e1["source-layer"]),
                      (this.filter = e1.filter)),
                    (this.options = i),
                    e1.slot && (this.slot = e1.slot),
                    t.layout &&
                      ((this._unevaluatedLayout = new sa(t.layout, i)),
                      (this.isConfigDependent =
                        this.isConfigDependent ||
                        this._unevaluatedLayout.isConfigDependent)),
                    t.paint))
                ) {
                  this._transitionablePaint = new ra(t.paint, i);
                  for (const t in e1.paint)
                    this.setPaintProperty(t, e1.paint[t], {
                      validate: !1,
                    });
                  for (const t in e1.layout)
                    this.setLayoutProperty(t, e1.layout[t], {
                      validate: !1,
                    });
                  (this.isConfigDependent =
                    this.isConfigDependent ||
                    this._transitionablePaint.isConfigDependent),
                    (this._transitioningPaint =
                      this._transitionablePaint.untransitioned()),
                    (this.paint = new la(t.paint));
                }
              }
              setScope(e1) {
                (this.scope = e1), (this.fqid = pa(this.id, e1));
              }
              getLayoutProperty(e1) {
                return "visibility" === e1
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(e1);
              }
              setLayoutProperty(e1, t, i = {}) {
                if (
                  null != t &&
                  this._validate(xs, `layers.${this.id}.layout.${e1}`, e1, t, i)
                )
                  return;
                if ("custom" === this.type && "visibility" === e1)
                  return void (this.visibility = t);
                const r = this._unevaluatedLayout;
                r._properties.properties[e1] &&
                  (r.setValue(e1, t),
                  (this.isConfigDependent =
                    this.isConfigDependent || r.isConfigDependent),
                  "visibility" === e1 && this.possiblyEvaluateVisibility());
              }
              possiblyEvaluateVisibility() {
                this.visibility =
                  this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                    zoom: 0,
                  });
              }
              getPaintProperty(e1) {
                return G(e1, ma)
                  ? this._transitionablePaint.getTransition(e1.slice(0, -11))
                  : this._transitionablePaint.getValue(e1);
              }
              setPaintProperty(e1, t, i = {}) {
                if (
                  null != t &&
                  this._validate(ys, `layers.${this.id}.paint.${e1}`, e1, t, i)
                )
                  return !1;
                const r = this._transitionablePaint,
                  n = r._properties.properties;
                if (G(e1, ma)) {
                  const i = e1.slice(0, -11);
                  return n[i] && r.setTransition(i, t || void 0), !1;
                }
                if (!n[e1]) return !1;
                const o = r._values[e1],
                  s = o.value.isDataDriven(),
                  a = o.value;
                r.setValue(e1, t),
                  (this.isConfigDependent =
                    this.isConfigDependent || r.isConfigDependent),
                  this._handleSpecialPaintPropertyUpdate(e1);
                const l = r._values[e1].value,
                  c = l.isDataDriven(),
                  h = G(e1, "pattern") || "line-dasharray" === e1;
                return (
                  c ||
                  s ||
                  h ||
                  this._handleOverridablePaintPropertyUpdate(e1, a, l)
                );
              }
              _handleSpecialPaintPropertyUpdate(e1) {}
              getProgramIds() {
                return null;
              }
              getDefaultProgramParams(e1, t) {
                return null;
              }
              _handleOverridablePaintPropertyUpdate(e1, t, i) {
                return !1;
              }
              isHidden(e1) {
                return (
                  !!(this.minzoom && e1 < this.minzoom) ||
                  !!(this.maxzoom && e1 >= this.maxzoom) ||
                  "none" === this.visibility
                );
              }
              updateTransitions(e1) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    e1,
                    this._transitioningPaint,
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(e1, t) {
                this._unevaluatedLayout &&
                  (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                    e1,
                    void 0,
                    t,
                  )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    e1,
                    void 0,
                    t,
                  ));
              }
              serialize() {
                return Z(
                  {
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout:
                      this._unevaluatedLayout &&
                      this._unevaluatedLayout.serialize(),
                    paint:
                      this._transitionablePaint &&
                      this._transitionablePaint.serialize(),
                  },
                  (e1, t) =>
                    !(
                      void 0 === e1 ||
                      ("layout" === t && !Object.keys(e1).length) ||
                      ("paint" === t && !Object.keys(e1).length)
                    ),
                );
              }
              _validate(e1, t, i, r, n = {}) {
                return (
                  (!n || !1 !== n.validate) &&
                  ws(
                    this,
                    e1.call(hs, {
                      key: t,
                      layerType: this.type,
                      objectKey: i,
                      value: r,
                      styleSpec: Ct,
                      style: {
                        glyphs: !0,
                        sprite: !0,
                      },
                    }),
                  )
                );
              }
              is3D() {
                return !1;
              }
              isSky() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              hasShadowPass() {
                return !1;
              }
              canCastShadows() {
                return !1;
              }
              hasLightBeamPass() {
                return !1;
              }
              cutoffRange() {
                return 0;
              }
              resize() {}
              isStateDependent() {
                for (const e1 in this.paint._values) {
                  const t = this.paint.get(e1);
                  if (
                    t instanceof aa &&
                    no(t.property.specification) &&
                    ("source" === t.value.kind ||
                      "composite" === t.value.kind) &&
                    t.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
              compileFilter() {
                this._filterCompiled ||
                  ((this._featureFilter = Ro(this.filter)),
                  (this._filterCompiled = !0));
              }
              invalidateCompiledFilter() {
                this._filterCompiled = !1;
              }
              dynamicFilter() {
                return this._featureFilter.dynamicFilter;
              }
              dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
              }
            }
            class ga {
              constructor() {
                (this.changed = !1),
                  (this._updatedLayers = {}),
                  (this._removedLayers = {}),
                  (this.updatedSourceCaches = {}),
                  (this.updatedPaintProps = new Set()),
                  (this.changedImages = new Set());
              }
              updateLayer(e1) {
                const t = e1.scope;
                (this._updatedLayers[t] = this._updatedLayers[t] || new Set()),
                  this._updatedLayers[t].add(e1.id);
              }
              removeLayer(e1) {
                const t = e1.scope;
                (this._removedLayers[t] = this._removedLayers[t] || {}),
                  (this._updatedLayers[t] =
                    this._updatedLayers[t] || new Set()),
                  (this._removedLayers[t][e1.id] = e1),
                  this._updatedLayers[t].delete(e1.id),
                  this.updatedPaintProps.delete(e1.fqid);
              }
              getRemovedLayer(e1) {
                return this._removedLayers[e1.scope]
                  ? this._removedLayers[e1.scope][e1.id]
                  : null;
              }
              discardLayerRemoval(e1) {
                this._removedLayers[e1.scope] &&
                  delete this._removedLayers[e1.scope][e1.id];
              }
              getLayerUpdatesByScope() {
                const e1 = {};
                for (const t in this._updatedLayers)
                  (e1[t] = e1[t] || {}),
                    (e1[t].updatedIds = Array.from(
                      this._updatedLayers[t].values(),
                    ));
                for (const t in this._removedLayers)
                  (e1[t] = e1[t] || {}),
                    (e1[t].removedIds = Object.keys(this._removedLayers[t]));
                return e1;
              }
              reset() {
                (this.changed = !1),
                  (this._updatedLayers = {}),
                  (this._removedLayers = {}),
                  (this.updatedSourceCaches = {}),
                  this.updatedPaintProps.clear(),
                  this.changedImages.clear();
              }
            }
            const ya = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class xa {
              constructor(e1, t) {
                (this._structArray = e1),
                  (this._pos1 = t * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8);
              }
            }
            class va {
              constructor() {
                (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
              }
              static serialize(e1, t) {
                return (
                  e1._trim(),
                  t && ((e1.isTransferred = !0), t.add(e1.arrayBuffer)),
                  {
                    length: e1.length,
                    arrayBuffer: e1.arrayBuffer,
                  }
                );
              }
              static deserialize(e1) {
                const t = Object.create(this.prototype);
                return (
                  (t.arrayBuffer = e1.arrayBuffer),
                  (t.length = e1.length),
                  (t.capacity = e1.arrayBuffer.byteLength / t.bytesPerElement),
                  t._refreshViews(),
                  t
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement,
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(e1) {
                this.reserve(e1), (this.length = e1);
              }
              reserve(e1) {
                if (e1 > this.capacity) {
                  (this.capacity = Math.max(
                    e1,
                    Math.floor(5 * this.capacity),
                    128,
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement,
                    ));
                  const t = this.uint8;
                  this._refreshViews(), t && this.uint8.set(t);
                }
              }
              _refreshViews() {
                throw new Error(
                  "_refreshViews() must be implemented by each concrete StructArray layout",
                );
              }
              destroy() {
                (this.int8 =
                  this.uint8 =
                  this.int16 =
                  this.uint16 =
                  this.int32 =
                  this.uint32 =
                  this.float32 =
                    null),
                  (this.arrayBuffer = null);
              }
            }
            function ba(e1, t = 1) {
              let i = 0,
                r = 0;
              return {
                members: e1.map((e1) => {
                  const n = ya[e1.type].BYTES_PER_ELEMENT,
                    o = (i = wa(i, Math.max(t, n))),
                    s = e1.components || 1;
                  return (
                    (r = Math.max(r, n)),
                    (i += n * s),
                    {
                      name: e1.name,
                      type: e1.type,
                      components: s,
                      offset: o,
                    }
                  );
                }),
                size: wa(i, Math.max(r, t)),
                alignment: t,
              };
            }
            function wa(e1, t) {
              return Math.ceil(e1 / t) * t;
            }
            class Ta extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, e1, t);
              }
              emplace(e1, t, i) {
                const r = 2 * e1;
                return (this.int16[r + 0] = t), (this.int16[r + 1] = i), e1;
              }
            }
            (Ta.prototype.bytesPerElement = 4), Is(Ta, "StructArrayLayout2i4");
            class Ea extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, e1, t, i);
              }
              emplace(e1, t, i, r) {
                const n = 3 * e1;
                return (
                  (this.int16[n + 0] = t),
                  (this.int16[n + 1] = i),
                  (this.int16[n + 2] = r),
                  e1
                );
              }
            }
            (Ea.prototype.bytesPerElement = 6), Is(Ea, "StructArrayLayout3i6");
            class Ma extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, e1, t, i, r);
              }
              emplace(e1, t, i, r, n) {
                const o = 4 * e1;
                return (
                  (this.int16[o + 0] = t),
                  (this.int16[o + 1] = i),
                  (this.int16[o + 2] = r),
                  (this.int16[o + 3] = n),
                  e1
                );
              }
            }
            (Ma.prototype.bytesPerElement = 8), Is(Ma, "StructArrayLayout4i8");
            class Aa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, e1, t, i, r, n);
              }
              emplace(e1, t, i, r, n, o) {
                const s = 5 * e1;
                return (
                  (this.int16[s + 0] = t),
                  (this.int16[s + 1] = i),
                  (this.int16[s + 2] = r),
                  (this.int16[s + 3] = n),
                  (this.int16[s + 4] = o),
                  e1
                );
              }
            }
            (Aa.prototype.bytesPerElement = 10),
              Is(Aa, "StructArrayLayout5i10");
            class Sa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s) {
                const a = this.length;
                return (
                  this.resize(a + 1), this.emplace(a, e1, t, i, r, n, o, s)
                );
              }
              emplace(e1, t, i, r, n, o, s, a) {
                const l = 6 * e1,
                  c = 12 * e1,
                  h = 3 * e1;
                return (
                  (this.int16[l + 0] = t),
                  (this.int16[l + 1] = i),
                  (this.uint8[c + 4] = r),
                  (this.uint8[c + 5] = n),
                  (this.uint8[c + 6] = o),
                  (this.uint8[c + 7] = s),
                  (this.float32[h + 2] = a),
                  e1
                );
              }
            }
            (Sa.prototype.bytesPerElement = 12),
              Is(Sa, "StructArrayLayout2i4ub1f12");
            class Ia extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, e1, t, i, r);
              }
              emplace(e1, t, i, r, n) {
                const o = 4 * e1;
                return (
                  (this.float32[o + 0] = t),
                  (this.float32[o + 1] = i),
                  (this.float32[o + 2] = r),
                  (this.float32[o + 3] = n),
                  e1
                );
              }
            }
            (Ia.prototype.bytesPerElement = 16),
              Is(Ia, "StructArrayLayout4f16");
            class Ca extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, e1, t, i, r, n);
              }
              emplace(e1, t, i, r, n, o) {
                const s = 6 * e1,
                  a = 3 * e1;
                return (
                  (this.uint16[s + 0] = t),
                  (this.uint16[s + 1] = i),
                  (this.uint16[s + 2] = r),
                  (this.uint16[s + 3] = n),
                  (this.float32[a + 2] = o),
                  e1
                );
              }
            }
            (Ca.prototype.bytesPerElement = 12),
              Is(Ca, "StructArrayLayout4ui1f12");
            class za extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, e1, t, i, r);
              }
              emplace(e1, t, i, r, n) {
                const o = 4 * e1;
                return (
                  (this.uint16[o + 0] = t),
                  (this.uint16[o + 1] = i),
                  (this.uint16[o + 2] = r),
                  (this.uint16[o + 3] = n),
                  e1
                );
              }
            }
            (za.prototype.bytesPerElement = 8), Is(za, "StructArrayLayout4ui8");
            class Da extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, e1, t, i, r, n, o);
              }
              emplace(e1, t, i, r, n, o, s) {
                const a = 6 * e1;
                return (
                  (this.int16[a + 0] = t),
                  (this.int16[a + 1] = i),
                  (this.int16[a + 2] = r),
                  (this.int16[a + 3] = n),
                  (this.int16[a + 4] = o),
                  (this.int16[a + 5] = s),
                  e1
                );
              }
            }
            (Da.prototype.bytesPerElement = 12),
              Is(Da, "StructArrayLayout6i12");
            class Pa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s, a, l, c, h, u) {
                const d = this.length;
                return (
                  this.resize(d + 1),
                  this.emplace(d, e1, t, i, r, n, o, s, a, l, c, h, u)
                );
              }
              emplace(e1, t, i, r, n, o, s, a, l, c, h, u, d) {
                const p = 12 * e1;
                return (
                  (this.int16[p + 0] = t),
                  (this.int16[p + 1] = i),
                  (this.int16[p + 2] = r),
                  (this.int16[p + 3] = n),
                  (this.uint16[p + 4] = o),
                  (this.uint16[p + 5] = s),
                  (this.uint16[p + 6] = a),
                  (this.uint16[p + 7] = l),
                  (this.int16[p + 8] = c),
                  (this.int16[p + 9] = h),
                  (this.int16[p + 10] = u),
                  (this.int16[p + 11] = d),
                  e1
                );
              }
            }
            (Pa.prototype.bytesPerElement = 24),
              Is(Pa, "StructArrayLayout4i4ui4i24");
            class Ra extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, e1, t, i, r, n, o);
              }
              emplace(e1, t, i, r, n, o, s) {
                const a = 10 * e1,
                  l = 5 * e1;
                return (
                  (this.int16[a + 0] = t),
                  (this.int16[a + 1] = i),
                  (this.int16[a + 2] = r),
                  (this.float32[l + 2] = n),
                  (this.float32[l + 3] = o),
                  (this.float32[l + 4] = s),
                  e1
                );
              }
            }
            (Ra.prototype.bytesPerElement = 20),
              Is(Ra, "StructArrayLayout3i3f20");
            class La extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(e1) {
                const t = this.length;
                return this.resize(t + 1), this.emplace(t, e1);
              }
              emplace(e1, t) {
                return (this.uint32[1 * e1 + 0] = t), e1;
              }
            }
            (La.prototype.bytesPerElement = 4), Is(La, "StructArrayLayout1ul4");
            class ka extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, e1, t);
              }
              emplace(e1, t, i) {
                const r = 2 * e1;
                return (this.uint16[r + 0] = t), (this.uint16[r + 1] = i), e1;
              }
            }
            (ka.prototype.bytesPerElement = 4), Is(ka, "StructArrayLayout2ui4");
            class Oa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s, a, l, c, h, u, d) {
                const p = this.length;
                return (
                  this.resize(p + 1),
                  this.emplace(p, e1, t, i, r, n, o, s, a, l, c, h, u, d)
                );
              }
              emplace(e1, t, i, r, n, o, s, a, l, c, h, u, d, p) {
                const f = 20 * e1,
                  m = 10 * e1;
                return (
                  (this.int16[f + 0] = t),
                  (this.int16[f + 1] = i),
                  (this.int16[f + 2] = r),
                  (this.int16[f + 3] = n),
                  (this.int16[f + 4] = o),
                  (this.float32[m + 3] = s),
                  (this.float32[m + 4] = a),
                  (this.float32[m + 5] = l),
                  (this.float32[m + 6] = c),
                  (this.int16[f + 14] = h),
                  (this.uint32[m + 8] = u),
                  (this.uint16[f + 18] = d),
                  (this.uint16[f + 19] = p),
                  e1
                );
              }
            }
            (Oa.prototype.bytesPerElement = 40),
              Is(Oa, "StructArrayLayout5i4f1i1ul2ui40");
            class Ba extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s) {
                const a = this.length;
                return (
                  this.resize(a + 1), this.emplace(a, e1, t, i, r, n, o, s)
                );
              }
              emplace(e1, t, i, r, n, o, s, a) {
                const l = 8 * e1;
                return (
                  (this.int16[l + 0] = t),
                  (this.int16[l + 1] = i),
                  (this.int16[l + 2] = r),
                  (this.int16[l + 4] = n),
                  (this.int16[l + 5] = o),
                  (this.int16[l + 6] = s),
                  (this.int16[l + 7] = a),
                  e1
                );
              }
            }
            (Ba.prototype.bytesPerElement = 16),
              Is(Ba, "StructArrayLayout3i2i2i16");
            class Fa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, e1, t, i, r, n);
              }
              emplace(e1, t, i, r, n, o) {
                const s = 4 * e1,
                  a = 8 * e1;
                return (
                  (this.float32[s + 0] = t),
                  (this.float32[s + 1] = i),
                  (this.float32[s + 2] = r),
                  (this.int16[a + 6] = n),
                  (this.int16[a + 7] = o),
                  e1
                );
              }
            }
            (Fa.prototype.bytesPerElement = 16),
              Is(Fa, "StructArrayLayout2f1f2i16");
            class Na extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, e1, t, i, r);
              }
              emplace(e1, t, i, r, n) {
                const o = 12 * e1,
                  s = 3 * e1;
                return (
                  (this.uint8[o + 0] = t),
                  (this.uint8[o + 1] = i),
                  (this.float32[s + 1] = r),
                  (this.float32[s + 2] = n),
                  e1
                );
              }
            }
            (Na.prototype.bytesPerElement = 12),
              Is(Na, "StructArrayLayout2ub2f12");
            class Ua extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, e1, t, i);
              }
              emplace(e1, t, i, r) {
                const n = 3 * e1;
                return (
                  (this.float32[n + 0] = t),
                  (this.float32[n + 1] = i),
                  (this.float32[n + 2] = r),
                  e1
                );
              }
            }
            (Ua.prototype.bytesPerElement = 12),
              Is(Ua, "StructArrayLayout3f12");
            class Va extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, e1, t, i);
              }
              emplace(e1, t, i, r) {
                const n = 3 * e1;
                return (
                  (this.uint16[n + 0] = t),
                  (this.uint16[n + 1] = i),
                  (this.uint16[n + 2] = r),
                  e1
                );
              }
            }
            (Va.prototype.bytesPerElement = 6), Is(Va, "StructArrayLayout3ui6");
            class ja extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
                y,
                x,
                v,
              ) {
                const b = this.length;
                return (
                  this.resize(b + 1),
                  this.emplace(
                    b,
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                    s,
                    a,
                    l,
                    c,
                    h,
                    u,
                    d,
                    p,
                    f,
                    m,
                    _,
                    g,
                    y,
                    x,
                    v,
                  )
                );
              }
              emplace(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
                y,
                x,
                v,
                b,
              ) {
                const w = 30 * e1,
                  T = 15 * e1,
                  E = 60 * e1;
                return (
                  (this.int16[w + 0] = t),
                  (this.int16[w + 1] = i),
                  (this.int16[w + 2] = r),
                  (this.float32[T + 2] = n),
                  (this.float32[T + 3] = o),
                  (this.uint16[w + 8] = s),
                  (this.uint16[w + 9] = a),
                  (this.uint32[T + 5] = l),
                  (this.uint32[T + 6] = c),
                  (this.uint32[T + 7] = h),
                  (this.uint16[w + 16] = u),
                  (this.uint16[w + 17] = d),
                  (this.uint16[w + 18] = p),
                  (this.float32[T + 10] = f),
                  (this.float32[T + 11] = m),
                  (this.uint8[E + 48] = _),
                  (this.uint8[E + 49] = g),
                  (this.uint8[E + 50] = y),
                  (this.uint32[T + 13] = x),
                  (this.int16[w + 28] = v),
                  (this.uint8[E + 58] = b),
                  e1
                );
              }
            }
            (ja.prototype.bytesPerElement = 60),
              Is(ja, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
            class Ga extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
                y,
                x,
                v,
                b,
                w,
                T,
                E,
                M,
                A,
                S,
                I,
                C,
                z,
                D,
              ) {
                const P = this.length;
                return (
                  this.resize(P + 1),
                  this.emplace(
                    P,
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                    s,
                    a,
                    l,
                    c,
                    h,
                    u,
                    d,
                    p,
                    f,
                    m,
                    _,
                    g,
                    y,
                    x,
                    v,
                    b,
                    w,
                    T,
                    E,
                    M,
                    A,
                    S,
                    I,
                    C,
                    z,
                    D,
                  )
                );
              }
              emplace(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
                y,
                x,
                v,
                b,
                w,
                T,
                E,
                M,
                A,
                S,
                I,
                C,
                z,
                D,
                P,
              ) {
                const R = 20 * e1,
                  L = 40 * e1,
                  k = 80 * e1;
                return (
                  (this.float32[R + 0] = t),
                  (this.float32[R + 1] = i),
                  (this.int16[L + 4] = r),
                  (this.int16[L + 5] = n),
                  (this.int16[L + 6] = o),
                  (this.int16[L + 7] = s),
                  (this.int16[L + 8] = a),
                  (this.int16[L + 9] = l),
                  (this.int16[L + 10] = c),
                  (this.int16[L + 11] = h),
                  (this.int16[L + 12] = u),
                  (this.uint16[L + 13] = d),
                  (this.uint16[L + 14] = p),
                  (this.uint16[L + 15] = f),
                  (this.uint16[L + 16] = m),
                  (this.uint16[L + 17] = _),
                  (this.uint16[L + 18] = g),
                  (this.uint16[L + 19] = y),
                  (this.uint16[L + 20] = x),
                  (this.uint16[L + 21] = v),
                  (this.uint16[L + 22] = b),
                  (this.uint16[L + 23] = w),
                  (this.uint16[L + 24] = T),
                  (this.uint16[L + 25] = E),
                  (this.uint16[L + 26] = M),
                  (this.uint16[L + 27] = A),
                  (this.uint32[R + 14] = S),
                  (this.float32[R + 15] = I),
                  (this.float32[R + 16] = C),
                  (this.float32[R + 17] = z),
                  (this.float32[R + 18] = D),
                  (this.uint8[k + 76] = P),
                  e1
                );
              }
            }
            (Ga.prototype.bytesPerElement = 80),
              Is(Ga, "StructArrayLayout2f9i15ui1ul4f1ub80");
            class qa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1) {
                const t = this.length;
                return this.resize(t + 1), this.emplace(t, e1);
              }
              emplace(e1, t) {
                return (this.float32[1 * e1 + 0] = t), e1;
              }
            }
            (qa.prototype.bytesPerElement = 4), Is(qa, "StructArrayLayout1f4");
            class Za extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, e1, t, i, r, n);
              }
              emplace(e1, t, i, r, n, o) {
                const s = 5 * e1;
                return (
                  (this.float32[s + 0] = t),
                  (this.float32[s + 1] = i),
                  (this.float32[s + 2] = r),
                  (this.float32[s + 3] = n),
                  (this.float32[s + 4] = o),
                  e1
                );
              }
            }
            (Za.prototype.bytesPerElement = 20),
              Is(Za, "StructArrayLayout5f20");
            class $a extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s) {
                const a = this.length;
                return (
                  this.resize(a + 1), this.emplace(a, e1, t, i, r, n, o, s)
                );
              }
              emplace(e1, t, i, r, n, o, s, a) {
                const l = 7 * e1;
                return (
                  (this.float32[l + 0] = t),
                  (this.float32[l + 1] = i),
                  (this.float32[l + 2] = r),
                  (this.float32[l + 3] = n),
                  (this.float32[l + 4] = o),
                  (this.float32[l + 5] = s),
                  (this.float32[l + 6] = a),
                  e1
                );
              }
            }
            ($a.prototype.bytesPerElement = 28),
              Is($a, "StructArrayLayout7f28");
            class Ha extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, e1, t, i, r);
              }
              emplace(e1, t, i, r, n) {
                const o = 6 * e1;
                return (
                  (this.uint32[3 * e1 + 0] = t),
                  (this.uint16[o + 2] = i),
                  (this.uint16[o + 3] = r),
                  (this.uint16[o + 4] = n),
                  e1
                );
              }
            }
            (Ha.prototype.bytesPerElement = 12),
              Is(Ha, "StructArrayLayout1ul3ui12");
            class Wa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(e1) {
                const t = this.length;
                return this.resize(t + 1), this.emplace(t, e1);
              }
              emplace(e1, t) {
                return (this.uint16[1 * e1 + 0] = t), e1;
              }
            }
            (Wa.prototype.bytesPerElement = 2), Is(Wa, "StructArrayLayout1ui2");
            class Xa extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, e1, t);
              }
              emplace(e1, t, i) {
                const r = 2 * e1;
                return (this.float32[r + 0] = t), (this.float32[r + 1] = i), e1;
              }
            }
            (Xa.prototype.bytesPerElement = 8), Is(Xa, "StructArrayLayout2f8");
            class Ya extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m) {
                const _ = this.length;
                return (
                  this.resize(_ + 1),
                  this.emplace(
                    _,
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                    s,
                    a,
                    l,
                    c,
                    h,
                    u,
                    d,
                    p,
                    f,
                    m,
                  )
                );
              }
              emplace(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m, _) {
                const g = 16 * e1;
                return (
                  (this.float32[g + 0] = t),
                  (this.float32[g + 1] = i),
                  (this.float32[g + 2] = r),
                  (this.float32[g + 3] = n),
                  (this.float32[g + 4] = o),
                  (this.float32[g + 5] = s),
                  (this.float32[g + 6] = a),
                  (this.float32[g + 7] = l),
                  (this.float32[g + 8] = c),
                  (this.float32[g + 9] = h),
                  (this.float32[g + 10] = u),
                  (this.float32[g + 11] = d),
                  (this.float32[g + 12] = p),
                  (this.float32[g + 13] = f),
                  (this.float32[g + 14] = m),
                  (this.float32[g + 15] = _),
                  e1
                );
              }
            }
            (Ya.prototype.bytesPerElement = 64),
              Is(Ya, "StructArrayLayout16f64");
            class Ka extends va {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(e1, t, i, r, n, o, s) {
                const a = this.length;
                return (
                  this.resize(a + 1), this.emplace(a, e1, t, i, r, n, o, s)
                );
              }
              emplace(e1, t, i, r, n, o, s, a) {
                const l = 10 * e1,
                  c = 5 * e1;
                return (
                  (this.uint16[l + 0] = t),
                  (this.uint16[l + 1] = i),
                  (this.uint16[l + 2] = r),
                  (this.uint16[l + 3] = n),
                  (this.float32[c + 2] = o),
                  (this.float32[c + 3] = s),
                  (this.float32[c + 4] = a),
                  e1
                );
              }
            }
            (Ka.prototype.bytesPerElement = 20),
              Is(Ka, "StructArrayLayout4ui3f20");
            class Ja extends va {
              _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
              }
              emplaceBack(e1) {
                const t = this.length;
                return this.resize(t + 1), this.emplace(t, e1);
              }
              emplace(e1, t) {
                return (this.uint8[1 * e1 + 0] = t), e1;
              }
            }
            (Ja.prototype.bytesPerElement = 1), Is(Ja, "StructArrayLayout1ub1");
            class Qa extends xa {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get x1() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get y1() {
                return this._structArray.float32[this._pos4 + 4];
              }
              get x2() {
                return this._structArray.float32[this._pos4 + 5];
              }
              get y2() {
                return this._structArray.float32[this._pos4 + 6];
              }
              get padding() {
                return this._structArray.int16[this._pos2 + 14];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
            }
            Qa.prototype.size = 40;
            class el extends Oa {
              get(e1) {
                return new Qa(this, e1);
              }
            }
            Is(el, "CollisionBoxArray");
            class tl extends xa {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
              }
              set placedOrientation(e1) {
                this._structArray.uint8[this._pos1 + 49] = e1;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
              }
              set hidden(e1) {
                this._structArray.uint8[this._pos1 + 50] = e1;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
              }
              set crossTileID(e1) {
                this._structArray.uint32[this._pos4 + 13] = e1;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
              }
              get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
              }
              set flipState(e1) {
                this._structArray.uint8[this._pos1 + 58] = e1;
              }
            }
            tl.prototype.size = 60;
            class il extends ja {
              get(e1) {
                return new tl(this, e1);
              }
            }
            Is(il, "PlacedSymbolArray");
            class rl extends xa {
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 13];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
              }
              set crossTileID(e1) {
                this._structArray.uint32[this._pos4 + 14] = e1;
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
              }
              get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
              }
              set zOffset(e1) {
                this._structArray.float32[this._pos4 + 18] = e1;
              }
              get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 76];
              }
            }
            rl.prototype.size = 80;
            class nl extends Ga {
              get(e1) {
                return new rl(this, e1);
              }
            }
            Is(nl, "SymbolInstanceArray");
            class ol extends qa {
              getoffsetX(e1) {
                return this.float32[1 * e1 + 0];
              }
            }
            Is(ol, "GlyphOffsetArray");
            class sl extends Ta {
              getx(e1) {
                return this.int16[2 * e1 + 0];
              }
              gety(e1) {
                return this.int16[2 * e1 + 1];
              }
            }
            Is(sl, "SymbolLineVertexArray");
            class al extends xa {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
              }
            }
            al.prototype.size = 12;
            class ll extends Ha {
              get(e1) {
                return new al(this, e1);
              }
            }
            Is(ll, "FeatureIndexArray");
            class cl extends ka {
              geta_centroid_pos0(e1) {
                return this.uint16[2 * e1 + 0];
              }
              geta_centroid_pos1(e1) {
                return this.uint16[2 * e1 + 1];
              }
            }
            Is(cl, "FillExtrusionCentroidArray");
            const hl = ba(
                [
                  {
                    name: "a_pos",
                    components: 2,
                    type: "Int16",
                  },
                ],
                4,
              ),
              ul = ba([
                {
                  name: "a_pos_3",
                  components: 3,
                  type: "Int16",
                },
                {
                  name: "a_pos_normal_3",
                  components: 3,
                  type: "Int16",
                },
              ]);
            class dl {
              constructor(e1 = []) {
                this.segments = e1;
              }
              _prepareSegment(e1, t, i, r) {
                let n = this.segments[this.segments.length - 1];
                return (
                  e1 > dl.MAX_VERTEX_ARRAY_LENGTH &&
                    W(
                      `Max vertices per segment is ${dl.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e1}`,
                    ),
                  (!n ||
                    n.vertexLength + e1 > dl.MAX_VERTEX_ARRAY_LENGTH ||
                    n.sortKey !== r) &&
                    ((n = {
                      vertexOffset: t,
                      primitiveOffset: i,
                      vertexLength: 0,
                      primitiveLength: 0,
                    }),
                    void 0 !== r && (n.sortKey = r),
                    this.segments.push(n)),
                  n
                );
              }
              prepareSegment(e1, t, i, r) {
                return this._prepareSegment(e1, t.length, i.length, r);
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const e1 of this.segments)
                  for (const t in e1.vaos) e1.vaos[t].destroy();
              }
              static simpleSegment(e1, t, i, r) {
                return new dl([
                  {
                    vertexOffset: e1,
                    primitiveOffset: t,
                    vertexLength: i,
                    primitiveLength: r,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            function pl(e1, t) {
              return (
                256 * (e1 = z(Math.floor(e1), 0, 255)) +
                z(Math.floor(t), 0, 255)
              );
            }
            (dl.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              Is(dl, "SegmentVector");
            const fl = ba([
                {
                  name: "a_pattern",
                  components: 4,
                  type: "Uint16",
                },
                {
                  name: "a_pixel_ratio",
                  components: 1,
                  type: "Float32",
                },
              ]),
              ml = ba([
                {
                  name: "a_dash",
                  components: 4,
                  type: "Uint16",
                },
              ]);
            var _l = {
                exports: {},
              },
              gl = {
                exports: {},
              };
            !(function (e1) {
              e1.exports = function (e1, t) {
                var i, r, n, o, s, a, l, c;
                for (
                  r = e1.length - (i = 3 & e1.length),
                    n = t,
                    s = 3432918353,
                    a = 461845907,
                    c = 0;
                  c < r;

                )
                  (l =
                    (255 & e1.charCodeAt(c)) |
                    ((255 & e1.charCodeAt(++c)) << 8) |
                    ((255 & e1.charCodeAt(++c)) << 16) |
                    ((255 & e1.charCodeAt(++c)) << 24)),
                    ++c,
                    (n =
                      27492 +
                      (65535 &
                        (o =
                          (5 *
                            (65535 &
                              (n =
                                ((n ^= l =
                                  ((65535 &
                                    (l =
                                      ((l =
                                        ((65535 & l) * s +
                                          ((((l >>> 16) * s) & 65535) << 16)) &
                                        4294967295) <<
                                        15) |
                                      (l >>> 17))) *
                                    a +
                                    ((((l >>> 16) * a) & 65535) << 16)) &
                                  4294967295) <<
                                  13) |
                                (n >>> 19))) +
                            (((5 * (n >>> 16)) & 65535) << 16)) &
                          4294967295)) +
                      (((58964 + (o >>> 16)) & 65535) << 16));
                switch (((l = 0), i)) {
                  case 3:
                    l ^= (255 & e1.charCodeAt(c + 2)) << 16;
                  case 2:
                    l ^= (255 & e1.charCodeAt(c + 1)) << 8;
                  case 1:
                    n ^= l =
                      ((65535 &
                        (l =
                          ((l =
                            ((65535 & (l ^= 255 & e1.charCodeAt(c))) * s +
                              ((((l >>> 16) * s) & 65535) << 16)) &
                            4294967295) <<
                            15) |
                          (l >>> 17))) *
                        a +
                        ((((l >>> 16) * a) & 65535) << 16)) &
                      4294967295;
                }
                return (
                  (n ^= e1.length),
                  (n =
                    (2246822507 * (65535 & (n ^= n >>> 16)) +
                      (((2246822507 * (n >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (n =
                    (3266489909 * (65535 & (n ^= n >>> 13)) +
                      (((3266489909 * (n >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (n ^= n >>> 16) >>> 0
                );
              };
            })(gl);
            var yl = gl.exports,
              xl = {
                exports: {},
              };
            !(function (e1) {
              e1.exports = function (e1, t) {
                for (var i, r = e1.length, n = t ^ r, o = 0; r >= 4; )
                  (i =
                    1540483477 *
                      (65535 &
                        (i =
                          (255 & e1.charCodeAt(o)) |
                          ((255 & e1.charCodeAt(++o)) << 8) |
                          ((255 & e1.charCodeAt(++o)) << 16) |
                          ((255 & e1.charCodeAt(++o)) << 24))) +
                    (((1540483477 * (i >>> 16)) & 65535) << 16)),
                    (n =
                      (1540483477 * (65535 & n) +
                        (((1540483477 * (n >>> 16)) & 65535) << 16)) ^
                      (i =
                        1540483477 * (65535 & (i ^= i >>> 24)) +
                        (((1540483477 * (i >>> 16)) & 65535) << 16))),
                    (r -= 4),
                    ++o;
                switch (r) {
                  case 3:
                    n ^= (255 & e1.charCodeAt(o + 2)) << 16;
                  case 2:
                    n ^= (255 & e1.charCodeAt(o + 1)) << 8;
                  case 1:
                    n =
                      1540483477 * (65535 & (n ^= 255 & e1.charCodeAt(o))) +
                      (((1540483477 * (n >>> 16)) & 65535) << 16);
                }
                return (
                  (n =
                    1540483477 * (65535 & (n ^= n >>> 13)) +
                    (((1540483477 * (n >>> 16)) & 65535) << 16)),
                  (n ^= n >>> 15) >>> 0
                );
              };
            })(xl);
            var vl = yl,
              bl = xl.exports;
            (_l.exports = vl),
              (_l.exports.murmur3 = vl),
              (_l.exports.murmur2 = bl);
            var wl = d(_l.exports);
            class Tl {
              constructor() {
                (this.ids = []),
                  (this.uniqueIds = []),
                  (this.positions = []),
                  (this.indexed = !1);
              }
              add(e1, t, i, r) {
                this.ids.push(El(e1)), this.positions.push(t, i, r);
              }
              eachPosition(e1, t) {
                const i = El(e1);
                let r = 0,
                  n = this.ids.length - 1;
                for (; r < n; ) {
                  const e1 = (r + n) >> 1;
                  this.ids[e1] >= i ? (n = e1) : (r = e1 + 1);
                }
                for (; this.ids[r] === i; )
                  t(
                    this.positions[3 * r],
                    this.positions[3 * r + 1],
                    this.positions[3 * r + 2],
                  ),
                    r++;
              }
              static serialize(e1, t) {
                const i = new Float64Array(e1.ids),
                  r = new Uint32Array(e1.positions);
                return (
                  Ml(i, r, 0, i.length - 1),
                  t && (t.add(i.buffer), t.add(r.buffer)),
                  {
                    ids: i,
                    positions: r,
                  }
                );
              }
              static deserialize(e1) {
                const t = new Tl();
                let i;
                (t.ids = e1.ids), (t.positions = e1.positions);
                for (const e1 of t.ids)
                  e1 !== i && t.uniqueIds.push(e1), (i = e1);
                return (t.indexed = !0), t;
              }
            }
            function El(e1) {
              const t = +e1;
              return !isNaN(t) &&
                Number.MIN_SAFE_INTEGER <= t &&
                t <= Number.MAX_SAFE_INTEGER
                ? t
                : wl(String(e1));
            }
            function Ml(e1, t, i, r) {
              for (; i < r; ) {
                const n = e1[(i + r) >> 1];
                let o = i - 1,
                  s = r + 1;
                for (;;) {
                  do o++;
                  while (e1[o] < n);
                  do s--;
                  while (e1[s] > n);
                  if (o >= s) break;
                  Al(e1, o, s),
                    Al(t, 3 * o, 3 * s),
                    Al(t, 3 * o + 1, 3 * s + 1),
                    Al(t, 3 * o + 2, 3 * s + 2);
                }
                s - i < r - s
                  ? (Ml(e1, t, i, s), (i = s + 1))
                  : (Ml(e1, t, s + 1, r), (r = s));
              }
            }
            function Al(e1, t, i) {
              const r = e1[t];
              (e1[t] = e1[i]), (e1[i] = r);
            }
            Is(Tl, "FeaturePositionMap");
            class Sl {
              constructor(e1) {
                (this.gl = e1.gl), (this.initialized = !1);
              }
              fetchUniformLocation(e1, t) {
                return (
                  this.location ||
                    this.initialized ||
                    ((this.location = this.gl.getUniformLocation(e1, t)),
                    (this.initialized = !0)),
                  !!this.location
                );
              }
            }
            class Il extends Sl {
              constructor(e1) {
                super(e1), (this.current = 0);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  this.current !== i &&
                  ((this.current = i), this.gl.uniform1i(this.location, i));
              }
            }
            class Cl extends Sl {
              constructor(e1) {
                super(e1), (this.current = 0);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  this.current !== i &&
                  ((this.current = i), this.gl.uniform1f(this.location, i));
              }
            }
            class zl extends Sl {
              constructor(e1) {
                super(e1), (this.current = [0, 0]);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  ((i[0] === this.current[0] && i[1] === this.current[1]) ||
                    ((this.current = i),
                    this.gl.uniform2f(this.location, i[0], i[1])));
              }
            }
            class Dl extends Sl {
              constructor(e1) {
                super(e1), (this.current = [0, 0, 0]);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  ((i[0] === this.current[0] &&
                    i[1] === this.current[1] &&
                    i[2] === this.current[2]) ||
                    ((this.current = i),
                    this.gl.uniform3f(this.location, i[0], i[1], i[2])));
              }
            }
            class Pl extends Sl {
              constructor(e1) {
                super(e1), (this.current = [0, 0, 0, 0]);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  ((i[0] === this.current[0] &&
                    i[1] === this.current[1] &&
                    i[2] === this.current[2] &&
                    i[3] === this.current[3]) ||
                    ((this.current = i),
                    this.gl.uniform4f(this.location, i[0], i[1], i[2], i[3])));
              }
            }
            class Rl extends Sl {
              constructor(e1) {
                super(e1), (this.current = li.transparent);
              }
              set(e1, t, i) {
                this.fetchUniformLocation(e1, t) &&
                  ((i.r === this.current.r &&
                    i.g === this.current.g &&
                    i.b === this.current.b &&
                    i.a === this.current.a) ||
                    ((this.current = i),
                    this.gl.uniform4f(this.location, i.r, i.g, i.b, i.a)));
              }
            }
            const Ll = new Float32Array(16);
            class kl extends Sl {
              constructor(e1) {
                super(e1), (this.current = Ll);
              }
              set(e1, t, i) {
                if (this.fetchUniformLocation(e1, t)) {
                  if (i[12] !== this.current[12] || i[0] !== this.current[0])
                    return (
                      (this.current = i),
                      void this.gl.uniformMatrix4fv(this.location, !1, i)
                    );
                  for (let e1 = 1; e1 < 16; e1++)
                    if (i[e1] !== this.current[e1]) {
                      (this.current = i),
                        this.gl.uniformMatrix4fv(this.location, !1, i);
                      break;
                    }
                }
              }
            }
            const Ol = new Float32Array(9);
            class Bl extends Sl {
              constructor(e1) {
                super(e1), (this.current = Ol);
              }
              set(e1, t, i) {
                if (this.fetchUniformLocation(e1, t)) {
                  for (let e1 = 0; e1 < 9; e1++)
                    if (i[e1] !== this.current[e1]) {
                      (this.current = i),
                        this.gl.uniformMatrix3fv(this.location, !1, i);
                      break;
                    }
                }
              }
            }
            const Fl = new Float32Array(4);
            class Nl extends Sl {
              constructor(e1) {
                super(e1), (this.current = Fl);
              }
              set(e1, t, i) {
                if (this.fetchUniformLocation(e1, t)) {
                  for (let e1 = 0; e1 < 4; e1++)
                    if (i[e1] !== this.current[e1]) {
                      (this.current = i),
                        this.gl.uniformMatrix2fv(this.location, !1, i);
                      break;
                    }
                }
              }
            }
            function Ul(e1) {
              return [pl(255 * e1.r, 255 * e1.g), pl(255 * e1.b, 255 * e1.a)];
            }
            class Vl {
              constructor(e1, t, i) {
                (this.value = e1),
                  (this.uniformNames = t.map((e1) => `u_${e1}`)),
                  (this.type = i);
              }
              setUniform(e1, t, i, r, n) {
                t.set(e1, n, r.constantOr(this.value));
              }
              getBinding(e1, t) {
                return "color" === this.type ? new Rl(e1) : new Cl(e1);
              }
            }
            class jl {
              constructor(e1, t) {
                (this.uniformNames = t.map((e1) => `u_${e1}`)),
                  (this.pattern = null),
                  (this.pixelRatio = 1);
              }
              setConstantPatternPositions(e1) {
                (this.pixelRatio = e1.pixelRatio || 1),
                  (this.pattern = e1.tl.concat(e1.br));
              }
              setUniform(e1, t, i, r, n) {
                const o =
                  "u_pattern" === n || "u_dash" === n
                    ? this.pattern
                    : "u_pixel_ratio" === n
                    ? this.pixelRatio
                    : null;
                o && t.set(e1, n, o);
              }
              getBinding(e1, t) {
                return "u_pattern" === t || "u_dash" === t
                  ? new Pl(e1)
                  : new Cl(e1);
              }
            }
            class Gl {
              constructor(e1, t, i, r) {
                (this.expression = e1),
                  (this.type = i),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = t.map((e1) => ({
                    name: `a_${e1}`,
                    type: "Float32",
                    components: "color" === i ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new r());
              }
              populatePaintArray(e1, t, i, r, n, o, s) {
                const a = this.paintVertexArray.length,
                  l = this.expression.evaluate(
                    new ea(0, {
                      brightness: o,
                    }),
                    t,
                    {},
                    n,
                    r,
                    s,
                  );
                this.paintVertexArray.resize(e1), this._setPaintValue(a, e1, l);
              }
              updatePaintArray(e1, t, i, r, n, o, s) {
                const a = this.expression.evaluate(
                  {
                    zoom: 0,
                    brightness: s,
                  },
                  i,
                  r,
                  void 0,
                  n,
                );
                this._setPaintValue(e1, t, a);
              }
              _setPaintValue(e1, t, i) {
                if ("color" === this.type) {
                  const r = Ul(i);
                  for (let i = e1; i < t; i++)
                    this.paintVertexArray.emplace(i, r[0], r[1]);
                } else {
                  for (let r = e1; r < t; r++)
                    this.paintVertexArray.emplace(r, i);
                  this.maxValue = Math.max(this.maxValue, Math.abs(i));
                }
              }
              upload(e1) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = e1.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent ||
                          !this.expression.isLightConstant,
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class ql {
              constructor(e1, t, i, r, n, o) {
                (this.expression = e1),
                  (this.uniformNames = t.map((e1) => `u_${e1}_t`)),
                  (this.type = i),
                  (this.useIntegerZoom = r),
                  (this.zoom = n),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = t.map((e1) => ({
                    name: `a_${e1}`,
                    type: "Float32",
                    components: "color" === i ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new o());
              }
              populatePaintArray(e1, t, i, r, n, o, s) {
                const a = this.expression.evaluate(
                    new ea(this.zoom, {
                      brightness: o,
                    }),
                    t,
                    {},
                    n,
                    r,
                    s,
                  ),
                  l = this.expression.evaluate(
                    new ea(this.zoom + 1, {
                      brightness: o,
                    }),
                    t,
                    {},
                    n,
                    r,
                    s,
                  ),
                  c = this.paintVertexArray.length;
                this.paintVertexArray.resize(e1),
                  this._setPaintValue(c, e1, a, l);
              }
              updatePaintArray(e1, t, i, r, n, o, s) {
                const a = this.expression.evaluate(
                    {
                      zoom: this.zoom,
                      brightness: s,
                    },
                    i,
                    r,
                    void 0,
                    n,
                  ),
                  l = this.expression.evaluate(
                    {
                      zoom: this.zoom + 1,
                      brightness: s,
                    },
                    i,
                    r,
                    void 0,
                    n,
                  );
                this._setPaintValue(e1, t, a, l);
              }
              _setPaintValue(e1, t, i, r) {
                if ("color" === this.type) {
                  const n = Ul(i),
                    o = Ul(r);
                  for (let i = e1; i < t; i++)
                    this.paintVertexArray.emplace(i, n[0], n[1], o[0], o[1]);
                } else {
                  for (let n = e1; n < t; n++)
                    this.paintVertexArray.emplace(n, i, r);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(i),
                    Math.abs(r),
                  );
                }
              }
              upload(e1) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = e1.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent ||
                          !this.expression.isLightConstant,
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(e1, t, i, r, n) {
                const o = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom,
                  s = z(
                    this.expression.interpolationFactor(
                      o,
                      this.zoom,
                      this.zoom + 1,
                    ),
                    0,
                    1,
                  );
                t.set(e1, n, s);
              }
              getBinding(e1, t) {
                return new Cl(e1);
              }
            }
            class Zl {
              constructor(e1, t, i, r, n) {
                (this.expression = e1),
                  (this.layerId = n),
                  (this.paintVertexAttributes = (
                    "array" === i ? ml : fl
                  ).members);
                for (let e1 = 0; e1 < t.length; ++e1);
                this.paintVertexArray = new r();
              }
              populatePaintArray(e1, t, i) {
                const r = this.paintVertexArray.length;
                this.paintVertexArray.resize(e1),
                  this._setPaintValues(
                    r,
                    e1,
                    t.patterns && t.patterns[this.layerId],
                    i,
                  );
              }
              updatePaintArray(e1, t, i, r, n, o, s) {
                this._setPaintValues(
                  e1,
                  t,
                  i.patterns && i.patterns[this.layerId],
                  o,
                );
              }
              _setPaintValues(e1, t, i, r) {
                if (!r || !i) return;
                const n = r[i];
                if (!n) return;
                const { tl: o, br: s, pixelRatio: a } = n;
                for (let i = e1; i < t; i++)
                  this.paintVertexArray.emplace(i, o[0], o[1], s[0], s[1], a);
              }
              upload(e1) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer = e1.createVertexBuffer(
                    this.paintVertexArray,
                    this.paintVertexAttributes,
                    this.expression.isStateDependent ||
                      !this.expression.isLightConstant,
                  ));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class $l {
              constructor(e1, t, i = () => !0) {
                (this.binders = {}), (this._buffers = []);
                const r = [];
                for (const n in e1.paint._values) {
                  const o = e1.paint.get(n);
                  if (!i(n)) continue;
                  if (!(o instanceof aa && no(o.property.specification)))
                    continue;
                  const s = Xl(n, e1.type),
                    a = o.value,
                    l = o.property.specification.type,
                    c = !!o.property.useIntegerZoom,
                    h = "line-dasharray" === n || n.endsWith("pattern"),
                    u =
                      "line-dasharray" === n &&
                      "constant" !== e1.layout.get("line-cap").value.kind;
                  if ("constant" !== a.kind || u) {
                    if ("source" === a.kind || u || h) {
                      const t = Jl(n, l, "source");
                      (this.binders[n] = h
                        ? new Zl(a, s, l, t, e1.id)
                        : new Gl(a, s, l, t)),
                        r.push(`/a_${n}`);
                    } else {
                      const e1 = Jl(n, l, "composite");
                      (this.binders[n] = new ql(a, s, l, c, t, e1)),
                        r.push(`/z_${n}`);
                    }
                  } else
                    (this.binders[n] = h
                      ? new jl(a.value, s)
                      : new Vl(a.value, s, l)),
                      r.push(`/u_${n}`);
                }
                this.cacheKey = r.sort().join("");
              }
              getMaxValue(e1) {
                const t = this.binders[e1];
                return t instanceof Gl || t instanceof ql ? t.maxValue : 0;
              }
              populatePaintArrays(e1, t, i, r, n, o, s) {
                for (const a in this.binders) {
                  const l = this.binders[a];
                  (l instanceof Gl || l instanceof ql || l instanceof Zl) &&
                    l.populatePaintArray(e1, t, i, r, n, o, s);
                }
              }
              setConstantPatternPositions(e1) {
                for (const t in this.binders) {
                  const i = this.binders[t];
                  i instanceof jl && i.setConstantPatternPositions(e1);
                }
              }
              updatePaintArrays(e1, t, i, r, n, o, s, a) {
                let l = !1;
                const c = Object.keys(e1),
                  h = 0 !== c.length,
                  u = h ? c : t.uniqueIds;
                for (const c in this.binders) {
                  const d = this.binders[c];
                  if (
                    (d instanceof Gl || d instanceof ql || d instanceof Zl) &&
                    (!0 === d.expression.isStateDependent ||
                      !1 === d.expression.isLightConstant)
                  ) {
                    const p = n.paint.get(c);
                    d.expression = p.value;
                    for (const i of u) {
                      const n = e1[i.toString()];
                      t.eachPosition(i, (e1, t, i) => {
                        const l = r.feature(e1);
                        d.updatePaintArray(t, i, l, n, o, s, a);
                      });
                    }
                    if (!h)
                      for (const t of i.uniqueIds) {
                        const n = e1[t.toString()];
                        i.eachPosition(t, (e1, t, i) => {
                          const l = r.feature(e1);
                          d.updatePaintArray(t, i, l, n, o, s, a);
                        });
                      }
                    l = !0;
                  }
                }
                return l;
              }
              defines() {
                const e1 = [];
                for (const t in this.binders) {
                  const i = this.binders[t];
                  (i instanceof Vl || i instanceof jl) &&
                    e1.push(
                      ...i.uniformNames.map(
                        (e1) => `#define HAS_UNIFORM_${e1}`,
                      ),
                    );
                }
                return e1;
              }
              getBinderAttributes() {
                const e1 = [];
                for (const t in this.binders) {
                  const i = this.binders[t];
                  if (i instanceof Gl || i instanceof ql || i instanceof Zl)
                    for (let t = 0; t < i.paintVertexAttributes.length; t++)
                      e1.push(i.paintVertexAttributes[t].name);
                }
                return e1;
              }
              getBinderUniforms() {
                const e1 = [];
                for (const t in this.binders) {
                  const i = this.binders[t];
                  if (i instanceof Vl || i instanceof jl || i instanceof ql)
                    for (const t of i.uniformNames) e1.push(t);
                }
                return e1;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(e1) {
                const t = [];
                for (const i in this.binders) {
                  const r = this.binders[i];
                  if (r instanceof Vl || r instanceof jl || r instanceof ql)
                    for (const n of r.uniformNames)
                      t.push({
                        name: n,
                        property: i,
                        binding: r.getBinding(e1, n),
                      });
                }
                return t;
              }
              setUniforms(e1, t, i, r, n) {
                for (const { name: t, property: o, binding: s } of i)
                  this.binders[o].setUniform(e1, s, n, r.get(o), t);
              }
              updatePaintBuffers() {
                this._buffers = [];
                for (const e1 in this.binders) {
                  const t = this.binders[e1];
                  (t instanceof Gl || t instanceof ql || t instanceof Zl) &&
                    t.paintVertexBuffer &&
                    this._buffers.push(t.paintVertexBuffer);
                }
              }
              upload(e1) {
                for (const t in this.binders) {
                  const i = this.binders[t];
                  (i instanceof Gl || i instanceof ql || i instanceof Zl) &&
                    i.upload(e1);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const e1 in this.binders) {
                  const t = this.binders[e1];
                  (t instanceof Gl || t instanceof ql || t instanceof Zl) &&
                    t.destroy();
                }
              }
            }
            class Hl {
              constructor(e1, t, i = () => !0) {
                this.programConfigurations = {};
                for (const r of e1)
                  this.programConfigurations[r.id] = new $l(r, t, i);
                (this.needsUpload = !1),
                  (this._featureMap = new Tl()),
                  (this._featureMapWithoutIds = new Tl()),
                  (this._bufferOffset = 0),
                  (this._idlessCounter = 0);
              }
              populatePaintArrays(e1, t, i, r, n, o, s, a) {
                for (const i in this.programConfigurations)
                  this.programConfigurations[i].populatePaintArrays(
                    e1,
                    t,
                    r,
                    n,
                    o,
                    s,
                    a,
                  );
                void 0 !== t.id
                  ? this._featureMap.add(t.id, i, this._bufferOffset, e1)
                  : (this._featureMapWithoutIds.add(
                      this._idlessCounter,
                      i,
                      this._bufferOffset,
                      e1,
                    ),
                    (this._idlessCounter += 1)),
                  (this._bufferOffset = e1),
                  (this.needsUpload = !0);
              }
              updatePaintArrays(e1, t, i, r, n, o) {
                for (const s of i)
                  this.needsUpload =
                    this.programConfigurations[s.id].updatePaintArrays(
                      e1,
                      this._featureMap,
                      this._featureMapWithoutIds,
                      t,
                      s,
                      r,
                      n,
                      o || 0,
                    ) || this.needsUpload;
              }
              get(e1) {
                return this.programConfigurations[e1];
              }
              upload(e1) {
                if (this.needsUpload) {
                  for (const t in this.programConfigurations)
                    this.programConfigurations[t].upload(e1);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const e1 in this.programConfigurations)
                  this.programConfigurations[e1].destroy();
              }
            }
            const Wl = {
              "text-opacity": ["opacity"],
              "icon-opacity": ["opacity"],
              "text-color": ["fill_color"],
              "icon-color": ["fill_color"],
              "text-emissive-strength": ["emissive_strength"],
              "icon-emissive-strength": ["emissive_strength"],
              "text-halo-color": ["halo_color"],
              "icon-halo-color": ["halo_color"],
              "text-halo-blur": ["halo_blur"],
              "icon-halo-blur": ["halo_blur"],
              "text-halo-width": ["halo_width"],
              "icon-halo-width": ["halo_width"],
              "line-gap-width": ["gapwidth"],
              "line-pattern": ["pattern", "pixel_ratio"],
              "fill-pattern": ["pattern", "pixel_ratio"],
              "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
              "line-dasharray": ["dash"],
            };
            function Xl(e1, t) {
              return Wl[e1] || [e1.replace(`${t}-`, "").replace(/-/g, "_")];
            }
            const Yl = {
                "line-pattern": {
                  source: Ca,
                  composite: Ca,
                },
                "fill-pattern": {
                  source: Ca,
                  composite: Ca,
                },
                "fill-extrusion-pattern": {
                  source: Ca,
                  composite: Ca,
                },
                "line-dasharray": {
                  source: za,
                  composite: za,
                },
              },
              Kl = {
                color: {
                  source: Xa,
                  composite: Ia,
                },
                number: {
                  source: qa,
                  composite: Xa,
                },
              };
            function Jl(e1, t, i) {
              const r = Yl[e1];
              return (r && r[i]) || Kl[t][i];
            }
            Is(Vl, "ConstantBinder"),
              Is(jl, "PatternConstantBinder"),
              Is(Gl, "SourceExpressionBinder"),
              Is(Zl, "PatternCompositeBinder"),
              Is(ql, "CompositeExpressionBinder"),
              Is($l, "ProgramConfiguration", {
                omit: ["_buffers"],
              }),
              Is(Hl, "ProgramConfigurationSet");
            class Ql {
              constructor(e1, t) {
                e1 &&
                  (t
                    ? this.setSouthWest(e1).setNorthEast(t)
                    : 4 === e1.length
                    ? this.setSouthWest([e1[0], e1[1]]).setNorthEast([
                        e1[2],
                        e1[3],
                      ])
                    : this.setSouthWest(e1[0]).setNorthEast(e1[1]));
              }
              setNorthEast(e1) {
                return (
                  (this._ne =
                    e1 instanceof Nd ? new Nd(e1.lng, e1.lat) : Nd.convert(e1)),
                  this
                );
              }
              setSouthWest(e1) {
                return (
                  (this._sw =
                    e1 instanceof Nd ? new Nd(e1.lng, e1.lat) : Nd.convert(e1)),
                  this
                );
              }
              extend(e1) {
                const t = this._sw,
                  i = this._ne;
                let r, n;
                if (e1 instanceof Nd) (r = e1), (n = e1);
                else {
                  if (!(e1 instanceof Ql))
                    return Array.isArray(e1)
                      ? 4 === e1.length || e1.every(Array.isArray)
                        ? this.extend(Ql.convert(e1))
                        : this.extend(Nd.convert(e1))
                      : "object" == typeof e1 &&
                        null !== e1 &&
                        e1.hasOwnProperty("lat") &&
                        (e1.hasOwnProperty("lon") || e1.hasOwnProperty("lng"))
                      ? this.extend(Nd.convert(e1))
                      : this;
                  if (((r = e1._sw), (n = e1._ne), !r || !n)) return this;
                }
                return (
                  t || i
                    ? ((t.lng = Math.min(r.lng, t.lng)),
                      (t.lat = Math.min(r.lat, t.lat)),
                      (i.lng = Math.max(n.lng, i.lng)),
                      (i.lat = Math.max(n.lat, i.lat)))
                    : ((this._sw = new Nd(r.lng, r.lat)),
                      (this._ne = new Nd(n.lng, n.lat))),
                  this
                );
              }
              getCenter() {
                return new Nd(
                  (this._sw.lng + this._ne.lng) / 2,
                  (this._sw.lat + this._ne.lat) / 2,
                );
              }
              getSouthWest() {
                return this._sw;
              }
              getNorthEast() {
                return this._ne;
              }
              getNorthWest() {
                return new Nd(this.getWest(), this.getNorth());
              }
              getSouthEast() {
                return new Nd(this.getEast(), this.getSouth());
              }
              getWest() {
                return this._sw.lng;
              }
              getSouth() {
                return this._sw.lat;
              }
              getEast() {
                return this._ne.lng;
              }
              getNorth() {
                return this._ne.lat;
              }
              toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
              }
              toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
              }
              isEmpty() {
                return !(this._sw && this._ne);
              }
              contains(e1) {
                const { lng: t, lat: i } = Nd.convert(e1);
                let r = this._sw.lng <= t && t <= this._ne.lng;
                return (
                  this._sw.lng > this._ne.lng &&
                    (r = this._sw.lng >= t && t >= this._ne.lng),
                  this._sw.lat <= i && i <= this._ne.lat && r
                );
              }
              static convert(e1) {
                return !e1 || e1 instanceof Ql ? e1 : new Ql(e1);
              }
            }
            var ec = {},
              tc = {};
            Object.defineProperty(tc, "__esModule", {
              value: !0,
            }),
              (tc.setMatrixArrayType = function (e1) {
                tc.ARRAY_TYPE = rc = e1;
              }),
              (tc.toRadian = function (e1) {
                return e1 * oc;
              }),
              (tc.equals = function (e1, t) {
                return (
                  Math.abs(e1 - t) <=
                  ic * Math.max(1, Math.abs(e1), Math.abs(t))
                );
              }),
              (tc.RANDOM = tc.ARRAY_TYPE = tc.EPSILON = void 0);
            var ic = 1e-6;
            tc.EPSILON = ic;
            var rc = "undefined" != typeof Float32Array ? Float32Array : Array;
            tc.ARRAY_TYPE = rc;
            var nc = Math.random;
            tc.RANDOM = nc;
            var oc = Math.PI / 180;
            Math.hypot ||
              (Math.hypot = function () {
                for (var e1 = 0, t = arguments.length; t--; )
                  e1 += arguments[t] * arguments[t];
                return Math.sqrt(e1);
              });
            var sc = {};
            function ac(e1) {
              return (
                (ac =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                ac(e1)
              );
            }
            Object.defineProperty(sc, "__esModule", {
              value: !0,
            }),
              (sc.create = function () {
                var e1 = new lc.ARRAY_TYPE(4);
                return (
                  lc.ARRAY_TYPE != Float32Array && ((e1[1] = 0), (e1[2] = 0)),
                  (e1[0] = 1),
                  (e1[3] = 1),
                  e1
                );
              }),
              (sc.clone = function (e1) {
                var t = new lc.ARRAY_TYPE(4);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  t
                );
              }),
              (sc.copy = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  e1
                );
              }),
              (sc.identity = function (e1) {
                return (e1[0] = 1), (e1[1] = 0), (e1[2] = 0), (e1[3] = 1), e1;
              }),
              (sc.fromValues = function (e1, t, i, r) {
                var n = new lc.ARRAY_TYPE(4);
                return (n[0] = e1), (n[1] = t), (n[2] = i), (n[3] = r), n;
              }),
              (sc.set = function (e1, t, i, r, n) {
                return (e1[0] = t), (e1[1] = i), (e1[2] = r), (e1[3] = n), e1;
              }),
              (sc.transpose = function (e1, t) {
                if (e1 === t) {
                  var i = t[1];
                  (e1[1] = t[2]), (e1[2] = i);
                } else
                  (e1[0] = t[0]),
                    (e1[1] = t[2]),
                    (e1[2] = t[1]),
                    (e1[3] = t[3]);
                return e1;
              }),
              (sc.invert = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i * o - n * r;
                return s
                  ? ((e1[0] = o * (s = 1 / s)),
                    (e1[1] = -r * s),
                    (e1[2] = -n * s),
                    (e1[3] = i * s),
                    e1)
                  : null;
              }),
              (sc.adjoint = function (e1, t) {
                var i = t[0];
                return (
                  (e1[0] = t[3]),
                  (e1[1] = -t[1]),
                  (e1[2] = -t[2]),
                  (e1[3] = i),
                  e1
                );
              }),
              (sc.determinant = function (e1) {
                return e1[0] * e1[3] - e1[2] * e1[1];
              }),
              (sc.multiply = hc),
              (sc.rotate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (e1[0] = r * l + o * a),
                  (e1[1] = n * l + s * a),
                  (e1[2] = r * -a + o * l),
                  (e1[3] = n * -a + s * l),
                  e1
                );
              }),
              (sc.scale = function (e1, t, i) {
                var r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i[0],
                  a = i[1];
                return (
                  (e1[0] = t[0] * s),
                  (e1[1] = r * s),
                  (e1[2] = n * a),
                  (e1[3] = o * a),
                  e1
                );
              }),
              (sc.fromRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (e1[0] = r), (e1[1] = i), (e1[2] = -i), (e1[3] = r), e1;
              }),
              (sc.fromScaling = function (e1, t) {
                return (
                  (e1[0] = t[0]), (e1[1] = 0), (e1[2] = 0), (e1[3] = t[1]), e1
                );
              }),
              (sc.str = function (e1) {
                return (
                  "mat2(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ")"
                );
              }),
              (sc.frob = function (e1) {
                return Math.hypot(e1[0], e1[1], e1[2], e1[3]);
              }),
              (sc.LDU = function (e1, t, i, r) {
                return (
                  (e1[2] = r[2] / r[0]),
                  (i[0] = r[0]),
                  (i[1] = r[1]),
                  (i[3] = r[3] - e1[2] * i[1]),
                  [e1, t, i]
                );
              }),
              (sc.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  e1
                );
              }),
              (sc.subtract = uc),
              (sc.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3]
                );
              }),
              (sc.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = t[0],
                  a = t[1],
                  l = t[2],
                  c = t[3];
                return (
                  Math.abs(i - s) <=
                    lc.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) &&
                  Math.abs(r - a) <=
                    lc.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) &&
                  Math.abs(n - l) <=
                    lc.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) &&
                  Math.abs(o - c) <=
                    lc.EPSILON * Math.max(1, Math.abs(o), Math.abs(c))
                );
              }),
              (sc.multiplyScalar = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  e1
                );
              }),
              (sc.multiplyScalarAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  (e1[3] = t[3] + i[3] * r),
                  e1
                );
              }),
              (sc.sub = sc.mul = void 0);
            var lc = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== ac(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = cc(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function cc(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (cc = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function hc(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = i[0],
                l = i[1],
                c = i[2],
                h = i[3];
              return (
                (e1[0] = r * a + o * l),
                (e1[1] = n * a + s * l),
                (e1[2] = r * c + o * h),
                (e1[3] = n * c + s * h),
                e1
              );
            }
            function uc(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                (e1[3] = t[3] - i[3]),
                e1
              );
            }
            (sc.mul = hc), (sc.sub = uc);
            var dc = {};
            function pc(e1) {
              return (
                (pc =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                pc(e1)
              );
            }
            Object.defineProperty(dc, "__esModule", {
              value: !0,
            }),
              (dc.create = function () {
                var e1 = new fc.ARRAY_TYPE(6);
                return (
                  fc.ARRAY_TYPE != Float32Array &&
                    ((e1[1] = 0), (e1[2] = 0), (e1[4] = 0), (e1[5] = 0)),
                  (e1[0] = 1),
                  (e1[3] = 1),
                  e1
                );
              }),
              (dc.clone = function (e1) {
                var t = new fc.ARRAY_TYPE(6);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  (t[4] = e1[4]),
                  (t[5] = e1[5]),
                  t
                );
              }),
              (dc.copy = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  (e1[4] = t[4]),
                  (e1[5] = t[5]),
                  e1
                );
              }),
              (dc.identity = function (e1) {
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 1),
                  (e1[4] = 0),
                  (e1[5] = 0),
                  e1
                );
              }),
              (dc.fromValues = function (e1, t, i, r, n, o) {
                var s = new fc.ARRAY_TYPE(6);
                return (
                  (s[0] = e1),
                  (s[1] = t),
                  (s[2] = i),
                  (s[3] = r),
                  (s[4] = n),
                  (s[5] = o),
                  s
                );
              }),
              (dc.set = function (e1, t, i, r, n, o, s) {
                return (
                  (e1[0] = t),
                  (e1[1] = i),
                  (e1[2] = r),
                  (e1[3] = n),
                  (e1[4] = o),
                  (e1[5] = s),
                  e1
                );
              }),
              (dc.invert = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = i * o - r * n;
                return l
                  ? ((e1[0] = o * (l = 1 / l)),
                    (e1[1] = -r * l),
                    (e1[2] = -n * l),
                    (e1[3] = i * l),
                    (e1[4] = (n * a - o * s) * l),
                    (e1[5] = (r * s - i * a) * l),
                    e1)
                  : null;
              }),
              (dc.determinant = function (e1) {
                return e1[0] * e1[3] - e1[1] * e1[2];
              }),
              (dc.multiply = _c),
              (dc.rotate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = Math.sin(i),
                  h = Math.cos(i);
                return (
                  (e1[0] = r * h + o * c),
                  (e1[1] = n * h + s * c),
                  (e1[2] = r * -c + o * h),
                  (e1[3] = n * -c + s * h),
                  (e1[4] = a),
                  (e1[5] = l),
                  e1
                );
              }),
              (dc.scale = function (e1, t, i) {
                var r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = i[0],
                  c = i[1];
                return (
                  (e1[0] = t[0] * l),
                  (e1[1] = r * l),
                  (e1[2] = n * c),
                  (e1[3] = o * c),
                  (e1[4] = s),
                  (e1[5] = a),
                  e1
                );
              }),
              (dc.translate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = i[0],
                  h = i[1];
                return (
                  (e1[0] = r),
                  (e1[1] = n),
                  (e1[2] = o),
                  (e1[3] = s),
                  (e1[4] = r * c + o * h + a),
                  (e1[5] = n * c + s * h + l),
                  e1
                );
              }),
              (dc.fromRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (
                  (e1[0] = r),
                  (e1[1] = i),
                  (e1[2] = -i),
                  (e1[3] = r),
                  (e1[4] = 0),
                  (e1[5] = 0),
                  e1
                );
              }),
              (dc.fromScaling = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = t[1]),
                  (e1[4] = 0),
                  (e1[5] = 0),
                  e1
                );
              }),
              (dc.fromTranslation = function (e1, t) {
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 1),
                  (e1[4] = t[0]),
                  (e1[5] = t[1]),
                  e1
                );
              }),
              (dc.str = function (e1) {
                return (
                  "mat2d(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ", " +
                  e1[4] +
                  ", " +
                  e1[5] +
                  ")"
                );
              }),
              (dc.frob = function (e1) {
                return Math.hypot(e1[0], e1[1], e1[2], e1[3], e1[4], e1[5], 1);
              }),
              (dc.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  (e1[4] = t[4] + i[4]),
                  (e1[5] = t[5] + i[5]),
                  e1
                );
              }),
              (dc.subtract = gc),
              (dc.multiplyScalar = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  (e1[4] = t[4] * i),
                  (e1[5] = t[5] * i),
                  e1
                );
              }),
              (dc.multiplyScalarAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  (e1[3] = t[3] + i[3] * r),
                  (e1[4] = t[4] + i[4] * r),
                  (e1[5] = t[5] + i[5] * r),
                  e1
                );
              }),
              (dc.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3] &&
                  e1[4] === t[4] &&
                  e1[5] === t[5]
                );
              }),
              (dc.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = e1[4],
                  a = e1[5],
                  l = t[0],
                  c = t[1],
                  h = t[2],
                  u = t[3],
                  d = t[4],
                  p = t[5];
                return (
                  Math.abs(i - l) <=
                    fc.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) &&
                  Math.abs(r - c) <=
                    fc.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) &&
                  Math.abs(n - h) <=
                    fc.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) &&
                  Math.abs(o - u) <=
                    fc.EPSILON * Math.max(1, Math.abs(o), Math.abs(u)) &&
                  Math.abs(s - d) <=
                    fc.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) &&
                  Math.abs(a - p) <=
                    fc.EPSILON * Math.max(1, Math.abs(a), Math.abs(p))
                );
              }),
              (dc.sub = dc.mul = void 0);
            var fc = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== pc(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = mc(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function mc(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (mc = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function _c(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = t[4],
                l = t[5],
                c = i[0],
                h = i[1],
                u = i[2],
                d = i[3],
                p = i[4],
                f = i[5];
              return (
                (e1[0] = r * c + o * h),
                (e1[1] = n * c + s * h),
                (e1[2] = r * u + o * d),
                (e1[3] = n * u + s * d),
                (e1[4] = r * p + o * f + a),
                (e1[5] = n * p + s * f + l),
                e1
              );
            }
            function gc(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                (e1[3] = t[3] - i[3]),
                (e1[4] = t[4] - i[4]),
                (e1[5] = t[5] - i[5]),
                e1
              );
            }
            (dc.mul = _c), (dc.sub = gc);
            var yc = {};
            function xc(e1) {
              return (
                (xc =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                xc(e1)
              );
            }
            Object.defineProperty(yc, "__esModule", {
              value: !0,
            }),
              (yc.create = function () {
                var e1 = new vc.ARRAY_TYPE(9);
                return (
                  vc.ARRAY_TYPE != Float32Array &&
                    ((e1[1] = 0),
                    (e1[2] = 0),
                    (e1[3] = 0),
                    (e1[5] = 0),
                    (e1[6] = 0),
                    (e1[7] = 0)),
                  (e1[0] = 1),
                  (e1[4] = 1),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.fromMat4 = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[4]),
                  (e1[4] = t[5]),
                  (e1[5] = t[6]),
                  (e1[6] = t[8]),
                  (e1[7] = t[9]),
                  (e1[8] = t[10]),
                  e1
                );
              }),
              (yc.clone = function (e1) {
                var t = new vc.ARRAY_TYPE(9);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  (t[4] = e1[4]),
                  (t[5] = e1[5]),
                  (t[6] = e1[6]),
                  (t[7] = e1[7]),
                  (t[8] = e1[8]),
                  t
                );
              }),
              (yc.copy = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  (e1[4] = t[4]),
                  (e1[5] = t[5]),
                  (e1[6] = t[6]),
                  (e1[7] = t[7]),
                  (e1[8] = t[8]),
                  e1
                );
              }),
              (yc.fromValues = function (e1, t, i, r, n, o, s, a, l) {
                var c = new vc.ARRAY_TYPE(9);
                return (
                  (c[0] = e1),
                  (c[1] = t),
                  (c[2] = i),
                  (c[3] = r),
                  (c[4] = n),
                  (c[5] = o),
                  (c[6] = s),
                  (c[7] = a),
                  (c[8] = l),
                  c
                );
              }),
              (yc.set = function (e1, t, i, r, n, o, s, a, l, c) {
                return (
                  (e1[0] = t),
                  (e1[1] = i),
                  (e1[2] = r),
                  (e1[3] = n),
                  (e1[4] = o),
                  (e1[5] = s),
                  (e1[6] = a),
                  (e1[7] = l),
                  (e1[8] = c),
                  e1
                );
              }),
              (yc.identity = function (e1) {
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 1),
                  (e1[5] = 0),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.transpose = function (e1, t) {
                if (e1 === t) {
                  var i = t[1],
                    r = t[2],
                    n = t[5];
                  (e1[1] = t[3]),
                    (e1[2] = t[6]),
                    (e1[3] = i),
                    (e1[5] = t[7]),
                    (e1[6] = r),
                    (e1[7] = n);
                } else
                  (e1[0] = t[0]),
                    (e1[1] = t[3]),
                    (e1[2] = t[6]),
                    (e1[3] = t[1]),
                    (e1[4] = t[4]),
                    (e1[5] = t[7]),
                    (e1[6] = t[2]),
                    (e1[7] = t[5]),
                    (e1[8] = t[8]);
                return e1;
              }),
              (yc.invert = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = t[6],
                  c = t[7],
                  h = t[8],
                  u = h * s - a * c,
                  d = -h * o + a * l,
                  p = c * o - s * l,
                  f = i * u + r * d + n * p;
                return f
                  ? ((e1[0] = u * (f = 1 / f)),
                    (e1[1] = (-h * r + n * c) * f),
                    (e1[2] = (a * r - n * s) * f),
                    (e1[3] = d * f),
                    (e1[4] = (h * i - n * l) * f),
                    (e1[5] = (-a * i + n * o) * f),
                    (e1[6] = p * f),
                    (e1[7] = (-c * i + r * l) * f),
                    (e1[8] = (s * i - r * o) * f),
                    e1)
                  : null;
              }),
              (yc.adjoint = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = t[6],
                  c = t[7],
                  h = t[8];
                return (
                  (e1[0] = s * h - a * c),
                  (e1[1] = n * c - r * h),
                  (e1[2] = r * a - n * s),
                  (e1[3] = a * l - o * h),
                  (e1[4] = i * h - n * l),
                  (e1[5] = n * o - i * a),
                  (e1[6] = o * c - s * l),
                  (e1[7] = r * l - i * c),
                  (e1[8] = i * s - r * o),
                  e1
                );
              }),
              (yc.determinant = function (e1) {
                var t = e1[3],
                  i = e1[4],
                  r = e1[5],
                  n = e1[6],
                  o = e1[7],
                  s = e1[8];
                return (
                  e1[0] * (s * i - r * o) +
                  e1[1] * (-s * t + r * n) +
                  e1[2] * (o * t - i * n)
                );
              }),
              (yc.multiply = wc),
              (yc.translate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = t[8],
                  d = i[0],
                  p = i[1];
                return (
                  (e1[0] = r),
                  (e1[1] = n),
                  (e1[2] = o),
                  (e1[3] = s),
                  (e1[4] = a),
                  (e1[5] = l),
                  (e1[6] = d * r + p * s + c),
                  (e1[7] = d * n + p * a + h),
                  (e1[8] = d * o + p * l + u),
                  e1
                );
              }),
              (yc.rotate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = t[8],
                  d = Math.sin(i),
                  p = Math.cos(i);
                return (
                  (e1[0] = p * r + d * s),
                  (e1[1] = p * n + d * a),
                  (e1[2] = p * o + d * l),
                  (e1[3] = p * s - d * r),
                  (e1[4] = p * a - d * n),
                  (e1[5] = p * l - d * o),
                  (e1[6] = c),
                  (e1[7] = h),
                  (e1[8] = u),
                  e1
                );
              }),
              (yc.scale = function (e1, t, i) {
                var r = i[0],
                  n = i[1];
                return (
                  (e1[0] = r * t[0]),
                  (e1[1] = r * t[1]),
                  (e1[2] = r * t[2]),
                  (e1[3] = n * t[3]),
                  (e1[4] = n * t[4]),
                  (e1[5] = n * t[5]),
                  (e1[6] = t[6]),
                  (e1[7] = t[7]),
                  (e1[8] = t[8]),
                  e1
                );
              }),
              (yc.fromTranslation = function (e1, t) {
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 1),
                  (e1[5] = 0),
                  (e1[6] = t[0]),
                  (e1[7] = t[1]),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.fromRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (
                  (e1[0] = r),
                  (e1[1] = i),
                  (e1[2] = 0),
                  (e1[3] = -i),
                  (e1[4] = r),
                  (e1[5] = 0),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.fromScaling = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = t[1]),
                  (e1[5] = 0),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.fromMat2d = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = 0),
                  (e1[3] = t[2]),
                  (e1[4] = t[3]),
                  (e1[5] = 0),
                  (e1[6] = t[4]),
                  (e1[7] = t[5]),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.fromQuat = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i + i,
                  a = r + r,
                  l = n + n,
                  c = i * s,
                  h = r * s,
                  u = r * a,
                  d = n * s,
                  p = n * a,
                  f = n * l,
                  m = o * s,
                  _ = o * a,
                  g = o * l;
                return (
                  (e1[0] = 1 - u - f),
                  (e1[3] = h - g),
                  (e1[6] = d + _),
                  (e1[1] = h + g),
                  (e1[4] = 1 - c - f),
                  (e1[7] = p - m),
                  (e1[2] = d - _),
                  (e1[5] = p + m),
                  (e1[8] = 1 - c - u),
                  e1
                );
              }),
              (yc.normalFromMat4 = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = t[6],
                  c = t[7],
                  h = t[8],
                  u = t[9],
                  d = t[10],
                  p = t[11],
                  f = t[12],
                  m = t[13],
                  _ = t[14],
                  g = t[15],
                  y = i * a - r * s,
                  x = i * l - n * s,
                  v = i * c - o * s,
                  b = r * l - n * a,
                  w = r * c - o * a,
                  T = n * c - o * l,
                  E = h * m - u * f,
                  M = h * _ - d * f,
                  A = h * g - p * f,
                  S = u * _ - d * m,
                  I = u * g - p * m,
                  C = d * g - p * _,
                  z = y * C - x * I + v * S + b * A - w * M + T * E;
                return z
                  ? ((e1[0] = (a * C - l * I + c * S) * (z = 1 / z)),
                    (e1[1] = (l * A - s * C - c * M) * z),
                    (e1[2] = (s * I - a * A + c * E) * z),
                    (e1[3] = (n * I - r * C - o * S) * z),
                    (e1[4] = (i * C - n * A + o * M) * z),
                    (e1[5] = (r * A - i * I - o * E) * z),
                    (e1[6] = (m * T - _ * w + g * b) * z),
                    (e1[7] = (_ * v - f * T - g * x) * z),
                    (e1[8] = (f * w - m * v + g * y) * z),
                    e1)
                  : null;
              }),
              (yc.projection = function (e1, t, i) {
                return (
                  (e1[0] = 2 / t),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = -2 / i),
                  (e1[5] = 0),
                  (e1[6] = -1),
                  (e1[7] = 1),
                  (e1[8] = 1),
                  e1
                );
              }),
              (yc.str = function (e1) {
                return (
                  "mat3(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ", " +
                  e1[4] +
                  ", " +
                  e1[5] +
                  ", " +
                  e1[6] +
                  ", " +
                  e1[7] +
                  ", " +
                  e1[8] +
                  ")"
                );
              }),
              (yc.frob = function (e1) {
                return Math.hypot(
                  e1[0],
                  e1[1],
                  e1[2],
                  e1[3],
                  e1[4],
                  e1[5],
                  e1[6],
                  e1[7],
                  e1[8],
                );
              }),
              (yc.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  (e1[4] = t[4] + i[4]),
                  (e1[5] = t[5] + i[5]),
                  (e1[6] = t[6] + i[6]),
                  (e1[7] = t[7] + i[7]),
                  (e1[8] = t[8] + i[8]),
                  e1
                );
              }),
              (yc.subtract = Tc),
              (yc.multiplyScalar = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  (e1[4] = t[4] * i),
                  (e1[5] = t[5] * i),
                  (e1[6] = t[6] * i),
                  (e1[7] = t[7] * i),
                  (e1[8] = t[8] * i),
                  e1
                );
              }),
              (yc.multiplyScalarAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  (e1[3] = t[3] + i[3] * r),
                  (e1[4] = t[4] + i[4] * r),
                  (e1[5] = t[5] + i[5] * r),
                  (e1[6] = t[6] + i[6] * r),
                  (e1[7] = t[7] + i[7] * r),
                  (e1[8] = t[8] + i[8] * r),
                  e1
                );
              }),
              (yc.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3] &&
                  e1[4] === t[4] &&
                  e1[5] === t[5] &&
                  e1[6] === t[6] &&
                  e1[7] === t[7] &&
                  e1[8] === t[8]
                );
              }),
              (yc.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = e1[4],
                  a = e1[5],
                  l = e1[6],
                  c = e1[7],
                  h = e1[8],
                  u = t[0],
                  d = t[1],
                  p = t[2],
                  f = t[3],
                  m = t[4],
                  _ = t[5],
                  g = t[6],
                  y = t[7],
                  x = t[8];
                return (
                  Math.abs(i - u) <=
                    vc.EPSILON * Math.max(1, Math.abs(i), Math.abs(u)) &&
                  Math.abs(r - d) <=
                    vc.EPSILON * Math.max(1, Math.abs(r), Math.abs(d)) &&
                  Math.abs(n - p) <=
                    vc.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) &&
                  Math.abs(o - f) <=
                    vc.EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) &&
                  Math.abs(s - m) <=
                    vc.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) &&
                  Math.abs(a - _) <=
                    vc.EPSILON * Math.max(1, Math.abs(a), Math.abs(_)) &&
                  Math.abs(l - g) <=
                    vc.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) &&
                  Math.abs(c - y) <=
                    vc.EPSILON * Math.max(1, Math.abs(c), Math.abs(y)) &&
                  Math.abs(h - x) <=
                    vc.EPSILON * Math.max(1, Math.abs(h), Math.abs(x))
                );
              }),
              (yc.sub = yc.mul = void 0);
            var vc = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== xc(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = bc(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function bc(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (bc = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function wc(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = t[4],
                l = t[5],
                c = t[6],
                h = t[7],
                u = t[8],
                d = i[0],
                p = i[1],
                f = i[2],
                m = i[3],
                _ = i[4],
                g = i[5],
                y = i[6],
                x = i[7],
                v = i[8];
              return (
                (e1[0] = d * r + p * s + f * c),
                (e1[1] = d * n + p * a + f * h),
                (e1[2] = d * o + p * l + f * u),
                (e1[3] = m * r + _ * s + g * c),
                (e1[4] = m * n + _ * a + g * h),
                (e1[5] = m * o + _ * l + g * u),
                (e1[6] = y * r + x * s + v * c),
                (e1[7] = y * n + x * a + v * h),
                (e1[8] = y * o + x * l + v * u),
                e1
              );
            }
            function Tc(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                (e1[3] = t[3] - i[3]),
                (e1[4] = t[4] - i[4]),
                (e1[5] = t[5] - i[5]),
                (e1[6] = t[6] - i[6]),
                (e1[7] = t[7] - i[7]),
                (e1[8] = t[8] - i[8]),
                e1
              );
            }
            (yc.mul = wc), (yc.sub = Tc);
            var Ec = {};
            function Mc(e1) {
              return (
                (Mc =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                Mc(e1)
              );
            }
            Object.defineProperty(Ec, "__esModule", {
              value: !0,
            }),
              (Ec.create = function () {
                var e1 = new Ac.ARRAY_TYPE(16);
                return (
                  Ac.ARRAY_TYPE != Float32Array &&
                    ((e1[1] = 0),
                    (e1[2] = 0),
                    (e1[3] = 0),
                    (e1[4] = 0),
                    (e1[6] = 0),
                    (e1[7] = 0),
                    (e1[8] = 0),
                    (e1[9] = 0),
                    (e1[11] = 0),
                    (e1[12] = 0),
                    (e1[13] = 0),
                    (e1[14] = 0)),
                  (e1[0] = 1),
                  (e1[5] = 1),
                  (e1[10] = 1),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.clone = function (e1) {
                var t = new Ac.ARRAY_TYPE(16);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  (t[4] = e1[4]),
                  (t[5] = e1[5]),
                  (t[6] = e1[6]),
                  (t[7] = e1[7]),
                  (t[8] = e1[8]),
                  (t[9] = e1[9]),
                  (t[10] = e1[10]),
                  (t[11] = e1[11]),
                  (t[12] = e1[12]),
                  (t[13] = e1[13]),
                  (t[14] = e1[14]),
                  (t[15] = e1[15]),
                  t
                );
              }),
              (Ec.copy = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  (e1[4] = t[4]),
                  (e1[5] = t[5]),
                  (e1[6] = t[6]),
                  (e1[7] = t[7]),
                  (e1[8] = t[8]),
                  (e1[9] = t[9]),
                  (e1[10] = t[10]),
                  (e1[11] = t[11]),
                  (e1[12] = t[12]),
                  (e1[13] = t[13]),
                  (e1[14] = t[14]),
                  (e1[15] = t[15]),
                  e1
                );
              }),
              (Ec.fromValues = function (
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
              ) {
                var _ = new Ac.ARRAY_TYPE(16);
                return (
                  (_[0] = e1),
                  (_[1] = t),
                  (_[2] = i),
                  (_[3] = r),
                  (_[4] = n),
                  (_[5] = o),
                  (_[6] = s),
                  (_[7] = a),
                  (_[8] = l),
                  (_[9] = c),
                  (_[10] = h),
                  (_[11] = u),
                  (_[12] = d),
                  (_[13] = p),
                  (_[14] = f),
                  (_[15] = m),
                  _
                );
              }),
              (Ec.set = function (
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
              ) {
                return (
                  (e1[0] = t),
                  (e1[1] = i),
                  (e1[2] = r),
                  (e1[3] = n),
                  (e1[4] = o),
                  (e1[5] = s),
                  (e1[6] = a),
                  (e1[7] = l),
                  (e1[8] = c),
                  (e1[9] = h),
                  (e1[10] = u),
                  (e1[11] = d),
                  (e1[12] = p),
                  (e1[13] = f),
                  (e1[14] = m),
                  (e1[15] = _),
                  e1
                );
              }),
              (Ec.identity = Ic),
              (Ec.transpose = function (e1, t) {
                if (e1 === t) {
                  var i = t[1],
                    r = t[2],
                    n = t[3],
                    o = t[6],
                    s = t[7],
                    a = t[11];
                  (e1[1] = t[4]),
                    (e1[2] = t[8]),
                    (e1[3] = t[12]),
                    (e1[4] = i),
                    (e1[6] = t[9]),
                    (e1[7] = t[13]),
                    (e1[8] = r),
                    (e1[9] = o),
                    (e1[11] = t[14]),
                    (e1[12] = n),
                    (e1[13] = s),
                    (e1[14] = a);
                } else
                  (e1[0] = t[0]),
                    (e1[1] = t[4]),
                    (e1[2] = t[8]),
                    (e1[3] = t[12]),
                    (e1[4] = t[1]),
                    (e1[5] = t[5]),
                    (e1[6] = t[9]),
                    (e1[7] = t[13]),
                    (e1[8] = t[2]),
                    (e1[9] = t[6]),
                    (e1[10] = t[10]),
                    (e1[11] = t[14]),
                    (e1[12] = t[3]),
                    (e1[13] = t[7]),
                    (e1[14] = t[11]),
                    (e1[15] = t[15]);
                return e1;
              }),
              (Ec.invert = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = t[6],
                  c = t[7],
                  h = t[8],
                  u = t[9],
                  d = t[10],
                  p = t[11],
                  f = t[12],
                  m = t[13],
                  _ = t[14],
                  g = t[15],
                  y = i * a - r * s,
                  x = i * l - n * s,
                  v = i * c - o * s,
                  b = r * l - n * a,
                  w = r * c - o * a,
                  T = n * c - o * l,
                  E = h * m - u * f,
                  M = h * _ - d * f,
                  A = h * g - p * f,
                  S = u * _ - d * m,
                  I = u * g - p * m,
                  C = d * g - p * _,
                  z = y * C - x * I + v * S + b * A - w * M + T * E;
                return z
                  ? ((e1[0] = (a * C - l * I + c * S) * (z = 1 / z)),
                    (e1[1] = (n * I - r * C - o * S) * z),
                    (e1[2] = (m * T - _ * w + g * b) * z),
                    (e1[3] = (d * w - u * T - p * b) * z),
                    (e1[4] = (l * A - s * C - c * M) * z),
                    (e1[5] = (i * C - n * A + o * M) * z),
                    (e1[6] = (_ * v - f * T - g * x) * z),
                    (e1[7] = (h * T - d * v + p * x) * z),
                    (e1[8] = (s * I - a * A + c * E) * z),
                    (e1[9] = (r * A - i * I - o * E) * z),
                    (e1[10] = (f * w - m * v + g * y) * z),
                    (e1[11] = (u * v - h * w - p * y) * z),
                    (e1[12] = (a * M - s * S - l * E) * z),
                    (e1[13] = (i * S - r * M + n * E) * z),
                    (e1[14] = (m * x - f * b - _ * y) * z),
                    (e1[15] = (h * b - u * x + d * y) * z),
                    e1)
                  : null;
              }),
              (Ec.adjoint = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = t[4],
                  a = t[5],
                  l = t[6],
                  c = t[7],
                  h = t[8],
                  u = t[9],
                  d = t[10],
                  p = t[11],
                  f = t[12],
                  m = t[13],
                  _ = t[14],
                  g = t[15];
                return (
                  (e1[0] =
                    a * (d * g - p * _) -
                    u * (l * g - c * _) +
                    m * (l * p - c * d)),
                  (e1[1] = -(
                    r * (d * g - p * _) -
                    u * (n * g - o * _) +
                    m * (n * p - o * d)
                  )),
                  (e1[2] =
                    r * (l * g - c * _) -
                    a * (n * g - o * _) +
                    m * (n * c - o * l)),
                  (e1[3] = -(
                    r * (l * p - c * d) -
                    a * (n * p - o * d) +
                    u * (n * c - o * l)
                  )),
                  (e1[4] = -(
                    s * (d * g - p * _) -
                    h * (l * g - c * _) +
                    f * (l * p - c * d)
                  )),
                  (e1[5] =
                    i * (d * g - p * _) -
                    h * (n * g - o * _) +
                    f * (n * p - o * d)),
                  (e1[6] = -(
                    i * (l * g - c * _) -
                    s * (n * g - o * _) +
                    f * (n * c - o * l)
                  )),
                  (e1[7] =
                    i * (l * p - c * d) -
                    s * (n * p - o * d) +
                    h * (n * c - o * l)),
                  (e1[8] =
                    s * (u * g - p * m) -
                    h * (a * g - c * m) +
                    f * (a * p - c * u)),
                  (e1[9] = -(
                    i * (u * g - p * m) -
                    h * (r * g - o * m) +
                    f * (r * p - o * u)
                  )),
                  (e1[10] =
                    i * (a * g - c * m) -
                    s * (r * g - o * m) +
                    f * (r * c - o * a)),
                  (e1[11] = -(
                    i * (a * p - c * u) -
                    s * (r * p - o * u) +
                    h * (r * c - o * a)
                  )),
                  (e1[12] = -(
                    s * (u * _ - d * m) -
                    h * (a * _ - l * m) +
                    f * (a * d - l * u)
                  )),
                  (e1[13] =
                    i * (u * _ - d * m) -
                    h * (r * _ - n * m) +
                    f * (r * d - n * u)),
                  (e1[14] = -(
                    i * (a * _ - l * m) -
                    s * (r * _ - n * m) +
                    f * (r * l - n * a)
                  )),
                  (e1[15] =
                    i * (a * d - l * u) -
                    s * (r * d - n * u) +
                    h * (r * l - n * a)),
                  e1
                );
              }),
              (Ec.determinant = function (e1) {
                var t = e1[0],
                  i = e1[1],
                  r = e1[2],
                  n = e1[3],
                  o = e1[4],
                  s = e1[5],
                  a = e1[6],
                  l = e1[7],
                  c = e1[8],
                  h = e1[9],
                  u = e1[10],
                  d = e1[11],
                  p = e1[12],
                  f = e1[13],
                  m = e1[14],
                  _ = e1[15];
                return (
                  (t * s - i * o) * (u * _ - d * m) -
                  (t * a - r * o) * (h * _ - d * f) +
                  (t * l - n * o) * (h * m - u * f) +
                  (i * a - r * s) * (c * _ - d * p) -
                  (i * l - n * s) * (c * m - u * p) +
                  (r * l - n * a) * (c * f - h * p)
                );
              }),
              (Ec.multiply = Cc),
              (Ec.translate = function (e1, t, i) {
                var r,
                  n,
                  o,
                  s,
                  a,
                  l,
                  c,
                  h,
                  u,
                  d,
                  p,
                  f,
                  m = i[0],
                  _ = i[1],
                  g = i[2];
                return (
                  t === e1
                    ? ((e1[12] = t[0] * m + t[4] * _ + t[8] * g + t[12]),
                      (e1[13] = t[1] * m + t[5] * _ + t[9] * g + t[13]),
                      (e1[14] = t[2] * m + t[6] * _ + t[10] * g + t[14]),
                      (e1[15] = t[3] * m + t[7] * _ + t[11] * g + t[15]))
                    : ((n = t[1]),
                      (o = t[2]),
                      (s = t[3]),
                      (a = t[4]),
                      (l = t[5]),
                      (c = t[6]),
                      (h = t[7]),
                      (u = t[8]),
                      (d = t[9]),
                      (p = t[10]),
                      (f = t[11]),
                      (e1[0] = r = t[0]),
                      (e1[1] = n),
                      (e1[2] = o),
                      (e1[3] = s),
                      (e1[4] = a),
                      (e1[5] = l),
                      (e1[6] = c),
                      (e1[7] = h),
                      (e1[8] = u),
                      (e1[9] = d),
                      (e1[10] = p),
                      (e1[11] = f),
                      (e1[12] = r * m + a * _ + u * g + t[12]),
                      (e1[13] = n * m + l * _ + d * g + t[13]),
                      (e1[14] = o * m + c * _ + p * g + t[14]),
                      (e1[15] = s * m + h * _ + f * g + t[15])),
                  e1
                );
              }),
              (Ec.scale = function (e1, t, i) {
                var r = i[0],
                  n = i[1],
                  o = i[2];
                return (
                  (e1[0] = t[0] * r),
                  (e1[1] = t[1] * r),
                  (e1[2] = t[2] * r),
                  (e1[3] = t[3] * r),
                  (e1[4] = t[4] * n),
                  (e1[5] = t[5] * n),
                  (e1[6] = t[6] * n),
                  (e1[7] = t[7] * n),
                  (e1[8] = t[8] * o),
                  (e1[9] = t[9] * o),
                  (e1[10] = t[10] * o),
                  (e1[11] = t[11] * o),
                  (e1[12] = t[12]),
                  (e1[13] = t[13]),
                  (e1[14] = t[14]),
                  (e1[15] = t[15]),
                  e1
                );
              }),
              (Ec.rotate = function (e1, t, i, r) {
                var n,
                  o,
                  s,
                  a,
                  l,
                  c,
                  h,
                  u,
                  d,
                  p,
                  f,
                  m,
                  _,
                  g,
                  y,
                  x,
                  v,
                  b,
                  w,
                  T,
                  E,
                  M,
                  A,
                  S,
                  I = r[0],
                  C = r[1],
                  z = r[2],
                  D = Math.hypot(I, C, z);
                return D < Ac.EPSILON
                  ? null
                  : ((I *= D = 1 / D),
                    (C *= D),
                    (z *= D),
                    (n = Math.sin(i)),
                    (o = Math.cos(i)),
                    (l = t[1]),
                    (c = t[2]),
                    (h = t[3]),
                    (d = t[5]),
                    (p = t[6]),
                    (f = t[7]),
                    (_ = t[9]),
                    (g = t[10]),
                    (y = t[11]),
                    (w = I * C * (s = 1 - o) - z * n),
                    (T = C * C * s + o),
                    (E = z * C * s + I * n),
                    (M = I * z * s + C * n),
                    (A = C * z * s - I * n),
                    (S = z * z * s + o),
                    (e1[0] =
                      (a = t[0]) * (x = I * I * s + o) +
                      (u = t[4]) * (v = C * I * s + z * n) +
                      (m = t[8]) * (b = z * I * s - C * n)),
                    (e1[1] = l * x + d * v + _ * b),
                    (e1[2] = c * x + p * v + g * b),
                    (e1[3] = h * x + f * v + y * b),
                    (e1[4] = a * w + u * T + m * E),
                    (e1[5] = l * w + d * T + _ * E),
                    (e1[6] = c * w + p * T + g * E),
                    (e1[7] = h * w + f * T + y * E),
                    (e1[8] = a * M + u * A + m * S),
                    (e1[9] = l * M + d * A + _ * S),
                    (e1[10] = c * M + p * A + g * S),
                    (e1[11] = h * M + f * A + y * S),
                    t !== e1 &&
                      ((e1[12] = t[12]),
                      (e1[13] = t[13]),
                      (e1[14] = t[14]),
                      (e1[15] = t[15])),
                    e1);
              }),
              (Ec.rotateX = function (e1, t, i) {
                var r = Math.sin(i),
                  n = Math.cos(i),
                  o = t[4],
                  s = t[5],
                  a = t[6],
                  l = t[7],
                  c = t[8],
                  h = t[9],
                  u = t[10],
                  d = t[11];
                return (
                  t !== e1 &&
                    ((e1[0] = t[0]),
                    (e1[1] = t[1]),
                    (e1[2] = t[2]),
                    (e1[3] = t[3]),
                    (e1[12] = t[12]),
                    (e1[13] = t[13]),
                    (e1[14] = t[14]),
                    (e1[15] = t[15])),
                  (e1[4] = o * n + c * r),
                  (e1[5] = s * n + h * r),
                  (e1[6] = a * n + u * r),
                  (e1[7] = l * n + d * r),
                  (e1[8] = c * n - o * r),
                  (e1[9] = h * n - s * r),
                  (e1[10] = u * n - a * r),
                  (e1[11] = d * n - l * r),
                  e1
                );
              }),
              (Ec.rotateY = function (e1, t, i) {
                var r = Math.sin(i),
                  n = Math.cos(i),
                  o = t[0],
                  s = t[1],
                  a = t[2],
                  l = t[3],
                  c = t[8],
                  h = t[9],
                  u = t[10],
                  d = t[11];
                return (
                  t !== e1 &&
                    ((e1[4] = t[4]),
                    (e1[5] = t[5]),
                    (e1[6] = t[6]),
                    (e1[7] = t[7]),
                    (e1[12] = t[12]),
                    (e1[13] = t[13]),
                    (e1[14] = t[14]),
                    (e1[15] = t[15])),
                  (e1[0] = o * n - c * r),
                  (e1[1] = s * n - h * r),
                  (e1[2] = a * n - u * r),
                  (e1[3] = l * n - d * r),
                  (e1[8] = o * r + c * n),
                  (e1[9] = s * r + h * n),
                  (e1[10] = a * r + u * n),
                  (e1[11] = l * r + d * n),
                  e1
                );
              }),
              (Ec.rotateZ = function (e1, t, i) {
                var r = Math.sin(i),
                  n = Math.cos(i),
                  o = t[0],
                  s = t[1],
                  a = t[2],
                  l = t[3],
                  c = t[4],
                  h = t[5],
                  u = t[6],
                  d = t[7];
                return (
                  t !== e1 &&
                    ((e1[8] = t[8]),
                    (e1[9] = t[9]),
                    (e1[10] = t[10]),
                    (e1[11] = t[11]),
                    (e1[12] = t[12]),
                    (e1[13] = t[13]),
                    (e1[14] = t[14]),
                    (e1[15] = t[15])),
                  (e1[0] = o * n + c * r),
                  (e1[1] = s * n + h * r),
                  (e1[2] = a * n + u * r),
                  (e1[3] = l * n + d * r),
                  (e1[4] = c * n - o * r),
                  (e1[5] = h * n - s * r),
                  (e1[6] = u * n - a * r),
                  (e1[7] = d * n - l * r),
                  e1
                );
              }),
              (Ec.fromTranslation = function (e1, t) {
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = 1),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = 0),
                  (e1[10] = 1),
                  (e1[11] = 0),
                  (e1[12] = t[0]),
                  (e1[13] = t[1]),
                  (e1[14] = t[2]),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromScaling = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = t[1]),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = 0),
                  (e1[10] = t[2]),
                  (e1[11] = 0),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = 0),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromRotation = function (e1, t, i) {
                var r,
                  n,
                  o,
                  s = i[0],
                  a = i[1],
                  l = i[2],
                  c = Math.hypot(s, a, l);
                return c < Ac.EPSILON
                  ? null
                  : ((s *= c = 1 / c),
                    (a *= c),
                    (l *= c),
                    (r = Math.sin(t)),
                    (n = Math.cos(t)),
                    (e1[0] = s * s * (o = 1 - n) + n),
                    (e1[1] = a * s * o + l * r),
                    (e1[2] = l * s * o - a * r),
                    (e1[3] = 0),
                    (e1[4] = s * a * o - l * r),
                    (e1[5] = a * a * o + n),
                    (e1[6] = l * a * o + s * r),
                    (e1[7] = 0),
                    (e1[8] = s * l * o + a * r),
                    (e1[9] = a * l * o - s * r),
                    (e1[10] = l * l * o + n),
                    (e1[11] = 0),
                    (e1[12] = 0),
                    (e1[13] = 0),
                    (e1[14] = 0),
                    (e1[15] = 1),
                    e1);
              }),
              (Ec.fromXRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (
                  (e1[0] = 1),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = r),
                  (e1[6] = i),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = -i),
                  (e1[10] = r),
                  (e1[11] = 0),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = 0),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromYRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (
                  (e1[0] = r),
                  (e1[1] = 0),
                  (e1[2] = -i),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = 1),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = i),
                  (e1[9] = 0),
                  (e1[10] = r),
                  (e1[11] = 0),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = 0),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromZRotation = function (e1, t) {
                var i = Math.sin(t),
                  r = Math.cos(t);
                return (
                  (e1[0] = r),
                  (e1[1] = i),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = -i),
                  (e1[5] = r),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = 0),
                  (e1[10] = 1),
                  (e1[11] = 0),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = 0),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromRotationTranslation = zc),
              (Ec.fromQuat2 = function (e1, t) {
                var i = new Ac.ARRAY_TYPE(3),
                  r = -t[0],
                  n = -t[1],
                  o = -t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = r * r + n * n + o * o + s * s;
                return (
                  u > 0
                    ? ((i[0] = (2 * (a * s + h * r + l * o - c * n)) / u),
                      (i[1] = (2 * (l * s + h * n + c * r - a * o)) / u),
                      (i[2] = (2 * (c * s + h * o + a * n - l * r)) / u))
                    : ((i[0] = 2 * (a * s + h * r + l * o - c * n)),
                      (i[1] = 2 * (l * s + h * n + c * r - a * o)),
                      (i[2] = 2 * (c * s + h * o + a * n - l * r))),
                  zc(e1, t, i),
                  e1
                );
              }),
              (Ec.getTranslation = function (e1, t) {
                return (e1[0] = t[12]), (e1[1] = t[13]), (e1[2] = t[14]), e1;
              }),
              (Ec.getScaling = Dc),
              (Ec.getRotation = function (e1, t) {
                var i = new Ac.ARRAY_TYPE(3);
                Dc(i, t);
                var r = 1 / i[0],
                  n = 1 / i[1],
                  o = 1 / i[2],
                  s = t[0] * r,
                  a = t[1] * n,
                  l = t[2] * o,
                  c = t[4] * r,
                  h = t[5] * n,
                  u = t[6] * o,
                  d = t[8] * r,
                  p = t[9] * n,
                  f = t[10] * o,
                  m = s + h + f,
                  _ = 0;
                return (
                  m > 0
                    ? ((_ = 2 * Math.sqrt(m + 1)),
                      (e1[3] = 0.25 * _),
                      (e1[0] = (u - p) / _),
                      (e1[1] = (d - l) / _),
                      (e1[2] = (a - c) / _))
                    : s > h && s > f
                    ? ((_ = 2 * Math.sqrt(1 + s - h - f)),
                      (e1[3] = (u - p) / _),
                      (e1[0] = 0.25 * _),
                      (e1[1] = (a + c) / _),
                      (e1[2] = (d + l) / _))
                    : h > f
                    ? ((_ = 2 * Math.sqrt(1 + h - s - f)),
                      (e1[3] = (d - l) / _),
                      (e1[0] = (a + c) / _),
                      (e1[1] = 0.25 * _),
                      (e1[2] = (u + p) / _))
                    : ((_ = 2 * Math.sqrt(1 + f - s - h)),
                      (e1[3] = (a - c) / _),
                      (e1[0] = (d + l) / _),
                      (e1[1] = (u + p) / _),
                      (e1[2] = 0.25 * _)),
                  e1
                );
              }),
              (Ec.fromRotationTranslationScale = function (e1, t, i, r) {
                var n = t[0],
                  o = t[1],
                  s = t[2],
                  a = t[3],
                  l = n + n,
                  c = o + o,
                  h = s + s,
                  u = n * l,
                  d = n * c,
                  p = n * h,
                  f = o * c,
                  m = o * h,
                  _ = s * h,
                  g = a * l,
                  y = a * c,
                  x = a * h,
                  v = r[0],
                  b = r[1],
                  w = r[2];
                return (
                  (e1[0] = (1 - (f + _)) * v),
                  (e1[1] = (d + x) * v),
                  (e1[2] = (p - y) * v),
                  (e1[3] = 0),
                  (e1[4] = (d - x) * b),
                  (e1[5] = (1 - (u + _)) * b),
                  (e1[6] = (m + g) * b),
                  (e1[7] = 0),
                  (e1[8] = (p + y) * w),
                  (e1[9] = (m - g) * w),
                  (e1[10] = (1 - (u + f)) * w),
                  (e1[11] = 0),
                  (e1[12] = i[0]),
                  (e1[13] = i[1]),
                  (e1[14] = i[2]),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromRotationTranslationScaleOrigin = function (
                e1,
                t,
                i,
                r,
                n,
              ) {
                var o = t[0],
                  s = t[1],
                  a = t[2],
                  l = t[3],
                  c = o + o,
                  h = s + s,
                  u = a + a,
                  d = o * c,
                  p = o * h,
                  f = o * u,
                  m = s * h,
                  _ = s * u,
                  g = a * u,
                  y = l * c,
                  x = l * h,
                  v = l * u,
                  b = r[0],
                  w = r[1],
                  T = r[2],
                  E = n[0],
                  M = n[1],
                  A = n[2],
                  S = (1 - (m + g)) * b,
                  I = (p + v) * b,
                  C = (f - x) * b,
                  z = (p - v) * w,
                  D = (1 - (d + g)) * w,
                  P = (_ + y) * w,
                  R = (f + x) * T,
                  L = (_ - y) * T,
                  k = (1 - (d + m)) * T;
                return (
                  (e1[0] = S),
                  (e1[1] = I),
                  (e1[2] = C),
                  (e1[3] = 0),
                  (e1[4] = z),
                  (e1[5] = D),
                  (e1[6] = P),
                  (e1[7] = 0),
                  (e1[8] = R),
                  (e1[9] = L),
                  (e1[10] = k),
                  (e1[11] = 0),
                  (e1[12] = i[0] + E - (S * E + z * M + R * A)),
                  (e1[13] = i[1] + M - (I * E + D * M + L * A)),
                  (e1[14] = i[2] + A - (C * E + P * M + k * A)),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.fromQuat = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i + i,
                  a = r + r,
                  l = n + n,
                  c = i * s,
                  h = r * s,
                  u = r * a,
                  d = n * s,
                  p = n * a,
                  f = n * l,
                  m = o * s,
                  _ = o * a,
                  g = o * l;
                return (
                  (e1[0] = 1 - u - f),
                  (e1[1] = h + g),
                  (e1[2] = d - _),
                  (e1[3] = 0),
                  (e1[4] = h - g),
                  (e1[5] = 1 - c - f),
                  (e1[6] = p + m),
                  (e1[7] = 0),
                  (e1[8] = d + _),
                  (e1[9] = p - m),
                  (e1[10] = 1 - c - u),
                  (e1[11] = 0),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = 0),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.frustum = function (e1, t, i, r, n, o, s) {
                var a = 1 / (i - t),
                  l = 1 / (n - r),
                  c = 1 / (o - s);
                return (
                  (e1[0] = 2 * o * a),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = 2 * o * l),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = (i + t) * a),
                  (e1[9] = (n + r) * l),
                  (e1[10] = (s + o) * c),
                  (e1[11] = -1),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = s * o * 2 * c),
                  (e1[15] = 0),
                  e1
                );
              }),
              (Ec.perspectiveNO = Pc),
              (Ec.perspectiveZO = function (e1, t, i, r, n) {
                var o,
                  s = 1 / Math.tan(t / 2);
                return (
                  (e1[0] = s / i),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = s),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = 0),
                  (e1[11] = -1),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[15] = 0),
                  null != n && n !== 1 / 0
                    ? ((e1[10] = n * (o = 1 / (r - n))), (e1[14] = n * r * o))
                    : ((e1[10] = -1), (e1[14] = -r)),
                  e1
                );
              }),
              (Ec.perspectiveFromFieldOfView = function (e1, t, i, r) {
                var n = Math.tan((t.upDegrees * Math.PI) / 180),
                  o = Math.tan((t.downDegrees * Math.PI) / 180),
                  s = Math.tan((t.leftDegrees * Math.PI) / 180),
                  a = Math.tan((t.rightDegrees * Math.PI) / 180),
                  l = 2 / (s + a),
                  c = 2 / (n + o);
                return (
                  (e1[0] = l),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = c),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = -(s - a) * l * 0.5),
                  (e1[9] = (n - o) * c * 0.5),
                  (e1[10] = r / (i - r)),
                  (e1[11] = -1),
                  (e1[12] = 0),
                  (e1[13] = 0),
                  (e1[14] = (r * i) / (i - r)),
                  (e1[15] = 0),
                  e1
                );
              }),
              (Ec.orthoNO = Rc),
              (Ec.orthoZO = function (e1, t, i, r, n, o, s) {
                var a = 1 / (t - i),
                  l = 1 / (r - n),
                  c = 1 / (o - s);
                return (
                  (e1[0] = -2 * a),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 0),
                  (e1[4] = 0),
                  (e1[5] = -2 * l),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  (e1[8] = 0),
                  (e1[9] = 0),
                  (e1[10] = c),
                  (e1[11] = 0),
                  (e1[12] = (t + i) * a),
                  (e1[13] = (n + r) * l),
                  (e1[14] = o * c),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.lookAt = function (e1, t, i, r) {
                var n,
                  o,
                  s,
                  a,
                  l,
                  c,
                  h,
                  u,
                  d,
                  p,
                  f = t[0],
                  m = t[1],
                  _ = t[2],
                  g = r[0],
                  y = r[1],
                  x = r[2],
                  v = i[0],
                  b = i[1],
                  w = i[2];
                return Math.abs(f - v) < Ac.EPSILON &&
                  Math.abs(m - b) < Ac.EPSILON &&
                  Math.abs(_ - w) < Ac.EPSILON
                  ? Ic(e1)
                  : ((h = f - v),
                    (u = m - b),
                    (d = _ - w),
                    (n = y * (d *= p = 1 / Math.hypot(h, u, d)) - x * (u *= p)),
                    (o = x * (h *= p) - g * d),
                    (s = g * u - y * h),
                    (p = Math.hypot(n, o, s))
                      ? ((n *= p = 1 / p), (o *= p), (s *= p))
                      : ((n = 0), (o = 0), (s = 0)),
                    (a = u * s - d * o),
                    (l = d * n - h * s),
                    (c = h * o - u * n),
                    (p = Math.hypot(a, l, c))
                      ? ((a *= p = 1 / p), (l *= p), (c *= p))
                      : ((a = 0), (l = 0), (c = 0)),
                    (e1[0] = n),
                    (e1[1] = a),
                    (e1[2] = h),
                    (e1[3] = 0),
                    (e1[4] = o),
                    (e1[5] = l),
                    (e1[6] = u),
                    (e1[7] = 0),
                    (e1[8] = s),
                    (e1[9] = c),
                    (e1[10] = d),
                    (e1[11] = 0),
                    (e1[12] = -(n * f + o * m + s * _)),
                    (e1[13] = -(a * f + l * m + c * _)),
                    (e1[14] = -(h * f + u * m + d * _)),
                    (e1[15] = 1),
                    e1);
              }),
              (Ec.targetTo = function (e1, t, i, r) {
                var n = t[0],
                  o = t[1],
                  s = t[2],
                  a = r[0],
                  l = r[1],
                  c = r[2],
                  h = n - i[0],
                  u = o - i[1],
                  d = s - i[2],
                  p = h * h + u * u + d * d;
                p > 0 && ((h *= p = 1 / Math.sqrt(p)), (u *= p), (d *= p));
                var f = l * d - c * u,
                  m = c * h - a * d,
                  _ = a * u - l * h;
                return (
                  (p = f * f + m * m + _ * _) > 0 &&
                    ((f *= p = 1 / Math.sqrt(p)), (m *= p), (_ *= p)),
                  (e1[0] = f),
                  (e1[1] = m),
                  (e1[2] = _),
                  (e1[3] = 0),
                  (e1[4] = u * _ - d * m),
                  (e1[5] = d * f - h * _),
                  (e1[6] = h * m - u * f),
                  (e1[7] = 0),
                  (e1[8] = h),
                  (e1[9] = u),
                  (e1[10] = d),
                  (e1[11] = 0),
                  (e1[12] = n),
                  (e1[13] = o),
                  (e1[14] = s),
                  (e1[15] = 1),
                  e1
                );
              }),
              (Ec.str = function (e1) {
                return (
                  "mat4(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ", " +
                  e1[4] +
                  ", " +
                  e1[5] +
                  ", " +
                  e1[6] +
                  ", " +
                  e1[7] +
                  ", " +
                  e1[8] +
                  ", " +
                  e1[9] +
                  ", " +
                  e1[10] +
                  ", " +
                  e1[11] +
                  ", " +
                  e1[12] +
                  ", " +
                  e1[13] +
                  ", " +
                  e1[14] +
                  ", " +
                  e1[15] +
                  ")"
                );
              }),
              (Ec.frob = function (e1) {
                return Math.hypot(
                  e1[0],
                  e1[1],
                  e1[2],
                  e1[3],
                  e1[4],
                  e1[5],
                  e1[6],
                  e1[7],
                  e1[8],
                  e1[9],
                  e1[10],
                  e1[11],
                  e1[12],
                  e1[13],
                  e1[14],
                  e1[15],
                );
              }),
              (Ec.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  (e1[4] = t[4] + i[4]),
                  (e1[5] = t[5] + i[5]),
                  (e1[6] = t[6] + i[6]),
                  (e1[7] = t[7] + i[7]),
                  (e1[8] = t[8] + i[8]),
                  (e1[9] = t[9] + i[9]),
                  (e1[10] = t[10] + i[10]),
                  (e1[11] = t[11] + i[11]),
                  (e1[12] = t[12] + i[12]),
                  (e1[13] = t[13] + i[13]),
                  (e1[14] = t[14] + i[14]),
                  (e1[15] = t[15] + i[15]),
                  e1
                );
              }),
              (Ec.subtract = Lc),
              (Ec.multiplyScalar = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  (e1[4] = t[4] * i),
                  (e1[5] = t[5] * i),
                  (e1[6] = t[6] * i),
                  (e1[7] = t[7] * i),
                  (e1[8] = t[8] * i),
                  (e1[9] = t[9] * i),
                  (e1[10] = t[10] * i),
                  (e1[11] = t[11] * i),
                  (e1[12] = t[12] * i),
                  (e1[13] = t[13] * i),
                  (e1[14] = t[14] * i),
                  (e1[15] = t[15] * i),
                  e1
                );
              }),
              (Ec.multiplyScalarAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  (e1[3] = t[3] + i[3] * r),
                  (e1[4] = t[4] + i[4] * r),
                  (e1[5] = t[5] + i[5] * r),
                  (e1[6] = t[6] + i[6] * r),
                  (e1[7] = t[7] + i[7] * r),
                  (e1[8] = t[8] + i[8] * r),
                  (e1[9] = t[9] + i[9] * r),
                  (e1[10] = t[10] + i[10] * r),
                  (e1[11] = t[11] + i[11] * r),
                  (e1[12] = t[12] + i[12] * r),
                  (e1[13] = t[13] + i[13] * r),
                  (e1[14] = t[14] + i[14] * r),
                  (e1[15] = t[15] + i[15] * r),
                  e1
                );
              }),
              (Ec.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3] &&
                  e1[4] === t[4] &&
                  e1[5] === t[5] &&
                  e1[6] === t[6] &&
                  e1[7] === t[7] &&
                  e1[8] === t[8] &&
                  e1[9] === t[9] &&
                  e1[10] === t[10] &&
                  e1[11] === t[11] &&
                  e1[12] === t[12] &&
                  e1[13] === t[13] &&
                  e1[14] === t[14] &&
                  e1[15] === t[15]
                );
              }),
              (Ec.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = e1[4],
                  a = e1[5],
                  l = e1[6],
                  c = e1[7],
                  h = e1[8],
                  u = e1[9],
                  d = e1[10],
                  p = e1[11],
                  f = e1[12],
                  m = e1[13],
                  _ = e1[14],
                  g = e1[15],
                  y = t[0],
                  x = t[1],
                  v = t[2],
                  b = t[3],
                  w = t[4],
                  T = t[5],
                  E = t[6],
                  M = t[7],
                  A = t[8],
                  S = t[9],
                  I = t[10],
                  C = t[11],
                  z = t[12],
                  D = t[13],
                  P = t[14],
                  R = t[15];
                return (
                  Math.abs(i - y) <=
                    Ac.EPSILON * Math.max(1, Math.abs(i), Math.abs(y)) &&
                  Math.abs(r - x) <=
                    Ac.EPSILON * Math.max(1, Math.abs(r), Math.abs(x)) &&
                  Math.abs(n - v) <=
                    Ac.EPSILON * Math.max(1, Math.abs(n), Math.abs(v)) &&
                  Math.abs(o - b) <=
                    Ac.EPSILON * Math.max(1, Math.abs(o), Math.abs(b)) &&
                  Math.abs(s - w) <=
                    Ac.EPSILON * Math.max(1, Math.abs(s), Math.abs(w)) &&
                  Math.abs(a - T) <=
                    Ac.EPSILON * Math.max(1, Math.abs(a), Math.abs(T)) &&
                  Math.abs(l - E) <=
                    Ac.EPSILON * Math.max(1, Math.abs(l), Math.abs(E)) &&
                  Math.abs(c - M) <=
                    Ac.EPSILON * Math.max(1, Math.abs(c), Math.abs(M)) &&
                  Math.abs(h - A) <=
                    Ac.EPSILON * Math.max(1, Math.abs(h), Math.abs(A)) &&
                  Math.abs(u - S) <=
                    Ac.EPSILON * Math.max(1, Math.abs(u), Math.abs(S)) &&
                  Math.abs(d - I) <=
                    Ac.EPSILON * Math.max(1, Math.abs(d), Math.abs(I)) &&
                  Math.abs(p - C) <=
                    Ac.EPSILON * Math.max(1, Math.abs(p), Math.abs(C)) &&
                  Math.abs(f - z) <=
                    Ac.EPSILON * Math.max(1, Math.abs(f), Math.abs(z)) &&
                  Math.abs(m - D) <=
                    Ac.EPSILON * Math.max(1, Math.abs(m), Math.abs(D)) &&
                  Math.abs(_ - P) <=
                    Ac.EPSILON * Math.max(1, Math.abs(_), Math.abs(P)) &&
                  Math.abs(g - R) <=
                    Ac.EPSILON * Math.max(1, Math.abs(g), Math.abs(R))
                );
              }),
              (Ec.sub = Ec.mul = Ec.ortho = Ec.perspective = void 0);
            var Ac = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== Mc(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = Sc(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function Sc(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (Sc = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function Ic(e1) {
              return (
                (e1[0] = 1),
                (e1[1] = 0),
                (e1[2] = 0),
                (e1[3] = 0),
                (e1[4] = 0),
                (e1[5] = 1),
                (e1[6] = 0),
                (e1[7] = 0),
                (e1[8] = 0),
                (e1[9] = 0),
                (e1[10] = 1),
                (e1[11] = 0),
                (e1[12] = 0),
                (e1[13] = 0),
                (e1[14] = 0),
                (e1[15] = 1),
                e1
              );
            }
            function Cc(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = t[4],
                l = t[5],
                c = t[6],
                h = t[7],
                u = t[8],
                d = t[9],
                p = t[10],
                f = t[11],
                m = t[12],
                _ = t[13],
                g = t[14],
                y = t[15],
                x = i[0],
                v = i[1],
                b = i[2],
                w = i[3];
              return (
                (e1[0] = x * r + v * a + b * u + w * m),
                (e1[1] = x * n + v * l + b * d + w * _),
                (e1[2] = x * o + v * c + b * p + w * g),
                (e1[3] = x * s + v * h + b * f + w * y),
                (e1[4] =
                  (x = i[4]) * r +
                  (v = i[5]) * a +
                  (b = i[6]) * u +
                  (w = i[7]) * m),
                (e1[5] = x * n + v * l + b * d + w * _),
                (e1[6] = x * o + v * c + b * p + w * g),
                (e1[7] = x * s + v * h + b * f + w * y),
                (e1[8] =
                  (x = i[8]) * r +
                  (v = i[9]) * a +
                  (b = i[10]) * u +
                  (w = i[11]) * m),
                (e1[9] = x * n + v * l + b * d + w * _),
                (e1[10] = x * o + v * c + b * p + w * g),
                (e1[11] = x * s + v * h + b * f + w * y),
                (e1[12] =
                  (x = i[12]) * r +
                  (v = i[13]) * a +
                  (b = i[14]) * u +
                  (w = i[15]) * m),
                (e1[13] = x * n + v * l + b * d + w * _),
                (e1[14] = x * o + v * c + b * p + w * g),
                (e1[15] = x * s + v * h + b * f + w * y),
                e1
              );
            }
            function zc(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = r + r,
                l = n + n,
                c = o + o,
                h = r * a,
                u = r * l,
                d = r * c,
                p = n * l,
                f = n * c,
                m = o * c,
                _ = s * a,
                g = s * l,
                y = s * c;
              return (
                (e1[0] = 1 - (p + m)),
                (e1[1] = u + y),
                (e1[2] = d - g),
                (e1[3] = 0),
                (e1[4] = u - y),
                (e1[5] = 1 - (h + m)),
                (e1[6] = f + _),
                (e1[7] = 0),
                (e1[8] = d + g),
                (e1[9] = f - _),
                (e1[10] = 1 - (h + p)),
                (e1[11] = 0),
                (e1[12] = i[0]),
                (e1[13] = i[1]),
                (e1[14] = i[2]),
                (e1[15] = 1),
                e1
              );
            }
            function Dc(e1, t) {
              var i = t[4],
                r = t[5],
                n = t[6],
                o = t[8],
                s = t[9],
                a = t[10];
              return (
                (e1[0] = Math.hypot(t[0], t[1], t[2])),
                (e1[1] = Math.hypot(i, r, n)),
                (e1[2] = Math.hypot(o, s, a)),
                e1
              );
            }
            function Pc(e1, t, i, r, n) {
              var o,
                s = 1 / Math.tan(t / 2);
              return (
                (e1[0] = s / i),
                (e1[1] = 0),
                (e1[2] = 0),
                (e1[3] = 0),
                (e1[4] = 0),
                (e1[5] = s),
                (e1[6] = 0),
                (e1[7] = 0),
                (e1[8] = 0),
                (e1[9] = 0),
                (e1[11] = -1),
                (e1[12] = 0),
                (e1[13] = 0),
                (e1[15] = 0),
                null != n && n !== 1 / 0
                  ? ((e1[10] = (n + r) * (o = 1 / (r - n))),
                    (e1[14] = 2 * n * r * o))
                  : ((e1[10] = -1), (e1[14] = -2 * r)),
                e1
              );
            }
            function Rc(e1, t, i, r, n, o, s) {
              var a = 1 / (t - i),
                l = 1 / (r - n),
                c = 1 / (o - s);
              return (
                (e1[0] = -2 * a),
                (e1[1] = 0),
                (e1[2] = 0),
                (e1[3] = 0),
                (e1[4] = 0),
                (e1[5] = -2 * l),
                (e1[6] = 0),
                (e1[7] = 0),
                (e1[8] = 0),
                (e1[9] = 0),
                (e1[10] = 2 * c),
                (e1[11] = 0),
                (e1[12] = (t + i) * a),
                (e1[13] = (n + r) * l),
                (e1[14] = (s + o) * c),
                (e1[15] = 1),
                e1
              );
            }
            function Lc(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                (e1[3] = t[3] - i[3]),
                (e1[4] = t[4] - i[4]),
                (e1[5] = t[5] - i[5]),
                (e1[6] = t[6] - i[6]),
                (e1[7] = t[7] - i[7]),
                (e1[8] = t[8] - i[8]),
                (e1[9] = t[9] - i[9]),
                (e1[10] = t[10] - i[10]),
                (e1[11] = t[11] - i[11]),
                (e1[12] = t[12] - i[12]),
                (e1[13] = t[13] - i[13]),
                (e1[14] = t[14] - i[14]),
                (e1[15] = t[15] - i[15]),
                e1
              );
            }
            (Ec.perspective = Pc),
              (Ec.ortho = Rc),
              (Ec.mul = Cc),
              (Ec.sub = Lc);
            var kc = {},
              Oc = {};
            function Bc(e1) {
              return (
                (Bc =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                Bc(e1)
              );
            }
            Object.defineProperty(Oc, "__esModule", {
              value: !0,
            }),
              (Oc.create = Uc),
              (Oc.clone = function (e1) {
                var t = new Fc.ARRAY_TYPE(3);
                return (t[0] = e1[0]), (t[1] = e1[1]), (t[2] = e1[2]), t;
              }),
              (Oc.length = Vc),
              (Oc.fromValues = function (e1, t, i) {
                var r = new Fc.ARRAY_TYPE(3);
                return (r[0] = e1), (r[1] = t), (r[2] = i), r;
              }),
              (Oc.copy = function (e1, t) {
                return (e1[0] = t[0]), (e1[1] = t[1]), (e1[2] = t[2]), e1;
              }),
              (Oc.set = function (e1, t, i, r) {
                return (e1[0] = t), (e1[1] = i), (e1[2] = r), e1;
              }),
              (Oc.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  e1
                );
              }),
              (Oc.subtract = jc),
              (Oc.multiply = Gc),
              (Oc.divide = qc),
              (Oc.ceil = function (e1, t) {
                return (
                  (e1[0] = Math.ceil(t[0])),
                  (e1[1] = Math.ceil(t[1])),
                  (e1[2] = Math.ceil(t[2])),
                  e1
                );
              }),
              (Oc.floor = function (e1, t) {
                return (
                  (e1[0] = Math.floor(t[0])),
                  (e1[1] = Math.floor(t[1])),
                  (e1[2] = Math.floor(t[2])),
                  e1
                );
              }),
              (Oc.min = function (e1, t, i) {
                return (
                  (e1[0] = Math.min(t[0], i[0])),
                  (e1[1] = Math.min(t[1], i[1])),
                  (e1[2] = Math.min(t[2], i[2])),
                  e1
                );
              }),
              (Oc.max = function (e1, t, i) {
                return (
                  (e1[0] = Math.max(t[0], i[0])),
                  (e1[1] = Math.max(t[1], i[1])),
                  (e1[2] = Math.max(t[2], i[2])),
                  e1
                );
              }),
              (Oc.round = function (e1, t) {
                return (
                  (e1[0] = Math.round(t[0])),
                  (e1[1] = Math.round(t[1])),
                  (e1[2] = Math.round(t[2])),
                  e1
                );
              }),
              (Oc.scale = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i), (e1[1] = t[1] * i), (e1[2] = t[2] * i), e1
                );
              }),
              (Oc.scaleAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  e1
                );
              }),
              (Oc.distance = Zc),
              (Oc.squaredDistance = $c),
              (Oc.squaredLength = Hc),
              (Oc.negate = function (e1, t) {
                return (e1[0] = -t[0]), (e1[1] = -t[1]), (e1[2] = -t[2]), e1;
              }),
              (Oc.inverse = function (e1, t) {
                return (
                  (e1[0] = 1 / t[0]), (e1[1] = 1 / t[1]), (e1[2] = 1 / t[2]), e1
                );
              }),
              (Oc.normalize = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = i * i + r * r + n * n;
                return (
                  o > 0 && (o = 1 / Math.sqrt(o)),
                  (e1[0] = t[0] * o),
                  (e1[1] = t[1] * o),
                  (e1[2] = t[2] * o),
                  e1
                );
              }),
              (Oc.dot = Wc),
              (Oc.cross = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = i[0],
                  a = i[1],
                  l = i[2];
                return (
                  (e1[0] = n * l - o * a),
                  (e1[1] = o * s - r * l),
                  (e1[2] = r * a - n * s),
                  e1
                );
              }),
              (Oc.lerp = function (e1, t, i, r) {
                var n = t[0],
                  o = t[1],
                  s = t[2];
                return (
                  (e1[0] = n + r * (i[0] - n)),
                  (e1[1] = o + r * (i[1] - o)),
                  (e1[2] = s + r * (i[2] - s)),
                  e1
                );
              }),
              (Oc.hermite = function (e1, t, i, r, n, o) {
                var s = o * o,
                  a = s * (2 * o - 3) + 1,
                  l = s * (o - 2) + o,
                  c = s * (o - 1),
                  h = s * (3 - 2 * o);
                return (
                  (e1[0] = t[0] * a + i[0] * l + r[0] * c + n[0] * h),
                  (e1[1] = t[1] * a + i[1] * l + r[1] * c + n[1] * h),
                  (e1[2] = t[2] * a + i[2] * l + r[2] * c + n[2] * h),
                  e1
                );
              }),
              (Oc.bezier = function (e1, t, i, r, n, o) {
                var s = 1 - o,
                  a = s * s,
                  l = o * o,
                  c = a * s,
                  h = 3 * o * a,
                  u = 3 * l * s,
                  d = l * o;
                return (
                  (e1[0] = t[0] * c + i[0] * h + r[0] * u + n[0] * d),
                  (e1[1] = t[1] * c + i[1] * h + r[1] * u + n[1] * d),
                  (e1[2] = t[2] * c + i[2] * h + r[2] * u + n[2] * d),
                  e1
                );
              }),
              (Oc.random = function (e1, t) {
                t = t || 1;
                var i = 2 * Fc.RANDOM() * Math.PI,
                  r = 2 * Fc.RANDOM() - 1,
                  n = Math.sqrt(1 - r * r) * t;
                return (
                  (e1[0] = Math.cos(i) * n),
                  (e1[1] = Math.sin(i) * n),
                  (e1[2] = r * t),
                  e1
                );
              }),
              (Oc.transformMat4 = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = i[3] * r + i[7] * n + i[11] * o + i[15];
                return (
                  (e1[0] =
                    (i[0] * r + i[4] * n + i[8] * o + i[12]) / (s = s || 1)),
                  (e1[1] = (i[1] * r + i[5] * n + i[9] * o + i[13]) / s),
                  (e1[2] = (i[2] * r + i[6] * n + i[10] * o + i[14]) / s),
                  e1
                );
              }),
              (Oc.transformMat3 = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2];
                return (
                  (e1[0] = r * i[0] + n * i[3] + o * i[6]),
                  (e1[1] = r * i[1] + n * i[4] + o * i[7]),
                  (e1[2] = r * i[2] + n * i[5] + o * i[8]),
                  e1
                );
              }),
              (Oc.transformQuat = function (e1, t, i) {
                var r = i[0],
                  n = i[1],
                  o = i[2],
                  s = t[0],
                  a = t[1],
                  l = t[2],
                  c = n * l - o * a,
                  h = o * s - r * l,
                  u = r * a - n * s,
                  d = n * u - o * h,
                  p = o * c - r * u,
                  f = r * h - n * c,
                  m = 2 * i[3];
                return (
                  (h *= m),
                  (u *= m),
                  (p *= 2),
                  (f *= 2),
                  (e1[0] = s + (c *= m) + (d *= 2)),
                  (e1[1] = a + h + p),
                  (e1[2] = l + u + f),
                  e1
                );
              }),
              (Oc.rotateX = function (e1, t, i, r) {
                var n = [],
                  o = [];
                return (
                  (n[0] = t[0] - i[0]),
                  (n[1] = t[1] - i[1]),
                  (n[2] = t[2] - i[2]),
                  (o[0] = n[0]),
                  (o[1] = n[1] * Math.cos(r) - n[2] * Math.sin(r)),
                  (o[2] = n[1] * Math.sin(r) + n[2] * Math.cos(r)),
                  (e1[0] = o[0] + i[0]),
                  (e1[1] = o[1] + i[1]),
                  (e1[2] = o[2] + i[2]),
                  e1
                );
              }),
              (Oc.rotateY = function (e1, t, i, r) {
                var n = [],
                  o = [];
                return (
                  (n[0] = t[0] - i[0]),
                  (n[1] = t[1] - i[1]),
                  (n[2] = t[2] - i[2]),
                  (o[0] = n[2] * Math.sin(r) + n[0] * Math.cos(r)),
                  (o[1] = n[1]),
                  (o[2] = n[2] * Math.cos(r) - n[0] * Math.sin(r)),
                  (e1[0] = o[0] + i[0]),
                  (e1[1] = o[1] + i[1]),
                  (e1[2] = o[2] + i[2]),
                  e1
                );
              }),
              (Oc.rotateZ = function (e1, t, i, r) {
                var n = [],
                  o = [];
                return (
                  (n[0] = t[0] - i[0]),
                  (n[1] = t[1] - i[1]),
                  (n[2] = t[2] - i[2]),
                  (o[0] = n[0] * Math.cos(r) - n[1] * Math.sin(r)),
                  (o[1] = n[0] * Math.sin(r) + n[1] * Math.cos(r)),
                  (o[2] = n[2]),
                  (e1[0] = o[0] + i[0]),
                  (e1[1] = o[1] + i[1]),
                  (e1[2] = o[2] + i[2]),
                  e1
                );
              }),
              (Oc.angle = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = t[0],
                  s = t[1],
                  a = t[2],
                  l =
                    Math.sqrt(i * i + r * r + n * n) *
                    Math.sqrt(o * o + s * s + a * a),
                  c = l && Wc(e1, t) / l;
                return Math.acos(Math.min(Math.max(c, -1), 1));
              }),
              (Oc.zero = function (e1) {
                return (e1[0] = 0), (e1[1] = 0), (e1[2] = 0), e1;
              }),
              (Oc.str = function (e1) {
                return "vec3(" + e1[0] + ", " + e1[1] + ", " + e1[2] + ")";
              }),
              (Oc.exactEquals = function (e1, t) {
                return e1[0] === t[0] && e1[1] === t[1] && e1[2] === t[2];
              }),
              (Oc.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = t[0],
                  s = t[1],
                  a = t[2];
                return (
                  Math.abs(i - o) <=
                    Fc.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) &&
                  Math.abs(r - s) <=
                    Fc.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) &&
                  Math.abs(n - a) <=
                    Fc.EPSILON * Math.max(1, Math.abs(n), Math.abs(a))
                );
              }),
              (Oc.forEach =
                Oc.sqrLen =
                Oc.len =
                Oc.sqrDist =
                Oc.dist =
                Oc.div =
                Oc.mul =
                Oc.sub =
                  void 0);
            var Fc = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== Bc(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = Nc(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function Nc(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (Nc = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function Uc() {
              var e1 = new Fc.ARRAY_TYPE(3);
              return (
                Fc.ARRAY_TYPE != Float32Array &&
                  ((e1[0] = 0), (e1[1] = 0), (e1[2] = 0)),
                e1
              );
            }
            function Vc(e1) {
              return Math.hypot(e1[0], e1[1], e1[2]);
            }
            function jc(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                e1
              );
            }
            function Gc(e1, t, i) {
              return (
                (e1[0] = t[0] * i[0]),
                (e1[1] = t[1] * i[1]),
                (e1[2] = t[2] * i[2]),
                e1
              );
            }
            function qc(e1, t, i) {
              return (
                (e1[0] = t[0] / i[0]),
                (e1[1] = t[1] / i[1]),
                (e1[2] = t[2] / i[2]),
                e1
              );
            }
            function Zc(e1, t) {
              return Math.hypot(t[0] - e1[0], t[1] - e1[1], t[2] - e1[2]);
            }
            function $c(e1, t) {
              var i = t[0] - e1[0],
                r = t[1] - e1[1],
                n = t[2] - e1[2];
              return i * i + r * r + n * n;
            }
            function Hc(e1) {
              var t = e1[0],
                i = e1[1],
                r = e1[2];
              return t * t + i * i + r * r;
            }
            function Wc(e1, t) {
              return e1[0] * t[0] + e1[1] * t[1] + e1[2] * t[2];
            }
            (Oc.sub = jc),
              (Oc.mul = Gc),
              (Oc.div = qc),
              (Oc.dist = Zc),
              (Oc.sqrDist = $c),
              (Oc.len = Vc),
              (Oc.sqrLen = Hc);
            var Xc,
              Yc =
                ((Xc = Uc()),
                function (e1, t, i, r, n, o) {
                  var s, a;
                  for (
                    t || (t = 3),
                      i || (i = 0),
                      a = r ? Math.min(r * t + i, e1.length) : e1.length,
                      s = i;
                    s < a;
                    s += t
                  )
                    (Xc[0] = e1[s]),
                      (Xc[1] = e1[s + 1]),
                      (Xc[2] = e1[s + 2]),
                      n(Xc, Xc, o),
                      (e1[s] = Xc[0]),
                      (e1[s + 1] = Xc[1]),
                      (e1[s + 2] = Xc[2]);
                  return e1;
                });
            Oc.forEach = Yc;
            var Kc = {};
            function Jc(e1) {
              return (
                (Jc =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                Jc(e1)
              );
            }
            Object.defineProperty(Kc, "__esModule", {
              value: !0,
            }),
              (Kc.create = th),
              (Kc.clone = function (e1) {
                var t = new Qc.ARRAY_TYPE(4);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  t
                );
              }),
              (Kc.fromValues = function (e1, t, i, r) {
                var n = new Qc.ARRAY_TYPE(4);
                return (n[0] = e1), (n[1] = t), (n[2] = i), (n[3] = r), n;
              }),
              (Kc.copy = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  e1
                );
              }),
              (Kc.set = function (e1, t, i, r, n) {
                return (e1[0] = t), (e1[1] = i), (e1[2] = r), (e1[3] = n), e1;
              }),
              (Kc.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  e1
                );
              }),
              (Kc.subtract = ih),
              (Kc.multiply = rh),
              (Kc.divide = nh),
              (Kc.ceil = function (e1, t) {
                return (
                  (e1[0] = Math.ceil(t[0])),
                  (e1[1] = Math.ceil(t[1])),
                  (e1[2] = Math.ceil(t[2])),
                  (e1[3] = Math.ceil(t[3])),
                  e1
                );
              }),
              (Kc.floor = function (e1, t) {
                return (
                  (e1[0] = Math.floor(t[0])),
                  (e1[1] = Math.floor(t[1])),
                  (e1[2] = Math.floor(t[2])),
                  (e1[3] = Math.floor(t[3])),
                  e1
                );
              }),
              (Kc.min = function (e1, t, i) {
                return (
                  (e1[0] = Math.min(t[0], i[0])),
                  (e1[1] = Math.min(t[1], i[1])),
                  (e1[2] = Math.min(t[2], i[2])),
                  (e1[3] = Math.min(t[3], i[3])),
                  e1
                );
              }),
              (Kc.max = function (e1, t, i) {
                return (
                  (e1[0] = Math.max(t[0], i[0])),
                  (e1[1] = Math.max(t[1], i[1])),
                  (e1[2] = Math.max(t[2], i[2])),
                  (e1[3] = Math.max(t[3], i[3])),
                  e1
                );
              }),
              (Kc.round = function (e1, t) {
                return (
                  (e1[0] = Math.round(t[0])),
                  (e1[1] = Math.round(t[1])),
                  (e1[2] = Math.round(t[2])),
                  (e1[3] = Math.round(t[3])),
                  e1
                );
              }),
              (Kc.scale = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  e1
                );
              }),
              (Kc.scaleAndAdd = function (e1, t, i, r) {
                return (
                  (e1[0] = t[0] + i[0] * r),
                  (e1[1] = t[1] + i[1] * r),
                  (e1[2] = t[2] + i[2] * r),
                  (e1[3] = t[3] + i[3] * r),
                  e1
                );
              }),
              (Kc.distance = oh),
              (Kc.squaredDistance = sh),
              (Kc.length = ah),
              (Kc.squaredLength = lh),
              (Kc.negate = function (e1, t) {
                return (
                  (e1[0] = -t[0]),
                  (e1[1] = -t[1]),
                  (e1[2] = -t[2]),
                  (e1[3] = -t[3]),
                  e1
                );
              }),
              (Kc.inverse = function (e1, t) {
                return (
                  (e1[0] = 1 / t[0]),
                  (e1[1] = 1 / t[1]),
                  (e1[2] = 1 / t[2]),
                  (e1[3] = 1 / t[3]),
                  e1
                );
              }),
              (Kc.normalize = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i * i + r * r + n * n + o * o;
                return (
                  s > 0 && (s = 1 / Math.sqrt(s)),
                  (e1[0] = i * s),
                  (e1[1] = r * s),
                  (e1[2] = n * s),
                  (e1[3] = o * s),
                  e1
                );
              }),
              (Kc.dot = function (e1, t) {
                return (
                  e1[0] * t[0] + e1[1] * t[1] + e1[2] * t[2] + e1[3] * t[3]
                );
              }),
              (Kc.cross = function (e1, t, i, r) {
                var n = i[0] * r[1] - i[1] * r[0],
                  o = i[0] * r[2] - i[2] * r[0],
                  s = i[0] * r[3] - i[3] * r[0],
                  a = i[1] * r[2] - i[2] * r[1],
                  l = i[1] * r[3] - i[3] * r[1],
                  c = i[2] * r[3] - i[3] * r[2],
                  h = t[0],
                  u = t[1],
                  d = t[2],
                  p = t[3];
                return (
                  (e1[0] = u * c - d * l + p * a),
                  (e1[1] = -h * c + d * s - p * o),
                  (e1[2] = h * l - u * s + p * n),
                  (e1[3] = -h * a + u * o - d * n),
                  e1
                );
              }),
              (Kc.lerp = function (e1, t, i, r) {
                var n = t[0],
                  o = t[1],
                  s = t[2],
                  a = t[3];
                return (
                  (e1[0] = n + r * (i[0] - n)),
                  (e1[1] = o + r * (i[1] - o)),
                  (e1[2] = s + r * (i[2] - s)),
                  (e1[3] = a + r * (i[3] - a)),
                  e1
                );
              }),
              (Kc.random = function (e1, t) {
                var i, r, n, o, s, a;
                t = t || 1;
                do
                  s =
                    (i = 2 * Qc.RANDOM() - 1) * i +
                    (r = 2 * Qc.RANDOM() - 1) * r;
                while (s >= 1);
                do
                  a =
                    (n = 2 * Qc.RANDOM() - 1) * n +
                    (o = 2 * Qc.RANDOM() - 1) * o;
                while (a >= 1);
                var l = Math.sqrt((1 - s) / a);
                return (
                  (e1[0] = t * i),
                  (e1[1] = t * r),
                  (e1[2] = t * n * l),
                  (e1[3] = t * o * l),
                  e1
                );
              }),
              (Kc.transformMat4 = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3];
                return (
                  (e1[0] = i[0] * r + i[4] * n + i[8] * o + i[12] * s),
                  (e1[1] = i[1] * r + i[5] * n + i[9] * o + i[13] * s),
                  (e1[2] = i[2] * r + i[6] * n + i[10] * o + i[14] * s),
                  (e1[3] = i[3] * r + i[7] * n + i[11] * o + i[15] * s),
                  e1
                );
              }),
              (Kc.transformQuat = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = i[0],
                  a = i[1],
                  l = i[2],
                  c = i[3],
                  h = c * r + a * o - l * n,
                  u = c * n + l * r - s * o,
                  d = c * o + s * n - a * r,
                  p = -s * r - a * n - l * o;
                return (
                  (e1[0] = h * c + p * -s + u * -l - d * -a),
                  (e1[1] = u * c + p * -a + d * -s - h * -l),
                  (e1[2] = d * c + p * -l + h * -a - u * -s),
                  (e1[3] = t[3]),
                  e1
                );
              }),
              (Kc.zero = function (e1) {
                return (e1[0] = 0), (e1[1] = 0), (e1[2] = 0), (e1[3] = 0), e1;
              }),
              (Kc.str = function (e1) {
                return (
                  "vec4(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ")"
                );
              }),
              (Kc.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3]
                );
              }),
              (Kc.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = t[0],
                  a = t[1],
                  l = t[2],
                  c = t[3];
                return (
                  Math.abs(i - s) <=
                    Qc.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) &&
                  Math.abs(r - a) <=
                    Qc.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) &&
                  Math.abs(n - l) <=
                    Qc.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) &&
                  Math.abs(o - c) <=
                    Qc.EPSILON * Math.max(1, Math.abs(o), Math.abs(c))
                );
              }),
              (Kc.forEach =
                Kc.sqrLen =
                Kc.len =
                Kc.sqrDist =
                Kc.dist =
                Kc.div =
                Kc.mul =
                Kc.sub =
                  void 0);
            var Qc = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== Jc(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = eh(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function eh(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (eh = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function th() {
              var e1 = new Qc.ARRAY_TYPE(4);
              return (
                Qc.ARRAY_TYPE != Float32Array &&
                  ((e1[0] = 0), (e1[1] = 0), (e1[2] = 0), (e1[3] = 0)),
                e1
              );
            }
            function ih(e1, t, i) {
              return (
                (e1[0] = t[0] - i[0]),
                (e1[1] = t[1] - i[1]),
                (e1[2] = t[2] - i[2]),
                (e1[3] = t[3] - i[3]),
                e1
              );
            }
            function rh(e1, t, i) {
              return (
                (e1[0] = t[0] * i[0]),
                (e1[1] = t[1] * i[1]),
                (e1[2] = t[2] * i[2]),
                (e1[3] = t[3] * i[3]),
                e1
              );
            }
            function nh(e1, t, i) {
              return (
                (e1[0] = t[0] / i[0]),
                (e1[1] = t[1] / i[1]),
                (e1[2] = t[2] / i[2]),
                (e1[3] = t[3] / i[3]),
                e1
              );
            }
            function oh(e1, t) {
              return Math.hypot(
                t[0] - e1[0],
                t[1] - e1[1],
                t[2] - e1[2],
                t[3] - e1[3],
              );
            }
            function sh(e1, t) {
              var i = t[0] - e1[0],
                r = t[1] - e1[1],
                n = t[2] - e1[2],
                o = t[3] - e1[3];
              return i * i + r * r + n * n + o * o;
            }
            function ah(e1) {
              return Math.hypot(e1[0], e1[1], e1[2], e1[3]);
            }
            function lh(e1) {
              var t = e1[0],
                i = e1[1],
                r = e1[2],
                n = e1[3];
              return t * t + i * i + r * r + n * n;
            }
            (Kc.sub = ih),
              (Kc.mul = rh),
              (Kc.div = nh),
              (Kc.dist = oh),
              (Kc.sqrDist = sh),
              (Kc.len = ah),
              (Kc.sqrLen = lh);
            var ch = (function () {
              var e1 = th();
              return function (t, i, r, n, o, s) {
                var a, l;
                for (
                  i || (i = 4),
                    r || (r = 0),
                    l = n ? Math.min(n * i + r, t.length) : t.length,
                    a = r;
                  a < l;
                  a += i
                )
                  (e1[0] = t[a]),
                    (e1[1] = t[a + 1]),
                    (e1[2] = t[a + 2]),
                    (e1[3] = t[a + 3]),
                    o(e1, e1, s),
                    (t[a] = e1[0]),
                    (t[a + 1] = e1[1]),
                    (t[a + 2] = e1[2]),
                    (t[a + 3] = e1[3]);
                return t;
              };
            })();
            function hh(e1) {
              return (
                (hh =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                hh(e1)
              );
            }
            (Kc.forEach = ch),
              Object.defineProperty(kc, "__esModule", {
                value: !0,
              }),
              (kc.create = gh),
              (kc.identity = function (e1) {
                return (e1[0] = 0), (e1[1] = 0), (e1[2] = 0), (e1[3] = 1), e1;
              }),
              (kc.setAxisAngle = yh),
              (kc.getAxisAngle = function (e1, t) {
                var i = 2 * Math.acos(t[3]),
                  r = Math.sin(i / 2);
                return (
                  r > uh.EPSILON
                    ? ((e1[0] = t[0] / r),
                      (e1[1] = t[1] / r),
                      (e1[2] = t[2] / r))
                    : ((e1[0] = 1), (e1[1] = 0), (e1[2] = 0)),
                  i
                );
              }),
              (kc.getAngle = function (e1, t) {
                var i = Mh(e1, t);
                return Math.acos(2 * i * i - 1);
              }),
              (kc.multiply = xh),
              (kc.rotateX = function (e1, t, i) {
                i *= 0.5;
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (e1[0] = r * l + s * a),
                  (e1[1] = n * l + o * a),
                  (e1[2] = o * l - n * a),
                  (e1[3] = s * l - r * a),
                  e1
                );
              }),
              (kc.rotateY = function (e1, t, i) {
                i *= 0.5;
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (e1[0] = r * l - o * a),
                  (e1[1] = n * l + s * a),
                  (e1[2] = o * l + r * a),
                  (e1[3] = s * l - n * a),
                  e1
                );
              }),
              (kc.rotateZ = function (e1, t, i) {
                i *= 0.5;
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (e1[0] = r * l + n * a),
                  (e1[1] = n * l - r * a),
                  (e1[2] = o * l + s * a),
                  (e1[3] = s * l - o * a),
                  e1
                );
              }),
              (kc.calculateW = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2];
                return (
                  (e1[0] = i),
                  (e1[1] = r),
                  (e1[2] = n),
                  (e1[3] = Math.sqrt(Math.abs(1 - i * i - r * r - n * n))),
                  e1
                );
              }),
              (kc.exp = vh),
              (kc.ln = bh),
              (kc.pow = function (e1, t, i) {
                return bh(e1, t), Eh(e1, e1, i), vh(e1, e1), e1;
              }),
              (kc.slerp = wh),
              (kc.random = function (e1) {
                var t = uh.RANDOM(),
                  i = uh.RANDOM(),
                  r = uh.RANDOM(),
                  n = Math.sqrt(1 - t),
                  o = Math.sqrt(t);
                return (
                  (e1[0] = n * Math.sin(2 * Math.PI * i)),
                  (e1[1] = n * Math.cos(2 * Math.PI * i)),
                  (e1[2] = o * Math.sin(2 * Math.PI * r)),
                  (e1[3] = o * Math.cos(2 * Math.PI * r)),
                  e1
                );
              }),
              (kc.invert = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = t[2],
                  o = t[3],
                  s = i * i + r * r + n * n + o * o,
                  a = s ? 1 / s : 0;
                return (
                  (e1[0] = -i * a),
                  (e1[1] = -r * a),
                  (e1[2] = -n * a),
                  (e1[3] = o * a),
                  e1
                );
              }),
              (kc.conjugate = function (e1, t) {
                return (
                  (e1[0] = -t[0]),
                  (e1[1] = -t[1]),
                  (e1[2] = -t[2]),
                  (e1[3] = t[3]),
                  e1
                );
              }),
              (kc.fromMat3 = Th),
              (kc.fromEuler = function (e1, t, i, r) {
                var n = (0.5 * Math.PI) / 180;
                (t *= n), (i *= n), (r *= n);
                var o = Math.sin(t),
                  s = Math.cos(t),
                  a = Math.sin(i),
                  l = Math.cos(i),
                  c = Math.sin(r),
                  h = Math.cos(r);
                return (
                  (e1[0] = o * l * h - s * a * c),
                  (e1[1] = s * a * h + o * l * c),
                  (e1[2] = s * l * c - o * a * h),
                  (e1[3] = s * l * h + o * a * c),
                  e1
                );
              }),
              (kc.str = function (e1) {
                return (
                  "quat(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ")"
                );
              }),
              (kc.setAxes =
                kc.sqlerp =
                kc.rotationTo =
                kc.equals =
                kc.exactEquals =
                kc.normalize =
                kc.sqrLen =
                kc.squaredLength =
                kc.len =
                kc.length =
                kc.lerp =
                kc.dot =
                kc.scale =
                kc.mul =
                kc.add =
                kc.set =
                kc.copy =
                kc.fromValues =
                kc.clone =
                  void 0);
            var uh = _h(tc),
              dh = _h(yc),
              ph = _h(Oc),
              fh = _h(Kc);
            function mh(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (mh = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function _h(e1, t) {
              if (!t && e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== hh(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = mh(t);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            }
            function gh() {
              var e1 = new uh.ARRAY_TYPE(4);
              return (
                uh.ARRAY_TYPE != Float32Array &&
                  ((e1[0] = 0), (e1[1] = 0), (e1[2] = 0)),
                (e1[3] = 1),
                e1
              );
            }
            function yh(e1, t, i) {
              i *= 0.5;
              var r = Math.sin(i);
              return (
                (e1[0] = r * t[0]),
                (e1[1] = r * t[1]),
                (e1[2] = r * t[2]),
                (e1[3] = Math.cos(i)),
                e1
              );
            }
            function xh(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = i[0],
                l = i[1],
                c = i[2],
                h = i[3];
              return (
                (e1[0] = r * h + s * a + n * c - o * l),
                (e1[1] = n * h + s * l + o * a - r * c),
                (e1[2] = o * h + s * c + r * l - n * a),
                (e1[3] = s * h - r * a - n * l - o * c),
                e1
              );
            }
            function vh(e1, t) {
              var i = t[0],
                r = t[1],
                n = t[2],
                o = t[3],
                s = Math.sqrt(i * i + r * r + n * n),
                a = Math.exp(o),
                l = s > 0 ? (a * Math.sin(s)) / s : 0;
              return (
                (e1[0] = i * l),
                (e1[1] = r * l),
                (e1[2] = n * l),
                (e1[3] = a * Math.cos(s)),
                e1
              );
            }
            function bh(e1, t) {
              var i = t[0],
                r = t[1],
                n = t[2],
                o = t[3],
                s = Math.sqrt(i * i + r * r + n * n),
                a = s > 0 ? Math.atan2(s, o) / s : 0;
              return (
                (e1[0] = i * a),
                (e1[1] = r * a),
                (e1[2] = n * a),
                (e1[3] = 0.5 * Math.log(i * i + r * r + n * n + o * o)),
                e1
              );
            }
            function wh(e1, t, i, r) {
              var n,
                o,
                s,
                a,
                l,
                c = t[0],
                h = t[1],
                u = t[2],
                d = t[3],
                p = i[0],
                f = i[1],
                m = i[2],
                _ = i[3];
              return (
                (o = c * p + h * f + u * m + d * _) < 0 &&
                  ((o = -o), (p = -p), (f = -f), (m = -m), (_ = -_)),
                1 - o > uh.EPSILON
                  ? ((n = Math.acos(o)),
                    (s = Math.sin(n)),
                    (a = Math.sin((1 - r) * n) / s),
                    (l = Math.sin(r * n) / s))
                  : ((a = 1 - r), (l = r)),
                (e1[0] = a * c + l * p),
                (e1[1] = a * h + l * f),
                (e1[2] = a * u + l * m),
                (e1[3] = a * d + l * _),
                e1
              );
            }
            function Th(e1, t) {
              var i,
                r = t[0] + t[4] + t[8];
              if (r > 0)
                (i = Math.sqrt(r + 1)),
                  (e1[3] = 0.5 * i),
                  (e1[0] = (t[5] - t[7]) * (i = 0.5 / i)),
                  (e1[1] = (t[6] - t[2]) * i),
                  (e1[2] = (t[1] - t[3]) * i);
              else {
                var n = 0;
                t[4] > t[0] && (n = 1), t[8] > t[3 * n + n] && (n = 2);
                var o = (n + 1) % 3,
                  s = (n + 2) % 3;
                (i = Math.sqrt(t[3 * n + n] - t[3 * o + o] - t[3 * s + s] + 1)),
                  (e1[n] = 0.5 * i),
                  (e1[3] = (t[3 * o + s] - t[3 * s + o]) * (i = 0.5 / i)),
                  (e1[o] = (t[3 * o + n] + t[3 * n + o]) * i),
                  (e1[s] = (t[3 * s + n] + t[3 * n + s]) * i);
              }
              return e1;
            }
            (kc.clone = fh.clone),
              (kc.fromValues = fh.fromValues),
              (kc.copy = fh.copy),
              (kc.set = fh.set),
              (kc.add = fh.add),
              (kc.mul = xh);
            var Eh = fh.scale;
            kc.scale = Eh;
            var Mh = fh.dot;
            (kc.dot = Mh), (kc.lerp = fh.lerp);
            var Ah = fh.length;
            (kc.length = Ah), (kc.len = Ah);
            var Sh = fh.squaredLength;
            (kc.squaredLength = Sh), (kc.sqrLen = Sh);
            var Ih = fh.normalize;
            (kc.normalize = Ih),
              (kc.exactEquals = fh.exactEquals),
              (kc.equals = fh.equals);
            var Ch,
              zh,
              Dh,
              Ph =
                ((Ch = ph.create()),
                (zh = ph.fromValues(1, 0, 0)),
                (Dh = ph.fromValues(0, 1, 0)),
                function (e1, t, i) {
                  var r = ph.dot(t, i);
                  return r < -0.999999
                    ? (ph.cross(Ch, zh, t),
                      ph.len(Ch) < 1e-6 && ph.cross(Ch, Dh, t),
                      ph.normalize(Ch, Ch),
                      yh(e1, Ch, Math.PI),
                      e1)
                    : r > 0.999999
                    ? ((e1[0] = 0), (e1[1] = 0), (e1[2] = 0), (e1[3] = 1), e1)
                    : (ph.cross(Ch, t, i),
                      (e1[0] = Ch[0]),
                      (e1[1] = Ch[1]),
                      (e1[2] = Ch[2]),
                      (e1[3] = 1 + r),
                      Ih(e1, e1));
                });
            kc.rotationTo = Ph;
            var Rh,
              Lh,
              kh =
                ((Rh = gh()),
                (Lh = gh()),
                function (e1, t, i, r, n, o) {
                  return (
                    wh(Rh, t, n, o),
                    wh(Lh, i, r, o),
                    wh(e1, Rh, Lh, 2 * o * (1 - o)),
                    e1
                  );
                });
            kc.sqlerp = kh;
            var Oh,
              Bh =
                ((Oh = dh.create()),
                function (e1, t, i, r) {
                  return (
                    (Oh[0] = i[0]),
                    (Oh[3] = i[1]),
                    (Oh[6] = i[2]),
                    (Oh[1] = r[0]),
                    (Oh[4] = r[1]),
                    (Oh[7] = r[2]),
                    (Oh[2] = -t[0]),
                    (Oh[5] = -t[1]),
                    (Oh[8] = -t[2]),
                    Ih(e1, Th(e1, Oh))
                  );
                });
            kc.setAxes = Bh;
            var Fh = {};
            function Nh(e1) {
              return (
                (Nh =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                Nh(e1)
              );
            }
            Object.defineProperty(Fh, "__esModule", {
              value: !0,
            }),
              (Fh.create = function () {
                var e1 = new Uh.ARRAY_TYPE(8);
                return (
                  Uh.ARRAY_TYPE != Float32Array &&
                    ((e1[0] = 0),
                    (e1[1] = 0),
                    (e1[2] = 0),
                    (e1[4] = 0),
                    (e1[5] = 0),
                    (e1[6] = 0),
                    (e1[7] = 0)),
                  (e1[3] = 1),
                  e1
                );
              }),
              (Fh.clone = function (e1) {
                var t = new Uh.ARRAY_TYPE(8);
                return (
                  (t[0] = e1[0]),
                  (t[1] = e1[1]),
                  (t[2] = e1[2]),
                  (t[3] = e1[3]),
                  (t[4] = e1[4]),
                  (t[5] = e1[5]),
                  (t[6] = e1[6]),
                  (t[7] = e1[7]),
                  t
                );
              }),
              (Fh.fromValues = function (e1, t, i, r, n, o, s, a) {
                var l = new Uh.ARRAY_TYPE(8);
                return (
                  (l[0] = e1),
                  (l[1] = t),
                  (l[2] = i),
                  (l[3] = r),
                  (l[4] = n),
                  (l[5] = o),
                  (l[6] = s),
                  (l[7] = a),
                  l
                );
              }),
              (Fh.fromRotationTranslationValues = function (
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
              ) {
                var a = new Uh.ARRAY_TYPE(8);
                (a[0] = e1), (a[1] = t), (a[2] = i), (a[3] = r);
                var l = 0.5 * n,
                  c = 0.5 * o,
                  h = 0.5 * s;
                return (
                  (a[4] = l * r + c * i - h * t),
                  (a[5] = c * r + h * e1 - l * i),
                  (a[6] = h * r + l * t - c * e1),
                  (a[7] = -l * e1 - c * t - h * i),
                  a
                );
              }),
              (Fh.fromRotationTranslation = Zh),
              (Fh.fromTranslation = function (e1, t) {
                return (
                  (e1[0] = 0),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 1),
                  (e1[4] = 0.5 * t[0]),
                  (e1[5] = 0.5 * t[1]),
                  (e1[6] = 0.5 * t[2]),
                  (e1[7] = 0),
                  e1
                );
              }),
              (Fh.fromRotation = function (e1, t) {
                return (
                  (e1[0] = t[0]),
                  (e1[1] = t[1]),
                  (e1[2] = t[2]),
                  (e1[3] = t[3]),
                  (e1[4] = 0),
                  (e1[5] = 0),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  e1
                );
              }),
              (Fh.fromMat4 = function (e1, t) {
                var i = Vh.create();
                jh.getRotation(i, t);
                var r = new Uh.ARRAY_TYPE(3);
                return jh.getTranslation(r, t), Zh(e1, i, r), e1;
              }),
              (Fh.copy = $h),
              (Fh.identity = function (e1) {
                return (
                  (e1[0] = 0),
                  (e1[1] = 0),
                  (e1[2] = 0),
                  (e1[3] = 1),
                  (e1[4] = 0),
                  (e1[5] = 0),
                  (e1[6] = 0),
                  (e1[7] = 0),
                  e1
                );
              }),
              (Fh.set = function (e1, t, i, r, n, o, s, a, l) {
                return (
                  (e1[0] = t),
                  (e1[1] = i),
                  (e1[2] = r),
                  (e1[3] = n),
                  (e1[4] = o),
                  (e1[5] = s),
                  (e1[6] = a),
                  (e1[7] = l),
                  e1
                );
              }),
              (Fh.getDual = function (e1, t) {
                return (
                  (e1[0] = t[4]),
                  (e1[1] = t[5]),
                  (e1[2] = t[6]),
                  (e1[3] = t[7]),
                  e1
                );
              }),
              (Fh.setDual = function (e1, t) {
                return (
                  (e1[4] = t[0]),
                  (e1[5] = t[1]),
                  (e1[6] = t[2]),
                  (e1[7] = t[3]),
                  e1
                );
              }),
              (Fh.getTranslation = function (e1, t) {
                var i = t[4],
                  r = t[5],
                  n = t[6],
                  o = t[7],
                  s = -t[0],
                  a = -t[1],
                  l = -t[2],
                  c = t[3];
                return (
                  (e1[0] = 2 * (i * c + o * s + r * l - n * a)),
                  (e1[1] = 2 * (r * c + o * a + n * s - i * l)),
                  (e1[2] = 2 * (n * c + o * l + i * a - r * s)),
                  e1
                );
              }),
              (Fh.translate = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = 0.5 * i[0],
                  l = 0.5 * i[1],
                  c = 0.5 * i[2],
                  h = t[4],
                  u = t[5],
                  d = t[6],
                  p = t[7];
                return (
                  (e1[0] = r),
                  (e1[1] = n),
                  (e1[2] = o),
                  (e1[3] = s),
                  (e1[4] = s * a + n * c - o * l + h),
                  (e1[5] = s * l + o * a - r * c + u),
                  (e1[6] = s * c + r * l - n * a + d),
                  (e1[7] = -r * a - n * l - o * c + p),
                  e1
                );
              }),
              (Fh.rotateX = function (e1, t, i) {
                var r = -t[0],
                  n = -t[1],
                  o = -t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = a * s + h * r + l * o - c * n,
                  d = l * s + h * n + c * r - a * o,
                  p = c * s + h * o + a * n - l * r,
                  f = h * s - a * r - l * n - c * o;
                return (
                  Vh.rotateX(e1, t, i),
                  (e1[4] =
                    u * (s = e1[3]) +
                    f * (r = e1[0]) +
                    d * (o = e1[2]) -
                    p * (n = e1[1])),
                  (e1[5] = d * s + f * n + p * r - u * o),
                  (e1[6] = p * s + f * o + u * n - d * r),
                  (e1[7] = f * s - u * r - d * n - p * o),
                  e1
                );
              }),
              (Fh.rotateY = function (e1, t, i) {
                var r = -t[0],
                  n = -t[1],
                  o = -t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = a * s + h * r + l * o - c * n,
                  d = l * s + h * n + c * r - a * o,
                  p = c * s + h * o + a * n - l * r,
                  f = h * s - a * r - l * n - c * o;
                return (
                  Vh.rotateY(e1, t, i),
                  (e1[4] =
                    u * (s = e1[3]) +
                    f * (r = e1[0]) +
                    d * (o = e1[2]) -
                    p * (n = e1[1])),
                  (e1[5] = d * s + f * n + p * r - u * o),
                  (e1[6] = p * s + f * o + u * n - d * r),
                  (e1[7] = f * s - u * r - d * n - p * o),
                  e1
                );
              }),
              (Fh.rotateZ = function (e1, t, i) {
                var r = -t[0],
                  n = -t[1],
                  o = -t[2],
                  s = t[3],
                  a = t[4],
                  l = t[5],
                  c = t[6],
                  h = t[7],
                  u = a * s + h * r + l * o - c * n,
                  d = l * s + h * n + c * r - a * o,
                  p = c * s + h * o + a * n - l * r,
                  f = h * s - a * r - l * n - c * o;
                return (
                  Vh.rotateZ(e1, t, i),
                  (e1[4] =
                    u * (s = e1[3]) +
                    f * (r = e1[0]) +
                    d * (o = e1[2]) -
                    p * (n = e1[1])),
                  (e1[5] = d * s + f * n + p * r - u * o),
                  (e1[6] = p * s + f * o + u * n - d * r),
                  (e1[7] = f * s - u * r - d * n - p * o),
                  e1
                );
              }),
              (Fh.rotateByQuatAppend = function (e1, t, i) {
                var r = i[0],
                  n = i[1],
                  o = i[2],
                  s = i[3],
                  a = t[0],
                  l = t[1],
                  c = t[2],
                  h = t[3];
                return (
                  (e1[0] = a * s + h * r + l * o - c * n),
                  (e1[1] = l * s + h * n + c * r - a * o),
                  (e1[2] = c * s + h * o + a * n - l * r),
                  (e1[3] = h * s - a * r - l * n - c * o),
                  (e1[4] =
                    (a = t[4]) * s +
                    (h = t[7]) * r +
                    (l = t[5]) * o -
                    (c = t[6]) * n),
                  (e1[5] = l * s + h * n + c * r - a * o),
                  (e1[6] = c * s + h * o + a * n - l * r),
                  (e1[7] = h * s - a * r - l * n - c * o),
                  e1
                );
              }),
              (Fh.rotateByQuatPrepend = function (e1, t, i) {
                var r = t[0],
                  n = t[1],
                  o = t[2],
                  s = t[3],
                  a = i[0],
                  l = i[1],
                  c = i[2],
                  h = i[3];
                return (
                  (e1[0] = r * h + s * a + n * c - o * l),
                  (e1[1] = n * h + s * l + o * a - r * c),
                  (e1[2] = o * h + s * c + r * l - n * a),
                  (e1[3] = s * h - r * a - n * l - o * c),
                  (e1[4] =
                    r * (h = i[7]) +
                    s * (a = i[4]) +
                    n * (c = i[6]) -
                    o * (l = i[5])),
                  (e1[5] = n * h + s * l + o * a - r * c),
                  (e1[6] = o * h + s * c + r * l - n * a),
                  (e1[7] = s * h - r * a - n * l - o * c),
                  e1
                );
              }),
              (Fh.rotateAroundAxis = function (e1, t, i, r) {
                if (Math.abs(r) < Uh.EPSILON) return $h(e1, t);
                var n = Math.hypot(i[0], i[1], i[2]);
                r *= 0.5;
                var o = Math.sin(r),
                  s = (o * i[0]) / n,
                  a = (o * i[1]) / n,
                  l = (o * i[2]) / n,
                  c = Math.cos(r),
                  h = t[0],
                  u = t[1],
                  d = t[2],
                  p = t[3];
                (e1[0] = h * c + p * s + u * l - d * a),
                  (e1[1] = u * c + p * a + d * s - h * l),
                  (e1[2] = d * c + p * l + h * a - u * s),
                  (e1[3] = p * c - h * s - u * a - d * l);
                var f = t[4],
                  m = t[5],
                  _ = t[6],
                  g = t[7];
                return (
                  (e1[4] = f * c + g * s + m * l - _ * a),
                  (e1[5] = m * c + g * a + _ * s - f * l),
                  (e1[6] = _ * c + g * l + f * a - m * s),
                  (e1[7] = g * c - f * s - m * a - _ * l),
                  e1
                );
              }),
              (Fh.add = function (e1, t, i) {
                return (
                  (e1[0] = t[0] + i[0]),
                  (e1[1] = t[1] + i[1]),
                  (e1[2] = t[2] + i[2]),
                  (e1[3] = t[3] + i[3]),
                  (e1[4] = t[4] + i[4]),
                  (e1[5] = t[5] + i[5]),
                  (e1[6] = t[6] + i[6]),
                  (e1[7] = t[7] + i[7]),
                  e1
                );
              }),
              (Fh.multiply = Hh),
              (Fh.scale = function (e1, t, i) {
                return (
                  (e1[0] = t[0] * i),
                  (e1[1] = t[1] * i),
                  (e1[2] = t[2] * i),
                  (e1[3] = t[3] * i),
                  (e1[4] = t[4] * i),
                  (e1[5] = t[5] * i),
                  (e1[6] = t[6] * i),
                  (e1[7] = t[7] * i),
                  e1
                );
              }),
              (Fh.lerp = function (e1, t, i, r) {
                var n = 1 - r;
                return (
                  Wh(t, i) < 0 && (r = -r),
                  (e1[0] = t[0] * n + i[0] * r),
                  (e1[1] = t[1] * n + i[1] * r),
                  (e1[2] = t[2] * n + i[2] * r),
                  (e1[3] = t[3] * n + i[3] * r),
                  (e1[4] = t[4] * n + i[4] * r),
                  (e1[5] = t[5] * n + i[5] * r),
                  (e1[6] = t[6] * n + i[6] * r),
                  (e1[7] = t[7] * n + i[7] * r),
                  e1
                );
              }),
              (Fh.invert = function (e1, t) {
                var i = Yh(t);
                return (
                  (e1[0] = -t[0] / i),
                  (e1[1] = -t[1] / i),
                  (e1[2] = -t[2] / i),
                  (e1[3] = t[3] / i),
                  (e1[4] = -t[4] / i),
                  (e1[5] = -t[5] / i),
                  (e1[6] = -t[6] / i),
                  (e1[7] = t[7] / i),
                  e1
                );
              }),
              (Fh.conjugate = function (e1, t) {
                return (
                  (e1[0] = -t[0]),
                  (e1[1] = -t[1]),
                  (e1[2] = -t[2]),
                  (e1[3] = t[3]),
                  (e1[4] = -t[4]),
                  (e1[5] = -t[5]),
                  (e1[6] = -t[6]),
                  (e1[7] = t[7]),
                  e1
                );
              }),
              (Fh.normalize = function (e1, t) {
                var i = Yh(t);
                if (i > 0) {
                  i = Math.sqrt(i);
                  var r = t[0] / i,
                    n = t[1] / i,
                    o = t[2] / i,
                    s = t[3] / i,
                    a = t[4],
                    l = t[5],
                    c = t[6],
                    h = t[7],
                    u = r * a + n * l + o * c + s * h;
                  (e1[0] = r),
                    (e1[1] = n),
                    (e1[2] = o),
                    (e1[3] = s),
                    (e1[4] = (a - r * u) / i),
                    (e1[5] = (l - n * u) / i),
                    (e1[6] = (c - o * u) / i),
                    (e1[7] = (h - s * u) / i);
                }
                return e1;
              }),
              (Fh.str = function (e1) {
                return (
                  "quat2(" +
                  e1[0] +
                  ", " +
                  e1[1] +
                  ", " +
                  e1[2] +
                  ", " +
                  e1[3] +
                  ", " +
                  e1[4] +
                  ", " +
                  e1[5] +
                  ", " +
                  e1[6] +
                  ", " +
                  e1[7] +
                  ")"
                );
              }),
              (Fh.exactEquals = function (e1, t) {
                return (
                  e1[0] === t[0] &&
                  e1[1] === t[1] &&
                  e1[2] === t[2] &&
                  e1[3] === t[3] &&
                  e1[4] === t[4] &&
                  e1[5] === t[5] &&
                  e1[6] === t[6] &&
                  e1[7] === t[7]
                );
              }),
              (Fh.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = e1[2],
                  o = e1[3],
                  s = e1[4],
                  a = e1[5],
                  l = e1[6],
                  c = e1[7],
                  h = t[0],
                  u = t[1],
                  d = t[2],
                  p = t[3],
                  f = t[4],
                  m = t[5],
                  _ = t[6],
                  g = t[7];
                return (
                  Math.abs(i - h) <=
                    Uh.EPSILON * Math.max(1, Math.abs(i), Math.abs(h)) &&
                  Math.abs(r - u) <=
                    Uh.EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) &&
                  Math.abs(n - d) <=
                    Uh.EPSILON * Math.max(1, Math.abs(n), Math.abs(d)) &&
                  Math.abs(o - p) <=
                    Uh.EPSILON * Math.max(1, Math.abs(o), Math.abs(p)) &&
                  Math.abs(s - f) <=
                    Uh.EPSILON * Math.max(1, Math.abs(s), Math.abs(f)) &&
                  Math.abs(a - m) <=
                    Uh.EPSILON * Math.max(1, Math.abs(a), Math.abs(m)) &&
                  Math.abs(l - _) <=
                    Uh.EPSILON * Math.max(1, Math.abs(l), Math.abs(_)) &&
                  Math.abs(c - g) <=
                    Uh.EPSILON * Math.max(1, Math.abs(c), Math.abs(g))
                );
              }),
              (Fh.sqrLen =
                Fh.squaredLength =
                Fh.len =
                Fh.length =
                Fh.dot =
                Fh.mul =
                Fh.setReal =
                Fh.getReal =
                  void 0);
            var Uh = qh(tc),
              Vh = qh(kc),
              jh = qh(Ec);
            function Gh(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (Gh = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function qh(e1, t) {
              if (!t && e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== Nh(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = Gh(t);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            }
            function Zh(e1, t, i) {
              var r = 0.5 * i[0],
                n = 0.5 * i[1],
                o = 0.5 * i[2],
                s = t[0],
                a = t[1],
                l = t[2],
                c = t[3];
              return (
                (e1[0] = s),
                (e1[1] = a),
                (e1[2] = l),
                (e1[3] = c),
                (e1[4] = r * c + n * l - o * a),
                (e1[5] = n * c + o * s - r * l),
                (e1[6] = o * c + r * a - n * s),
                (e1[7] = -r * s - n * a - o * l),
                e1
              );
            }
            function $h(e1, t) {
              return (
                (e1[0] = t[0]),
                (e1[1] = t[1]),
                (e1[2] = t[2]),
                (e1[3] = t[3]),
                (e1[4] = t[4]),
                (e1[5] = t[5]),
                (e1[6] = t[6]),
                (e1[7] = t[7]),
                e1
              );
            }
            function Hh(e1, t, i) {
              var r = t[0],
                n = t[1],
                o = t[2],
                s = t[3],
                a = i[4],
                l = i[5],
                c = i[6],
                h = i[7],
                u = t[4],
                d = t[5],
                p = t[6],
                f = t[7],
                m = i[0],
                _ = i[1],
                g = i[2],
                y = i[3];
              return (
                (e1[0] = r * y + s * m + n * g - o * _),
                (e1[1] = n * y + s * _ + o * m - r * g),
                (e1[2] = o * y + s * g + r * _ - n * m),
                (e1[3] = s * y - r * m - n * _ - o * g),
                (e1[4] =
                  r * h +
                  s * a +
                  n * c -
                  o * l +
                  u * y +
                  f * m +
                  d * g -
                  p * _),
                (e1[5] =
                  n * h +
                  s * l +
                  o * a -
                  r * c +
                  d * y +
                  f * _ +
                  p * m -
                  u * g),
                (e1[6] =
                  o * h +
                  s * c +
                  r * l -
                  n * a +
                  p * y +
                  f * g +
                  u * _ -
                  d * m),
                (e1[7] =
                  s * h -
                  r * a -
                  n * l -
                  o * c +
                  f * y -
                  u * m -
                  d * _ -
                  p * g),
                e1
              );
            }
            (Fh.getReal = Vh.copy), (Fh.setReal = Vh.copy), (Fh.mul = Hh);
            var Wh = Vh.dot;
            Fh.dot = Wh;
            var Xh = Vh.length;
            (Fh.length = Xh), (Fh.len = Xh);
            var Yh = Vh.squaredLength;
            (Fh.squaredLength = Yh), (Fh.sqrLen = Yh);
            var Kh = {};
            function Jh(e1) {
              return (
                (Jh =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                Jh(e1)
              );
            }
            Object.defineProperty(Kh, "__esModule", {
              value: !0,
            }),
              (Kh.create = tu),
              (Kh.clone = function (e1) {
                var t = new Qh.ARRAY_TYPE(2);
                return (t[0] = e1[0]), (t[1] = e1[1]), t;
              }),
              (Kh.fromValues = function (e1, t) {
                var i = new Qh.ARRAY_TYPE(2);
                return (i[0] = e1), (i[1] = t), i;
              }),
              (Kh.copy = function (e1, t) {
                return (e1[0] = t[0]), (e1[1] = t[1]), e1;
              }),
              (Kh.set = function (e1, t, i) {
                return (e1[0] = t), (e1[1] = i), e1;
              }),
              (Kh.add = function (e1, t, i) {
                return (e1[0] = t[0] + i[0]), (e1[1] = t[1] + i[1]), e1;
              }),
              (Kh.subtract = iu),
              (Kh.multiply = ru),
              (Kh.divide = nu),
              (Kh.ceil = function (e1, t) {
                return (e1[0] = Math.ceil(t[0])), (e1[1] = Math.ceil(t[1])), e1;
              }),
              (Kh.floor = function (e1, t) {
                return (
                  (e1[0] = Math.floor(t[0])), (e1[1] = Math.floor(t[1])), e1
                );
              }),
              (Kh.min = function (e1, t, i) {
                return (
                  (e1[0] = Math.min(t[0], i[0])),
                  (e1[1] = Math.min(t[1], i[1])),
                  e1
                );
              }),
              (Kh.max = function (e1, t, i) {
                return (
                  (e1[0] = Math.max(t[0], i[0])),
                  (e1[1] = Math.max(t[1], i[1])),
                  e1
                );
              }),
              (Kh.round = function (e1, t) {
                return (
                  (e1[0] = Math.round(t[0])), (e1[1] = Math.round(t[1])), e1
                );
              }),
              (Kh.scale = function (e1, t, i) {
                return (e1[0] = t[0] * i), (e1[1] = t[1] * i), e1;
              }),
              (Kh.scaleAndAdd = function (e1, t, i, r) {
                return (e1[0] = t[0] + i[0] * r), (e1[1] = t[1] + i[1] * r), e1;
              }),
              (Kh.distance = ou),
              (Kh.squaredDistance = su),
              (Kh.length = au),
              (Kh.squaredLength = lu),
              (Kh.negate = function (e1, t) {
                return (e1[0] = -t[0]), (e1[1] = -t[1]), e1;
              }),
              (Kh.inverse = function (e1, t) {
                return (e1[0] = 1 / t[0]), (e1[1] = 1 / t[1]), e1;
              }),
              (Kh.normalize = function (e1, t) {
                var i = t[0],
                  r = t[1],
                  n = i * i + r * r;
                return (
                  n > 0 && (n = 1 / Math.sqrt(n)),
                  (e1[0] = t[0] * n),
                  (e1[1] = t[1] * n),
                  e1
                );
              }),
              (Kh.dot = function (e1, t) {
                return e1[0] * t[0] + e1[1] * t[1];
              }),
              (Kh.cross = function (e1, t, i) {
                var r = t[0] * i[1] - t[1] * i[0];
                return (e1[0] = e1[1] = 0), (e1[2] = r), e1;
              }),
              (Kh.lerp = function (e1, t, i, r) {
                var n = t[0],
                  o = t[1];
                return (
                  (e1[0] = n + r * (i[0] - n)), (e1[1] = o + r * (i[1] - o)), e1
                );
              }),
              (Kh.random = function (e1, t) {
                t = t || 1;
                var i = 2 * Qh.RANDOM() * Math.PI;
                return (e1[0] = Math.cos(i) * t), (e1[1] = Math.sin(i) * t), e1;
              }),
              (Kh.transformMat2 = function (e1, t, i) {
                var r = t[0],
                  n = t[1];
                return (
                  (e1[0] = i[0] * r + i[2] * n),
                  (e1[1] = i[1] * r + i[3] * n),
                  e1
                );
              }),
              (Kh.transformMat2d = function (e1, t, i) {
                var r = t[0],
                  n = t[1];
                return (
                  (e1[0] = i[0] * r + i[2] * n + i[4]),
                  (e1[1] = i[1] * r + i[3] * n + i[5]),
                  e1
                );
              }),
              (Kh.transformMat3 = function (e1, t, i) {
                var r = t[0],
                  n = t[1];
                return (
                  (e1[0] = i[0] * r + i[3] * n + i[6]),
                  (e1[1] = i[1] * r + i[4] * n + i[7]),
                  e1
                );
              }),
              (Kh.transformMat4 = function (e1, t, i) {
                var r = t[0],
                  n = t[1];
                return (
                  (e1[0] = i[0] * r + i[4] * n + i[12]),
                  (e1[1] = i[1] * r + i[5] * n + i[13]),
                  e1
                );
              }),
              (Kh.rotate = function (e1, t, i, r) {
                var n = t[0] - i[0],
                  o = t[1] - i[1],
                  s = Math.sin(r),
                  a = Math.cos(r);
                return (
                  (e1[0] = n * a - o * s + i[0]),
                  (e1[1] = n * s + o * a + i[1]),
                  e1
                );
              }),
              (Kh.angle = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = t[0],
                  o = t[1],
                  s = Math.sqrt(i * i + r * r) * Math.sqrt(n * n + o * o);
                return Math.acos(
                  Math.min(Math.max(s && (i * n + r * o) / s, -1), 1),
                );
              }),
              (Kh.zero = function (e1) {
                return (e1[0] = 0), (e1[1] = 0), e1;
              }),
              (Kh.str = function (e1) {
                return "vec2(" + e1[0] + ", " + e1[1] + ")";
              }),
              (Kh.exactEquals = function (e1, t) {
                return e1[0] === t[0] && e1[1] === t[1];
              }),
              (Kh.equals = function (e1, t) {
                var i = e1[0],
                  r = e1[1],
                  n = t[0],
                  o = t[1];
                return (
                  Math.abs(i - n) <=
                    Qh.EPSILON * Math.max(1, Math.abs(i), Math.abs(n)) &&
                  Math.abs(r - o) <=
                    Qh.EPSILON * Math.max(1, Math.abs(r), Math.abs(o))
                );
              }),
              (Kh.forEach =
                Kh.sqrLen =
                Kh.sqrDist =
                Kh.dist =
                Kh.div =
                Kh.mul =
                Kh.sub =
                Kh.len =
                  void 0);
            var Qh = (function (e1, t) {
              if (e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== Jh(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = eu(void 0);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            })(tc);
            function eu(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (eu = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function tu() {
              var e1 = new Qh.ARRAY_TYPE(2);
              return (
                Qh.ARRAY_TYPE != Float32Array && ((e1[0] = 0), (e1[1] = 0)), e1
              );
            }
            function iu(e1, t, i) {
              return (e1[0] = t[0] - i[0]), (e1[1] = t[1] - i[1]), e1;
            }
            function ru(e1, t, i) {
              return (e1[0] = t[0] * i[0]), (e1[1] = t[1] * i[1]), e1;
            }
            function nu(e1, t, i) {
              return (e1[0] = t[0] / i[0]), (e1[1] = t[1] / i[1]), e1;
            }
            function ou(e1, t) {
              return Math.hypot(t[0] - e1[0], t[1] - e1[1]);
            }
            function su(e1, t) {
              var i = t[0] - e1[0],
                r = t[1] - e1[1];
              return i * i + r * r;
            }
            function au(e1) {
              return Math.hypot(e1[0], e1[1]);
            }
            function lu(e1) {
              var t = e1[0],
                i = e1[1];
              return t * t + i * i;
            }
            (Kh.len = au),
              (Kh.sub = iu),
              (Kh.mul = ru),
              (Kh.div = nu),
              (Kh.dist = ou),
              (Kh.sqrDist = su),
              (Kh.sqrLen = lu);
            var cu = (function () {
              var e1 = tu();
              return function (t, i, r, n, o, s) {
                var a, l;
                for (
                  i || (i = 2),
                    r || (r = 0),
                    l = n ? Math.min(n * i + r, t.length) : t.length,
                    a = r;
                  a < l;
                  a += i
                )
                  (e1[0] = t[a]),
                    (e1[1] = t[a + 1]),
                    o(e1, e1, s),
                    (t[a] = e1[0]),
                    (t[a + 1] = e1[1]);
                return t;
              };
            })();
            function hu(e1) {
              return (
                (hu =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (e1) {
                        return typeof e1;
                      }
                    : function (e1) {
                        return e1 &&
                          "function" == typeof Symbol &&
                          e1.constructor === Symbol &&
                          e1 !== Symbol.prototype
                          ? "symbol"
                          : typeof e1;
                      }),
                hu(e1)
              );
            }
            (Kh.forEach = cu),
              Object.defineProperty(ec, "__esModule", {
                value: !0,
              });
            var uu =
                (ec.vec4 =
                Mu =
                ec.vec3 =
                ec.vec2 =
                ec.quat2 =
                bu =
                ec.quat =
                xu =
                ec.mat4 =
                gu =
                ec.mat3 =
                ec.mat2d =
                fu =
                ec.mat2 =
                ec.glMatrix =
                  void 0),
              du = Iu(tc);
            ec.glMatrix = du;
            var pu = Iu(sc),
              fu = (ec.mat2 = pu),
              mu = Iu(dc);
            ec.mat2d = mu;
            var _u = Iu(yc),
              gu = (ec.mat3 = _u),
              yu = Iu(Ec),
              xu = (ec.mat4 = yu),
              vu = Iu(kc),
              bu = (ec.quat = vu),
              wu = Iu(Fh);
            ec.quat2 = wu;
            var Tu = Iu(Kh);
            ec.vec2 = Tu;
            var Eu = Iu(Oc),
              Mu = (ec.vec3 = Eu),
              Au = Iu(Kc);
            function Su(e1) {
              if ("function" != typeof WeakMap) return null;
              var t = new WeakMap(),
                i = new WeakMap();
              return (Su = function (e1) {
                return e1 ? i : t;
              })(e1);
            }
            function Iu(e1, t) {
              if (!t && e1 && e1.__esModule) return e1;
              if (
                null === e1 ||
                ("object" !== hu(e1) && "function" != typeof e1)
              )
                return {
                  default: e1,
                };
              var i = Su(t);
              if (i && i.has(e1)) return i.get(e1);
              var r = {},
                n = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o in e1)
                if (
                  "default" !== o &&
                  Object.prototype.hasOwnProperty.call(e1, o)
                ) {
                  var s = n ? Object.getOwnPropertyDescriptor(e1, o) : null;
                  s && (s.get || s.set)
                    ? Object.defineProperty(r, o, s)
                    : (r[o] = e1[o]);
                }
              return (r.default = e1), i && i.set(e1, r), r;
            }
            uu = ec.vec4 = Au;
            const Cu = ba([
                {
                  type: "Float32",
                  name: "a_globe_pos",
                  components: 3,
                },
                {
                  type: "Float32",
                  name: "a_uv",
                  components: 2,
                },
              ]),
              { members: zu } = Cu,
              Du = ba([
                {
                  name: "a_pos_3",
                  components: 3,
                  type: "Int16",
                },
              ]);
            var Pu = ba([
                {
                  name: "a_pos",
                  type: "Int16",
                  components: 2,
                },
              ]),
              Ru = {};
            !(function (e1, t) {
              !(function (e1) {
                function t(e1, t, r) {
                  var n = i(256 * e1, 256 * (t = Math.pow(2, r) - t - 1), r),
                    o = i(256 * (e1 + 1), 256 * (t + 1), r);
                  return n[0] + "," + n[1] + "," + o[0] + "," + o[1];
                }
                function i(e1, t, i) {
                  var r = (2 * Math.PI * 6378137) / 256 / Math.pow(2, i);
                  return [
                    e1 * r - (2 * Math.PI * 6378137) / 2,
                    t * r - (2 * Math.PI * 6378137) / 2,
                  ];
                }
                (e1.getURL = function (e1, i, r, n, o, s) {
                  return (
                    (s = s || {}),
                    e1 +
                      "?" +
                      [
                        "bbox=" + t(r, n, o),
                        "format=" + (s.format || "image/png"),
                        "service=" + (s.service || "WMS"),
                        "version=" + (s.version || "1.1.1"),
                        "request=" + (s.request || "GetMap"),
                        "srs=" + (s.srs || "EPSG:3857"),
                        "width=" + (s.width || 256),
                        "height=" + (s.height || 256),
                        "layers=" + i,
                      ].join("&")
                  );
                }),
                  (e1.getTileBBox = t),
                  (e1.getMercCoords = i),
                  Object.defineProperty(e1, "__esModule", {
                    value: !0,
                  });
              })(t);
            })(0, Ru);
            var Lu = Ru;
            class ku {
              constructor(e1, t, i) {
                (this.z = e1),
                  (this.x = t),
                  (this.y = i),
                  (this.key = Fu(0, e1, e1, t, i));
              }
              equals(e1) {
                return this.z === e1.z && this.x === e1.x && this.y === e1.y;
              }
              url(e1, t) {
                const i = Lu.getTileBBox(this.x, this.y, this.z),
                  r = (function (e1, t, i) {
                    let r,
                      n = "";
                    for (let o = e1; o > 0; o--)
                      (r = 1 << (o - 1)),
                        (n += (t & r ? 1 : 0) + (i & r ? 2 : 0));
                    return n;
                  })(this.z, this.x, this.y);
                return e1[(this.x + this.y) % e1.length]
                  .replace(
                    "{prefix}",
                    (this.x % 16).toString(16) + (this.y % 16).toString(16),
                  )
                  .replace(/{z}/g, String(this.z))
                  .replace(/{x}/g, String(this.x))
                  .replace(
                    /{y}/g,
                    String(
                      "tms" === t ? Math.pow(2, this.z) - this.y - 1 : this.y,
                    ),
                  )
                  .replace("{quadkey}", r)
                  .replace("{bbox-epsg-3857}", i);
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class Ou {
              constructor(e1, t) {
                (this.wrap = e1),
                  (this.canonical = t),
                  (this.key = Fu(e1, t.z, t.z, t.x, t.y));
              }
            }
            class Bu {
              constructor(e1, t, i, r, n) {
                (this.overscaledZ = e1),
                  (this.wrap = t),
                  (this.canonical = new ku(i, +r, +n)),
                  (this.key =
                    0 === t && e1 === i
                      ? this.canonical.key
                      : Fu(t, e1, i, r, n));
              }
              equals(e1) {
                return (
                  this.overscaledZ === e1.overscaledZ &&
                  this.wrap === e1.wrap &&
                  this.canonical.equals(e1.canonical)
                );
              }
              scaledTo(e1) {
                const t = this.canonical.z - e1;
                return e1 > this.canonical.z
                  ? new Bu(
                      e1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y,
                    )
                  : new Bu(
                      e1,
                      this.wrap,
                      e1,
                      this.canonical.x >> t,
                      this.canonical.y >> t,
                    );
              }
              calculateScaledKey(e1, t = !0) {
                if (this.overscaledZ === e1 && t) return this.key;
                if (e1 > this.canonical.z)
                  return Fu(
                    this.wrap * +t,
                    e1,
                    this.canonical.z,
                    this.canonical.x,
                    this.canonical.y,
                  );
                {
                  const i = this.canonical.z - e1;
                  return Fu(
                    this.wrap * +t,
                    e1,
                    e1,
                    this.canonical.x >> i,
                    this.canonical.y >> i,
                  );
                }
              }
              isChildOf(e1) {
                if (e1.wrap !== this.wrap) return !1;
                const t = this.canonical.z - e1.canonical.z;
                return (
                  0 === e1.overscaledZ ||
                  (e1.overscaledZ < this.overscaledZ &&
                    e1.canonical.z < this.canonical.z &&
                    e1.canonical.x === this.canonical.x >> t &&
                    e1.canonical.y === this.canonical.y >> t)
                );
              }
              children(e1) {
                if (this.overscaledZ >= e1)
                  return [
                    new Bu(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y,
                    ),
                  ];
                const t = this.canonical.z + 1,
                  i = 2 * this.canonical.x,
                  r = 2 * this.canonical.y;
                return [
                  new Bu(t, this.wrap, t, i, r),
                  new Bu(t, this.wrap, t, i + 1, r),
                  new Bu(t, this.wrap, t, i, r + 1),
                  new Bu(t, this.wrap, t, i + 1, r + 1),
                ];
              }
              isLessThan(e1) {
                return (
                  this.wrap < e1.wrap ||
                  (!(this.wrap > e1.wrap) &&
                    (this.overscaledZ < e1.overscaledZ ||
                      (!(this.overscaledZ > e1.overscaledZ) &&
                        (this.canonical.x < e1.canonical.x ||
                          (!(this.canonical.x > e1.canonical.x) &&
                            this.canonical.y < e1.canonical.y)))))
                );
              }
              wrapped() {
                return new Bu(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y,
                );
              }
              unwrapTo(e1) {
                return new Bu(
                  this.overscaledZ,
                  e1,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y,
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new Ou(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
            }
            function Fu(e1, t, i, r, n) {
              const o = 1 << Math.min(i, 22);
              let s = o * (n % o) + (r % o);
              return (
                e1 &&
                  i < 22 &&
                  (s +=
                    o *
                    o *
                    ((e1 < 0 ? -2 * e1 - 1 : 2 * e1) % (1 << (2 * (22 - i))))),
                16 * (32 * s + i) + (t - i)
              );
            }
            const Nu = [
              (e1) => {
                let t = e1.canonical.x - 1,
                  i = e1.wrap;
                return (
                  t < 0 && ((t = (1 << e1.canonical.z) - 1), i--),
                  new Bu(e1.overscaledZ, i, e1.canonical.z, t, e1.canonical.y)
                );
              },
              (e1) => {
                let t = e1.canonical.x + 1,
                  i = e1.wrap;
                return (
                  t === 1 << e1.canonical.z && ((t = 0), i++),
                  new Bu(e1.overscaledZ, i, e1.canonical.z, t, e1.canonical.y)
                );
              },
              (e1) =>
                new Bu(
                  e1.overscaledZ,
                  e1.wrap,
                  e1.canonical.z,
                  e1.canonical.x,
                  (0 === e1.canonical.y
                    ? 1 << e1.canonical.z
                    : e1.canonical.y) - 1,
                ),
              (e1) =>
                new Bu(
                  e1.overscaledZ,
                  e1.wrap,
                  e1.canonical.z,
                  e1.canonical.x,
                  e1.canonical.y === (1 << e1.canonical.z) - 1
                    ? 0
                    : e1.canonical.y + 1,
                ),
            ];
            Is(ku, "CanonicalTileID"),
              Is(Bu, "OverscaledTileID", {
                omit: ["projMatrix"],
              });
            class Uu {
              constructor(e1, t) {
                (this.pos = e1), (this.dir = t);
              }
              intersectsPlane(e1, t, i) {
                const r = Mu.dot(t, this.dir);
                if (Math.abs(r) < 1e-6) return !1;
                const n =
                  ((e1[0] - this.pos[0]) * t[0] +
                    (e1[1] - this.pos[1]) * t[1] +
                    (e1[2] - this.pos[2]) * t[2]) /
                  r;
                return (
                  (i[0] = this.pos[0] + this.dir[0] * n),
                  (i[1] = this.pos[1] + this.dir[1] * n),
                  (i[2] = this.pos[2] + this.dir[2] * n),
                  !0
                );
              }
              closestPointOnSphere(e1, t, i) {
                if (Mu.equals(this.pos, e1) || 0 === t)
                  return (i[0] = i[1] = i[2] = 0), !1;
                const [r, n, o] = this.dir,
                  s = this.pos[0] - e1[0],
                  a = this.pos[1] - e1[1],
                  l = this.pos[2] - e1[2],
                  c = r * r + n * n + o * o,
                  h = 2 * (s * r + a * n + l * o),
                  u = h * h - 4 * c * (s * s + a * a + l * l - t * t);
                if (u < 0) {
                  const e1 = Math.max(-h / 2, 0),
                    c = s + r * e1,
                    u = a + n * e1,
                    d = l + o * e1,
                    p = Math.hypot(c, u, d);
                  return (
                    (i[0] = (c * t) / p),
                    (i[1] = (u * t) / p),
                    (i[2] = (d * t) / p),
                    !1
                  );
                }
                {
                  const e1 = (-h - Math.sqrt(u)) / (2 * c);
                  if (e1 < 0) {
                    const e1 = Math.hypot(s, a, l);
                    return (
                      (i[0] = (s * t) / e1),
                      (i[1] = (a * t) / e1),
                      (i[2] = (l * t) / e1),
                      !1
                    );
                  }
                  return (
                    (i[0] = s + r * e1),
                    (i[1] = a + n * e1),
                    (i[2] = l + o * e1),
                    !0
                  );
                }
              }
            }
            class Vu {
              constructor(e1, t, i, r, n) {
                (this.TL = e1),
                  (this.TR = t),
                  (this.BR = i),
                  (this.BL = r),
                  (this.horizon = n);
              }
              static fromInvProjectionMatrix(e1, t, i) {
                const r = [-1, 1, 1],
                  n = [1, 1, 1],
                  o = [1, -1, 1],
                  s = [-1, -1, 1],
                  a = Mu.transformMat4(r, r, e1),
                  l = Mu.transformMat4(n, n, e1),
                  c = Mu.transformMat4(o, o, e1),
                  h = Mu.transformMat4(s, s, e1);
                return new Vu(a, l, c, h, t / i);
              }
            }
            function ju(e1, t, i) {
              let r = 1 / 0,
                n = -1 / 0;
              const o = [];
              for (const s of e1) {
                Mu.sub(o, s, t);
                const e1 = Mu.dot(o, i);
                (r = Math.min(r, e1)), (n = Math.max(n, e1));
              }
              return [r, n];
            }
            function Gu(e1, t) {
              let i = !0;
              for (let r = 0; r < e1.planes.length; r++) {
                const n = e1.planes[r];
                let o = 0;
                for (let e1 = 0; e1 < t.length; e1++)
                  o += Mu.dot(n, t[e1]) + n[3] >= 0;
                if (0 === o) return 0;
                o !== t.length && (i = !1);
              }
              return i ? 2 : 1;
            }
            function qu(e1, t) {
              for (const i of e1.projections) {
                const r = ju(t, e1.points[0], i.axis);
                if (i.projection[1] < r[0] || i.projection[0] > r[1]) return 0;
              }
              return 1;
            }
            function Zu(e1, t) {
              let i = 0;
              const r = [0, 0, 0, 0];
              for (let n = 0; n < e1.length; n++)
                (r[0] = e1[n][0]),
                  (r[1] = e1[n][1]),
                  (r[2] = e1[n][2]),
                  (r[3] = 1),
                  uu.dot(r, t) >= 0 && i++;
              return i;
            }
            class $u {
              constructor(e1, t) {
                (this.points = e1 || new Array(8).fill([0, 0, 0])),
                  (this.planes = t || new Array(6).fill([0, 0, 0, 0])),
                  (this.bounds = Hu.fromPoints(this.points)),
                  (this.projections = []),
                  (this.frustumEdges = [
                    Mu.sub([], this.points[2], this.points[3]),
                    Mu.sub([], this.points[0], this.points[3]),
                    Mu.sub([], this.points[4], this.points[0]),
                    Mu.sub([], this.points[5], this.points[1]),
                    Mu.sub([], this.points[6], this.points[2]),
                    Mu.sub([], this.points[7], this.points[3]),
                  ]);
                for (const e1 of this.frustumEdges) {
                  const t = [0, -e1[2], e1[1]],
                    i = [e1[2], 0, -e1[0]];
                  this.projections.push({
                    axis: t,
                    projection: ju(this.points, this.points[0], t),
                  }),
                    this.projections.push({
                      axis: i,
                      projection: ju(this.points, this.points[0], i),
                    });
                }
              }
              static fromInvProjectionMatrix(e1, t, i, r) {
                const n = Math.pow(2, i),
                  o = [
                    [-1, 1, -1, 1],
                    [1, 1, -1, 1],
                    [1, -1, -1, 1],
                    [-1, -1, -1, 1],
                    [-1, 1, 1, 1],
                    [1, 1, 1, 1],
                    [1, -1, 1, 1],
                    [-1, -1, 1, 1],
                  ].map((i) => {
                    const o = uu.transformMat4([], i, e1),
                      s = (1 / o[3] / t) * n;
                    return uu.mul(o, o, [s, s, r ? 1 / o[3] : s, s]);
                  }),
                  s = [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ].map((e1) => {
                    const t = Mu.sub([], o[e1[0]], o[e1[1]]),
                      i = Mu.sub([], o[e1[2]], o[e1[1]]),
                      r = Mu.normalize([], Mu.cross([], t, i)),
                      n = -Mu.dot(r, o[e1[1]]);
                    return r.concat(n);
                  }),
                  a = [];
                for (let e1 = 0; e1 < o.length; e1++)
                  a.push([o[e1][0], o[e1][1], o[e1][2]]);
                return new $u(a, s);
              }
              intersectsPrecise(e1, t, i) {
                for (let i = 0; i < t.length; i++) if (!Zu(e1, t[i])) return 0;
                for (let t = 0; t < this.planes.length; t++)
                  if (!Zu(e1, this.planes[t])) return 0;
                for (const t of i)
                  for (const i of this.frustumEdges) {
                    const r = Mu.cross([], t, i),
                      n = Mu.length(r);
                    if (0 === n) continue;
                    Mu.scale(r, r, 1 / n);
                    const o = ju(this.points, this.points[0], r),
                      s = ju(e1, this.points[0], r);
                    if (o[0] > s[1] || s[0] > o[1]) return 0;
                  }
                return 1;
              }
            }
            class Hu {
              static fromPoints(e1) {
                const t = [1 / 0, 1 / 0, 1 / 0],
                  i = [-1 / 0, -1 / 0, -1 / 0];
                for (const r of e1) Mu.min(t, t, r), Mu.max(i, i, r);
                return new Hu(t, i);
              }
              static fromTileIdAndHeight(e1, t, i) {
                const r = 1 << e1.canonical.z,
                  n = e1.canonical.x,
                  o = e1.canonical.y;
                return new Hu([n / r, o / r, t], [(n + 1) / r, (o + 1) / r, i]);
              }
              static applyTransform(e1, t) {
                const i = e1.getCorners();
                for (let e1 = 0; e1 < i.length; ++e1)
                  Mu.transformMat4(i[e1], i[e1], t);
                return Hu.fromPoints(i);
              }
              static projectAabbCorners(e1, t) {
                const i = e1.getCorners();
                for (let e1 = 0; e1 < i.length; ++e1)
                  Mu.transformMat4(i[e1], i[e1], t);
                return i;
              }
              constructor(e1, t) {
                (this.min = e1),
                  (this.max = t),
                  (this.center = Mu.scale(
                    [],
                    Mu.add([], this.min, this.max),
                    0.5,
                  ));
              }
              quadrant(e1) {
                const t = [e1 % 2 == 0, e1 < 2],
                  i = Mu.clone(this.min),
                  r = Mu.clone(this.max);
                for (let e1 = 0; e1 < t.length; e1++)
                  (i[e1] = t[e1] ? this.min[e1] : this.center[e1]),
                    (r[e1] = t[e1] ? this.center[e1] : this.max[e1]);
                return (r[2] = this.max[2]), new Hu(i, r);
              }
              distanceX(e1) {
                return (
                  Math.max(Math.min(this.max[0], e1[0]), this.min[0]) - e1[0]
                );
              }
              distanceY(e1) {
                return (
                  Math.max(Math.min(this.max[1], e1[1]), this.min[1]) - e1[1]
                );
              }
              distanceZ(e1) {
                return (
                  Math.max(Math.min(this.max[2], e1[2]), this.min[2]) - e1[2]
                );
              }
              getCorners() {
                const e1 = this.min,
                  t = this.max;
                return [
                  [e1[0], e1[1], e1[2]],
                  [t[0], e1[1], e1[2]],
                  [t[0], t[1], e1[2]],
                  [e1[0], t[1], e1[2]],
                  [e1[0], e1[1], t[2]],
                  [t[0], e1[1], t[2]],
                  [t[0], t[1], t[2]],
                  [e1[0], t[1], t[2]],
                ];
              }
              intersects(e1) {
                return this.intersectsAabb(e1.bounds)
                  ? Gu(e1, this.getCorners())
                  : 0;
              }
              intersectsFlat(e1) {
                return this.intersectsAabb(e1.bounds)
                  ? Gu(e1, [
                      [this.min[0], this.min[1], 0],
                      [this.max[0], this.min[1], 0],
                      [this.max[0], this.max[1], 0],
                      [this.min[0], this.max[1], 0],
                    ])
                  : 0;
              }
              intersectsPrecise(e1, t) {
                return t || this.intersects(e1) ? qu(e1, this.getCorners()) : 0;
              }
              intersectsPreciseFlat(e1, t) {
                return t || this.intersectsFlat(e1)
                  ? qu(e1, [
                      [this.min[0], this.min[1], 0],
                      [this.max[0], this.min[1], 0],
                      [this.max[0], this.max[1], 0],
                      [this.min[0], this.max[1], 0],
                    ])
                  : 0;
              }
              intersectsAabb(e1) {
                for (let t = 0; t < 3; ++t)
                  if (this.min[t] > e1.max[t] || e1.min[t] > this.max[t])
                    return !1;
                return !0;
              }
              intersectsAabbXY(e1) {
                return !(
                  this.min[0] > e1.max[0] ||
                  e1.min[0] > this.max[0] ||
                  this.min[1] > e1.max[1] ||
                  e1.min[1] > this.max[1]
                );
              }
              encapsulate(e1) {
                for (let t = 0; t < 3; t++)
                  (this.min[t] = Math.min(this.min[t], e1.min[t])),
                    (this.max[t] = Math.max(this.max[t], e1.max[t]));
              }
              encapsulatePoint(e1) {
                for (let t = 0; t < 3; t++)
                  (this.min[t] = Math.min(this.min[t], e1[t])),
                    (this.max[t] = Math.max(this.max[t], e1[t]));
              }
              closestPoint(e1) {
                return [
                  Math.max(Math.min(this.max[0], e1[0]), this.min[0]),
                  Math.max(Math.min(this.max[1], e1[1]), this.min[1]),
                  Math.max(Math.min(this.max[2], e1[2]), this.min[2]),
                ];
              }
            }
            Is(Hu, "Aabb");
            const Wu = 5,
              Xu = 6,
              Yu = sr / Math.PI / 2,
              Ku = 16383,
              Ju = 64,
              Qu = [Ju, 32, 16],
              ed = -Yu,
              td = Yu,
              id = [
                new Hu([ed, ed, ed], [td, td, td]),
                new Hu([ed, ed, ed], [0, 0, td]),
                new Hu([0, ed, ed], [td, 0, td]),
                new Hu([ed, 0, ed], [0, td, td]),
                new Hu([0, 0, ed], [td, td, td]),
              ];
            function rd(e1) {
              return (e1 * Yu) / Od;
            }
            function nd(e1, t, i, r = !0) {
              const n = Mu.scale([], e1._camera.position, e1.worldSize),
                o = [t, i, 1, 1];
              uu.transformMat4(o, o, e1.pixelMatrixInverse),
                uu.scale(o, o, 1 / o[3]);
              const s = Mu.sub([], o, n),
                a = Mu.normalize([], s),
                l = e1.globeMatrix,
                c = [l[12], l[13], l[14]],
                h = Mu.sub([], c, n),
                u = Mu.length(h),
                d = Mu.normalize([], h),
                p = e1.worldSize / (2 * Math.PI),
                f = Mu.dot(d, a),
                m = Math.asin(p / u);
              if (m < Math.acos(f)) {
                if (!r) return null;
                const e1 = [],
                  t = [];
                Mu.scale(e1, a, u / f),
                  Mu.normalize(t, Mu.sub(t, e1, h)),
                  Mu.normalize(
                    a,
                    Mu.add(a, h, Mu.scale(a, t, Math.tan(m) * u)),
                  );
              }
              const _ = [];
              new Uu(n, a).closestPointOnSphere(c, p, _);
              const g = Mu.normalize([], ne(l, 0)),
                y = Mu.normalize([], ne(l, 1)),
                x = Mu.normalize([], ne(l, 2)),
                v = Mu.dot(g, _),
                b = Mu.dot(y, _),
                w = Mu.dot(x, _),
                E = T(Math.asin(-b / p));
              let M = T(Math.atan2(v, w));
              M =
                e1.center.lng +
                (function (e1, t) {
                  const i = ((t - e1 + 180) % 360) - 180;
                  return i < -180 ? i + 360 : i;
                })(e1.center.lng, M);
              const A = Gd(M),
                S = z(qd(E), 0, 1);
              return new ep(A, S);
            }
            class od {
              constructor(e1, t, i) {
                (this.a = Mu.sub([], e1, i)),
                  (this.b = Mu.sub([], t, i)),
                  (this.center = i);
                const r = Mu.normalize([], this.a),
                  n = Mu.normalize([], this.b);
                this.angle = Math.acos(Mu.dot(r, n));
              }
            }
            function sd(e1, t) {
              if (0 === e1.angle) return null;
              let i;
              return (
                (i =
                  0 === e1.a[t]
                    ? (1 / e1.angle) * 0.5 * Math.PI
                    : (1 / e1.angle) *
                      Math.atan(
                        e1.b[t] / e1.a[t] / Math.sin(e1.angle) -
                          1 / Math.tan(e1.angle),
                      )),
                i < 0 || i > 1
                  ? null
                  : (function (e1, t, i, r) {
                      const n = Math.sin(i);
                      return (
                        e1 * (Math.sin((1 - r) * i) / n) +
                        t * (Math.sin(r * i) / n)
                      );
                    })(e1.a[t], e1.b[t], e1.angle, z(i, 0, 1)) + e1.center[t]
              );
            }
            function ad(e1) {
              if (e1.z <= 1) return id[e1.z + 2 * e1.y + e1.x];
              const t = pd(dd(e1));
              return Hu.fromPoints(t);
            }
            function ld(e1, t, i) {
              return Mu.scale(e1, e1, 1 - i), Mu.scaleAndAdd(e1, e1, t, i);
            }
            function cd(e1, t) {
              const i = Ed(t.zoom);
              if (0 === i) return ad(e1);
              const r = dd(e1),
                n = pd(r),
                o = Gd(r.getWest()) * t.worldSize,
                s = Gd(r.getEast()) * t.worldSize,
                a = qd(r.getNorth()) * t.worldSize,
                l = qd(r.getSouth()) * t.worldSize,
                c = [o, a, 0],
                h = [s, a, 0],
                u = [o, l, 0],
                d = [s, l, 0],
                p = xu.invert([], t.globeMatrix);
              return (
                Mu.transformMat4(c, c, p),
                Mu.transformMat4(h, h, p),
                Mu.transformMat4(u, u, p),
                Mu.transformMat4(d, d, p),
                (n[0] = ld(n[0], u, i)),
                (n[1] = ld(n[1], d, i)),
                (n[2] = ld(n[2], h, i)),
                (n[3] = ld(n[3], c, i)),
                Hu.fromPoints(n)
              );
            }
            function hd(e1, t, i) {
              for (const r of e1) Mu.transformMat4(r, r, t), Mu.scale(r, r, i);
            }
            function ud(e1, t, i, r) {
              const n = t / e1.worldSize,
                o = e1.globeMatrix;
              if (i.z <= 1) {
                const e1 = ad(i).getCorners();
                return hd(e1, o, n), Hu.fromPoints(e1);
              }
              const s = dd(i, r),
                a = pd(s);
              hd(a, o, n);
              const l = Number.MAX_VALUE,
                c = [-l, -l, -l],
                h = [l, l, l];
              if (s.contains(e1.center)) {
                for (const e1 of a) Mu.min(h, h, e1), Mu.max(c, c, e1);
                c[2] = 0;
                const t = e1.point,
                  i = [t.x * n, t.y * n, 0];
                return Mu.min(h, h, i), Mu.max(c, c, i), new Hu(h, c);
              }
              const u = [o[12] * n, o[13] * n, o[14] * n],
                d = s.getCenter(),
                p = z(e1.center.lat, -Xd, Xd),
                f = z(d.lat, -Xd, Xd),
                m = Gd(e1.center.lng),
                _ = qd(p);
              let g = m - Gd(d.lng);
              const y = _ - qd(f);
              g > 0.5 ? (g -= 1) : g < -0.5 && (g += 1);
              let x = 0;
              if (Math.abs(g) > Math.abs(y)) x = g >= 0 ? 1 : 3;
              else {
                x = y >= 0 ? 0 : 2;
                const e1 = [o[4] * n, o[5] * n, o[6] * n],
                  t = -Math.sin(w(y >= 0 ? s.getSouth() : s.getNorth())) * Yu;
                Mu.scaleAndAdd(u, u, e1, t);
              }
              const v = a[x],
                b = a[(x + 1) % 4],
                T = new od(v, b, u),
                E = [sd(T, 0) || v[0], sd(T, 1) || v[1], sd(T, 2) || v[2]],
                M = Ed(e1.zoom);
              if (M > 0) {
                const r = (function ({ x: e1, y: t, z: i }, r, n, o, s) {
                  const a = 1 / (1 << i);
                  let l = e1 * a,
                    c = l + a,
                    h = t * a,
                    u = h + a,
                    d = 0;
                  const p = (l + c) / 2 - o;
                  return (
                    p > 0.5 ? (d = -1) : p < -0.5 && (d = 1),
                    (l = ((l + d) * r - (o *= r)) * n + o),
                    (c = ((c + d) * r - o) * n + o),
                    (h = (h * r - (s *= r)) * n + s),
                    (u = (u * r - s) * n + s),
                    [
                      [l, u, 0],
                      [c, u, 0],
                      [c, h, 0],
                      [l, h, 0],
                    ]
                  );
                })(i, t, e1._pixelsPerMercatorPixel, m, _);
                for (let e1 = 0; e1 < a.length; e1++) ld(a[e1], r[e1], M);
                const n = Mu.add([], r[x], r[(x + 1) % 4]);
                Mu.scale(n, n, 0.5), ld(E, n, M);
              }
              for (const e1 of a) Mu.min(h, h, e1), Mu.max(c, c, e1);
              return (
                (h[2] = Math.min(v[2], b[2])),
                Mu.min(h, h, E),
                Mu.max(c, c, E),
                new Hu(h, c)
              );
            }
            function dd({ x: e1, y: t, z: i }, r = !1) {
              const n = 1 / (1 << i),
                o = new Nd(
                  $d(e1 * n),
                  t === (1 << i) - 1 && r ? -90 : Hd((t + 1) * n),
                ),
                s = new Nd($d((e1 + 1) * n), 0 === t && r ? 90 : Hd(t * n));
              return new Ql(o, s);
            }
            function pd(e1) {
              const t = w(e1.getNorth()),
                i = w(e1.getSouth()),
                r = Math.cos(t),
                n = Math.cos(i),
                o = Math.sin(t),
                s = Math.sin(i),
                a = e1.getWest(),
                l = e1.getEast();
              return [fd(n, s, a), fd(n, s, l), fd(r, o, l), fd(r, o, a)];
            }
            function fd(e1, t, i, r = Yu) {
              return (
                (i = w(i)), [e1 * Math.sin(i) * r, -t * r, e1 * Math.cos(i) * r]
              );
            }
            function md(e1, t, i) {
              return fd(Math.cos(w(e1)), Math.sin(w(e1)), t, i);
            }
            function _d(e1, t, i, r) {
              const n = 1 << i.z,
                o = (e1 / sr + i.x) / n;
              return md(Hd((t / sr + i.y) / n), $d(o), r);
            }
            function gd({ min: e1, max: t }) {
              return Ku / Math.max(t[0] - e1[0], t[1] - e1[1], t[2] - e1[2]);
            }
            const yd = new Float64Array(16);
            function xd(e1) {
              const t = gd(e1),
                i = xu.fromScaling(yd, [t, t, t]);
              return xu.translate(i, i, Mu.negate([], e1.min));
            }
            function vd(e1) {
              const t = xu.fromTranslation(yd, e1.min),
                i = 1 / gd(e1);
              return xu.scale(t, t, [i, i, i]);
            }
            function bd(e1) {
              const t = sr / (2 * Math.PI);
              return e1 / (2 * Math.PI) / t;
            }
            function wd(e1, t) {
              return (sr / (512 * Math.pow(2, e1))) * gd(ad(t));
            }
            function Td(e1, t, i, r, n) {
              const o = bd(i),
                s = [e1, t, -i / (2 * Math.PI)],
                a = xu.identity(new Float64Array(16));
              return (
                xu.translate(a, a, s),
                xu.scale(a, a, [o, o, o]),
                xu.rotateX(a, a, w(-n)),
                xu.rotateY(a, a, w(-r)),
                a
              );
            }
            function Ed(e1) {
              return D(Wu, Xu, e1);
            }
            function Md(e1, t, i) {
              const r = xu.identity(new Float64Array(16)),
                n = (t / (1 << e1) - 0.5) * Math.PI * 2;
              return xu.rotateY(r, i.globeMatrix, n), Float32Array.from(r);
            }
            function Ad(e1, t, i) {
              const r = Ed(i.zoom),
                n = e1.style.map._antialias,
                o =
                  t.extStandardDerivativesForceOff ||
                  (e1.terrain && e1.terrain.exaggeration() > 0);
              return 0 === r && !n && !o;
            }
            function Sd(e1, t, i, r) {
              const n = t.getNorth(),
                o = t.getSouth(),
                s = t.getWest(),
                a = t.getEast(),
                l = 1 << e1.z,
                c = a - s,
                h = n - o,
                u = c / Ju,
                d = -h / Qu[i],
                p = [0, u, 0, d, 0, 0, n, s, 0];
              if (e1.z > 0) {
                const e1 = 180 / r;
                gu.multiply(p, p, [
                  e1 / c + 1,
                  0,
                  0,
                  0,
                  e1 / h + 1,
                  0,
                  (-0.5 * e1) / u,
                  (0.5 * e1) / d,
                  1,
                ]);
              }
              return (p[2] = l), (p[5] = e1.x), (p[8] = e1.y), p;
            }
            function Id(e1) {
              const t = Xd - 5;
              e1 = (z(e1, -t, t) / t) * 90;
              const i = Math.pow(Math.abs(Math.sin(w(e1))), 3);
              return Math.round(i * (Qu.length - 1));
            }
            function Cd(e1) {
              const t = [0, 0, 0],
                i = xu.identity(new Float64Array(16));
              return (
                xu.multiply(i, e1.pixelMatrix, e1.globeMatrix),
                Mu.transformMat4(t, t, i),
                new y(t[0], t[1])
              );
            }
            function zd(e1, t) {
              const i = md(t.lat, t.lng),
                r = (function (e1) {
                  const t = md(e1._center.lat, e1._center.lng),
                    i = Mu.fromValues(0, 1, 0);
                  let r = Mu.cross([], i, t);
                  const n = xu.fromRotation([], -e1.angle, t);
                  (r = Mu.transformMat4(r, r, n)),
                    xu.fromRotation(n, -e1._pitch, r);
                  const o = Mu.normalize([], t);
                  return (
                    Mu.scale(
                      o,
                      o,
                      rd(e1.cameraToCenterDistance / e1.pixelsPerMeter),
                    ),
                    Mu.transformMat4(o, o, n),
                    Mu.add([], t, o)
                  );
                })(e1),
                n = Mu.subtract([], r, i);
              return Mu.angle(n, i);
            }
            function Dd(e1, t) {
              return zd(e1, t) > (Math.PI / 2) * 1.01;
            }
            const Pd = w(85),
              Rd = Math.cos(Pd),
              Ld = Math.sin(Pd);
            class kd {
              constructor(e1) {
                this._createGrid(e1), this._createPoles(e1);
              }
              destroy() {
                this._poleIndexBuffer.destroy(),
                  this._gridBuffer.destroy(),
                  this._gridIndexBuffer.destroy(),
                  this._poleNorthVertexBuffer.destroy(),
                  this._poleSouthVertexBuffer.destroy();
                for (const e1 of this._poleSegments) e1.destroy();
                for (const e1 of this._gridSegments)
                  e1.withSkirts.destroy(), e1.withoutSkirts.destroy();
              }
              _fillGridMeshWithLods(e1, t) {
                const i = new Ta(),
                  r = new Va(),
                  n = [],
                  o = e1 + 1 + 2,
                  s = t[0] + 1,
                  a = t[0] + 1 + (1 + t.length),
                  l = (e1, t, i) => {
                    let r = e1 === o - 1 ? e1 - 2 : 0 === e1 ? e1 : e1 - 1;
                    return (r += i ? 24575 : 0), [r, t];
                  };
                for (let e1 = 0; e1 < o; ++e1) i.emplaceBack(...l(e1, 0, !0));
                for (let e1 = 0; e1 < s; ++e1)
                  for (let t = 0; t < o; ++t)
                    i.emplaceBack(...l(t, e1, (0 === t || t === o - 1) && !0));
                for (let e1 = 0; e1 < t.length; ++e1) {
                  const r = t[e1];
                  for (let e1 = 0; e1 < o; ++e1) i.emplaceBack(...l(e1, r, !0));
                }
                for (let e1 = 0; e1 < t.length; ++e1) {
                  const s = r.length,
                    l = t[e1] + 1 + 2,
                    c = new Va();
                  for (let i = 0; i < l - 1; i++) {
                    const n = i === l - 2,
                      s = n ? o * (a - t.length + e1 - i) : o;
                    for (let e1 = 0; e1 < o - 1; e1++) {
                      const t = i * o + e1;
                      0 === i || n || 0 === e1 || e1 === o - 2
                        ? (c.emplaceBack(t + 1, t, t + s),
                          c.emplaceBack(t + s, t + s + 1, t + 1))
                        : (r.emplaceBack(t + 1, t, t + s),
                          r.emplaceBack(t + s, t + s + 1, t + 1));
                    }
                  }
                  const h = dl.simpleSegment(0, s, i.length, r.length - s);
                  for (let e1 = 0; e1 < c.uint16.length; e1 += 3)
                    r.emplaceBack(
                      c.uint16[e1],
                      c.uint16[e1 + 1],
                      c.uint16[e1 + 2],
                    );
                  const u = dl.simpleSegment(0, s, i.length, r.length - s);
                  n.push({
                    withoutSkirts: h,
                    withSkirts: u,
                  });
                }
                return {
                  vertices: i,
                  indices: r,
                  segments: n,
                };
              }
              _createGrid(e1) {
                const t = this._fillGridMeshWithLods(Ju, Qu);
                (this._gridSegments = t.segments),
                  (this._gridBuffer = e1.createVertexBuffer(
                    t.vertices,
                    Pu.members,
                  )),
                  (this._gridIndexBuffer = e1.createIndexBuffer(t.indices, !0));
              }
              _createPoles(e1) {
                const t = new Va();
                for (let e1 = 0; e1 <= Ju; e1++)
                  t.emplaceBack(0, e1 + 1, e1 + 2);
                this._poleIndexBuffer = e1.createIndexBuffer(t, !0);
                const i = new Za(),
                  r = new Za(),
                  n = new Za(),
                  o = new Za();
                this._poleSegments = [];
                for (let e1 = 0, t = 0; e1 < Wu; e1++) {
                  const s = 360 / (1 << e1);
                  i.emplaceBack(0, -Yu, 0, 0.5, 0),
                    r.emplaceBack(0, -Yu, 0, 0.5, 1),
                    n.emplaceBack(0, -Yu, 0, 0.5, 0.5),
                    o.emplaceBack(0, -Yu, 0, 0.5, 0.5);
                  for (let e1 = 0; e1 <= Ju; e1++) {
                    let t = e1 / Ju,
                      a = 0;
                    const l = Wr(0, s, t),
                      [c, h, u] = fd(Rd, Ld, l, Yu);
                    i.emplaceBack(c, h, u, t, a),
                      r.emplaceBack(c, h, u, t, 1 - a);
                    const d = w(l);
                    (t = 0.5 + 0.5 * Math.sin(d)),
                      (a = 0.5 + 0.5 * Math.cos(d)),
                      n.emplaceBack(c, h, u, t, a),
                      o.emplaceBack(c, h, u, t, 1 - a);
                  }
                  this._poleSegments.push(dl.simpleSegment(t, 0, 66, 64)),
                    (t += 66);
                }
                (this._poleNorthVertexBuffer = e1.createVertexBuffer(
                  i,
                  zu,
                  !1,
                )),
                  (this._poleSouthVertexBuffer = e1.createVertexBuffer(
                    r,
                    zu,
                    !1,
                  )),
                  (this._texturedPoleNorthVertexBuffer = e1.createVertexBuffer(
                    n,
                    zu,
                    !1,
                  )),
                  (this._texturedPoleSouthVertexBuffer = e1.createVertexBuffer(
                    o,
                    zu,
                    !1,
                  ));
              }
              getGridBuffers(e1, t) {
                return [
                  this._gridBuffer,
                  this._gridIndexBuffer,
                  t
                    ? this._gridSegments[e1].withSkirts
                    : this._gridSegments[e1].withoutSkirts,
                ];
              }
              getPoleBuffers(e1, t) {
                return [
                  t
                    ? this._texturedPoleNorthVertexBuffer
                    : this._poleNorthVertexBuffer,
                  t
                    ? this._texturedPoleSouthVertexBuffer
                    : this._poleSouthVertexBuffer,
                  this._poleIndexBuffer,
                  this._poleSegments[e1],
                ];
              }
            }
            const Od = 6371008.8,
              Bd = 2 * Math.PI * Od;
            class Fd {
              constructor(e1, t) {
                if (isNaN(e1) || isNaN(t))
                  throw new Error(`Invalid LngLat object: (${e1}, ${t})`);
                if (
                  ((this.lng = +e1),
                  (this.lat = +t),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90",
                  );
              }
              wrap() {
                return new Fd(P(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(e1) {
                const t = Math.PI / 180,
                  i = this.lat * t,
                  r = e1.lat * t,
                  n =
                    Math.sin(i) * Math.sin(r) +
                    Math.cos(i) *
                      Math.cos(r) *
                      Math.cos((e1.lng - this.lng) * t);
                return Od * Math.acos(Math.min(n, 1));
              }
              toBounds(e1 = 0) {
                const t = (360 * e1) / 40075017,
                  i = t / Math.cos((Math.PI / 180) * this.lat);
                return new Ql(
                  new Fd(this.lng - i, this.lat - t),
                  new Fd(this.lng + i, this.lat + t),
                );
              }
              toEcef(e1) {
                const t = rd(e1);
                return md(this.lat, this.lng, Yu + t);
              }
              static convert(e1) {
                if (e1 instanceof Fd) return e1;
                if (Array.isArray(e1) && (2 === e1.length || 3 === e1.length))
                  return new Fd(Number(e1[0]), Number(e1[1]));
                if (!Array.isArray(e1) && "object" == typeof e1 && null !== e1)
                  return new Fd(
                    Number("lng" in e1 ? e1.lng : e1.lon),
                    Number(e1.lat),
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]",
                );
              }
            }
            var Nd = Fd;
            const Ud = 0,
              Vd = 25.5;
            function jd(e1) {
              return Bd * Math.cos((e1 * Math.PI) / 180);
            }
            function Gd(e1) {
              return (180 + e1) / 360;
            }
            function qd(e1) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (e1 * Math.PI) / 360))) /
                360
              );
            }
            function Zd(e1, t) {
              return e1 / jd(t);
            }
            function $d(e1) {
              return 360 * e1 - 180;
            }
            function Hd(e1) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * e1) * Math.PI) / 180)) -
                90
              );
            }
            function Wd(e1, t) {
              return e1 * jd(Hd(t));
            }
            const Xd = 85.051129;
            function Yd(e1) {
              return Math.cos(w(z(e1, -Xd, Xd)));
            }
            function Kd(e1, t) {
              const i = z(t, Ud, Vd),
                r = Math.pow(2, i);
              return (Yd(e1) * Bd) / (512 * r);
            }
            function Jd(e1) {
              return 1 / Math.cos((e1 * Math.PI) / 180);
            }
            function Qd(e1, t = 0) {
              const i = Math.exp(
                Math.PI * (1 - ((e1.y + t / sr) / (1 << e1.z)) * 2),
              );
              return (80150034 * i) / (i * i + 1) / sr / (1 << e1.z);
            }
            class ep {
              constructor(e1, t, i = 0) {
                (this.x = +e1), (this.y = +t), (this.z = +i);
              }
              static fromLngLat(e1, t = 0) {
                const i = Nd.convert(e1);
                return new ep(Gd(i.lng), qd(i.lat), Zd(t, i.lat));
              }
              toLngLat() {
                return new Nd($d(this.x), Hd(this.y));
              }
              toAltitude() {
                return Wd(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (1 / Bd) * Jd(Hd(this.y));
              }
            }
            function tp(e1, t, i, r, n, o, s, a, l) {
              const c = (t + r) / 2,
                h = (i + n) / 2,
                u = new y(c, h);
              a(u),
                (function (e1, t, i, r, n, o) {
                  const s = i - n,
                    a = r - o;
                  return (
                    Math.abs((r - t) * s - (i - e1) * a) / Math.hypot(s, a)
                  );
                })(u.x, u.y, o.x, o.y, s.x, s.y) >= l
                  ? (tp(e1, t, i, c, h, o, u, a, l),
                    tp(e1, c, h, r, n, u, s, a, l))
                  : e1.push(s);
            }
            function ip(e1, t, i) {
              let r = e1[0],
                n = r.x,
                o = r.y;
              t(r);
              const s = [r];
              for (let a = 1; a < e1.length; a++) {
                const l = e1[a],
                  { x: c, y: h } = l;
                t(l), tp(s, n, o, c, h, r, l, t, i), (n = c), (o = h), (r = l);
              }
              return s;
            }
            function rp(e1, t, i, r) {
              if (r(t, i)) {
                const n = t.add(i)._mult(0.5);
                rp(e1, t, n, r), rp(e1, n, i, r);
              } else e1.push(i);
            }
            function np(e1, t) {
              let i = e1[0];
              const r = [i];
              for (let n = 1; n < e1.length; n++) {
                const o = e1[n];
                rp(r, i, o, t), (i = o);
              }
              return r;
            }
            const op = Math.pow(2, 14) - 1,
              sp = -op - 1;
            function ap(e1, t) {
              const i = Math.round(e1.x * t),
                r = Math.round(e1.y * t);
              return (
                (e1.x = z(i, sp, op)),
                (e1.y = z(r, sp, op)),
                (i < e1.x || i > e1.x + 1 || r < e1.y || r > e1.y + 1) &&
                  W(
                    "Geometry exceeds allowed extent, reduce your vector tile buffer size",
                  ),
                e1
              );
            }
            function lp(e1, t, i) {
              const r = e1.loadGeometry(),
                n = e1.extent,
                o = sr / n;
              if (t && i && i.projection.isReprojectedInTileSpace) {
                const o = 1 << t.z,
                  { scale: s, x: a, y: l, projection: c } = i,
                  h = (e1) => {
                    const i = $d((t.x + e1.x / n) / o),
                      r = Hd((t.y + e1.y / n) / o),
                      h = c.project(i, r);
                    (e1.x = (h.x * s - a) * n), (e1.y = (h.y * s - l) * n);
                  };
                for (let t = 0; t < r.length; t++)
                  if (1 !== e1.type) r[t] = ip(r[t], h, 1);
                  else {
                    const e1 = [];
                    for (const i of r[t])
                      i.x < 0 ||
                        i.x >= n ||
                        i.y < 0 ||
                        i.y >= n ||
                        (h(i), e1.push(i));
                    r[t] = e1;
                  }
              }
              for (const e1 of r) for (const t of e1) ap(t, o);
              return r;
            }
            function cp(e1, t) {
              return {
                type: e1.type,
                id: e1.id,
                properties: e1.properties,
                geometry: t ? lp(e1) : [],
              };
            }
            function hp(e1, t, i, r, n) {
              e1.emplaceBack(2 * t + (r + 1) / 2, 2 * i + (n + 1) / 2);
            }
            function up(e1, t, i) {
              const r = 16384;
              e1.emplaceBack(t.x, t.y, t.z, i[0] * r, i[1] * r, i[2] * r);
            }
            class dp {
              constructor(e1) {
                (this.zoom = e1.zoom),
                  (this.overscaling = e1.overscaling),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.index = e1.index),
                  (this.hasPattern = !1),
                  (this.projection = e1.projection),
                  (this.layoutVertexArray = new Ta()),
                  (this.indexArray = new Va()),
                  (this.segments = new dl()),
                  (this.programConfigurations = new Hl(e1.layers, e1.zoom)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id));
              }
              populate(e1, t, i, r) {
                const n = this.layers[0],
                  o = [];
                let s = null;
                "circle" === n.type && (s = n.layout.get("circle-sort-key"));
                for (const {
                  feature: t,
                  id: n,
                  index: a,
                  sourceLayerIndex: l,
                } of e1) {
                  const e1 = this.layers[0]._featureFilter.needGeometry,
                    c = cp(t, e1);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ea(this.zoom),
                      c,
                      i,
                    )
                  )
                    continue;
                  const h = s ? s.evaluate(c, {}, i) : void 0,
                    u = {
                      id: n,
                      properties: t.properties,
                      type: t.type,
                      sourceLayerIndex: l,
                      index: a,
                      geometry: e1 ? c.geometry : lp(t, i, r),
                      patterns: {},
                      sortKey: h,
                    };
                  o.push(u);
                }
                s && o.sort((e1, t) => e1.sortKey - t.sortKey);
                let a = null;
                "globe" === r.projection.name &&
                  ((this.globeExtVertexArray = new Da()), (a = r.projection));
                for (const r of o) {
                  const { geometry: n, index: o, sourceLayerIndex: s } = r,
                    l = e1[o].feature;
                  this.addFeature(
                    r,
                    n,
                    o,
                    t.availableImages,
                    i,
                    a,
                    t.brightness,
                  ),
                    t.featureIndex.insert(l, n, o, s, this.index);
                }
              }
              update(e1, t, i, r, n) {
                const o = 0 !== Object.keys(e1).length;
                (o && !this.stateDependentLayers.length) ||
                  this.programConfigurations.updatePaintArrays(
                    e1,
                    t,
                    o ? this.stateDependentLayers : this.layers,
                    i,
                    r,
                    n,
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(e1) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = e1.createVertexBuffer(
                    this.layoutVertexArray,
                    hl.members,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray)),
                  this.globeExtVertexArray &&
                    (this.globeExtVertexBuffer = e1.createVertexBuffer(
                      this.globeExtVertexArray,
                      ul.members,
                    ))),
                  this.programConfigurations.upload(e1),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy());
              }
              addFeature(e1, t, i, r, n, o, s) {
                for (const i of t)
                  for (const t of i) {
                    const i = t.x,
                      r = t.y;
                    if (i < 0 || i >= sr || r < 0 || r >= sr) continue;
                    if (o) {
                      const e1 = o.projectTilePoint(i, r, n),
                        t = o.upVector(n, i, r),
                        s = this.globeExtVertexArray;
                      up(s, e1, t), up(s, e1, t), up(s, e1, t), up(s, e1, t);
                    }
                    const s = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                        e1.sortKey,
                      ),
                      a = s.vertexLength;
                    hp(this.layoutVertexArray, i, r, -1, -1),
                      hp(this.layoutVertexArray, i, r, 1, -1),
                      hp(this.layoutVertexArray, i, r, 1, 1),
                      hp(this.layoutVertexArray, i, r, -1, 1),
                      this.indexArray.emplaceBack(a, a + 1, a + 2),
                      this.indexArray.emplaceBack(a, a + 2, a + 3),
                      (s.vertexLength += 4),
                      (s.primitiveLength += 2);
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e1,
                  i,
                  {},
                  r,
                  n,
                  s,
                );
              }
            }
            function pp(e1, t) {
              for (let i = 0; i < e1.length; i++) if (wp(t, e1[i])) return !0;
              for (let i = 0; i < t.length; i++) if (wp(e1, t[i])) return !0;
              return !!gp(e1, t);
            }
            function fp(e1, t, i) {
              return !!wp(e1, t) || !!xp(t, e1, i);
            }
            function mp(e1, t) {
              if (1 === e1.length) return bp(t, e1[0]);
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                for (let t = 0; t < r.length; t++) if (wp(e1, r[t])) return !0;
              }
              for (let i = 0; i < e1.length; i++) if (bp(t, e1[i])) return !0;
              for (let i = 0; i < t.length; i++) if (gp(e1, t[i])) return !0;
              return !1;
            }
            function _p(e1, t, i) {
              if (e1.length > 1) {
                if (gp(e1, t)) return !0;
                for (let r = 0; r < t.length; r++)
                  if (xp(t[r], e1, i)) return !0;
              }
              for (let r = 0; r < e1.length; r++)
                if (xp(e1[r], t, i)) return !0;
              return !1;
            }
            function gp(e1, t) {
              if (0 === e1.length || 0 === t.length) return !1;
              for (let i = 0; i < e1.length - 1; i++) {
                const r = e1[i],
                  n = e1[i + 1];
                for (let e1 = 0; e1 < t.length - 1; e1++)
                  if (yp(r, n, t[e1], t[e1 + 1])) return !0;
              }
              return !1;
            }
            function yp(e1, t, i, r) {
              return X(e1, i, r) !== X(t, i, r) && X(e1, t, i) !== X(e1, t, r);
            }
            function xp(e1, t, i) {
              const r = i * i;
              if (1 === t.length) return e1.distSqr(t[0]) < r;
              for (let i = 1; i < t.length; i++)
                if (vp(e1, t[i - 1], t[i]) < r) return !0;
              return !1;
            }
            function vp(e1, t, i) {
              const r = t.distSqr(i);
              if (0 === r) return e1.distSqr(t);
              const n =
                ((e1.x - t.x) * (i.x - t.x) + (e1.y - t.y) * (i.y - t.y)) / r;
              return e1.distSqr(
                n < 0 ? t : n > 1 ? i : i.sub(t)._mult(n)._add(t),
              );
            }
            function bp(e1, t) {
              let i,
                r,
                n,
                o = !1;
              for (let s = 0; s < e1.length; s++) {
                i = e1[s];
                for (let e1 = 0, s = i.length - 1; e1 < i.length; s = e1++)
                  (r = i[e1]),
                    (n = i[s]),
                    r.y > t.y != n.y > t.y &&
                      t.x < ((n.x - r.x) * (t.y - r.y)) / (n.y - r.y) + r.x &&
                      (o = !o);
              }
              return o;
            }
            function wp(e1, t) {
              let i = !1;
              for (let r = 0, n = e1.length - 1; r < e1.length; n = r++) {
                const o = e1[r],
                  s = e1[n];
                o.y > t.y != s.y > t.y &&
                  t.x < ((s.x - o.x) * (t.y - o.y)) / (s.y - o.y) + o.x &&
                  (i = !i);
              }
              return i;
            }
            function Tp(e1, t, i, r, n) {
              for (const o of e1)
                if (t <= o.x && i <= o.y && r >= o.x && n >= o.y) return !0;
              const o = [new y(t, i), new y(t, n), new y(r, n), new y(r, i)];
              if (e1.length > 2) {
                for (const t of o) if (wp(e1, t)) return !0;
              }
              for (let t = 0; t < e1.length - 1; t++)
                if (Ep(e1[t], e1[t + 1], o)) return !0;
              return !1;
            }
            function Ep(e1, t, i) {
              const r = i[0],
                n = i[2];
              if (
                (e1.x < r.x && t.x < r.x) ||
                (e1.x > n.x && t.x > n.x) ||
                (e1.y < r.y && t.y < r.y) ||
                (e1.y > n.y && t.y > n.y)
              )
                return !1;
              const o = X(e1, t, i[0]);
              return (
                o !== X(e1, t, i[1]) ||
                o !== X(e1, t, i[2]) ||
                o !== X(e1, t, i[3])
              );
            }
            function Mp(e1, t, i, r, n, o) {
              let s = t.y - e1.y,
                a = e1.x - t.x;
              if ((o = o || 0)) {
                const e1 = s * s + a * a;
                if (0 === e1) return !0;
                const t = Math.sqrt(e1);
                (s /= t), (a /= t);
              }
              return !(
                (i.x - e1.x) * s + (i.y - e1.y) * a - o < 0 ||
                (r.x - e1.x) * s + (r.y - e1.y) * a - o < 0 ||
                (n.x - e1.x) * s + (n.y - e1.y) * a - o < 0
              );
            }
            function Ap(e1, t, i, r, n, o, s) {
              return !(
                Mp(e1, t, r, n, o, s) ||
                Mp(t, i, r, n, o, s) ||
                Mp(i, e1, r, n, o, s) ||
                Mp(r, n, e1, t, i, s) ||
                Mp(n, o, e1, t, i, s) ||
                Mp(o, r, e1, t, i, s)
              );
            }
            function Sp(e1, t, i) {
              const r = t.paint.get(e1).value;
              return "constant" === r.kind
                ? r.value
                : i.programConfigurations.get(t.id).getMaxValue(e1);
            }
            function Ip(e1) {
              return Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]);
            }
            function Cp(e1, t, i, r, n) {
              if (!t[0] && !t[1]) return e1;
              const o = y.convert(t)._mult(n);
              "viewport" === i && o._rotate(-r);
              const s = [];
              for (let t = 0; t < e1.length; t++) s.push(e1[t].sub(o));
              return s;
            }
            function zp(e1, t, i, r) {
              const n = y.convert(e1)._mult(r);
              return "viewport" === t && n._rotate(-i), n;
            }
            Is(dp, "CircleBucket", {
              omit: ["layers"],
            });
            const Dp = new da({
              "circle-sort-key": new ha(Ct.layout_circle["circle-sort-key"]),
              visibility: new ca(Ct.layout_circle.visibility),
            });
            var Pp = {
              paint: new da({
                "circle-radius": new ha(Ct.paint_circle["circle-radius"]),
                "circle-color": new ha(Ct.paint_circle["circle-color"]),
                "circle-blur": new ha(Ct.paint_circle["circle-blur"]),
                "circle-opacity": new ha(Ct.paint_circle["circle-opacity"]),
                "circle-translate": new ca(Ct.paint_circle["circle-translate"]),
                "circle-translate-anchor": new ca(
                  Ct.paint_circle["circle-translate-anchor"],
                ),
                "circle-pitch-scale": new ca(
                  Ct.paint_circle["circle-pitch-scale"],
                ),
                "circle-pitch-alignment": new ca(
                  Ct.paint_circle["circle-pitch-alignment"],
                ),
                "circle-stroke-width": new ha(
                  Ct.paint_circle["circle-stroke-width"],
                ),
                "circle-stroke-color": new ha(
                  Ct.paint_circle["circle-stroke-color"],
                ),
                "circle-stroke-opacity": new ha(
                  Ct.paint_circle["circle-stroke-opacity"],
                ),
                "circle-emissive-strength": new ca(
                  Ct.paint_circle["circle-emissive-strength"],
                ),
              }),
              layout: Dp,
            };
            const Rp = xu.create(),
              Lp = (e1, t, i, r, n, o) => {
                const s = e1.transform,
                  a = "globe" === s.projection.name;
                let l;
                if ("map" === o.paint.get("circle-pitch-alignment")) {
                  if (a) {
                    const e1 =
                      wd(s.zoom, t.canonical) * s._pixelsPerMercatorPixel;
                    l = Float32Array.from([e1, 0, 0, e1]);
                  } else l = s.calculatePixelsToTileUnitsMatrix(i);
                } else
                  l = new Float32Array([
                    s.pixelsToGLUnits[0],
                    0,
                    0,
                    s.pixelsToGLUnits[1],
                  ]);
                const c = {
                  u_camera_to_center_distance:
                    e1.transform.getCameraToCenterDistance(s.projection),
                  u_matrix: e1.translatePosMatrix(
                    t.projMatrix,
                    i,
                    o.paint.get("circle-translate"),
                    o.paint.get("circle-translate-anchor"),
                  ),
                  u_device_pixel_ratio: ht.devicePixelRatio,
                  u_extrude_scale: l,
                  u_inv_rot_matrix: Rp,
                  u_merc_center: [0, 0],
                  u_tile_id: [0, 0, 0],
                  u_zoom_transition: 0,
                  u_up_dir: [0, 0, 0],
                  u_emissive_strength: o.paint.get("circle-emissive-strength"),
                };
                if (a) {
                  (c.u_inv_rot_matrix = r),
                    (c.u_merc_center = n),
                    (c.u_tile_id = [
                      t.canonical.x,
                      t.canonical.y,
                      1 << t.canonical.z,
                    ]),
                    (c.u_zoom_transition = Ed(s.zoom));
                  const e1 = n[0] * sr,
                    i = n[1] * sr;
                  c.u_up_dir = s.projection.upVector(new ku(0, 0, 0), e1, i);
                }
                return c;
              },
              kp = (e1) => {
                const t = [];
                return (
                  "map" === e1.paint.get("circle-pitch-alignment") &&
                    t.push("PITCH_WITH_MAP"),
                  "map" === e1.paint.get("circle-pitch-scale") &&
                    t.push("SCALE_WITH_MAP"),
                  t
                );
              };
            function Op(e1, t, i, r, n, o, s, a, l) {
              if (o && e1.queryGeometry.isAboveHorizon) return !1;
              o && (l *= e1.pixelToTileUnitsFactor);
              const c = e1.tileID.canonical,
                h = i.projection.upVectorScale(
                  c,
                  i.center.lat,
                  i.worldSize,
                ).metersToTile;
              for (const u of t)
                for (const t of u) {
                  const u = t.add(a),
                    d =
                      n && i.elevation
                        ? i.elevation.exaggeration() *
                          n.getElevationAt(u.x, u.y, !0)
                        : 0,
                    p = i.projection.projectTilePoint(u.x, u.y, c);
                  if (d > 0) {
                    const e1 = i.projection.upVector(c, u.x, u.y);
                    (p.x += e1[0] * h * d),
                      (p.y += e1[1] * h * d),
                      (p.z += e1[2] * h * d);
                  }
                  const f = o ? u : Bp(p.x, p.y, p.z, r),
                    m = o
                      ? e1.tilespaceRays.map((e1) => Up(e1, d))
                      : e1.queryGeometry.screenGeometry,
                    _ = uu.transformMat4([], [p.x, p.y, p.z, 1], r);
                  if (
                    (!s && o
                      ? (l *= _[3] / i.cameraToCenterDistance)
                      : s && !o && (l *= i.cameraToCenterDistance / _[3]),
                    o)
                  ) {
                    const e1 = Hd((t.y / sr + c.y) / (1 << c.z));
                    l /= i.projection.pixelsPerMeter(e1, 1) / Zd(1, e1);
                  }
                  if (fp(m, f, l)) return !0;
                }
              return !1;
            }
            function Bp(e1, t, i, r) {
              const n = uu.transformMat4([], [e1, t, i, 1], r);
              return new y(n[0] / n[3], n[1] / n[3]);
            }
            const Fp = Mu.fromValues(0, 0, 0),
              Np = Mu.fromValues(0, 0, 1);
            function Up(e1, t) {
              const i = Mu.create();
              return (
                (Fp[2] = t), e1.intersectsPlane(Fp, Np, i), new y(i[0], i[1])
              );
            }
            class Vp extends dp {}
            function jp(e1, { width: t, height: i }, r, n) {
              if (n) {
                if (n instanceof Uint8ClampedArray)
                  n = new Uint8Array(n.buffer);
                else if (n.length !== t * i * r)
                  throw new RangeError("mismatched image size");
              } else n = new Uint8Array(t * i * r);
              return (e1.width = t), (e1.height = i), (e1.data = n), e1;
            }
            function Gp(e1, t, i) {
              const { width: r, height: n } = t;
              (r === e1.width && n === e1.height) ||
                (qp(
                  e1,
                  t,
                  {
                    x: 0,
                    y: 0,
                  },
                  {
                    x: 0,
                    y: 0,
                  },
                  {
                    width: Math.min(e1.width, r),
                    height: Math.min(e1.height, n),
                  },
                  i,
                ),
                (e1.width = r),
                (e1.height = n),
                (e1.data = t.data));
            }
            function qp(e1, t, i, r, n, o) {
              if (0 === n.width || 0 === n.height) return t;
              if (
                n.width > e1.width ||
                n.height > e1.height ||
                i.x > e1.width - n.width ||
                i.y > e1.height - n.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy",
                );
              if (
                n.width > t.width ||
                n.height > t.height ||
                r.x > t.width - n.width ||
                r.y > t.height - n.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy",
                );
              const s = e1.data,
                a = t.data;
              for (let l = 0; l < n.height; l++) {
                const c = ((i.y + l) * e1.width + i.x) * o,
                  h = ((r.y + l) * t.width + r.x) * o;
                for (let e1 = 0; e1 < n.width * o; e1++) a[h + e1] = s[c + e1];
              }
              return t;
            }
            Is(Vp, "HeatmapBucket", {
              omit: ["layers"],
            });
            class Zp {
              constructor(e1, t) {
                jp(this, e1, 1, t);
              }
              resize(e1) {
                Gp(this, new Zp(e1), 1);
              }
              clone() {
                return new Zp(
                  {
                    width: this.width,
                    height: this.height,
                  },
                  new Uint8Array(this.data),
                );
              }
              static copy(e1, t, i, r, n) {
                qp(e1, t, i, r, n, 1);
              }
            }
            class $p {
              constructor(e1, t) {
                jp(this, e1, 4, t);
              }
              resize(e1) {
                Gp(this, new $p(e1), 4);
              }
              replace(e1, t) {
                t
                  ? this.data.set(e1)
                  : (this.data =
                      e1 instanceof Uint8ClampedArray
                        ? new Uint8Array(e1.buffer)
                        : e1);
              }
              clone() {
                return new $p(
                  {
                    width: this.width,
                    height: this.height,
                  },
                  new Uint8Array(this.data),
                );
              }
              static copy(e1, t, i, r, n) {
                qp(e1, t, i, r, n, 4);
              }
            }
            class Hp {
              constructor(e1, t) {
                (this.width = e1.width),
                  (this.height = e1.height),
                  (this.data =
                    t instanceof Uint8Array ? new Float32Array(t.buffer) : t);
              }
            }
            Is(Zp, "AlphaImage"), Is($p, "RGBAImage");
            const Wp = new da({
              visibility: new ca(Ct.layout_heatmap.visibility),
            });
            var Xp = {
              paint: new da({
                "heatmap-radius": new ha(Ct.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new ha(Ct.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new ca(
                  Ct.paint_heatmap["heatmap-intensity"],
                ),
                "heatmap-color": new ua(Ct.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new ca(Ct.paint_heatmap["heatmap-opacity"]),
              }),
              layout: Wp,
            };
            function Yp(e1) {
              const t = {},
                i = e1.resolution || 256,
                r = e1.clips ? e1.clips.length : 1,
                n =
                  e1.image ||
                  new $p({
                    width: i,
                    height: r,
                  }),
                o = (i, r, o) => {
                  t[e1.evaluationKey] = o;
                  const s = e1.expression.evaluate(t);
                  s &&
                    ((n.data[i + r + 0] = Math.floor((255 * s.r) / s.a)),
                    (n.data[i + r + 1] = Math.floor((255 * s.g) / s.a)),
                    (n.data[i + r + 2] = Math.floor((255 * s.b) / s.a)),
                    (n.data[i + r + 3] = Math.floor(255 * s.a)));
                };
              if (e1.clips)
                for (let t = 0, n = 0; t < r; ++t, n += 4 * i)
                  for (let r = 0, s = 0; r < i; r++, s += 4) {
                    const a = r / (i - 1),
                      { start: l, end: c } = e1.clips[t];
                    o(n, s, l * (1 - a) + c * a);
                  }
              else
                for (let e1 = 0, t = 0; e1 < i; e1++, t += 4)
                  o(0, t, e1 / (i - 1));
              return n;
            }
            const Kp = new da({
              visibility: new ca(Ct.layout_hillshade.visibility),
            });
            var Jp = {
              paint: new da({
                "hillshade-illumination-direction": new ca(
                  Ct.paint_hillshade["hillshade-illumination-direction"],
                ),
                "hillshade-illumination-anchor": new ca(
                  Ct.paint_hillshade["hillshade-illumination-anchor"],
                ),
                "hillshade-exaggeration": new ca(
                  Ct.paint_hillshade["hillshade-exaggeration"],
                ),
                "hillshade-shadow-color": new ca(
                  Ct.paint_hillshade["hillshade-shadow-color"],
                ),
                "hillshade-highlight-color": new ca(
                  Ct.paint_hillshade["hillshade-highlight-color"],
                ),
                "hillshade-accent-color": new ca(
                  Ct.paint_hillshade["hillshade-accent-color"],
                ),
                "hillshade-emissive-strength": new ca(
                  Ct.paint_hillshade["hillshade-emissive-strength"],
                ),
              }),
              layout: Kp,
            };
            const Qp = ba(
                [
                  {
                    name: "a_pos",
                    components: 2,
                    type: "Int16",
                  },
                ],
                4,
              ),
              { members: ef } = Qp;
            var tf = {
              exports: {},
            };
            function rf(e1, t, i) {
              i = i || 2;
              var r,
                n,
                o,
                s,
                a,
                l,
                c,
                h = t && t.length,
                u = h ? t[0] * i : e1.length,
                d = nf(e1, 0, u, i, !0),
                p = [];
              if (!d || d.next === d.prev) return p;
              if (
                (h &&
                  (d = (function (e1, t, i, r) {
                    var n,
                      o,
                      s,
                      a = [];
                    for (n = 0, o = t.length; n < o; n++)
                      (s = nf(
                        e1,
                        t[n] * r,
                        n < o - 1 ? t[n + 1] * r : e1.length,
                        r,
                        !1,
                      )) === s.next && (s.steiner = !0),
                        a.push(mf(s));
                    for (a.sort(uf), n = 0; n < a.length; n++) i = df(a[n], i);
                    return i;
                  })(e1, t, d, i)),
                e1.length > 80 * i)
              ) {
                (r = o = e1[0]), (n = s = e1[1]);
                for (var f = i; f < u; f += i)
                  (a = e1[f]) < r && (r = a),
                    (l = e1[f + 1]) < n && (n = l),
                    a > o && (o = a),
                    l > s && (s = l);
                c = 0 !== (c = Math.max(o - r, s - n)) ? 32767 / c : 0;
              }
              return sf(d, p, i, r, n, c, 0), p;
            }
            function nf(e1, t, i, r, n) {
              var o, s;
              if (n === If(e1, t, i, r) > 0)
                for (o = t; o < i; o += r) s = Mf(o, e1[o], e1[o + 1], s);
              else
                for (o = i - r; o >= t; o -= r) s = Mf(o, e1[o], e1[o + 1], s);
              return s && xf(s, s.next) && (Af(s), (s = s.next)), s;
            }
            function of(e1, t) {
              if (!e1) return e1;
              t || (t = e1);
              var i,
                r = e1;
              do
                if (
                  ((i = !1),
                  r.steiner || (!xf(r, r.next) && 0 !== yf(r.prev, r, r.next)))
                )
                  r = r.next;
                else {
                  if ((Af(r), (r = t = r.prev) === r.next)) break;
                  i = !0;
                }
              while (i || r !== t);
              return t;
            }
            function sf(e1, t, i, r, n, o, s) {
              if (e1) {
                !s &&
                  o &&
                  (function (e1, t, i, r) {
                    var n = e1;
                    do
                      0 === n.z && (n.z = ff(n.x, n.y, t, i, r)),
                        (n.prevZ = n.prev),
                        (n.nextZ = n.next),
                        (n = n.next);
                    while (n !== e1);
                    (n.prevZ.nextZ = null),
                      (n.prevZ = null),
                      (function (e1) {
                        var t,
                          i,
                          r,
                          n,
                          o,
                          s,
                          a,
                          l,
                          c = 1;
                        do {
                          for (i = e1, e1 = null, o = null, s = 0; i; ) {
                            for (
                              s++, r = i, a = 0, t = 0;
                              t < c && (a++, (r = r.nextZ));
                              t++
                            );
                            for (l = c; a > 0 || (l > 0 && r); )
                              0 !== a && (0 === l || !r || i.z <= r.z)
                                ? ((n = i), (i = i.nextZ), a--)
                                : ((n = r), (r = r.nextZ), l--),
                                o ? (o.nextZ = n) : (e1 = n),
                                (n.prevZ = o),
                                (o = n);
                            i = r;
                          }
                          (o.nextZ = null), (c *= 2);
                        } while (s > 1);
                      })(n);
                  })(e1, r, n, o);
                for (var a, l, c = e1; e1.prev !== e1.next; )
                  if (
                    ((a = e1.prev), (l = e1.next), o ? lf(e1, r, n, o) : af(e1))
                  )
                    t.push((a.i / i) | 0),
                      t.push((e1.i / i) | 0),
                      t.push((l.i / i) | 0),
                      Af(e1),
                      (e1 = l.next),
                      (c = l.next);
                  else if ((e1 = l) === c) {
                    s
                      ? 1 === s
                        ? sf((e1 = cf(of(e1), t, i)), t, i, r, n, o, 2)
                        : 2 === s && hf(e1, t, i, r, n, o)
                      : sf(of(e1), t, i, r, n, o, 1);
                    break;
                  }
              }
            }
            function af(e1) {
              var t = e1.prev,
                i = e1,
                r = e1.next;
              if (yf(t, i, r) >= 0) return !1;
              for (
                var n = t.x,
                  o = i.x,
                  s = r.x,
                  a = t.y,
                  l = i.y,
                  c = r.y,
                  h = n < o ? (n < s ? n : s) : o < s ? o : s,
                  u = a < l ? (a < c ? a : c) : l < c ? l : c,
                  d = n > o ? (n > s ? n : s) : o > s ? o : s,
                  p = a > l ? (a > c ? a : c) : l > c ? l : c,
                  f = r.next;
                f !== t;

              ) {
                if (
                  f.x >= h &&
                  f.x <= d &&
                  f.y >= u &&
                  f.y <= p &&
                  _f(n, a, o, l, s, c, f.x, f.y) &&
                  yf(f.prev, f, f.next) >= 0
                )
                  return !1;
                f = f.next;
              }
              return !0;
            }
            function lf(e1, t, i, r) {
              var n = e1.prev,
                o = e1,
                s = e1.next;
              if (yf(n, o, s) >= 0) return !1;
              for (
                var a = n.x,
                  l = o.x,
                  c = s.x,
                  h = n.y,
                  u = o.y,
                  d = s.y,
                  p = a < l ? (a < c ? a : c) : l < c ? l : c,
                  f = h < u ? (h < d ? h : d) : u < d ? u : d,
                  m = a > l ? (a > c ? a : c) : l > c ? l : c,
                  _ = h > u ? (h > d ? h : d) : u > d ? u : d,
                  g = ff(p, f, t, i, r),
                  y = ff(m, _, t, i, r),
                  x = e1.prevZ,
                  v = e1.nextZ;
                x && x.z >= g && v && v.z <= y;

              ) {
                if (
                  x.x >= p &&
                  x.x <= m &&
                  x.y >= f &&
                  x.y <= _ &&
                  x !== n &&
                  x !== s &&
                  _f(a, h, l, u, c, d, x.x, x.y) &&
                  yf(x.prev, x, x.next) >= 0
                )
                  return !1;
                if (
                  ((x = x.prevZ),
                  v.x >= p &&
                    v.x <= m &&
                    v.y >= f &&
                    v.y <= _ &&
                    v !== n &&
                    v !== s &&
                    _f(a, h, l, u, c, d, v.x, v.y) &&
                    yf(v.prev, v, v.next) >= 0)
                )
                  return !1;
                v = v.nextZ;
              }
              for (; x && x.z >= g; ) {
                if (
                  x.x >= p &&
                  x.x <= m &&
                  x.y >= f &&
                  x.y <= _ &&
                  x !== n &&
                  x !== s &&
                  _f(a, h, l, u, c, d, x.x, x.y) &&
                  yf(x.prev, x, x.next) >= 0
                )
                  return !1;
                x = x.prevZ;
              }
              for (; v && v.z <= y; ) {
                if (
                  v.x >= p &&
                  v.x <= m &&
                  v.y >= f &&
                  v.y <= _ &&
                  v !== n &&
                  v !== s &&
                  _f(a, h, l, u, c, d, v.x, v.y) &&
                  yf(v.prev, v, v.next) >= 0
                )
                  return !1;
                v = v.nextZ;
              }
              return !0;
            }
            function cf(e1, t, i) {
              var r = e1;
              do {
                var n = r.prev,
                  o = r.next.next;
                !xf(n, o) &&
                  vf(n, r, r.next, o) &&
                  Tf(n, o) &&
                  Tf(o, n) &&
                  (t.push((n.i / i) | 0),
                  t.push((r.i / i) | 0),
                  t.push((o.i / i) | 0),
                  Af(r),
                  Af(r.next),
                  (r = e1 = o)),
                  (r = r.next);
              } while (r !== e1);
              return of(r);
            }
            function hf(e1, t, i, r, n, o) {
              var s = e1;
              do {
                for (var a = s.next.next; a !== s.prev; ) {
                  if (s.i !== a.i && gf(s, a)) {
                    var l = Ef(s, a);
                    return (
                      (s = of(s, s.next)),
                      (l = of(l, l.next)),
                      sf(s, t, i, r, n, o, 0),
                      void sf(l, t, i, r, n, o, 0)
                    );
                  }
                  a = a.next;
                }
                s = s.next;
              } while (s !== e1);
            }
            function uf(e1, t) {
              return e1.x - t.x;
            }
            function df(e1, t) {
              var i = (function (e1, t) {
                var i,
                  r = t,
                  n = e1.x,
                  o = e1.y,
                  s = -1 / 0;
                do {
                  if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                    var a =
                      r.x + ((o - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
                    if (
                      a <= n &&
                      a > s &&
                      ((s = a), (i = r.x < r.next.x ? r : r.next), a === n)
                    )
                      return i;
                  }
                  r = r.next;
                } while (r !== t);
                if (!i) return null;
                var l,
                  c = i,
                  h = i.x,
                  u = i.y,
                  d = 1 / 0;
                r = i;
                do
                  n >= r.x &&
                    r.x >= h &&
                    n !== r.x &&
                    _f(o < u ? n : s, o, h, u, o < u ? s : n, o, r.x, r.y) &&
                    ((l = Math.abs(o - r.y) / (n - r.x)),
                    Tf(r, e1) &&
                      (l < d ||
                        (l === d &&
                          (r.x > i.x || (r.x === i.x && pf(i, r))))) &&
                      ((i = r), (d = l))),
                    (r = r.next);
                while (r !== c);
                return i;
              })(e1, t);
              if (!i) return t;
              var r = Ef(i, e1);
              return of(r, r.next), of(i, i.next);
            }
            function pf(e1, t) {
              return yf(e1.prev, e1, t.prev) < 0 && yf(t.next, e1, e1.next) < 0;
            }
            function ff(e1, t, i, r, n) {
              return (
                (e1 =
                  1431655765 &
                  ((e1 =
                    858993459 &
                    ((e1 =
                      252645135 &
                      ((e1 =
                        16711935 & ((e1 = ((e1 - i) * n) | 0) | (e1 << 8))) |
                        (e1 << 4))) |
                      (e1 << 2))) |
                    (e1 << 1))) |
                ((t =
                  1431655765 &
                  ((t =
                    858993459 &
                    ((t =
                      252645135 &
                      ((t = 16711935 & ((t = ((t - r) * n) | 0) | (t << 8))) |
                        (t << 4))) |
                      (t << 2))) |
                    (t << 1))) <<
                  1)
              );
            }
            function mf(e1) {
              var t = e1,
                i = e1;
              do
                (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t),
                  (t = t.next);
              while (t !== e1);
              return i;
            }
            function _f(e1, t, i, r, n, o, s, a) {
              return (
                (n - s) * (t - a) >= (e1 - s) * (o - a) &&
                (e1 - s) * (r - a) >= (i - s) * (t - a) &&
                (i - s) * (o - a) >= (n - s) * (r - a)
              );
            }
            function gf(e1, t) {
              return (
                e1.next.i !== t.i &&
                e1.prev.i !== t.i &&
                !(function (e1, t) {
                  var i = e1;
                  do {
                    if (
                      i.i !== e1.i &&
                      i.next.i !== e1.i &&
                      i.i !== t.i &&
                      i.next.i !== t.i &&
                      vf(i, i.next, e1, t)
                    )
                      return !0;
                    i = i.next;
                  } while (i !== e1);
                  return !1;
                })(e1, t) &&
                ((Tf(e1, t) &&
                  Tf(t, e1) &&
                  (function (e1, t) {
                    var i = e1,
                      r = !1,
                      n = (e1.x + t.x) / 2,
                      o = (e1.y + t.y) / 2;
                    do
                      i.y > o != i.next.y > o &&
                        i.next.y !== i.y &&
                        n <
                          ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) +
                            i.x &&
                        (r = !r),
                        (i = i.next);
                    while (i !== e1);
                    return r;
                  })(e1, t) &&
                  (yf(e1.prev, e1, t.prev) || yf(e1, t.prev, t))) ||
                  (xf(e1, t) &&
                    yf(e1.prev, e1, e1.next) > 0 &&
                    yf(t.prev, t, t.next) > 0))
              );
            }
            function yf(e1, t, i) {
              return (t.y - e1.y) * (i.x - t.x) - (t.x - e1.x) * (i.y - t.y);
            }
            function xf(e1, t) {
              return e1.x === t.x && e1.y === t.y;
            }
            function vf(e1, t, i, r) {
              var n = wf(yf(e1, t, i)),
                o = wf(yf(e1, t, r)),
                s = wf(yf(i, r, e1)),
                a = wf(yf(i, r, t));
              return (
                (n !== o && s !== a) ||
                !(0 !== n || !bf(e1, i, t)) ||
                !(0 !== o || !bf(e1, r, t)) ||
                !(0 !== s || !bf(i, e1, r)) ||
                !(0 !== a || !bf(i, t, r))
              );
            }
            function bf(e1, t, i) {
              return (
                t.x <= Math.max(e1.x, i.x) &&
                t.x >= Math.min(e1.x, i.x) &&
                t.y <= Math.max(e1.y, i.y) &&
                t.y >= Math.min(e1.y, i.y)
              );
            }
            function wf(e1) {
              return e1 > 0 ? 1 : e1 < 0 ? -1 : 0;
            }
            function Tf(e1, t) {
              return yf(e1.prev, e1, e1.next) < 0
                ? yf(e1, t, e1.next) >= 0 && yf(e1, e1.prev, t) >= 0
                : yf(e1, t, e1.prev) < 0 || yf(e1, e1.next, t) < 0;
            }
            function Ef(e1, t) {
              var i = new Sf(e1.i, e1.x, e1.y),
                r = new Sf(t.i, t.x, t.y),
                n = e1.next,
                o = t.prev;
              return (
                (e1.next = t),
                (t.prev = e1),
                (i.next = n),
                (n.prev = i),
                (r.next = i),
                (i.prev = r),
                (o.next = r),
                (r.prev = o),
                r
              );
            }
            function Mf(e1, t, i, r) {
              var n = new Sf(e1, t, i);
              return (
                r
                  ? ((n.next = r.next),
                    (n.prev = r),
                    (r.next.prev = n),
                    (r.next = n))
                  : ((n.prev = n), (n.next = n)),
                n
              );
            }
            function Af(e1) {
              (e1.next.prev = e1.prev),
                (e1.prev.next = e1.next),
                e1.prevZ && (e1.prevZ.nextZ = e1.nextZ),
                e1.nextZ && (e1.nextZ.prevZ = e1.prevZ);
            }
            function Sf(e1, t, i) {
              (this.i = e1),
                (this.x = t),
                (this.y = i),
                (this.prev = null),
                (this.next = null),
                (this.z = 0),
                (this.prevZ = null),
                (this.nextZ = null),
                (this.steiner = !1);
            }
            function If(e1, t, i, r) {
              for (var n = 0, o = t, s = i - r; o < i; o += r)
                (n += (e1[s] - e1[o]) * (e1[o + 1] + e1[s + 1])), (s = o);
              return n;
            }
            (tf.exports = rf),
              (tf.exports.default = rf),
              (rf.deviation = function (e1, t, i, r) {
                var n = t && t.length,
                  o = Math.abs(If(e1, 0, n ? t[0] * i : e1.length, i));
                if (n)
                  for (var s = 0, a = t.length; s < a; s++)
                    o -= Math.abs(
                      If(e1, t[s] * i, s < a - 1 ? t[s + 1] * i : e1.length, i),
                    );
                var l = 0;
                for (s = 0; s < r.length; s += 3) {
                  var c = r[s] * i,
                    h = r[s + 1] * i,
                    u = r[s + 2] * i;
                  l += Math.abs(
                    (e1[c] - e1[u]) * (e1[h + 1] - e1[c + 1]) -
                      (e1[c] - e1[h]) * (e1[u + 1] - e1[c + 1]),
                  );
                }
                return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o);
              }),
              (rf.flatten = function (e1) {
                for (
                  var t = e1[0][0].length,
                    i = {
                      vertices: [],
                      holes: [],
                      dimensions: t,
                    },
                    r = 0,
                    n = 0;
                  n < e1.length;
                  n++
                ) {
                  for (var o = 0; o < e1[n].length; o++)
                    for (var s = 0; s < t; s++) i.vertices.push(e1[n][o][s]);
                  n > 0 && i.holes.push((r += e1[n - 1].length));
                }
                return i;
              });
            var Cf = d(tf.exports);
            function zf(e1, t) {
              const i = e1.length;
              if (i <= 1) return [e1];
              const r = [];
              let n, o;
              for (let t = 0; t < i; t++) {
                const i = Y(e1[t]);
                0 !== i &&
                  ((e1[t].area = Math.abs(i)),
                  void 0 === o && (o = i < 0),
                  o === i < 0
                    ? (n && r.push(n), (n = [e1[t]]))
                    : n.push(e1[t]));
              }
              if ((n && r.push(n), t > 1))
                for (let e1 = 0; e1 < r.length; e1++)
                  r[e1].length <= t ||
                    (ki(r[e1], t, 1, r[e1].length - 1, Df),
                    (r[e1] = r[e1].slice(0, t)));
              return r;
            }
            function Df(e1, t) {
              return t.area - e1.area;
            }
            function Pf(e1, t, i) {
              const r = i.patternDependencies;
              let n = !1;
              for (const i of t) {
                const t = i.paint.get(`${e1}-pattern`);
                t.isConstant() || (n = !0);
                const o = t.constantOr(null);
                o && ((n = !0), (r[o] = !0));
              }
              return n;
            }
            function Rf(e1, t, i, r, n) {
              const o = n.patternDependencies;
              for (const s of t) {
                const t = s.paint.get(`${e1}-pattern`).value;
                if ("constant" !== t.kind) {
                  let e1 = t.evaluate(
                    {
                      zoom: r,
                    },
                    i,
                    {},
                    n.availableImages,
                  );
                  (e1 = e1 && e1.name ? e1.name : e1),
                    (o[e1] = !0),
                    (i.patterns[s.id] = e1);
                }
              }
              return i;
            }
            class Lf {
              constructor(e1) {
                (this.zoom = e1.zoom),
                  (this.overscaling = e1.overscaling),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.index = e1.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.layoutVertexArray = new Ta()),
                  (this.indexArray = new Va()),
                  (this.indexArray2 = new ka()),
                  (this.programConfigurations = new Hl(e1.layers, e1.zoom)),
                  (this.segments = new dl()),
                  (this.segments2 = new dl()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id)),
                  (this.projection = e1.projection);
              }
              populate(e1, t, i, r) {
                this.hasPattern = Pf("fill", this.layers, t);
                const n = this.layers[0].layout.get("fill-sort-key"),
                  o = [];
                for (const {
                  feature: s,
                  id: a,
                  index: l,
                  sourceLayerIndex: c,
                } of e1) {
                  const e1 = this.layers[0]._featureFilter.needGeometry,
                    h = cp(s, e1);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ea(this.zoom),
                      h,
                      i,
                    )
                  )
                    continue;
                  const u = n
                      ? n.evaluate(h, {}, i, t.availableImages)
                      : void 0,
                    d = {
                      id: a,
                      properties: s.properties,
                      type: s.type,
                      sourceLayerIndex: c,
                      index: l,
                      geometry: e1 ? h.geometry : lp(s, i, r),
                      patterns: {},
                      sortKey: u,
                    };
                  o.push(d);
                }
                n && o.sort((e1, t) => e1.sortKey - t.sortKey);
                for (const r of o) {
                  const { geometry: n, index: o, sourceLayerIndex: s } = r;
                  if (this.hasPattern) {
                    const e1 = Rf("fill", this.layers, r, this.zoom, t);
                    this.patternFeatures.push(e1);
                  } else
                    this.addFeature(
                      r,
                      n,
                      o,
                      i,
                      {},
                      t.availableImages,
                      t.brightness,
                    );
                  t.featureIndex.insert(e1[o].feature, n, o, s, this.index);
                }
              }
              update(e1, t, i, r, n) {
                const o = 0 !== Object.keys(e1).length;
                (o && !this.stateDependentLayers.length) ||
                  this.programConfigurations.updatePaintArrays(
                    e1,
                    t,
                    o ? this.stateDependentLayers : this.layers,
                    i,
                    r,
                    n,
                  );
              }
              addFeatures(e1, t, i, r, n, o) {
                for (const e1 of this.patternFeatures)
                  this.addFeature(e1, e1.geometry, e1.index, t, i, r, o);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(e1) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = e1.createVertexBuffer(
                    this.layoutVertexArray,
                    ef,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray)),
                  (this.indexBuffer2 = e1.createIndexBuffer(this.indexArray2))),
                  this.programConfigurations.upload(e1),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.indexBuffer2.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.segments2.destroy());
              }
              addFeature(e1, t, i, r, n, o = [], s) {
                for (const e1 of zf(t, 500)) {
                  let t = 0;
                  for (const i of e1) t += i.length;
                  const i = this.segments.prepareSegment(
                      t,
                      this.layoutVertexArray,
                      this.indexArray,
                    ),
                    r = i.vertexLength,
                    n = [],
                    o = [];
                  for (const t of e1) {
                    if (0 === t.length) continue;
                    t !== e1[0] && o.push(n.length / 2);
                    const i = this.segments2.prepareSegment(
                        t.length,
                        this.layoutVertexArray,
                        this.indexArray2,
                      ),
                      r = i.vertexLength;
                    this.layoutVertexArray.emplaceBack(t[0].x, t[0].y),
                      this.indexArray2.emplaceBack(r + t.length - 1, r),
                      n.push(t[0].x),
                      n.push(t[0].y);
                    for (let e1 = 1; e1 < t.length; e1++)
                      this.layoutVertexArray.emplaceBack(t[e1].x, t[e1].y),
                        this.indexArray2.emplaceBack(r + e1 - 1, r + e1),
                        n.push(t[e1].x),
                        n.push(t[e1].y);
                    (i.vertexLength += t.length),
                      (i.primitiveLength += t.length);
                  }
                  const s = Cf(n, o);
                  for (let e1 = 0; e1 < s.length; e1 += 3)
                    this.indexArray.emplaceBack(
                      r + s[e1],
                      r + s[e1 + 1],
                      r + s[e1 + 2],
                    );
                  (i.vertexLength += t), (i.primitiveLength += s.length / 3);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e1,
                  i,
                  n,
                  o,
                  r,
                  s,
                );
              }
            }
            Is(Lf, "FillBucket", {
              omit: ["layers", "patternFeatures"],
            });
            const kf = new da({
              "fill-sort-key": new ha(Ct.layout_fill["fill-sort-key"]),
              visibility: new ca(Ct.layout_fill.visibility),
            });
            var Of = {
              paint: new da({
                "fill-antialias": new ca(Ct.paint_fill["fill-antialias"]),
                "fill-opacity": new ha(Ct.paint_fill["fill-opacity"]),
                "fill-color": new ha(Ct.paint_fill["fill-color"]),
                "fill-outline-color": new ha(
                  Ct.paint_fill["fill-outline-color"],
                ),
                "fill-translate": new ca(Ct.paint_fill["fill-translate"]),
                "fill-translate-anchor": new ca(
                  Ct.paint_fill["fill-translate-anchor"],
                ),
                "fill-pattern": new ha(Ct.paint_fill["fill-pattern"]),
                "fill-emissive-strength": new ca(
                  Ct.paint_fill["fill-emissive-strength"],
                ),
              }),
              layout: kf,
            };
            const Bf = ba([
                {
                  name: "a_pos_normal_ed",
                  components: 4,
                  type: "Int16",
                },
              ]),
              Ff = ba([
                {
                  name: "a_pos_end",
                  components: 4,
                  type: "Int16",
                },
                {
                  name: "a_angular_offset_factor",
                  components: 1,
                  type: "Int16",
                },
              ]),
              Nf = ba([
                {
                  name: "a_centroid_pos",
                  components: 2,
                  type: "Uint16",
                },
              ]),
              Uf = ba([
                {
                  name: "a_hidden_by_landmark",
                  components: 1,
                  type: "Uint8",
                },
              ]),
              Vf = ba([
                {
                  name: "a_pos_3",
                  components: 3,
                  type: "Int16",
                },
                {
                  name: "a_pos_normal_3",
                  components: 3,
                  type: "Int16",
                },
              ]),
              { members: jf } = Bf;
            var Gf = {},
              qf = _,
              Zf = $f;
            function $f(e1, t, i, r, n) {
              (this.properties = {}),
                (this.extent = i),
                (this.type = 0),
                (this._pbf = e1),
                (this._geometry = -1),
                (this._keys = r),
                (this._values = n),
                e1.readFields(Hf, this, t);
            }
            function Hf(e1, t, i) {
              1 == e1
                ? (t.id = i.readVarint())
                : 2 == e1
                ? (function (e1, t) {
                    for (var i = e1.readVarint() + e1.pos; e1.pos < i; ) {
                      var r = t._keys[e1.readVarint()],
                        n = t._values[e1.readVarint()];
                      t.properties[r] = n;
                    }
                  })(i, t)
                : 3 == e1
                ? (t.type = i.readVarint())
                : 4 == e1 && (t._geometry = i.pos);
            }
            function Wf(e1) {
              for (
                var t, i, r = 0, n = 0, o = e1.length, s = o - 1;
                n < o;
                s = n++
              )
                r += ((i = e1[s]).x - (t = e1[n]).x) * (t.y + i.y);
              return r;
            }
            ($f.types = ["Unknown", "Point", "LineString", "Polygon"]),
              ($f.prototype.loadGeometry = function () {
                var e1 = this._pbf;
                e1.pos = this._geometry;
                for (
                  var t,
                    i = e1.readVarint() + e1.pos,
                    r = 1,
                    n = 0,
                    o = 0,
                    s = 0,
                    a = [];
                  e1.pos < i;

                ) {
                  if (n <= 0) {
                    var l = e1.readVarint();
                    (r = 7 & l), (n = l >> 3);
                  }
                  if ((n--, 1 === r || 2 === r))
                    (o += e1.readSVarint()),
                      (s += e1.readSVarint()),
                      1 === r && (t && a.push(t), (t = [])),
                      t.push(new qf(o, s));
                  else {
                    if (7 !== r) throw new Error("unknown command " + r);
                    t && t.push(t[0].clone());
                  }
                }
                return t && a.push(t), a;
              }),
              ($f.prototype.bbox = function () {
                var e1 = this._pbf;
                e1.pos = this._geometry;
                for (
                  var t = e1.readVarint() + e1.pos,
                    i = 1,
                    r = 0,
                    n = 0,
                    o = 0,
                    s = 1 / 0,
                    a = -1 / 0,
                    l = 1 / 0,
                    c = -1 / 0;
                  e1.pos < t;

                ) {
                  if (r <= 0) {
                    var h = e1.readVarint();
                    (i = 7 & h), (r = h >> 3);
                  }
                  if ((r--, 1 === i || 2 === i))
                    (n += e1.readSVarint()) < s && (s = n),
                      n > a && (a = n),
                      (o += e1.readSVarint()) < l && (l = o),
                      o > c && (c = o);
                  else if (7 !== i) throw new Error("unknown command " + i);
                }
                return [s, l, a, c];
              }),
              ($f.prototype.toGeoJSON = function (e1, t, i) {
                var r,
                  n,
                  o = this.extent * Math.pow(2, i),
                  s = this.extent * e1,
                  a = this.extent * t,
                  l = this.loadGeometry(),
                  c = $f.types[this.type];
                function h(e1) {
                  for (var t = 0; t < e1.length; t++) {
                    var i = e1[t];
                    e1[t] = [
                      (360 * (i.x + s)) / o - 180,
                      (360 / Math.PI) *
                        Math.atan(
                          Math.exp(
                            ((180 - (360 * (i.y + a)) / o) * Math.PI) / 180,
                          ),
                        ) -
                        90,
                    ];
                  }
                }
                switch (this.type) {
                  case 1:
                    var u = [];
                    for (r = 0; r < l.length; r++) u[r] = l[r][0];
                    h((l = u));
                    break;
                  case 2:
                    for (r = 0; r < l.length; r++) h(l[r]);
                    break;
                  case 3:
                    for (
                      l = (function (e1) {
                        var t = e1.length;
                        if (t <= 1) return [e1];
                        for (var i, r, n = [], o = 0; o < t; o++) {
                          var s = Wf(e1[o]);
                          0 !== s &&
                            (void 0 === r && (r = s < 0),
                            r === s < 0
                              ? (i && n.push(i), (i = [e1[o]]))
                              : i.push(e1[o]));
                        }
                        return i && n.push(i), n;
                      })(l),
                        r = 0;
                      r < l.length;
                      r++
                    )
                      for (n = 0; n < l[r].length; n++) h(l[r][n]);
                }
                1 === l.length ? (l = l[0]) : (c = "Multi" + c);
                var d = {
                  type: "Feature",
                  geometry: {
                    type: c,
                    coordinates: l,
                  },
                  properties: this.properties,
                };
                return "id" in this && (d.id = this.id), d;
              });
            var Xf = Zf,
              Yf = Kf;
            function Kf(e1, t) {
              (this.version = 1),
                (this.name = null),
                (this.extent = 4096),
                (this.length = 0),
                (this._pbf = e1),
                (this._keys = []),
                (this._values = []),
                (this._features = []),
                e1.readFields(Jf, this, t),
                (this.length = this._features.length);
            }
            function Jf(e1, t, i) {
              15 === e1
                ? (t.version = i.readVarint())
                : 1 === e1
                ? (t.name = i.readString())
                : 5 === e1
                ? (t.extent = i.readVarint())
                : 2 === e1
                ? t._features.push(i.pos)
                : 3 === e1
                ? t._keys.push(i.readString())
                : 4 === e1 &&
                  t._values.push(
                    (function (e1) {
                      for (
                        var t = null, i = e1.readVarint() + e1.pos;
                        e1.pos < i;

                      ) {
                        var r = e1.readVarint() >> 3;
                        t =
                          1 === r
                            ? e1.readString()
                            : 2 === r
                            ? e1.readFloat()
                            : 3 === r
                            ? e1.readDouble()
                            : 4 === r
                            ? e1.readVarint64()
                            : 5 === r
                            ? e1.readVarint()
                            : 6 === r
                            ? e1.readSVarint()
                            : 7 === r
                            ? e1.readBoolean()
                            : null;
                      }
                      return t;
                    })(i),
                  );
            }
            Kf.prototype.feature = function (e1) {
              if (e1 < 0 || e1 >= this._features.length)
                throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[e1];
              var t = this._pbf.readVarint() + this._pbf.pos;
              return new Xf(
                this._pbf,
                t,
                this.extent,
                this._keys,
                this._values,
              );
            };
            var Qf = Yf;
            function em(e1, t, i) {
              if (3 === e1) {
                var r = new Qf(i, i.readVarint() + i.pos);
                r.length && (t[r.name] = r);
              }
            }
            var tm = (Gf.VectorTile = function (e1, t) {
                this.layers = e1.readFields(em, {}, t);
              }),
              im = (Gf.VectorTileFeature = Zf);
            function rm(e1, t, i, r) {
              const n = [],
                o =
                  0 === r
                    ? (e1, t, i, r, n, o) => {
                        e1.push(new y(o, i + ((o - t) / (r - t)) * (n - i)));
                      }
                    : (e1, t, i, r, n, o) => {
                        e1.push(new y(t + ((o - i) / (n - i)) * (r - t), o));
                      };
              for (const s of e1) {
                const e1 = [];
                for (const n of s) {
                  if (n.length <= 2) continue;
                  const s = [];
                  for (let e1 = 0; e1 < n.length - 1; e1++) {
                    const a = n[e1].x,
                      l = n[e1].y,
                      c = n[e1 + 1].x,
                      h = n[e1 + 1].y,
                      u = 0 === r ? a : l,
                      d = 0 === r ? c : h;
                    u < t
                      ? d > t && o(s, a, l, c, h, t)
                      : u > i
                      ? d < i && o(s, a, l, c, h, i)
                      : s.push(n[e1]),
                      d < t && u >= t && o(s, a, l, c, h, t),
                      d > i && u <= i && o(s, a, l, c, h, i);
                  }
                  let a = n[n.length - 1];
                  const l = 0 === r ? a.x : a.y;
                  l >= t && l <= i && s.push(a),
                    s.length &&
                      ((a = s[s.length - 1]),
                      (s[0].x === a.x && s[0].y === a.y) || s.push(s[0]),
                      e1.push(s));
                }
                e1.length && n.push(e1);
              }
              return n;
            }
            Gf.VectorTileLayer = Yf;
            class nm {
              constructor(e1) {
                (this._stringToNumber = {}), (this._numberToString = []);
                for (let t = 0; t < e1.length; t++) {
                  const i = e1[t];
                  (this._stringToNumber[i] = t), (this._numberToString[t] = i);
                }
              }
              encode(e1) {
                return this._stringToNumber[e1];
              }
              decode(e1) {
                return this._numberToString[e1];
              }
            }
            var om = {
                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ read: function (
                  e1,
                  t,
                  i,
                  r,
                  n,
                ) {
                  var o,
                    s,
                    a = 8 * n - r - 1,
                    l = (1 << a) - 1,
                    c = l >> 1,
                    h = -7,
                    u = i ? n - 1 : 0,
                    d = i ? -1 : 1,
                    p = e1[t + u];
                  for (
                    u += d, o = p & ((1 << -h) - 1), p >>= -h, h += a;
                    h > 0;
                    o = 256 * o + e1[t + u], u += d, h -= 8
                  );
                  for (
                    s = o & ((1 << -h) - 1), o >>= -h, h += r;
                    h > 0;
                    s = 256 * s + e1[t + u], u += d, h -= 8
                  );
                  if (0 === o) o = 1 - c;
                  else {
                    if (o === l) return s ? NaN : (1 / 0) * (p ? -1 : 1);
                    (s += Math.pow(2, r)), (o -= c);
                  }
                  return (p ? -1 : 1) * s * Math.pow(2, o - r);
                },
                write: function (e1, t, i, r, n, o) {
                  var s,
                    a,
                    l,
                    c = 8 * o - n - 1,
                    h = (1 << c) - 1,
                    u = h >> 1,
                    d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    p = r ? 0 : o - 1,
                    f = r ? 1 : -1,
                    m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
                  for (
                    t = Math.abs(t),
                      isNaN(t) || t === 1 / 0
                        ? ((a = isNaN(t) ? 1 : 0), (s = h))
                        : ((s = Math.floor(Math.log(t) / Math.LN2)),
                          t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                          (t += s + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) *
                            l >=
                            2 && (s++, (l /= 2)),
                          s + u >= h
                            ? ((a = 0), (s = h))
                            : s + u >= 1
                            ? ((a = (t * l - 1) * Math.pow(2, n)), (s += u))
                            : ((a = t * Math.pow(2, u - 1) * Math.pow(2, n)),
                              (s = 0)));
                    n >= 8;
                    e1[i + p] = 255 & a, p += f, a /= 256, n -= 8
                  );
                  for (
                    s = (s << n) | a, c += n;
                    c > 0;
                    e1[i + p] = 255 & s, p += f, s /= 256, c -= 8
                  );
                  e1[i + p - f] |= 128 * m;
                },
              },
              sm = lm,
              am = om;
            function lm(e1) {
              (this.buf =
                ArrayBuffer.isView && ArrayBuffer.isView(e1)
                  ? e1
                  : new Uint8Array(e1 || 0)),
                (this.pos = 0),
                (this.type = 0),
                (this.length = this.buf.length);
            }
            (lm.Varint = 0), (lm.Fixed64 = 1), (lm.Bytes = 2), (lm.Fixed32 = 5);
            var cm = 4294967296,
              hm = 1 / cm,
              um =
                "undefined" == typeof TextDecoder
                  ? null
                  : new TextDecoder("utf8");
            function dm(e1) {
              return e1.type === lm.Bytes
                ? e1.readVarint() + e1.pos
                : e1.pos + 1;
            }
            function pm(e1, t, i) {
              return i
                ? 4294967296 * t + (e1 >>> 0)
                : 4294967296 * (t >>> 0) + (e1 >>> 0);
            }
            function fm(e1, t, i) {
              var r =
                t <= 16383
                  ? 1
                  : t <= 2097151
                  ? 2
                  : t <= 268435455
                  ? 3
                  : Math.floor(Math.log(t) / (7 * Math.LN2));
              i.realloc(r);
              for (var n = i.pos - 1; n >= e1; n--) i.buf[n + r] = i.buf[n];
            }
            function mm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeVarint(e1[i]);
            }
            function _m(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeSVarint(e1[i]);
            }
            function gm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeFloat(e1[i]);
            }
            function ym(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeDouble(e1[i]);
            }
            function xm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeBoolean(e1[i]);
            }
            function vm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeFixed32(e1[i]);
            }
            function bm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeSFixed32(e1[i]);
            }
            function wm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeFixed64(e1[i]);
            }
            function Tm(e1, t) {
              for (var i = 0; i < e1.length; i++) t.writeSFixed64(e1[i]);
            }
            function Em(e1, t) {
              return (
                (e1[t] | (e1[t + 1] << 8) | (e1[t + 2] << 16)) +
                16777216 * e1[t + 3]
              );
            }
            function Mm(e1, t, i) {
              (e1[i] = t),
                (e1[i + 1] = t >>> 8),
                (e1[i + 2] = t >>> 16),
                (e1[i + 3] = t >>> 24);
            }
            function Am(e1, t) {
              return (
                (e1[t] | (e1[t + 1] << 8) | (e1[t + 2] << 16)) +
                (e1[t + 3] << 24)
              );
            }
            lm.prototype = {
              destroy: function () {
                this.buf = null;
              },
              readFields: function (e1, t, i) {
                for (i = i || this.length; this.pos < i; ) {
                  var r = this.readVarint(),
                    n = r >> 3,
                    o = this.pos;
                  (this.type = 7 & r),
                    e1(n, t, this),
                    this.pos === o && this.skip(r);
                }
                return t;
              },
              readMessage: function (e1, t) {
                return this.readFields(e1, t, this.readVarint() + this.pos);
              },
              readFixed32: function () {
                var e1 = Em(this.buf, this.pos);
                return (this.pos += 4), e1;
              },
              readSFixed32: function () {
                var e1 = Am(this.buf, this.pos);
                return (this.pos += 4), e1;
              },
              readFixed64: function () {
                var e1 =
                  Em(this.buf, this.pos) + Em(this.buf, this.pos + 4) * cm;
                return (this.pos += 8), e1;
              },
              readSFixed64: function () {
                var e1 =
                  Em(this.buf, this.pos) + Am(this.buf, this.pos + 4) * cm;
                return (this.pos += 8), e1;
              },
              readFloat: function () {
                var e1 = am.read(this.buf, this.pos, !0, 23, 4);
                return (this.pos += 4), e1;
              },
              readDouble: function () {
                var e1 = am.read(this.buf, this.pos, !0, 52, 8);
                return (this.pos += 8), e1;
              },
              readVarint: function (e1) {
                var t,
                  i,
                  r = this.buf;
                return (
                  (t = 127 & (i = r[this.pos++])),
                  i < 128
                    ? t
                    : ((t |= (127 & (i = r[this.pos++])) << 7),
                      i < 128
                        ? t
                        : ((t |= (127 & (i = r[this.pos++])) << 14),
                          i < 128
                            ? t
                            : ((t |= (127 & (i = r[this.pos++])) << 21),
                              i < 128
                                ? t
                                : (function (e1, t, i) {
                                    var r,
                                      n,
                                      o = i.buf;
                                    if (
                                      ((r = (112 & (n = o[i.pos++])) >> 4),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    if (
                                      ((r |= (127 & (n = o[i.pos++])) << 3),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    if (
                                      ((r |= (127 & (n = o[i.pos++])) << 10),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    if (
                                      ((r |= (127 & (n = o[i.pos++])) << 17),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    if (
                                      ((r |= (127 & (n = o[i.pos++])) << 24),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    if (
                                      ((r |= (1 & (n = o[i.pos++])) << 31),
                                      n < 128)
                                    )
                                      return pm(e1, r, t);
                                    throw new Error(
                                      "Expected varint not more than 10 bytes",
                                    );
                                  })(
                                    (t |= (15 & (i = r[this.pos])) << 28),
                                    e1,
                                    this,
                                  ))))
                );
              },
              readVarint64: function () {
                return this.readVarint(!0);
              },
              readSVarint: function () {
                var e1 = this.readVarint();
                return e1 % 2 == 1 ? (e1 + 1) / -2 : e1 / 2;
              },
              readBoolean: function () {
                return Boolean(this.readVarint());
              },
              readString: function () {
                var e1 = this.readVarint() + this.pos,
                  t = this.pos;
                return (
                  (this.pos = e1),
                  e1 - t >= 12 && um
                    ? (function (e1, t, i) {
                        return um.decode(e1.subarray(t, i));
                      })(this.buf, t, e1)
                    : (function (e1, t, i) {
                        for (var r = "", n = t; n < i; ) {
                          var o,
                            s,
                            a,
                            l = e1[n],
                            c = null,
                            h = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                          if (n + h > i) break;
                          1 === h
                            ? l < 128 && (c = l)
                            : 2 === h
                            ? 128 == (192 & (o = e1[n + 1])) &&
                              (c = ((31 & l) << 6) | (63 & o)) <= 127 &&
                              (c = null)
                            : 3 === h
                            ? ((s = e1[n + 2]),
                              128 == (192 & (o = e1[n + 1])) &&
                                128 == (192 & s) &&
                                ((c =
                                  ((15 & l) << 12) |
                                  ((63 & o) << 6) |
                                  (63 & s)) <= 2047 ||
                                  (c >= 55296 && c <= 57343)) &&
                                (c = null))
                            : 4 === h &&
                              ((s = e1[n + 2]),
                              (a = e1[n + 3]),
                              128 == (192 & (o = e1[n + 1])) &&
                                128 == (192 & s) &&
                                128 == (192 & a) &&
                                ((c =
                                  ((15 & l) << 18) |
                                  ((63 & o) << 12) |
                                  ((63 & s) << 6) |
                                  (63 & a)) <= 65535 ||
                                  c >= 1114112) &&
                                (c = null)),
                            null === c
                              ? ((c = 65533), (h = 1))
                              : c > 65535 &&
                                ((c -= 65536),
                                (r += String.fromCharCode(
                                  ((c >>> 10) & 1023) | 55296,
                                )),
                                (c = 56320 | (1023 & c))),
                            (r += String.fromCharCode(c)),
                            (n += h);
                        }
                        return r;
                      })(this.buf, t, e1)
                );
              },
              readBytes: function () {
                var e1 = this.readVarint() + this.pos,
                  t = this.buf.subarray(this.pos, e1);
                return (this.pos = e1), t;
              },
              readPackedVarint: function (e1, t) {
                if (this.type !== lm.Bytes) return e1.push(this.readVarint(t));
                var i = dm(this);
                for (e1 = e1 || []; this.pos < i; ) e1.push(this.readVarint(t));
                return e1;
              },
              readPackedSVarint: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readSVarint());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readSVarint());
                return e1;
              },
              readPackedBoolean: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readBoolean());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readBoolean());
                return e1;
              },
              readPackedFloat: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readFloat());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readFloat());
                return e1;
              },
              readPackedDouble: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readDouble());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readDouble());
                return e1;
              },
              readPackedFixed32: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readFixed32());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readFixed32());
                return e1;
              },
              readPackedSFixed32: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readSFixed32());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; )
                  e1.push(this.readSFixed32());
                return e1;
              },
              readPackedFixed64: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readFixed64());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; ) e1.push(this.readFixed64());
                return e1;
              },
              readPackedSFixed64: function (e1) {
                if (this.type !== lm.Bytes) return e1.push(this.readSFixed64());
                var t = dm(this);
                for (e1 = e1 || []; this.pos < t; )
                  e1.push(this.readSFixed64());
                return e1;
              },
              skip: function (e1) {
                var t = 7 & e1;
                if (t === lm.Varint) for (; this.buf[this.pos++] > 127; );
                else if (t === lm.Bytes)
                  this.pos = this.readVarint() + this.pos;
                else if (t === lm.Fixed32) this.pos += 4;
                else {
                  if (t !== lm.Fixed64)
                    throw new Error("Unimplemented type: " + t);
                  this.pos += 8;
                }
              },
              writeTag: function (e1, t) {
                this.writeVarint((e1 << 3) | t);
              },
              realloc: function (e1) {
                for (var t = this.length || 16; t < this.pos + e1; ) t *= 2;
                if (t !== this.length) {
                  var i = new Uint8Array(t);
                  i.set(this.buf), (this.buf = i), (this.length = t);
                }
              },
              finish: function () {
                return (
                  (this.length = this.pos),
                  (this.pos = 0),
                  this.buf.subarray(0, this.length)
                );
              },
              writeFixed32: function (e1) {
                this.realloc(4), Mm(this.buf, e1, this.pos), (this.pos += 4);
              },
              writeSFixed32: function (e1) {
                this.realloc(4), Mm(this.buf, e1, this.pos), (this.pos += 4);
              },
              writeFixed64: function (e1) {
                this.realloc(8),
                  Mm(this.buf, -1 & e1, this.pos),
                  Mm(this.buf, Math.floor(e1 * hm), this.pos + 4),
                  (this.pos += 8);
              },
              writeSFixed64: function (e1) {
                this.realloc(8),
                  Mm(this.buf, -1 & e1, this.pos),
                  Mm(this.buf, Math.floor(e1 * hm), this.pos + 4),
                  (this.pos += 8);
              },
              writeVarint: function (e1) {
                (e1 = +e1 || 0) > 268435455 || e1 < 0
                  ? (function (e1, t) {
                      var i, r;
                      if (
                        (e1 >= 0
                          ? ((i = e1 % 4294967296 | 0),
                            (r = (e1 / 4294967296) | 0))
                          : ((r = ~(-e1 / 4294967296)),
                            4294967295 ^ (i = ~(-e1 % 4294967296))
                              ? (i = (i + 1) | 0)
                              : ((i = 0), (r = (r + 1) | 0))),
                        e1 >= 0x10000000000000000 || e1 < -18446744073709552000)
                      )
                        throw new Error(
                          "Given varint doesn't fit into 10 bytes",
                        );
                      t.realloc(10),
                        (function (e1, t, i) {
                          (i.buf[i.pos++] = (127 & e1) | 128),
                            (e1 >>>= 7),
                            (i.buf[i.pos++] = (127 & e1) | 128),
                            (e1 >>>= 7),
                            (i.buf[i.pos++] = (127 & e1) | 128),
                            (e1 >>>= 7),
                            (i.buf[i.pos++] = (127 & e1) | 128),
                            (i.buf[i.pos] = 127 & (e1 >>>= 7));
                        })(i, 0, t),
                        (function (e1, t) {
                          var i = (7 & e1) << 4;
                          (t.buf[t.pos++] |= i | ((e1 >>>= 3) ? 128 : 0)),
                            e1 &&
                              ((t.buf[t.pos++] =
                                (127 & e1) | ((e1 >>>= 7) ? 128 : 0)),
                              e1 &&
                                ((t.buf[t.pos++] =
                                  (127 & e1) | ((e1 >>>= 7) ? 128 : 0)),
                                e1 &&
                                  ((t.buf[t.pos++] =
                                    (127 & e1) | ((e1 >>>= 7) ? 128 : 0)),
                                  e1 &&
                                    ((t.buf[t.pos++] =
                                      (127 & e1) | ((e1 >>>= 7) ? 128 : 0)),
                                    e1 && (t.buf[t.pos++] = 127 & e1)))));
                        })(r, t);
                    })(e1, this)
                  : (this.realloc(4),
                    (this.buf[this.pos++] = (127 & e1) | (e1 > 127 ? 128 : 0)),
                    e1 <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (e1 >>>= 7)) | (e1 > 127 ? 128 : 0)),
                      e1 <= 127 ||
                        ((this.buf[this.pos++] =
                          (127 & (e1 >>>= 7)) | (e1 > 127 ? 128 : 0)),
                        e1 <= 127 ||
                          (this.buf[this.pos++] = (e1 >>> 7) & 127))));
              },
              writeSVarint: function (e1) {
                this.writeVarint(e1 < 0 ? 2 * -e1 - 1 : 2 * e1);
              },
              writeBoolean: function (e1) {
                this.writeVarint(Boolean(e1));
              },
              writeString: function (e1) {
                (e1 = String(e1)), this.realloc(4 * e1.length), this.pos++;
                var t = this.pos;
                this.pos = (function (e1, t, i) {
                  for (var r, n, o = 0; o < t.length; o++) {
                    if ((r = t.charCodeAt(o)) > 55295 && r < 57344) {
                      if (!n) {
                        r > 56319 || o + 1 === t.length
                          ? ((e1[i++] = 239), (e1[i++] = 191), (e1[i++] = 189))
                          : (n = r);
                        continue;
                      }
                      if (r < 56320) {
                        (e1[i++] = 239),
                          (e1[i++] = 191),
                          (e1[i++] = 189),
                          (n = r);
                        continue;
                      }
                      (r = ((n - 55296) << 10) | (r - 56320) | 65536),
                        (n = null);
                    } else
                      n &&
                        ((e1[i++] = 239),
                        (e1[i++] = 191),
                        (e1[i++] = 189),
                        (n = null));
                    r < 128
                      ? (e1[i++] = r)
                      : (r < 2048
                          ? (e1[i++] = (r >> 6) | 192)
                          : (r < 65536
                              ? (e1[i++] = (r >> 12) | 224)
                              : ((e1[i++] = (r >> 18) | 240),
                                (e1[i++] = ((r >> 12) & 63) | 128)),
                            (e1[i++] = ((r >> 6) & 63) | 128)),
                        (e1[i++] = (63 & r) | 128));
                  }
                  return i;
                })(this.buf, e1, this.pos);
                var i = this.pos - t;
                i >= 128 && fm(t, i, this),
                  (this.pos = t - 1),
                  this.writeVarint(i),
                  (this.pos += i);
              },
              writeFloat: function (e1) {
                this.realloc(4),
                  am.write(this.buf, e1, this.pos, !0, 23, 4),
                  (this.pos += 4);
              },
              writeDouble: function (e1) {
                this.realloc(8),
                  am.write(this.buf, e1, this.pos, !0, 52, 8),
                  (this.pos += 8);
              },
              writeBytes: function (e1) {
                var t = e1.length;
                this.writeVarint(t), this.realloc(t);
                for (var i = 0; i < t; i++) this.buf[this.pos++] = e1[i];
              },
              writeRawMessage: function (e1, t) {
                this.pos++;
                var i = this.pos;
                e1(t, this);
                var r = this.pos - i;
                r >= 128 && fm(i, r, this),
                  (this.pos = i - 1),
                  this.writeVarint(r),
                  (this.pos += r);
              },
              writeMessage: function (e1, t, i) {
                this.writeTag(e1, lm.Bytes), this.writeRawMessage(t, i);
              },
              writePackedVarint: function (e1, t) {
                t.length && this.writeMessage(e1, mm, t);
              },
              writePackedSVarint: function (e1, t) {
                t.length && this.writeMessage(e1, _m, t);
              },
              writePackedBoolean: function (e1, t) {
                t.length && this.writeMessage(e1, xm, t);
              },
              writePackedFloat: function (e1, t) {
                t.length && this.writeMessage(e1, gm, t);
              },
              writePackedDouble: function (e1, t) {
                t.length && this.writeMessage(e1, ym, t);
              },
              writePackedFixed32: function (e1, t) {
                t.length && this.writeMessage(e1, vm, t);
              },
              writePackedSFixed32: function (e1, t) {
                t.length && this.writeMessage(e1, bm, t);
              },
              writePackedFixed64: function (e1, t) {
                t.length && this.writeMessage(e1, wm, t);
              },
              writePackedSFixed64: function (e1, t) {
                t.length && this.writeMessage(e1, Tm, t);
              },
              writeBytesField: function (e1, t) {
                this.writeTag(e1, lm.Bytes), this.writeBytes(t);
              },
              writeFixed32Field: function (e1, t) {
                this.writeTag(e1, lm.Fixed32), this.writeFixed32(t);
              },
              writeSFixed32Field: function (e1, t) {
                this.writeTag(e1, lm.Fixed32), this.writeSFixed32(t);
              },
              writeFixed64Field: function (e1, t) {
                this.writeTag(e1, lm.Fixed64), this.writeFixed64(t);
              },
              writeSFixed64Field: function (e1, t) {
                this.writeTag(e1, lm.Fixed64), this.writeSFixed64(t);
              },
              writeVarintField: function (e1, t) {
                this.writeTag(e1, lm.Varint), this.writeVarint(t);
              },
              writeSVarintField: function (e1, t) {
                this.writeTag(e1, lm.Varint), this.writeSVarint(t);
              },
              writeStringField: function (e1, t) {
                this.writeTag(e1, lm.Bytes), this.writeString(t);
              },
              writeFloatField: function (e1, t) {
                this.writeTag(e1, lm.Fixed32), this.writeFloat(t);
              },
              writeDoubleField: function (e1, t) {
                this.writeTag(e1, lm.Fixed64), this.writeDouble(t);
              },
              writeBooleanField: function (e1, t) {
                this.writeVarintField(e1, Boolean(t));
              },
            };
            var Sm = d(sm);
            const Im = ["tile", "layer", "source", "sourceLayer", "state"];
            class Cm {
              constructor(e1, t, i, r, n) {
                (this.type = "Feature"),
                  (this._vectorTileFeature = e1),
                  (this._z = t),
                  (this._x = i),
                  (this._y = r),
                  (this.properties = e1.properties),
                  (this.id = n);
              }
              get geometry() {
                return (
                  void 0 === this._geometry &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._x,
                      this._y,
                      this._z,
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(e1) {
                this._geometry = e1;
              }
              toJSON() {
                const e1 = {
                  type: "Feature",
                  state: void 0,
                  geometry: this.geometry,
                  properties: this.properties,
                };
                void 0 !== this.id && (e1.id = this.id);
                for (const t of Im) void 0 !== this[t] && (e1[t] = this[t]);
                return e1;
              }
            }
            class zm {
              constructor() {
                (this.state = {}),
                  (this.stateChanges = {}),
                  (this.deletedStates = {});
              }
              updateState(e1, t, i) {
                const r = String(t);
                if (
                  ((this.stateChanges[e1] = this.stateChanges[e1] || {}),
                  (this.stateChanges[e1][r] = this.stateChanges[e1][r] || {}),
                  k(this.stateChanges[e1][r], i),
                  null === this.deletedStates[e1])
                ) {
                  this.deletedStates[e1] = {};
                  for (const t in this.state[e1])
                    t !== r && (this.deletedStates[e1][t] = null);
                } else if (
                  this.deletedStates[e1] &&
                  null === this.deletedStates[e1][r]
                ) {
                  this.deletedStates[e1][r] = {};
                  for (const t in this.state[e1][r])
                    i[t] || (this.deletedStates[e1][r][t] = null);
                } else
                  for (const t in i)
                    this.deletedStates[e1] &&
                      this.deletedStates[e1][r] &&
                      null === this.deletedStates[e1][r][t] &&
                      delete this.deletedStates[e1][r][t];
              }
              removeFeatureState(e1, t, i) {
                if (null === this.deletedStates[e1]) return;
                const r = String(t);
                if (
                  ((this.deletedStates[e1] = this.deletedStates[e1] || {}),
                  i && void 0 !== t)
                )
                  null !== this.deletedStates[e1][r] &&
                    ((this.deletedStates[e1][r] =
                      this.deletedStates[e1][r] || {}),
                    (this.deletedStates[e1][r][i] = null));
                else if (void 0 !== t) {
                  if (this.stateChanges[e1] && this.stateChanges[e1][r])
                    for (i in ((this.deletedStates[e1][r] = {}),
                    this.stateChanges[e1][r]))
                      this.deletedStates[e1][r][i] = null;
                  else this.deletedStates[e1][r] = null;
                } else this.deletedStates[e1] = null;
              }
              getState(e1, t) {
                const i = String(t),
                  r = k(
                    {},
                    (this.state[e1] || {})[i],
                    (this.stateChanges[e1] || {})[i],
                  );
                if (null === this.deletedStates[e1]) return {};
                if (this.deletedStates[e1]) {
                  const i = this.deletedStates[e1][t];
                  if (null === i) return {};
                  for (const e1 in i) delete r[e1];
                }
                return r;
              }
              initializeTileState(e1, t) {
                e1.setFeatureState(this.state, t);
              }
              coalesceChanges(e1, t) {
                const i = {};
                for (const e1 in this.stateChanges) {
                  this.state[e1] = this.state[e1] || {};
                  const t = {};
                  for (const i in this.stateChanges[e1])
                    this.state[e1][i] || (this.state[e1][i] = {}),
                      k(this.state[e1][i], this.stateChanges[e1][i]),
                      (t[i] = this.state[e1][i]);
                  i[e1] = t;
                }
                for (const e1 in this.deletedStates) {
                  this.state[e1] = this.state[e1] || {};
                  const t = {};
                  if (null === this.deletedStates[e1])
                    for (const i in this.state[e1])
                      (t[i] = {}), (this.state[e1][i] = {});
                  else
                    for (const i in this.deletedStates[e1]) {
                      if (null === this.deletedStates[e1][i])
                        this.state[e1][i] = {};
                      else if (this.state[e1][i])
                        for (const t of Object.keys(this.deletedStates[e1][i]))
                          delete this.state[e1][i][t];
                      t[i] = this.state[e1][i];
                    }
                  (i[e1] = i[e1] || {}), k(i[e1], t);
                }
                if (
                  ((this.stateChanges = {}),
                  (this.deletedStates = {}),
                  0 !== Object.keys(i).length)
                )
                  for (const r in e1) e1[r].setFeatureState(i, t);
              }
            }
            class Dm {
              constructor(e1) {
                (this.size = e1),
                  (this.minimums = []),
                  (this.maximums = []),
                  (this.leaves = []);
              }
              getElevation(e1, t) {
                const i = this.toIdx(e1, t);
                return {
                  min: this.minimums[i],
                  max: this.maximums[i],
                };
              }
              isLeaf(e1, t) {
                return this.leaves[this.toIdx(e1, t)];
              }
              toIdx(e1, t) {
                return t * this.size + e1;
              }
            }
            function Pm(e1, t, i, r) {
              let n = 0,
                o = Number.MAX_VALUE;
              for (let s = 0; s < 3; s++)
                if (Math.abs(r[s]) < 1e-15) {
                  if (i[s] < e1[s] || i[s] > t[s]) return null;
                } else {
                  const a = 1 / r[s];
                  let l = (e1[s] - i[s]) * a,
                    c = (t[s] - i[s]) * a;
                  if (l > c) {
                    const e1 = l;
                    (l = c), (c = e1);
                  }
                  if ((l > n && (n = l), c < o && (o = c), n > o)) return null;
                }
              return n;
            }
            function Rm(e1, t, i, r, n, o, s, a, l, c, h) {
              const u = r - e1,
                d = n - t,
                p = o - i,
                f = s - e1,
                m = a - t,
                _ = l - i,
                g = h[1] * _ - h[2] * m,
                y = h[2] * f - h[0] * _,
                x = h[0] * m - h[1] * f,
                v = u * g + d * y + p * x;
              if (Math.abs(v) < 1e-15) return null;
              const b = 1 / v,
                w = c[0] - e1,
                T = c[1] - t,
                E = c[2] - i,
                M = (w * g + T * y + E * x) * b;
              if (M < 0 || M > 1) return null;
              const A = T * p - E * d,
                S = E * u - w * p,
                I = w * d - T * u,
                C = (h[0] * A + h[1] * S + h[2] * I) * b;
              return C < 0 || M + C > 1 ? null : (f * A + m * S + _ * I) * b;
            }
            function Lm(e1, t, i) {
              return (e1 - t) / (i - t);
            }
            function km(e1, t, i, r, n, o, s, a, l) {
              const c = 1 << i,
                h = o - r,
                u = s - n,
                d = ((e1 + 1) / c) * h + r,
                p = ((t + 0) / c) * u + n,
                f = ((t + 1) / c) * u + n;
              (a[0] = ((e1 + 0) / c) * h + r),
                (a[1] = p),
                (l[0] = d),
                (l[1] = f);
            }
            class Om {
              constructor(e1) {
                if (
                  ((this.maximums = []),
                  (this.minimums = []),
                  (this.leaves = []),
                  (this.childOffsets = []),
                  (this.nodeCount = 0),
                  (this.dem = e1),
                  (this._siblingOffset = [
                    [0, 0],
                    [1, 0],
                    [0, 1],
                    [1, 1],
                  ]),
                  !this.dem)
                )
                  return;
                const t = (function (e1) {
                    const t = Math.ceil(Math.log2(e1.dim / 8)),
                      i = [];
                    let r = Math.ceil(Math.pow(2, t));
                    const n = 1 / r,
                      o = (e1, t, i, r, n) => {
                        const o = r ? 1 : 0,
                          s = (e1 + 1) * i - o,
                          a = t * i,
                          l = (t + 1) * i - o;
                        (n[0] = e1 * i), (n[1] = a), (n[2] = s), (n[3] = l);
                      };
                    let s = new Dm(r);
                    const a = [];
                    for (let t = 0; t < r * r; t++) {
                      o(t % r, Math.floor(t / r), n, !1, a);
                      const i = Fm(a[0], a[1], e1),
                        l = Fm(a[2], a[1], e1),
                        c = Fm(a[2], a[3], e1),
                        h = Fm(a[0], a[3], e1);
                      s.minimums.push(Math.min(i, l, c, h)),
                        s.maximums.push(Math.max(i, l, c, h)),
                        s.leaves.push(1);
                    }
                    for (i.push(s), r /= 2; r >= 1; r /= 2) {
                      const e1 = i[i.length - 1];
                      s = new Dm(r);
                      for (let t = 0; t < r * r; t++) {
                        o(t % r, Math.floor(t / r), 2, !0, a);
                        const i = e1.getElevation(a[0], a[1]),
                          n = e1.getElevation(a[2], a[1]),
                          l = e1.getElevation(a[2], a[3]),
                          c = e1.getElevation(a[0], a[3]),
                          h = e1.isLeaf(a[0], a[1]),
                          u = e1.isLeaf(a[2], a[1]),
                          d = e1.isLeaf(a[2], a[3]),
                          p = e1.isLeaf(a[0], a[3]),
                          f = Math.min(i.min, n.min, l.min, c.min),
                          m = Math.max(i.max, n.max, l.max, c.max),
                          _ = h && u && d && p;
                        s.maximums.push(m),
                          s.minimums.push(f),
                          s.leaves.push(m - f <= 5 && _ ? 1 : 0);
                      }
                      i.push(s);
                    }
                    return i;
                  })(this.dem),
                  i = t.length - 1,
                  r = t[i];
                this._addNode(r.minimums[0], r.maximums[0], r.leaves[0]),
                  this._construct(t, 0, 0, i, 0);
              }
              raycastRoot(e1, t, i, r, n, o, s = 1) {
                return Pm([e1, t, -100], [i, r, this.maximums[0] * s], n, o);
              }
              raycast(e1, t, i, r, n, o, s = 1) {
                if (!this.nodeCount) return null;
                const a = this.raycastRoot(e1, t, i, r, n, o, s);
                if (null == a) return null;
                const l = [],
                  c = [],
                  h = [],
                  u = [],
                  d = [
                    {
                      idx: 0,
                      t: a,
                      nodex: 0,
                      nodey: 0,
                      depth: 0,
                    },
                  ];
                for (; d.length > 0; ) {
                  const {
                    idx: a,
                    t: p,
                    nodex: f,
                    nodey: m,
                    depth: _,
                  } = d.pop();
                  if (this.leaves[a]) {
                    km(f, m, _, e1, t, i, r, h, u);
                    const a = 1 << _,
                      l = (f + 0) / a,
                      c = (f + 1) / a,
                      d = (m + 0) / a,
                      g = (m + 1) / a,
                      y = Fm(l, d, this.dem) * s,
                      x = Fm(c, d, this.dem) * s,
                      v = Fm(c, g, this.dem) * s,
                      b = Fm(l, g, this.dem) * s,
                      w = Rm(h[0], h[1], y, u[0], h[1], x, u[0], u[1], v, n, o),
                      T = Rm(u[0], u[1], v, h[0], u[1], b, h[0], h[1], y, n, o),
                      E = Math.min(
                        null !== w ? w : Number.MAX_VALUE,
                        null !== T ? T : Number.MAX_VALUE,
                      );
                    if (E !== Number.MAX_VALUE) return E;
                    {
                      const e1 = Mu.scaleAndAdd([], n, o, p);
                      if (
                        Bm(
                          y,
                          x,
                          b,
                          v,
                          Lm(e1[0], h[0], u[0]),
                          Lm(e1[1], h[1], u[1]),
                        ) >= e1[2]
                      )
                        return p;
                    }
                    continue;
                  }
                  let g = 0;
                  for (let d = 0; d < this._siblingOffset.length; d++) {
                    km(
                      (f << 1) + this._siblingOffset[d][0],
                      (m << 1) + this._siblingOffset[d][1],
                      _ + 1,
                      e1,
                      t,
                      i,
                      r,
                      h,
                      u,
                    ),
                      (h[2] = -100),
                      (u[2] = this.maximums[this.childOffsets[a] + d] * s);
                    const p = Pm(h, u, n, o);
                    if (null != p) {
                      const e1 = p;
                      l[d] = e1;
                      let t = !1;
                      for (let i = 0; i < g && !t; i++)
                        e1 >= l[c[i]] && (c.splice(i, 0, d), (t = !0));
                      t || (c[g] = d), g++;
                    }
                  }
                  for (let e1 = 0; e1 < g; e1++) {
                    const t = c[e1];
                    d.push({
                      idx: this.childOffsets[a] + t,
                      t: l[t],
                      nodex: (f << 1) + this._siblingOffset[t][0],
                      nodey: (m << 1) + this._siblingOffset[t][1],
                      depth: _ + 1,
                    });
                  }
                }
                return null;
              }
              _addNode(e1, t, i) {
                return (
                  this.minimums.push(e1),
                  this.maximums.push(t),
                  this.leaves.push(i),
                  this.childOffsets.push(0),
                  this.nodeCount++
                );
              }
              _construct(e1, t, i, r, n) {
                if (1 === e1[r].isLeaf(t, i)) return;
                this.childOffsets[n] || (this.childOffsets[n] = this.nodeCount);
                const o = r - 1,
                  s = e1[o];
                let a = 0,
                  l = 0;
                for (let e1 = 0; e1 < this._siblingOffset.length; e1++) {
                  const r = 2 * t + this._siblingOffset[e1][0],
                    n = 2 * i + this._siblingOffset[e1][1],
                    o = s.getElevation(r, n),
                    c = s.isLeaf(r, n),
                    h = this._addNode(o.min, o.max, c);
                  c && (a |= 1 << e1), l || (l = h);
                }
                for (let r = 0; r < this._siblingOffset.length; r++)
                  a & (1 << r) ||
                    this._construct(
                      e1,
                      2 * t + this._siblingOffset[r][0],
                      2 * i + this._siblingOffset[r][1],
                      o,
                      l + r,
                    );
              }
            }
            function Bm(e1, t, i, r, n, o) {
              return Wr(Wr(e1, i, o), Wr(t, r, o), n);
            }
            function Fm(e1, t, i) {
              const r = i.dim,
                n = z(e1 * r - 0.5, 0, r - 1),
                o = z(t * r - 0.5, 0, r - 1),
                s = Math.floor(n),
                a = Math.floor(o),
                l = Math.min(s + 1, r - 1),
                c = Math.min(a + 1, r - 1);
              return Bm(
                i.get(s, a),
                i.get(l, a),
                i.get(s, c),
                i.get(l, c),
                n - s,
                o - a,
              );
            }
            const Nm = {
              mapbox: [6553.6, 25.6, 0.1, 1e4],
              terrarium: [256, 1, 1 / 256, 32768],
              float: [1, 1, 1, 1],
            };
            function Um(e1, t, i) {
              return (256 * e1 * 256 + 256 * t + i) / 10 - 1e4;
            }
            function Vm(e1, t, i) {
              return 256 * e1 + t + i / 256 - 32768;
            }
            class jm {
              get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
              }
              constructor(e1, t, i, r, n = !1) {
                if (((this.uid = e1), t.height !== t.width))
                  throw new RangeError("DEM tiles must be square");
                if (i && "mapbox" !== i && "terrarium" !== i)
                  return W(
                    `"${i}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`,
                  );
                this.stride = t.height;
                const o = (this.dim = t.height - 2),
                  s = new Uint32Array(t.data.buffer);
                if (
                  ((this.pixels = new Uint8Array(t.data.buffer)),
                  (this.encoding = i || "mapbox"),
                  (this.borderReady = n),
                  (this._modifiedForSources = {}),
                  !n)
                ) {
                  for (let e1 = 0; e1 < o; e1++)
                    (s[this._idx(-1, e1)] = s[this._idx(0, e1)]),
                      (s[this._idx(o, e1)] = s[this._idx(o - 1, e1)]),
                      (s[this._idx(e1, -1)] = s[this._idx(e1, 0)]),
                      (s[this._idx(e1, o)] = s[this._idx(e1, o - 1)]);
                  (s[this._idx(-1, -1)] = s[this._idx(0, 0)]),
                    (s[this._idx(o, -1)] = s[this._idx(o - 1, 0)]),
                    (s[this._idx(-1, o)] = s[this._idx(0, o - 1)]),
                    (s[this._idx(o, o)] = s[this._idx(o - 1, o - 1)]);
                }
                if (r) {
                  const e1 = new Float32Array(t.data.buffer),
                    i = "terrarium" === this.encoding ? Vm : Um;
                  for (let t = 0; t < s.length; ++t) {
                    const r = 4 * t;
                    e1[t] = i(
                      this.pixels[r],
                      this.pixels[r + 1],
                      this.pixels[r + 2],
                    );
                  }
                  this.encoding = "float";
                }
                this._timestamp = ht.now();
              }
              _buildQuadTree() {
                this._tree = new Om(this);
              }
              get(e1, t, i = !1) {
                i && ((e1 = z(e1, -1, this.dim)), (t = z(t, -1, this.dim)));
                const r = this._idx(e1, t);
                if ("float" === this.encoding)
                  return (
                    this.floatView ||
                      (this.floatView = new Float32Array(this.pixels.buffer)),
                    this.floatView[r]
                  );
                const n = 4 * r;
                return ("terrarium" === this.encoding ? Vm : Um)(
                  this.pixels[n],
                  this.pixels[n + 1],
                  this.pixels[n + 2],
                );
              }
              set(e1, t, i) {
                const r = this._idx(e1, t);
                if ("float" === this.encoding) {
                  this.floatView ||
                    (this.floatView = new Float32Array(this.pixels.buffer));
                  const e1 = this.floatView[r];
                  return (this.floatView[r] = i), i - e1;
                }
                const n = 4 * r,
                  o = ("terrarium" === this.encoding ? Vm : Um)(
                    this.pixels[n],
                    this.pixels[n + 1],
                    this.pixels[n + 2],
                  ),
                  s = jm.pack(
                    i,
                    "terrarium" === this.encoding ? "terrarium" : "mapbox",
                  );
                return (
                  (this.pixels[n] = s[0]),
                  (this.pixels[n + 1] = s[1]),
                  (this.pixels[n + 2] = s[2]),
                  i - o
                );
              }
              static getUnpackVector(e1) {
                return Nm[e1];
              }
              get unpackVector() {
                return Nm[this.encoding];
              }
              _idx(e1, t) {
                if (
                  e1 < -1 ||
                  e1 >= this.dim + 1 ||
                  t < -1 ||
                  t >= this.dim + 1
                )
                  throw new RangeError(
                    "out of range source coordinates for DEM data",
                  );
                return (t + 1) * this.stride + (e1 + 1);
              }
              static pack(e1, t) {
                const i = [0, 0, 0, 0],
                  r = jm.getUnpackVector(t);
                let n = Math.floor((e1 + r[3]) / r[2]);
                return (
                  (i[2] = n % 256),
                  (n = Math.floor(n / 256)),
                  (i[1] = n % 256),
                  (n = Math.floor(n / 256)),
                  (i[0] = n),
                  i
                );
              }
              getPixels() {
                return "float" === this.encoding
                  ? new Hp(
                      {
                        width: this.stride,
                        height: this.stride,
                      },
                      this.pixels,
                    )
                  : new $p(
                      {
                        width: this.stride,
                        height: this.stride,
                      },
                      this.pixels,
                    );
              }
              backfillBorder(e1, t, i) {
                if (this.dim !== e1.dim)
                  throw new Error("dem dimension mismatch");
                let r = t * this.dim,
                  n = t * this.dim + this.dim,
                  o = i * this.dim,
                  s = i * this.dim + this.dim;
                switch (t) {
                  case -1:
                    r = n - 1;
                    break;
                  case 1:
                    n = r + 1;
                }
                switch (i) {
                  case -1:
                    o = s - 1;
                    break;
                  case 1:
                    s = o + 1;
                }
                const a = -t * this.dim,
                  l = -i * this.dim;
                for (let t = o; t < s; t++)
                  for (let i = r; i < n; i++) {
                    const r = 4 * this._idx(i, t),
                      n = 4 * this._idx(i + a, t + l);
                    (this.pixels[r + 0] = e1.pixels[n + 0]),
                      (this.pixels[r + 1] = e1.pixels[n + 1]),
                      (this.pixels[r + 2] = e1.pixels[n + 2]),
                      (this.pixels[r + 3] = e1.pixels[n + 3]);
                  }
              }
              onDeserialize() {
                this._tree && (this._tree.dem = this);
              }
            }
            Is(jm, "DEMData"),
              Is(Om, "DemMinMaxQuadTree", {
                omit: ["dem"],
              });
            class Gm {
              isDataAvailableAtPoint(e1) {
                const t = this._source();
                if (this.isUsingMockSource() || !t || e1.y < 0 || e1.y > 1)
                  return !1;
                const i = t.getSource().maxzoom,
                  r = 1 << i,
                  n = Math.floor(e1.x),
                  o = Math.floor((e1.x - n) * r),
                  s = Math.floor(e1.y * r),
                  a = this.findDEMTileFor(new Bu(i, n, i, o, s));
                return !(!a || !a.dem);
              }
              getAtPointOrZero(e1, t = 0) {
                return this.getAtPoint(e1, t) || 0;
              }
              getAtPoint(e1, t, i = !0) {
                if (this.isUsingMockSource()) return null;
                null == t && (t = null);
                const r = this._source();
                if (!r) return t;
                if (e1.y < 0 || e1.y > 1) return t;
                const n = r.getSource().maxzoom,
                  o = 1 << n,
                  s = Math.floor(e1.x),
                  a = e1.x - s,
                  l = new Bu(n, s, n, Math.floor(a * o), Math.floor(e1.y * o)),
                  c = this.findDEMTileFor(l);
                if (!c || !c.dem) return t;
                const h = c.dem,
                  u = 1 << c.tileID.canonical.z,
                  d = (a * u - c.tileID.canonical.x) * h.dim,
                  p = (e1.y * u - c.tileID.canonical.y) * h.dim,
                  f = Math.floor(d),
                  m = Math.floor(p);
                return (
                  (i ? this.exaggeration() : 1) *
                  Wr(
                    Wr(h.get(f, m), h.get(f, m + 1), p - m),
                    Wr(h.get(f + 1, m), h.get(f + 1, m + 1), p - m),
                    d - f,
                  )
                );
              }
              getAtTileOffset(e1, t, i) {
                const r = 1 << e1.canonical.z;
                return this.getAtPointOrZero(
                  new ep(
                    e1.wrap + (e1.canonical.x + t / sr) / r,
                    (e1.canonical.y + i / sr) / r,
                  ),
                );
              }
              getAtTileOffsetFunc(e1, t, i, r) {
                return (n) => {
                  const o = this.getAtTileOffset(e1, n.x, n.y),
                    s = r.upVector(e1.canonical, n.x, n.y),
                    a = r.upVectorScale(e1.canonical, t, i).metersToTile;
                  return Mu.scale(s, s, o * a), s;
                };
              }
              getForTilePoints(e1, t, i, r) {
                if (this.isUsingMockSource()) return !1;
                const n = qm.create(this, e1, r);
                return (
                  !!n &&
                  (t.forEach((e1) => {
                    e1[2] =
                      this.exaggeration() * n.getElevationAt(e1[0], e1[1], i);
                  }),
                  !0)
                );
              }
              getMinMaxForTile(e1) {
                if (this.isUsingMockSource()) return null;
                const t = this.findDEMTileFor(e1);
                if (!t || !t.dem) return null;
                const i = t.dem.tree,
                  r = t.tileID,
                  n = 1 << (e1.canonical.z - r.canonical.z);
                let o = e1.canonical.x / n - r.canonical.x,
                  s = e1.canonical.y / n - r.canonical.y,
                  a = 0;
                for (
                  let t = 0;
                  t < e1.canonical.z - r.canonical.z && !i.leaves[a];
                  t++
                ) {
                  (o *= 2), (s *= 2);
                  const e1 = 2 * Math.floor(s) + Math.floor(o);
                  (a = i.childOffsets[a] + e1), (o %= 1), (s %= 1);
                }
                return {
                  min: this.exaggeration() * i.minimums[a],
                  max: this.exaggeration() * i.maximums[a],
                };
              }
              getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
              }
              raycast(e1, t, i) {
                throw new Error("Pure virtual method called.");
              }
              pointCoordinate(e1) {
                throw new Error("Pure virtual method called.");
              }
              _source() {
                throw new Error("Pure virtual method called.");
              }
              isUsingMockSource() {
                throw new Error("Pure virtual method called.");
              }
              exaggeration() {
                throw new Error("Pure virtual method called.");
              }
              findDEMTileFor(e1) {
                throw new Error("Pure virtual method called.");
              }
              get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
              }
            }
            class qm {
              constructor(e1, t, i) {
                (this._demTile = e1),
                  (this._dem = this._demTile.dem),
                  (this._scale = t),
                  (this._offset = i);
              }
              static create(e1, t, i) {
                const r = i || e1.findDEMTileFor(t);
                if (!r || !r.dem) return;
                const n = r.dem,
                  o = r.tileID,
                  s = 1 << (t.canonical.z - o.canonical.z);
                return new qm(r, n.dim / sr / s, [
                  (t.canonical.x / s - o.canonical.x) * n.dim,
                  (t.canonical.y / s - o.canonical.y) * n.dim,
                ]);
              }
              tileCoordToPixel(e1, t) {
                const i = t * this._scale + this._offset[1],
                  r = Math.floor(e1 * this._scale + this._offset[0]),
                  n = Math.floor(i);
                return new y(r, n);
              }
              getElevationAt(e1, t, i, r) {
                const n = e1 * this._scale + this._offset[0],
                  o = t * this._scale + this._offset[1],
                  s = Math.floor(n),
                  a = Math.floor(o),
                  l = this._dem;
                return (
                  (r = !!r),
                  i
                    ? Wr(
                        Wr(l.get(s, a, r), l.get(s, a + 1, r), o - a),
                        Wr(l.get(s + 1, a, r), l.get(s + 1, a + 1, r), o - a),
                        n - s,
                      )
                    : l.get(s, a, r)
                );
              }
              getElevationAtPixel(e1, t, i) {
                return this._dem.get(e1, t, !!i);
              }
              getMeterToDEM(e1) {
                return (
                  (1 << this._demTile.tileID.canonical.z) *
                  Zd(1, e1) *
                  this._dem.stride
                );
              }
            }
            class Zm {
              constructor(e1, t) {
                (this.tileID = e1),
                  (this.x = e1.canonical.x),
                  (this.y = e1.canonical.y),
                  (this.z = e1.canonical.z),
                  (this.grid = new As(sr, 16, 0)),
                  (this.featureIndexArray = new ll()),
                  (this.promoteId = t);
              }
              insert(e1, t, i, r, n, o = 0) {
                const s = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(i, r, n, o);
                const a = this.grid;
                for (let e1 = 0; e1 < t.length; e1++) {
                  const i = t[e1],
                    r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let e1 = 0; e1 < i.length; e1++) {
                    const t = i[e1];
                    (r[0] = Math.min(r[0], t.x)),
                      (r[1] = Math.min(r[1], t.y)),
                      (r[2] = Math.max(r[2], t.x)),
                      (r[3] = Math.max(r[3], t.y));
                  }
                  r[0] < sr &&
                    r[1] < sr &&
                    r[2] >= 0 &&
                    r[3] >= 0 &&
                    a.insert(s, r[0], r[1], r[2], r[3]);
                }
              }
              loadVTLayers() {
                if (!this.vtLayers) {
                  (this.vtLayers = new tm(new Sm(this.rawTileData)).layers),
                    (this.sourceLayerCoder = new nm(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"],
                    )),
                    (this.vtFeatures = {});
                  for (const e1 in this.vtLayers) this.vtFeatures[e1] = [];
                }
                return this.vtLayers;
              }
              query(e1, t, i, r) {
                this.loadVTLayers();
                const n = e1.params || {},
                  o = Ro(n.filter),
                  s = e1.tileResult,
                  a = e1.transform,
                  l = s.bufferedTilespaceBounds,
                  c = this.grid.query(
                    l.min.x,
                    l.min.y,
                    l.max.x,
                    l.max.y,
                    (e1, t, i, r) =>
                      Tp(s.bufferedTilespaceGeometry, e1, t, i, r),
                  );
                c.sort(Hm);
                let h = null;
                a.elevation &&
                  c.length > 0 &&
                  (h = qm.create(a.elevation, this.tileID));
                const u = {};
                let d;
                for (let a = 0; a < c.length; a++) {
                  const l = c[a];
                  if (l === d) continue;
                  d = l;
                  const p = this.featureIndexArray.get(l);
                  let f = null;
                  this.loadMatchingFeature(
                    u,
                    p,
                    o,
                    n.layers,
                    n.availableImages,
                    t,
                    i,
                    r,
                    (t, i, r, n = 0) => (
                      f || (f = lp(t, this.tileID.canonical, e1.tileTransform)),
                      i.queryIntersectsFeature(
                        s,
                        t,
                        r,
                        f,
                        this.z,
                        e1.transform,
                        e1.pixelPosMatrix,
                        h,
                        n,
                      )
                    ),
                  );
                }
                return u;
              }
              loadMatchingFeature(e1, t, i, r, n, o, s, a, l) {
                const {
                    featureIndex: c,
                    bucketIndex: h,
                    sourceLayerIndex: u,
                    layoutVertexArrayOffset: d,
                  } = t,
                  p = this.bucketLayerIDs[h];
                if (
                  r &&
                  !(function (e1, t) {
                    for (let i = 0; i < e1.length; i++)
                      if (t.indexOf(e1[i]) >= 0) return !0;
                    return !1;
                  })(r, p)
                )
                  return;
                const f = this.sourceLayerCoder.decode(u),
                  m = this.vtLayers[f].feature(c);
                if (i.needGeometry) {
                  const e1 = cp(m, !0);
                  if (
                    !i.filter(
                      new ea(this.tileID.overscaledZ),
                      e1,
                      this.tileID.canonical,
                    )
                  )
                    return;
                } else if (!i.filter(new ea(this.tileID.overscaledZ), m))
                  return;
                const _ = this.getId(m, f);
                for (let t = 0; t < p.length; t++) {
                  const i = p[t];
                  if (r && r.indexOf(i) < 0) continue;
                  const h = o[i];
                  if (!h) continue;
                  let u = {};
                  void 0 !== _ &&
                    a &&
                    (u = a.getState(h.sourceLayer || "_geojsonTileLayer", _));
                  const f = k({}, s[i]);
                  (f.paint = $m(f.paint, h.paint, m, u, n)),
                    (f.layout = $m(f.layout, h.layout, m, u, n));
                  const g = !l || l(m, h, u, d);
                  if (!g) continue;
                  const y = new Cm(m, this.z, this.x, this.y, _);
                  y.layer = f;
                  let x = e1[i];
                  void 0 === x && (x = e1[i] = []),
                    x.push({
                      featureIndex: c,
                      feature: y,
                      intersectionZ: g,
                    });
                }
              }
              lookupSymbolFeatures(e1, t, i, r, n, o, s, a) {
                const l = {};
                this.loadVTLayers();
                const c = Ro(n);
                for (const n of e1)
                  this.loadMatchingFeature(
                    l,
                    {
                      bucketIndex: i,
                      sourceLayerIndex: r,
                      featureIndex: n,
                      layoutVertexArrayOffset: 0,
                    },
                    c,
                    o,
                    s,
                    a,
                    t,
                  );
                return l;
              }
              loadFeature(e1) {
                const { featureIndex: t, sourceLayerIndex: i } = e1;
                this.loadVTLayers();
                const r = this.sourceLayerCoder.decode(i),
                  n = this.vtFeatures[r];
                if (n[t]) return n[t];
                const o = this.vtLayers[r].feature(t);
                return (n[t] = o), o;
              }
              hasLayer(e1) {
                for (const t of this.bucketLayerIDs)
                  for (const i of t) if (e1 === i) return !0;
                return !1;
              }
              getId(e1, t) {
                let i = e1.id;
                if (this.promoteId) {
                  const r =
                    "string" == typeof this.promoteId
                      ? this.promoteId
                      : this.promoteId[t];
                  null != r && (i = e1.properties[r]),
                    "boolean" == typeof i && (i = Number(i));
                }
                return i;
              }
            }
            function $m(e1, t, i, r, n) {
              return q(e1, (e1, o) => {
                const s = t instanceof la ? t.get(o) : null;
                return s && s.evaluate ? s.evaluate(i, r, n) : s;
              });
            }
            function Hm(e1, t) {
              return t - e1;
            }
            Is(Zm, "FeatureIndex", {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            const Wm = ba(
                [
                  {
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16",
                  },
                  {
                    name: "a_tex_size",
                    components: 4,
                    type: "Uint16",
                  },
                  {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16",
                  },
                ],
                4,
              ),
              Xm = ba(
                [
                  {
                    name: "a_globe_anchor",
                    components: 3,
                    type: "Int16",
                  },
                  {
                    name: "a_globe_normal",
                    components: 3,
                    type: "Float32",
                  },
                ],
                4,
              ),
              Ym = ba(
                [
                  {
                    name: "a_projected_pos",
                    components: 4,
                    type: "Float32",
                  },
                ],
                4,
              );
            ba(
              [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint32",
                },
              ],
              4,
            );
            const Km = ba(
                [
                  {
                    name: "a_z_offset",
                    components: 1,
                    type: "Float32",
                  },
                ],
                4,
              ),
              Jm = ba([
                {
                  name: "a_texb",
                  components: 2,
                  type: "Uint16",
                },
              ]),
              Qm = ba([
                {
                  name: "a_placed",
                  components: 2,
                  type: "Uint8",
                },
                {
                  name: "a_shift",
                  components: 2,
                  type: "Float32",
                },
              ]),
              e_ = ba([
                {
                  name: "a_size_scale",
                  components: 1,
                  type: "Float32",
                },
                {
                  name: "a_padding",
                  components: 2,
                  type: "Float32",
                },
              ]);
            ba([
              {
                type: "Int16",
                name: "projectedAnchorX",
              },
              {
                type: "Int16",
                name: "projectedAnchorY",
              },
              {
                type: "Int16",
                name: "projectedAnchorZ",
              },
              {
                type: "Int16",
                name: "tileAnchorX",
              },
              {
                type: "Int16",
                name: "tileAnchorY",
              },
              {
                type: "Float32",
                name: "x1",
              },
              {
                type: "Float32",
                name: "y1",
              },
              {
                type: "Float32",
                name: "x2",
              },
              {
                type: "Float32",
                name: "y2",
              },
              {
                type: "Int16",
                name: "padding",
              },
              {
                type: "Uint32",
                name: "featureIndex",
              },
              {
                type: "Uint16",
                name: "sourceLayerIndex",
              },
              {
                type: "Uint16",
                name: "bucketIndex",
              },
            ]);
            const t_ = ba(
                [
                  {
                    name: "a_pos",
                    components: 3,
                    type: "Int16",
                  },
                  {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16",
                  },
                  {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16",
                  },
                ],
                4,
              ),
              i_ = ba(
                [
                  {
                    name: "a_pos_2f",
                    components: 2,
                    type: "Float32",
                  },
                  {
                    name: "a_radius",
                    components: 1,
                    type: "Float32",
                  },
                  {
                    name: "a_flags",
                    components: 2,
                    type: "Int16",
                  },
                ],
                4,
              );
            ba([
              {
                name: "triangle",
                components: 3,
                type: "Uint16",
              },
            ]),
              ba([
                {
                  type: "Int16",
                  name: "projectedAnchorX",
                },
                {
                  type: "Int16",
                  name: "projectedAnchorY",
                },
                {
                  type: "Int16",
                  name: "projectedAnchorZ",
                },
                {
                  type: "Float32",
                  name: "tileAnchorX",
                },
                {
                  type: "Float32",
                  name: "tileAnchorY",
                },
                {
                  type: "Uint16",
                  name: "glyphStartIndex",
                },
                {
                  type: "Uint16",
                  name: "numGlyphs",
                },
                {
                  type: "Uint32",
                  name: "vertexStartIndex",
                },
                {
                  type: "Uint32",
                  name: "lineStartIndex",
                },
                {
                  type: "Uint32",
                  name: "lineLength",
                },
                {
                  type: "Uint16",
                  name: "segment",
                },
                {
                  type: "Uint16",
                  name: "lowerSize",
                },
                {
                  type: "Uint16",
                  name: "upperSize",
                },
                {
                  type: "Float32",
                  name: "lineOffsetX",
                },
                {
                  type: "Float32",
                  name: "lineOffsetY",
                },
                {
                  type: "Uint8",
                  name: "writingMode",
                },
                {
                  type: "Uint8",
                  name: "placedOrientation",
                },
                {
                  type: "Uint8",
                  name: "hidden",
                },
                {
                  type: "Uint32",
                  name: "crossTileID",
                },
                {
                  type: "Int16",
                  name: "associatedIconIndex",
                },
                {
                  type: "Uint8",
                  name: "flipState",
                },
              ]),
              ba([
                {
                  type: "Float32",
                  name: "tileAnchorX",
                },
                {
                  type: "Float32",
                  name: "tileAnchorY",
                },
                {
                  type: "Int16",
                  name: "projectedAnchorX",
                },
                {
                  type: "Int16",
                  name: "projectedAnchorY",
                },
                {
                  type: "Int16",
                  name: "projectedAnchorZ",
                },
                {
                  type: "Int16",
                  name: "rightJustifiedTextSymbolIndex",
                },
                {
                  type: "Int16",
                  name: "centerJustifiedTextSymbolIndex",
                },
                {
                  type: "Int16",
                  name: "leftJustifiedTextSymbolIndex",
                },
                {
                  type: "Int16",
                  name: "verticalPlacedTextSymbolIndex",
                },
                {
                  type: "Int16",
                  name: "placedIconSymbolIndex",
                },
                {
                  type: "Int16",
                  name: "verticalPlacedIconSymbolIndex",
                },
                {
                  type: "Uint16",
                  name: "key",
                },
                {
                  type: "Uint16",
                  name: "textBoxStartIndex",
                },
                {
                  type: "Uint16",
                  name: "textBoxEndIndex",
                },
                {
                  type: "Uint16",
                  name: "verticalTextBoxStartIndex",
                },
                {
                  type: "Uint16",
                  name: "verticalTextBoxEndIndex",
                },
                {
                  type: "Uint16",
                  name: "iconBoxStartIndex",
                },
                {
                  type: "Uint16",
                  name: "iconBoxEndIndex",
                },
                {
                  type: "Uint16",
                  name: "verticalIconBoxStartIndex",
                },
                {
                  type: "Uint16",
                  name: "verticalIconBoxEndIndex",
                },
                {
                  type: "Uint16",
                  name: "featureIndex",
                },
                {
                  type: "Uint16",
                  name: "numHorizontalGlyphVertices",
                },
                {
                  type: "Uint16",
                  name: "numVerticalGlyphVertices",
                },
                {
                  type: "Uint16",
                  name: "numIconVertices",
                },
                {
                  type: "Uint16",
                  name: "numVerticalIconVertices",
                },
                {
                  type: "Uint16",
                  name: "useRuntimeCollisionCircles",
                },
                {
                  type: "Uint32",
                  name: "crossTileID",
                },
                {
                  type: "Float32",
                  components: 2,
                  name: "textOffset",
                },
                {
                  type: "Float32",
                  name: "collisionCircleDiameter",
                },
                {
                  type: "Float32",
                  name: "zOffset",
                },
                {
                  type: "Uint8",
                  name: "hasIconTextFit",
                },
              ]),
              ba([
                {
                  type: "Float32",
                  name: "offsetX",
                },
              ]),
              ba([
                {
                  type: "Int16",
                  name: "x",
                },
                {
                  type: "Int16",
                  name: "y",
                },
              ]);
            var r_ = 24;
            const n_ = 128;
            function o_(e1, t) {
              const { expression: i } = t;
              if ("constant" === i.kind)
                return {
                  kind: "constant",
                  layoutSize: i.evaluate(new ea(e1 + 1)),
                };
              if ("source" === i.kind)
                return {
                  kind: "source",
                };
              {
                const { zoomStops: t, interpolationType: r } = i;
                let n = 0;
                for (; n < t.length && t[n] <= e1; ) n++;
                n = Math.max(0, n - 1);
                let o = n;
                for (; o < t.length && t[o] < e1 + 1; ) o++;
                o = Math.min(t.length - 1, o);
                const s = t[n],
                  a = t[o];
                return "composite" === i.kind
                  ? {
                      kind: "composite",
                      minZoom: s,
                      maxZoom: a,
                      interpolationType: r,
                    }
                  : {
                      kind: "camera",
                      minZoom: s,
                      maxZoom: a,
                      minSize: i.evaluate(new ea(s)),
                      maxSize: i.evaluate(new ea(a)),
                      interpolationType: r,
                    };
              }
            }
            function s_(
              e1,
              { uSize: t, uSizeT: i },
              { lowerSize: r, upperSize: n },
            ) {
              return "source" === e1.kind
                ? r / n_
                : "composite" === e1.kind
                ? Wr(r / n_, n / n_, i)
                : t;
            }
            function a_(e1, t) {
              let i = 0,
                r = 0;
              if ("constant" === e1.kind) r = e1.layoutSize;
              else if ("source" !== e1.kind) {
                const { interpolationType: n, minZoom: o, maxZoom: s } = e1,
                  a = n ? z(yn.interpolationFactor(n, t, o, s), 0, 1) : 0;
                "camera" === e1.kind
                  ? (r = Wr(e1.minSize, e1.maxSize, a))
                  : (i = a);
              }
              return {
                uSizeT: i,
                uSize: r,
              };
            }
            var l_ = Object.freeze({
              __proto__: null,
              SIZE_PACK_FACTOR: n_,
              evaluateSizeForFeature: s_,
              evaluateSizeForZoom: a_,
              getSizeData: o_,
            });
            function c_(e1, t, i) {
              return (
                e1.sections.forEach((e1) => {
                  e1.text = (function (e1, t, i) {
                    const r = t.layout.get("text-transform").evaluate(i, {});
                    return (
                      "uppercase" === r
                        ? (e1 = e1.toLocaleUpperCase())
                        : "lowercase" === r && (e1 = e1.toLocaleLowerCase()),
                      Qs.applyArabicShaping && (e1 = Qs.applyArabicShaping(e1)),
                      e1
                    );
                  })(e1.text, t, i);
                }),
                e1
              );
            }
            const h_ = {
              "!": "\uFE15",
              "#": "\uFF03",
              $: "\uFF04",
              "%": "\uFF05",
              "&": "\uFF06",
              "(": "\uFE35",
              ")": "\uFE36",
              "*": "\uFF0A",
              "+": "\uFF0B",
              ",": "\uFE10",
              "-": "\uFE32",
              ".": "\u30FB",
              "/": "\uFF0F",
              ":": "\uFE13",
              ";": "\uFE14",
              "<": "\uFE3F",
              "=": "\uFF1D",
              ">": "\uFE40",
              "?": "\uFE16",
              "@": "\uFF20",
              "[": "\uFE47",
              "\\": "\uFF3C",
              "]": "\uFE48",
              "^": "\uFF3E",
              _: "\uFE33",
              "`": "\uFF40",
              "{": "\uFE37",
              "|": "\u2015",
              "}": "\uFE38",
              "~": "\uFF5E",
              "\xa2": "\uFFE0",
              "\xa3": "\uFFE1",
              "\xa5": "\uFFE5",
              "\xa6": "\uFFE4",
              "\xac": "\uFFE2",
              "\xaf": "\uFFE3",
              "\u2013": "\uFE32",
              "\u2014": "\uFE31",
              "\u2018": "\uFE43",
              "\u2019": "\uFE44",
              "\u201C": "\uFE41",
              "\u201D": "\uFE42",
              "\u2026": "\uFE19",
              "\u2027": "\u30FB",
              "\u20A9": "\uFFE6",
              "\u3001": "\uFE11",
              "\u3002": "\uFE12",
              "\u3008": "\uFE3F",
              "\u3009": "\uFE40",
              "\u300A": "\uFE3D",
              "\u300B": "\uFE3E",
              "\u300C": "\uFE41",
              "\u300D": "\uFE42",
              "\u300E": "\uFE43",
              "\u300F": "\uFE44",
              "\u3010": "\uFE3B",
              "\u3011": "\uFE3C",
              "\u3014": "\uFE39",
              "\u3015": "\uFE3A",
              "\u3016": "\uFE17",
              "\u3017": "\uFE18",
              "\uFF01": "\uFE15",
              "\uFF08": "\uFE35",
              "\uFF09": "\uFE36",
              "\uFF0C": "\uFE10",
              "\uFF0D": "\uFE32",
              "\uFF0E": "\u30FB",
              "\uFF1A": "\uFE13",
              "\uFF1B": "\uFE14",
              "\uFF1C": "\uFE3F",
              "\uFF1E": "\uFE40",
              "\uFF1F": "\uFE16",
              "\uFF3B": "\uFE47",
              "\uFF3D": "\uFE48",
              "\uFF3F": "\uFE33",
              "\uFF5B": "\uFE37",
              "\uFF5C": "\u2015",
              "\uFF5D": "\uFE38",
              "\uFF5F": "\uFE35",
              "\uFF60": "\uFE36",
              "\uFF61": "\uFE12",
              "\uFF62": "\uFE41",
              "\uFF63": "\uFE42",
              "\u2190": "\u2191",
              "\u2192": "\u2193",
            };
            function u_(e1) {
              return (
                "\uFE36" === e1 ||
                "\uFE48" === e1 ||
                "\uFE38" === e1 ||
                "\uFE44" === e1 ||
                "\uFE42" === e1 ||
                "\uFE3E" === e1 ||
                "\uFE3C" === e1 ||
                "\uFE3A" === e1 ||
                "\uFE18" === e1 ||
                "\uFE40" === e1 ||
                "\uFE10" === e1 ||
                "\uFE13" === e1 ||
                "\uFE14" === e1 ||
                "\uFF40" === e1 ||
                "\uFFE3" === e1 ||
                "\uFE11" === e1 ||
                "\uFE12" === e1
              );
            }
            function d_(e1) {
              return (
                "\uFE35" === e1 ||
                "\uFE47" === e1 ||
                "\uFE37" === e1 ||
                "\uFE43" === e1 ||
                "\uFE41" === e1 ||
                "\uFE3D" === e1 ||
                "\uFE3B" === e1 ||
                "\uFE39" === e1 ||
                "\uFE17" === e1 ||
                "\uFE3F" === e1
              );
            }
            const p_ = 3;
            function f_(e1, t, i) {
              (t.glyphs = []), 1 === e1 && i.readMessage(m_, t);
            }
            function m_(e1, t, i) {
              if (3 === e1) {
                const {
                  id: e1,
                  bitmap: r,
                  width: n,
                  height: o,
                  left: s,
                  top: a,
                  advance: l,
                } = i.readMessage(__, {});
                t.glyphs.push({
                  id: e1,
                  bitmap: new Zp(
                    {
                      width: n + 2 * p_,
                      height: o + 2 * p_,
                    },
                    r,
                  ),
                  metrics: {
                    width: n,
                    height: o,
                    left: s,
                    top: a,
                    advance: l,
                  },
                });
              } else
                4 === e1
                  ? (t.ascender = i.readSVarint())
                  : 5 === e1 && (t.descender = i.readSVarint());
            }
            function __(e1, t, i) {
              1 === e1
                ? (t.id = i.readVarint())
                : 2 === e1
                ? (t.bitmap = i.readBytes())
                : 3 === e1
                ? (t.width = i.readVarint())
                : 4 === e1
                ? (t.height = i.readVarint())
                : 5 === e1
                ? (t.left = i.readSVarint())
                : 6 === e1
                ? (t.top = i.readSVarint())
                : 7 === e1 && (t.advance = i.readVarint());
            }
            const g_ = p_;
            function y_(e1) {
              let t = 0,
                i = 0;
              for (const r of e1) (t += r.w * r.h), (i = Math.max(i, r.w));
              e1.sort((e1, t) => t.h - e1.h);
              const r = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), i),
                  h: 1 / 0,
                },
              ];
              let n = 0,
                o = 0;
              for (const t of e1)
                for (let e1 = r.length - 1; e1 >= 0; e1--) {
                  const i = r[e1];
                  if (!(t.w > i.w || t.h > i.h)) {
                    if (
                      ((t.x = i.x),
                      (t.y = i.y),
                      (o = Math.max(o, t.y + t.h)),
                      (n = Math.max(n, t.x + t.w)),
                      t.w === i.w && t.h === i.h)
                    ) {
                      const t = r.pop();
                      e1 < r.length && (r[e1] = t);
                    } else
                      t.h === i.h
                        ? ((i.x += t.w), (i.w -= t.w))
                        : t.w === i.w
                        ? ((i.y += t.h), (i.h -= t.h))
                        : (r.push({
                            x: i.x + t.w,
                            y: i.y,
                            w: i.w - t.w,
                            h: t.h,
                          }),
                          (i.y += t.h),
                          (i.h -= t.h));
                    break;
                  }
                }
              return {
                w: n,
                h: o,
                fill: t / (n * o) || 0,
              };
            }
            const x_ = 1;
            class v_ {
              constructor(
                e1,
                {
                  pixelRatio: t,
                  version: i,
                  stretchX: r,
                  stretchY: n,
                  content: o,
                },
              ) {
                (this.paddedRect = e1),
                  (this.pixelRatio = t),
                  (this.stretchX = r),
                  (this.stretchY = n),
                  (this.content = o),
                  (this.version = i);
              }
              get tl() {
                return [this.paddedRect.x + x_, this.paddedRect.y + x_];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - x_,
                  this.paddedRect.y + this.paddedRect.h - x_,
                ];
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2 * x_) / this.pixelRatio,
                  (this.paddedRect.h - 2 * x_) / this.pixelRatio,
                ];
              }
            }
            class b_ {
              constructor(e1, t) {
                const i = {},
                  r = {};
                this.haveRenderCallbacks = [];
                const n = [];
                this.addImages(e1, i, n), this.addImages(t, r, n);
                const { w: o, h: s } = y_(n),
                  a = new $p({
                    width: o || 1,
                    height: s || 1,
                  });
                for (const t in e1) {
                  const r = e1[t],
                    n = i[t].paddedRect;
                  $p.copy(
                    r.data,
                    a,
                    {
                      x: 0,
                      y: 0,
                    },
                    {
                      x: n.x + x_,
                      y: n.y + x_,
                    },
                    r.data,
                  );
                }
                for (const e1 in t) {
                  const i = t[e1],
                    n = r[e1].paddedRect,
                    o = n.x + x_,
                    s = n.y + x_,
                    l = i.data.width,
                    c = i.data.height;
                  $p.copy(
                    i.data,
                    a,
                    {
                      x: 0,
                      y: 0,
                    },
                    {
                      x: o,
                      y: s,
                    },
                    i.data,
                  ),
                    $p.copy(
                      i.data,
                      a,
                      {
                        x: 0,
                        y: c - 1,
                      },
                      {
                        x: o,
                        y: s - 1,
                      },
                      {
                        width: l,
                        height: 1,
                      },
                    ),
                    $p.copy(
                      i.data,
                      a,
                      {
                        x: 0,
                        y: 0,
                      },
                      {
                        x: o,
                        y: s + c,
                      },
                      {
                        width: l,
                        height: 1,
                      },
                    ),
                    $p.copy(
                      i.data,
                      a,
                      {
                        x: l - 1,
                        y: 0,
                      },
                      {
                        x: o - 1,
                        y: s,
                      },
                      {
                        width: 1,
                        height: c,
                      },
                    ),
                    $p.copy(
                      i.data,
                      a,
                      {
                        x: 0,
                        y: 0,
                      },
                      {
                        x: o + l,
                        y: s,
                      },
                      {
                        width: 1,
                        height: c,
                      },
                    );
                }
                (this.image = a),
                  (this.iconPositions = i),
                  (this.patternPositions = r);
              }
              addImages(e1, t, i) {
                for (const r in e1) {
                  const n = e1[r],
                    o = {
                      x: 0,
                      y: 0,
                      w: n.data.width + 2 * x_,
                      h: n.data.height + 2 * x_,
                    };
                  i.push(o),
                    (t[r] = new v_(o, n)),
                    n.hasRenderCallback && this.haveRenderCallbacks.push(r);
                }
              }
              patchUpdatedImages(e1, t, i) {
                (this.haveRenderCallbacks = this.haveRenderCallbacks.filter(
                  (t) => e1.hasImage(t, i),
                )),
                  e1.dispatchRenderCallbacks(this.haveRenderCallbacks, i);
                for (const r in e1.getUpdatedImages(i))
                  this.patchUpdatedImage(
                    this.iconPositions[r],
                    e1.getImage(r, i),
                    t,
                  ),
                    this.patchUpdatedImage(
                      this.patternPositions[r],
                      e1.getImage(r, i),
                      t,
                    );
              }
              patchUpdatedImage(e1, t, i) {
                if (!e1 || !t) return;
                if (e1.version === t.version) return;
                e1.version = t.version;
                const [r, n] = e1.tl;
                i.update(t.data, void 0, {
                  x: r,
                  y: n,
                });
              }
            }
            Is(v_, "ImagePosition"), Is(b_, "ImageAtlas");
            const w_ = {
                horizontal: 1,
                vertical: 2,
                horizontalOnly: 3,
              },
              T_ = -17;
            class E_ {
              constructor() {
                (this.scale = 1),
                  (this.fontStack = ""),
                  (this.imageName = null);
              }
              static forText(e1, t) {
                const i = new E_();
                return (i.scale = e1 || 1), (i.fontStack = t), i;
              }
              static forImage(e1) {
                const t = new E_();
                return (t.imageName = e1), t;
              }
            }
            class M_ {
              constructor() {
                (this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null);
              }
              static fromFeature(e1, t) {
                const i = new M_();
                for (let r = 0; r < e1.sections.length; r++) {
                  const n = e1.sections[r];
                  n.image ? i.addImageSection(n) : i.addTextSection(n, t);
                }
                return i;
              }
              length() {
                return this.text.length;
              }
              getSection(e1) {
                return this.sections[this.sectionIndex[e1]];
              }
              getSections() {
                return this.sections;
              }
              getSectionIndex(e1) {
                return this.sectionIndex[e1];
              }
              getCodePoint(e1) {
                return this.text.codePointAt(e1);
              }
              verticalizePunctuation(e1) {
                this.text = (function (e1, t) {
                  let i = "";
                  for (let r = 0; r < e1.length; r++) {
                    const n = e1.charCodeAt(r + 1) || null,
                      o = e1.charCodeAt(r - 1) || null;
                    i +=
                      (!t &&
                        ((n && Fs(n) && !h_[e1[r + 1]]) ||
                          (o && Fs(o) && !h_[e1[r - 1]]))) ||
                      !h_[e1[r]]
                        ? e1[r]
                        : h_[e1[r]];
                  }
                  return i;
                })(this.text, e1);
              }
              trim() {
                let e1 = 0;
                for (
                  let t = 0;
                  t < this.text.length && S_[this.text.charCodeAt(t)];
                  t++
                )
                  e1++;
                let t = this.text.length;
                for (
                  let i = this.text.length - 1;
                  i >= 0 && i >= e1 && S_[this.text.charCodeAt(i)];
                  i--
                )
                  t--;
                (this.text = this.text.substring(e1, t)),
                  (this.sectionIndex = this.sectionIndex.slice(e1, t));
              }
              substring(e1, t) {
                const i = new M_();
                return (
                  (i.text = this.text.substring(e1, t)),
                  (i.sectionIndex = this.sectionIndex.slice(e1, t)),
                  (i.sections = this.sections),
                  i
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (e1, t) => Math.max(e1, this.sections[t].scale),
                  0,
                );
              }
              addTextSection(e1, t) {
                (this.text += e1.text),
                  this.sections.push(E_.forText(e1.scale, e1.fontStack || t));
                const i = this.sections.length - 1;
                for (let t = 0; t < e1.text.length; ++t)
                  this.sectionIndex.push(i);
              }
              addImageSection(e1) {
                const t = e1.image ? e1.image.namePrimary : "";
                if (0 === t.length)
                  return void W(
                    "Can't add FormattedSection with an empty image.",
                  );
                const i = this.getNextImageSectionCharCode();
                i
                  ? ((this.text += String.fromCodePoint(i)),
                    this.sections.push(E_.forImage(t)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : W("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function A_(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f) {
              const m = M_.fromFeature(e1, n);
              u === w_.vertical && m.verticalizePunctuation(d);
              let _ = [];
              const g = (function (e1, t, i, r, n, o) {
                  if (!e1) return [];
                  const s = [],
                    a = (function (e1, t, i, r, n, o) {
                      let s = 0;
                      for (let i = 0; i < e1.length(); i++) {
                        const a = e1.getSection(i);
                        s += C_(e1.getCodePoint(i), a, r, n, t, o);
                      }
                      return s / Math.max(1, Math.ceil(s / i));
                    })(e1, t, i, r, n, o),
                    l = e1.text.indexOf("\u200B") >= 0;
                  let c = 0;
                  for (let i = 0; i < e1.length(); i++) {
                    const u = e1.getSection(i),
                      d = e1.getCodePoint(i);
                    if (
                      (S_[d] || (c += C_(d, u, r, n, t, o)),
                      i < e1.length() - 1)
                    ) {
                      const t = !(
                        (h = d) < 11904 ||
                        !(
                          Rs["Bopomofo Extended"](h) ||
                          Rs.Bopomofo(h) ||
                          Rs["CJK Compatibility Forms"](h) ||
                          Rs["CJK Compatibility Ideographs"](h) ||
                          Rs["CJK Compatibility"](h) ||
                          Rs["CJK Radicals Supplement"](h) ||
                          Rs["CJK Strokes"](h) ||
                          Rs["CJK Symbols and Punctuation"](h) ||
                          Rs["CJK Unified Ideographs Extension A"](h) ||
                          Rs["CJK Unified Ideographs"](h) ||
                          Rs["Enclosed CJK Letters and Months"](h) ||
                          Rs["Halfwidth and Fullwidth Forms"](h) ||
                          Rs.Hiragana(h) ||
                          Rs["Ideographic Description Characters"](h) ||
                          Rs["Kangxi Radicals"](h) ||
                          Rs["Katakana Phonetic Extensions"](h) ||
                          Rs.Katakana(h) ||
                          Rs["Vertical Forms"](h) ||
                          Rs["Yi Radicals"](h) ||
                          Rs["Yi Syllables"](h)
                        )
                      );
                      (I_[d] || t || u.imageName) &&
                        s.push(
                          P_(
                            i + 1,
                            c,
                            a,
                            s,
                            D_(d, e1.getCodePoint(i + 1), t && l),
                            !1,
                          ),
                        );
                    }
                  }
                  var h;
                  return R_(P_(e1.length(), c, a, s, 0, !0));
                })(m, c, o, t, r, p),
                {
                  processBidirectionalText: y,
                  processStyledBidirectionalText: x,
                } = Qs;
              if (y && 1 === m.sections.length) {
                const e1 = y(m.toString(), g);
                for (const t of e1) {
                  const e1 = new M_();
                  (e1.text = t), (e1.sections = m.sections);
                  for (let i = 0; i < t.length; i++) e1.sectionIndex.push(0);
                  _.push(e1);
                }
              } else if (x) {
                const e1 = x(m.text, m.sectionIndex, g);
                for (const t of e1) {
                  const e1 = new M_();
                  (e1.text = t[0]),
                    (e1.sectionIndex = t[1]),
                    (e1.sections = m.sections),
                    _.push(e1);
                }
              } else
                _ = (function (e1, t) {
                  const i = [],
                    r = e1.text;
                  let n = 0;
                  for (const r of t) i.push(e1.substring(n, r)), (n = r);
                  return n < r.length && i.push(e1.substring(n, r.length)), i;
                })(m, g);
              const v = [],
                b = {
                  positionedLines: v,
                  text: m.toString(),
                  top: h[1],
                  bottom: h[1],
                  left: h[0],
                  right: h[0],
                  writingMode: u,
                  iconsInText: !1,
                  verticalizable: !1,
                  hasBaseline: !1,
                };
              return (
                (function (e1, t, i, r, n, o, s, a, l, c, h, u) {
                  let d = 0,
                    p = 0,
                    f = 0;
                  const m = "right" === a ? 1 : "left" === a ? 0 : 0.5;
                  let _ = !1;
                  for (const e1 of n) {
                    const i = e1.getSections();
                    for (const e1 of i) {
                      if (e1.imageName) continue;
                      const i = t[e1.fontStack];
                      if (
                        i &&
                        ((_ = void 0 !== i.ascender && void 0 !== i.descender),
                        !_)
                      )
                        break;
                    }
                    if (!_) break;
                  }
                  let g = 0;
                  for (const s of n) {
                    s.trim();
                    const n = s.getMaxScale(),
                      a = (n - 1) * r_,
                      x = {
                        positionedGlyphs: [],
                        lineOffset: 0,
                      };
                    e1.positionedLines[g] = x;
                    const v = x.positionedGlyphs;
                    let b = 0;
                    if (!s.length()) {
                      (p += o), ++g;
                      continue;
                    }
                    let w = 0,
                      T = 0;
                    for (let o = 0; o < s.length(); o++) {
                      const a = s.getSection(o),
                        f = s.getSectionIndex(o),
                        m = s.getCodePoint(o);
                      let g = a.scale,
                        x = null,
                        E = null,
                        M = null,
                        A = r_,
                        S = 0;
                      const I = !(
                        l === w_.horizontal ||
                        (!h && !Bs(m)) ||
                        (h &&
                          (S_[m] ||
                            ((y = m),
                            Rs.Arabic(y) ||
                              Rs["Arabic Supplement"](y) ||
                              Rs["Arabic Extended-A"](y) ||
                              Rs["Arabic Presentation Forms-A"](y) ||
                              Rs["Arabic Presentation Forms-B"](y))))
                      );
                      if (a.imageName) {
                        const t = r[a.imageName];
                        if (!t) continue;
                        (M = a.imageName),
                          (e1.iconsInText = e1.iconsInText || !0),
                          (E = t.paddedRect);
                        const i = t.displaySize;
                        (g = (g * r_) / u),
                          (x = {
                            width: i[0],
                            height: i[1],
                            left: x_,
                            top: -g_,
                            advance: I ? i[1] : i[0],
                            localGlyph: !1,
                          }),
                          (S = _ ? -x.height * g : T_ + n * r_ - i[1] * g),
                          (A = x.advance);
                        const o = (I ? i[0] : i[1]) * g - r_ * n;
                        o > 0 && o > b && (b = o);
                      } else {
                        const e1 = i[a.fontStack];
                        if (!e1) continue;
                        e1[m] && (E = e1[m]);
                        const r = t[a.fontStack];
                        if (!r) continue;
                        const o = r.glyphs[m];
                        if (!o) continue;
                        if (((x = o.metrics), (A = 8203 !== m ? r_ : 0), _)) {
                          const e1 =
                              void 0 !== r.ascender ? Math.abs(r.ascender) : 0,
                            t =
                              void 0 !== r.descender
                                ? Math.abs(r.descender)
                                : 0,
                            i = (e1 + t) * g;
                          w < i && ((w = i), (T = ((e1 - t) / 2) * g)),
                            (S = -e1 * g);
                        } else S = T_ + (n - g) * r_;
                      }
                      I
                        ? ((e1.verticalizable = !0),
                          v.push({
                            glyph: m,
                            imageName: M,
                            x: d,
                            y: p + S,
                            vertical: I,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: f,
                            metrics: x,
                            rect: E,
                          }),
                          (d += A * g + c))
                        : (v.push({
                            glyph: m,
                            imageName: M,
                            x: d,
                            y: p + S,
                            vertical: I,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: f,
                            metrics: x,
                            rect: E,
                          }),
                          (d += x.advance * g + c));
                    }
                    0 !== v.length &&
                      ((f = Math.max(d - c, f)),
                      _ ? k_(v, m, b, T, (o * n) / 2) : k_(v, m, b, 0, o / 2)),
                      (d = 0);
                    const E = o * n + b;
                    (x.lineOffset = Math.max(b, a)), (p += E), ++g;
                  }
                  var y;
                  const x = p,
                    { horizontalAlign: v, verticalAlign: b } = L_(s);
                  (function (e1, t, i, r, n, o) {
                    const s = (t - i) * n,
                      a = -o * r;
                    for (const t of e1)
                      for (const e1 of t.positionedGlyphs)
                        (e1.x += s), (e1.y += a);
                  })(e1.positionedLines, m, v, b, f, x),
                    (e1.top += -b * x),
                    (e1.bottom = e1.top + x),
                    (e1.left += -v * f),
                    (e1.right = e1.left + f),
                    (e1.hasBaseline = _);
                })(b, t, i, r, _, s, a, l, u, c, d, f),
                !(function (e1) {
                  for (const t of e1)
                    if (0 !== t.positionedGlyphs.length) return !1;
                  return !0;
                })(v) && b
              );
            }
            const S_ = {
                9: !0,
                10: !0,
                11: !0,
                12: !0,
                13: !0,
                32: !0,
              },
              I_ = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              };
            function C_(e1, t, i, r, n, o) {
              if (t.imageName) {
                const e1 = r[t.imageName];
                return e1 ? (e1.displaySize[0] * t.scale * r_) / o + n : 0;
              }
              {
                const r = i[t.fontStack],
                  o = r && r.glyphs[e1];
                return o ? o.metrics.advance * t.scale + n : 0;
              }
            }
            function z_(e1, t, i, r) {
              const n = Math.pow(e1 - t, 2);
              return r ? (e1 < t ? n / 2 : 2 * n) : n + Math.abs(i) * i;
            }
            function D_(e1, t, i) {
              let r = 0;
              return (
                10 === e1 && (r -= 1e4),
                i && (r += 150),
                (40 !== e1 && 65288 !== e1) || (r += 50),
                (41 !== t && 65289 !== t) || (r += 50),
                r
              );
            }
            function P_(e1, t, i, r, n, o) {
              let s = null,
                a = z_(t, i, n, o);
              for (const e1 of r) {
                const r = z_(t - e1.x, i, n, o) + e1.badness;
                r <= a && ((s = e1), (a = r));
              }
              return {
                index: e1,
                x: t,
                priorBreak: s,
                badness: a,
              };
            }
            function R_(e1) {
              return e1 ? R_(e1.priorBreak).concat(e1.index) : [];
            }
            function L_(e1) {
              let t = 0.5,
                i = 0.5;
              switch (e1) {
                case "right":
                case "top-right":
                case "bottom-right":
                  t = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  t = 0;
              }
              switch (e1) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  i = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  i = 0;
              }
              return {
                horizontalAlign: t,
                verticalAlign: i,
              };
            }
            function k_(e1, t, i, r, n) {
              if (!(t || i || r || n)) return;
              const o = e1.length - 1,
                s = e1[o],
                a = (s.x + s.metrics.advance * s.scale) * t;
              for (let t = 0; t <= o; t++)
                (e1[t].x -= a), (e1[t].y += i + r + n);
            }
            function O_(e1, t, i, r) {
              const { horizontalAlign: n, verticalAlign: o } = L_(r),
                s = i[0] - e1.displaySize[0] * n,
                a = i[1] - e1.displaySize[1] * o;
              return {
                imagePrimary: e1,
                imageSecondary: t,
                top: a,
                bottom: a + e1.displaySize[1],
                left: s,
                right: s + e1.displaySize[0],
              };
            }
            function B_(e1, t, i, r, n, o) {
              const s = e1.imagePrimary;
              let a;
              if (s.content) {
                const e1 = s.content,
                  t = s.pixelRatio || 1;
                a = [
                  e1[0] / t,
                  e1[1] / t,
                  s.displaySize[0] - e1[2] / t,
                  s.displaySize[1] - e1[3] / t,
                ];
              }
              const l = t.left * o,
                c = t.right * o;
              let h, u, d, p;
              "width" === i || "both" === i
                ? ((p = n[0] + l - r[3]), (u = n[0] + c + r[1]))
                : ((p = n[0] + (l + c - s.displaySize[0]) / 2),
                  (u = p + s.displaySize[0]));
              const f = t.top * o,
                m = t.bottom * o;
              return (
                "height" === i || "both" === i
                  ? ((h = n[1] + f - r[0]), (d = n[1] + m + r[2]))
                  : ((h = n[1] + (f + m - s.displaySize[1]) / 2),
                    (d = h + s.displaySize[1])),
                {
                  imagePrimary: s,
                  imageSecondary: void 0,
                  top: h,
                  right: u,
                  bottom: d,
                  left: p,
                  collisionPadding: a,
                }
              );
            }
            class F_ extends y {
              constructor(e1, t, i, r, n) {
                super(e1, t),
                  (this.angle = r),
                  (this.z = i),
                  void 0 !== n && (this.segment = n);
              }
              clone() {
                return new F_(this.x, this.y, this.z, this.angle, this.segment);
              }
            }
            function N_(e1, t, i, r, n) {
              if (void 0 === t.segment) return !0;
              let o = t,
                s = t.segment + 1,
                a = 0;
              for (; a > -i / 2; ) {
                if ((s--, s < 0)) return !1;
                (a -= e1[s].dist(o)), (o = e1[s]);
              }
              (a += e1[s].dist(e1[s + 1])), s++;
              const l = [];
              let c = 0;
              for (; a < i / 2; ) {
                const t = e1[s],
                  i = e1[s + 1];
                if (!i) return !1;
                let o = e1[s - 1].angleTo(t) - t.angleTo(i);
                for (
                  o = Math.abs(((o + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    l.push({
                      distance: a,
                      angleDelta: o,
                    }),
                    c += o;
                  a - l[0].distance > r;

                )
                  c -= l.shift().angleDelta;
                if (c > n) return !1;
                s++, (a += t.dist(i));
              }
              return !0;
            }
            function U_(e1) {
              let t = 0;
              for (let i = 0; i < e1.length - 1; i++)
                t += e1[i].dist(e1[i + 1]);
              return t;
            }
            function V_(e1, t, i) {
              return e1 ? 0.6 * t * i : 0;
            }
            function j_(e1, t) {
              return Math.max(
                e1 ? e1.right - e1.left : 0,
                t ? t.right - t.left : 0,
              );
            }
            function G_(e1, t, i, r, n, o) {
              const s = V_(i, n, o),
                a = j_(i, r) * o;
              let l = 0;
              const c = U_(e1) / 2;
              for (let i = 0; i < e1.length - 1; i++) {
                const r = e1[i],
                  n = e1[i + 1],
                  o = r.dist(n);
                if (l + o > c) {
                  const h = (c - l) / o,
                    u = Wr(r.x, n.x, h),
                    d = Wr(r.y, n.y, h),
                    p = new F_(u, d, 0, n.angleTo(r), i);
                  return !s || N_(e1, p, a, s, t) ? p : void 0;
                }
                l += o;
              }
            }
            function q_(e1, t, i, r, n, o, s, a, l) {
              const c = V_(r, o, s),
                h = j_(r, n),
                u = h * s,
                d =
                  0 === e1[0].x ||
                  e1[0].x === l ||
                  0 === e1[0].y ||
                  e1[0].y === l;
              return (
                t - u < t / 4 && (t = u + t / 4),
                Z_(
                  e1,
                  d ? ((t / 2) * a) % t : ((h / 2 + 2 * o) * s * a) % t,
                  t,
                  c,
                  i,
                  u,
                  d,
                  !1,
                  l,
                )
              );
            }
            function Z_(e1, t, i, r, n, o, s, a, l) {
              const c = o / 2,
                h = U_(e1);
              let u = 0,
                d = t - i,
                p = [];
              for (let t = 0; t < e1.length - 1; t++) {
                const s = e1[t],
                  a = e1[t + 1],
                  f = s.dist(a),
                  m = a.angleTo(s);
                for (; d + i < u + f; ) {
                  d += i;
                  const _ = (d - u) / f,
                    g = Wr(s.x, a.x, _),
                    y = Wr(s.y, a.y, _);
                  if (
                    g >= 0 &&
                    g < l &&
                    y >= 0 &&
                    y < l &&
                    d - c >= 0 &&
                    d + c <= h
                  ) {
                    const i = new F_(g, y, 0, m, t);
                    (r && !N_(e1, i, o, r, n)) || p.push(i);
                  }
                }
                u += f;
              }
              return (
                a || p.length || s || (p = Z_(e1, u / 2, i, r, n, o, s, !0, l)),
                p
              );
            }
            function $_(e1, t, i, r, n) {
              const o = [];
              for (let s = 0; s < e1.length; s++) {
                const a = e1[s];
                let l;
                for (let e1 = 0; e1 < a.length - 1; e1++) {
                  let s = a[e1],
                    c = a[e1 + 1];
                  (s.x < t && c.x < t) ||
                    (s.x < t
                      ? (s = new y(
                          t,
                          s.y + ((t - s.x) / (c.x - s.x)) * (c.y - s.y),
                        )._round())
                      : c.x < t &&
                        (c = new y(
                          t,
                          s.y + ((t - s.x) / (c.x - s.x)) * (c.y - s.y),
                        )._round()),
                    (s.y < i && c.y < i) ||
                      (s.y < i
                        ? (s = new y(
                            s.x + ((i - s.y) / (c.y - s.y)) * (c.x - s.x),
                            i,
                          )._round())
                        : c.y < i &&
                          (c = new y(
                            s.x + ((i - s.y) / (c.y - s.y)) * (c.x - s.x),
                            i,
                          )._round()),
                      (s.x >= r && c.x >= r) ||
                        (s.x >= r
                          ? (s = new y(
                              r,
                              s.y + ((r - s.x) / (c.x - s.x)) * (c.y - s.y),
                            )._round())
                          : c.x >= r &&
                            (c = new y(
                              r,
                              s.y + ((r - s.x) / (c.x - s.x)) * (c.y - s.y),
                            )._round()),
                        (s.y >= n && c.y >= n) ||
                          (s.y >= n
                            ? (s = new y(
                                s.x + ((n - s.y) / (c.y - s.y)) * (c.x - s.x),
                                n,
                              )._round())
                            : c.y >= n &&
                              (c = new y(
                                s.x + ((n - s.y) / (c.y - s.y)) * (c.x - s.x),
                                n,
                              )._round()),
                          (l && s.equals(l[l.length - 1])) ||
                            ((l = [s]), o.push(l)),
                          l.push(c)))));
                }
              }
              return o;
            }
            Is(F_, "Anchor");
            const H_ = 1e20;
            function W_(e1, t, i, r, n, o, s, a, l) {
              for (let c = t; c < t + r; c++) X_(e1, i * o + c, o, n, s, a, l);
              for (let c = i; c < i + n; c++) X_(e1, c * o + t, 1, r, s, a, l);
            }
            function X_(e1, t, i, r, n, o, s) {
              (o[0] = 0), (s[0] = -H_), (s[1] = H_), (n[0] = e1[t]);
              for (let a = 1, l = 0, c = 0; a < r; a++) {
                n[a] = e1[t + a * i];
                const r = a * a;
                do {
                  const e1 = o[l];
                  c = (n[a] - n[e1] + r - e1 * e1) / (a - e1) / 2;
                } while (c <= s[l] && --l > -1);
                l++, (o[l] = a), (s[l] = c), (s[l + 1] = H_);
              }
              for (let a = 0, l = 0; a < r; a++) {
                for (; s[l + 1] < a; ) l++;
                const r = o[l],
                  c = a - r;
                e1[t + a * i] = n[r] + c * c;
              }
            }
            const Y_ = 2;
            class K_ {
              constructor(e1, t, i) {
                (this.requestManager = e1),
                  (this.localGlyphMode = t),
                  (this.localFontFamily = i),
                  (this.urls = {}),
                  (this.entries = {}),
                  (this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {},
                  });
              }
              setURL(e1, t) {
                this.urls[t] = e1;
              }
              getGlyphs(e1, t, i) {
                const r = [],
                  o = this.urls[t] || n.GLYPHS_URL;
                for (const t in e1)
                  for (const i of e1[t])
                    r.push({
                      stack: t,
                      id: i,
                    });
                R(
                  r,
                  ({ stack: e1, id: t }, i) => {
                    let r = this.entries[e1];
                    r ||
                      (r = this.entries[e1] =
                        {
                          glyphs: {},
                          requests: {},
                          ranges: {},
                          ascender: void 0,
                          descender: void 0,
                        });
                    let n = r.glyphs[t];
                    if (void 0 !== n)
                      return void i(null, {
                        stack: e1,
                        id: t,
                        glyph: n,
                      });
                    if (((n = this._tinySDF(r, e1, t)), n))
                      return (
                        (r.glyphs[t] = n),
                        void i(null, {
                          stack: e1,
                          id: t,
                          glyph: n,
                        })
                      );
                    const s = Math.floor(t / 256);
                    if (256 * s > 65535)
                      return void i(new Error("glyphs > 65535 not supported"));
                    if (r.ranges[s])
                      return void i(null, {
                        stack: e1,
                        id: t,
                        glyph: n,
                      });
                    let a = r.requests[s];
                    a ||
                      ((a = r.requests[s] = []),
                      K_.loadGlyphRange(
                        e1,
                        s,
                        o,
                        this.requestManager,
                        (e1, t) => {
                          if (t) {
                            (r.ascender = t.ascender),
                              (r.descender = t.descender);
                            for (const e1 in t.glyphs)
                              this._doesCharSupportLocalGlyph(+e1) ||
                                (r.glyphs[+e1] = t.glyphs[+e1]);
                            r.ranges[s] = !0;
                          }
                          for (const i of a) i(e1, t);
                          delete r.requests[s];
                        },
                      )),
                      a.push((r, n) => {
                        r
                          ? i(r)
                          : n &&
                            i(null, {
                              stack: e1,
                              id: t,
                              glyph: n.glyphs[t] || null,
                            });
                      });
                  },
                  (e1, t) => {
                    if (e1) i(e1);
                    else if (t) {
                      const e1 = {};
                      for (const { stack: i, id: r, glyph: n } of t)
                        void 0 === e1[i] && (e1[i] = {}),
                          void 0 === e1[i].glyphs && (e1[i].glyphs = {}),
                          (e1[i].glyphs[r] = n && {
                            id: n.id,
                            bitmap: n.bitmap.clone(),
                            metrics: n.metrics,
                          }),
                          (e1[i].ascender = this.entries[i].ascender),
                          (e1[i].descender = this.entries[i].descender);
                      i(null, e1);
                    }
                  },
                );
              }
              _doesCharSupportLocalGlyph(e1) {
                return (
                  0 !== this.localGlyphMode &&
                  (2 === this.localGlyphMode
                    ? !!this.localFontFamily
                    : !!this.localFontFamily &&
                      (Rs["CJK Unified Ideographs"](e1) ||
                        Rs["Hangul Syllables"](e1) ||
                        Rs.Hiragana(e1) ||
                        Rs.Katakana(e1) ||
                        Rs["CJK Symbols and Punctuation"](e1) ||
                        Rs["CJK Unified Ideographs Extension A"](e1) ||
                        Rs["CJK Unified Ideographs Extension B"](e1)))
                );
              }
              _tinySDF(e1, t, i) {
                const r = this.localFontFamily;
                if (!r || !this._doesCharSupportLocalGlyph(i)) return;
                let n = e1.tinySDF;
                if (!n) {
                  let i = "400";
                  /bold/i.test(t)
                    ? (i = "900")
                    : /medium/i.test(t)
                    ? (i = "500")
                    : /light/i.test(t) && (i = "200"),
                    (n = e1.tinySDF =
                      new K_.TinySDF({
                        fontFamily: r,
                        fontWeight: i,
                        fontSize: 24 * Y_,
                        buffer: 3 * Y_,
                        radius: 8 * Y_,
                      })),
                    (n.fontWeight = i);
                }
                if (this.localGlyphs[n.fontWeight][i])
                  return this.localGlyphs[n.fontWeight][i];
                const o = String.fromCodePoint(i),
                  {
                    data: s,
                    width: a,
                    height: l,
                    glyphWidth: c,
                    glyphHeight: h,
                    glyphLeft: u,
                    glyphTop: d,
                    glyphAdvance: p,
                  } = n.draw(o);
                return (this.localGlyphs[n.fontWeight][i] = {
                  id: i,
                  bitmap: new Zp(
                    {
                      width: a,
                      height: l,
                    },
                    s,
                  ),
                  metrics: {
                    width: c / Y_,
                    height: h / Y_,
                    left: u / Y_,
                    top: d / Y_ - 27,
                    advance: p / Y_,
                    localGlyph: !0,
                  },
                });
              }
            }
            (K_.loadGlyphRange = function (e1, t, i, r, n) {
              const o = 256 * t,
                s = o + 255,
                a = r.transformRequest(
                  r
                    .normalizeGlyphsURL(i)
                    .replace("{fontstack}", e1)
                    .replace("{range}", `${o}-${s}`),
                  ye.Glyphs,
                );
              Te(a, (e1, t) => {
                if (e1) n(e1);
                else if (t) {
                  const e1 = {},
                    i = (function (e1) {
                      return new Sm(e1).readFields(f_, {});
                    })(t);
                  for (const t of i.glyphs) e1[t.id] = t;
                  n(null, {
                    glyphs: e1,
                    ascender: i.ascender,
                    descender: i.descender,
                  });
                }
              });
            }),
              (K_.TinySDF = class {
                constructor({
                  fontSize: e1 = 24,
                  buffer: t = 3,
                  radius: i = 8,
                  cutoff: r = 0.25,
                  fontFamily: n = "sans-serif",
                  fontWeight: o = "normal",
                  fontStyle: s = "normal",
                } = {}) {
                  (this.buffer = t), (this.cutoff = r), (this.radius = i);
                  const a = (this.size = e1 + 4 * t),
                    l = this._createCanvas(a),
                    c = (this.ctx = l.getContext("2d", {
                      willReadFrequently: !0,
                    }));
                  (c.font = `${s} ${o} ${e1}px ${n}`),
                    (c.textBaseline = "alphabetic"),
                    (c.textAlign = "left"),
                    (c.fillStyle = "black"),
                    (this.gridOuter = new Float64Array(a * a)),
                    (this.gridInner = new Float64Array(a * a)),
                    (this.f = new Float64Array(a)),
                    (this.z = new Float64Array(a + 1)),
                    (this.v = new Uint16Array(a));
                }
                _createCanvas(e1) {
                  const t = document.createElement("canvas");
                  return (t.width = t.height = e1), t;
                }
                draw(e1) {
                  const {
                      width: t,
                      actualBoundingBoxAscent: i,
                      actualBoundingBoxDescent: r,
                      actualBoundingBoxLeft: n,
                      actualBoundingBoxRight: o,
                    } = this.ctx.measureText(e1),
                    s = Math.ceil(i),
                    a = Math.max(
                      0,
                      Math.min(this.size - this.buffer, Math.ceil(o - n)),
                    ),
                    l = Math.min(this.size - this.buffer, s + Math.ceil(r)),
                    c = a + 2 * this.buffer,
                    h = l + 2 * this.buffer,
                    u = Math.max(c * h, 0),
                    d = new Uint8ClampedArray(u),
                    p = {
                      data: d,
                      width: c,
                      height: h,
                      glyphWidth: a,
                      glyphHeight: l,
                      glyphTop: s,
                      glyphLeft: 0,
                      glyphAdvance: t,
                    };
                  if (0 === a || 0 === l) return p;
                  const {
                    ctx: f,
                    buffer: m,
                    gridInner: _,
                    gridOuter: g,
                  } = this;
                  f.clearRect(m, m, a, l), f.fillText(e1, m, m + s);
                  const y = f.getImageData(m, m, a, l);
                  g.fill(H_, 0, u), _.fill(0, 0, u);
                  for (let e1 = 0; e1 < l; e1++)
                    for (let t = 0; t < a; t++) {
                      const i = y.data[4 * (e1 * a + t) + 3] / 255;
                      if (0 === i) continue;
                      const r = (e1 + m) * c + t + m;
                      if (1 === i) (g[r] = 0), (_[r] = H_);
                      else {
                        const e1 = 0.5 - i;
                        (g[r] = e1 > 0 ? e1 * e1 : 0),
                          (_[r] = e1 < 0 ? e1 * e1 : 0);
                      }
                    }
                  W_(g, 0, 0, c, h, c, this.f, this.v, this.z),
                    W_(_, m, m, a, l, c, this.f, this.v, this.z);
                  for (let e1 = 0; e1 < u; e1++) {
                    const t = Math.sqrt(g[e1]) - Math.sqrt(_[e1]);
                    d[e1] = Math.round(
                      255 - 255 * (t / this.radius + this.cutoff),
                    );
                  }
                  return p;
                }
              });
            const J_ = x_;
            function Q_(e1, t, i, r) {
              const n = [],
                o = e1.imagePrimary,
                s = o.pixelRatio,
                a = o.paddedRect.w - 2 * J_,
                l = o.paddedRect.h - 2 * J_,
                c = e1.right - e1.left,
                h = e1.bottom - e1.top,
                u = o.stretchX || [[0, a]],
                d = o.stretchY || [[0, l]],
                p = (e1, t) => e1 + t[1] - t[0],
                f = u.reduce(p, 0),
                m = d.reduce(p, 0),
                _ = a - f,
                g = l - m;
              let x = 0,
                v = f,
                b = 0,
                w = m,
                T = 0,
                E = _,
                M = 0,
                A = g;
              if (o.content && r) {
                const e1 = o.content;
                (x = eg(u, 0, e1[0])),
                  (b = eg(d, 0, e1[1])),
                  (v = eg(u, e1[0], e1[2])),
                  (w = eg(d, e1[1], e1[3])),
                  (T = e1[0] - x),
                  (M = e1[1] - b),
                  (E = e1[2] - e1[0] - v),
                  (A = e1[3] - e1[1] - w);
              }
              const S = (r, n, a, l) => {
                const u = ig(r.stretch - x, v, c, e1.left),
                  d = rg(r.fixed - T, E, r.stretch, f),
                  p = ig(n.stretch - b, w, h, e1.top),
                  _ = rg(n.fixed - M, A, n.stretch, m),
                  g = ig(a.stretch - x, v, c, e1.left),
                  S = rg(a.fixed - T, E, a.stretch, f),
                  I = ig(l.stretch - b, w, h, e1.top),
                  C = rg(l.fixed - M, A, l.stretch, m),
                  z = new y(u, p),
                  D = new y(g, p),
                  P = new y(g, I),
                  R = new y(u, I),
                  L = new y(d / s, _ / s),
                  k = new y(S / s, C / s),
                  O = (t * Math.PI) / 180;
                if (O) {
                  const e1 = Math.sin(O),
                    t = Math.cos(O),
                    i = [t, -e1, e1, t];
                  z._matMult(i), D._matMult(i), R._matMult(i), P._matMult(i);
                }
                const B = r.stretch + r.fixed,
                  F = a.stretch + a.fixed,
                  N = n.stretch + n.fixed,
                  U = l.stretch + l.fixed,
                  V = e1.imageSecondary;
                return {
                  tl: z,
                  tr: D,
                  bl: R,
                  br: P,
                  texPrimary: {
                    x: o.paddedRect.x + J_ + B,
                    y: o.paddedRect.y + J_ + N,
                    w: F - B,
                    h: U - N,
                  },
                  texSecondary: V
                    ? {
                        x: V.paddedRect.x + J_ + B,
                        y: V.paddedRect.y + J_ + N,
                        w: F - B,
                        h: U - N,
                      }
                    : void 0,
                  writingMode: void 0,
                  glyphOffset: [0, 0],
                  sectionIndex: 0,
                  pixelOffsetTL: L,
                  pixelOffsetBR: k,
                  minFontScaleX: E / s / c,
                  minFontScaleY: A / s / h,
                  isSDF: i,
                };
              };
              if (r && (o.stretchX || o.stretchY)) {
                const e1 = tg(u, _, f),
                  t = tg(d, g, m);
                for (let i = 0; i < e1.length - 1; i++) {
                  const r = e1[i],
                    o = e1[i + 1];
                  for (let e1 = 0; e1 < t.length - 1; e1++)
                    n.push(S(r, t[e1], o, t[e1 + 1]));
                }
              } else
                n.push(
                  S(
                    {
                      fixed: 0,
                      stretch: -1,
                    },
                    {
                      fixed: 0,
                      stretch: -1,
                    },
                    {
                      fixed: 0,
                      stretch: a + 1,
                    },
                    {
                      fixed: 0,
                      stretch: l + 1,
                    },
                  ),
                );
              return n;
            }
            function eg(e1, t, i) {
              let r = 0;
              for (const n of e1)
                r +=
                  Math.max(t, Math.min(i, n[1])) -
                  Math.max(t, Math.min(i, n[0]));
              return r;
            }
            function tg(e1, t, i) {
              const r = [
                {
                  fixed: -J_,
                  stretch: 0,
                },
              ];
              for (const [t, i] of e1) {
                const e1 = r[r.length - 1];
                r.push({
                  fixed: t - e1.stretch,
                  stretch: e1.stretch,
                }),
                  r.push({
                    fixed: t - e1.stretch,
                    stretch: e1.stretch + (i - t),
                  });
              }
              return (
                r.push({
                  fixed: t + J_,
                  stretch: i,
                }),
                r
              );
            }
            function ig(e1, t, i, r) {
              return (e1 / t) * i + r;
            }
            function rg(e1, t, i, r) {
              return e1 - (t * i) / r;
            }
            function ng(e1, t, i, r) {
              const n = t + e1.positionedLines[r].lineOffset;
              return 0 === r
                ? i + n / 2
                : i + (n + (t + e1.positionedLines[r - 1].lineOffset)) / 2;
            }
            function og(e1, t = 1, i = !1) {
              let r = 1 / 0,
                n = 1 / 0,
                o = -1 / 0,
                s = -1 / 0;
              const a = e1[0];
              for (let e1 = 0; e1 < a.length; e1++) {
                const t = a[e1];
                (!e1 || t.x < r) && (r = t.x),
                  (!e1 || t.y < n) && (n = t.y),
                  (!e1 || t.x > o) && (o = t.x),
                  (!e1 || t.y > s) && (s = t.y);
              }
              const l = Math.min(o - r, s - n);
              let c = l / 2;
              const h = new or([], sg);
              if (0 === l) return new y(r, n);
              for (let t = r; t < o; t += l)
                for (let i = n; i < s; i += l)
                  h.push(new ag(t + c, i + c, c, e1));
              let u = (function (e1) {
                  let t = 0,
                    i = 0,
                    r = 0;
                  const n = e1[0];
                  for (let e1 = 0, o = n.length, s = o - 1; e1 < o; s = e1++) {
                    const o = n[e1],
                      a = n[s],
                      l = o.x * a.y - a.x * o.y;
                    (i += (o.x + a.x) * l),
                      (r += (o.y + a.y) * l),
                      (t += 3 * l);
                  }
                  return new ag(i / t, r / t, 0, e1);
                })(e1),
                d = h.length;
              for (; h.length; ) {
                const r = h.pop();
                (r.d > u.d || !u.d) &&
                  ((u = r),
                  i &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * r.d) / 1e4,
                      d,
                    )),
                  r.max - u.d <= t ||
                    ((c = r.h / 2),
                    h.push(new ag(r.p.x - c, r.p.y - c, c, e1)),
                    h.push(new ag(r.p.x + c, r.p.y - c, c, e1)),
                    h.push(new ag(r.p.x - c, r.p.y + c, c, e1)),
                    h.push(new ag(r.p.x + c, r.p.y + c, c, e1)),
                    (d += 4));
              }
              return (
                i &&
                  (console.log(`num probes: ${d}`),
                  console.log(`best distance: ${u.d}`)),
                u.p
              );
            }
            function sg(e1, t) {
              return t.max - e1.max;
            }
            class ag {
              constructor(e1, t, i, r) {
                (this.p = new y(e1, t)),
                  (this.h = i),
                  (this.d = (function (e1, t) {
                    let i = !1,
                      r = 1 / 0;
                    for (let n = 0; n < t.length; n++) {
                      const o = t[n];
                      for (let t = 0, n = o.length, s = n - 1; t < n; s = t++) {
                        const n = o[t],
                          a = o[s];
                        n.y > e1.y != a.y > e1.y &&
                          e1.x <
                            ((a.x - n.x) * (e1.y - n.y)) / (a.y - n.y) + n.x &&
                          (i = !i),
                          (r = Math.min(r, vp(e1, n, a)));
                      }
                    }
                    return (i ? 1 : -1) * Math.sqrt(r);
                  })(this.p, r)),
                  (this.max = this.d + this.h * Math.SQRT2);
              }
            }
            const lg = 7,
              cg = Number.POSITIVE_INFINITY,
              hg = Math.sqrt(2);
            function ug(e1, [t, i]) {
              let r = 0,
                n = 0;
              if (i === cg) {
                t < 0 && (t = 0);
                const i = t / hg;
                switch (e1) {
                  case "top-right":
                  case "top-left":
                    n = i - lg;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                    n = -i + lg;
                    break;
                  case "bottom":
                    n = -t + lg;
                    break;
                  case "top":
                    n = t - lg;
                }
                switch (e1) {
                  case "top-right":
                  case "bottom-right":
                    r = -i;
                    break;
                  case "top-left":
                  case "bottom-left":
                    r = i;
                    break;
                  case "left":
                    r = t;
                    break;
                  case "right":
                    r = -t;
                }
              } else {
                switch (((t = Math.abs(t)), (i = Math.abs(i)), e1)) {
                  case "top-right":
                  case "top-left":
                  case "top":
                    n = i - lg;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                  case "bottom":
                    n = -i + lg;
                }
                switch (e1) {
                  case "top-right":
                  case "bottom-right":
                  case "right":
                    r = -t;
                    break;
                  case "top-left":
                  case "bottom-left":
                  case "left":
                    r = t;
                }
              }
              return [r, n];
            }
            function dg(e1, t, i, r, n, o, s, a, l, c, h) {
              e1.createArrays(),
                (e1.tilePixelRatio = sr / (512 * e1.overscaling)),
                (e1.compareText = {}),
                (e1.iconsNeedLinear = !1);
              const u = e1.layers[0].layout,
                d = e1.layers[0]._unevaluatedLayout._values,
                p = {};
              if ("composite" === e1.textSizeData.kind) {
                const { minZoom: t, maxZoom: i } = e1.textSizeData;
                p.compositeTextSizes = [
                  d["text-size"].possiblyEvaluate(new ea(t), a),
                  d["text-size"].possiblyEvaluate(new ea(i), a),
                ];
              }
              if ("composite" === e1.iconSizeData.kind) {
                const { minZoom: t, maxZoom: i } = e1.iconSizeData;
                p.compositeIconSizes = [
                  d["icon-size"].possiblyEvaluate(new ea(t), a),
                  d["icon-size"].possiblyEvaluate(new ea(i), a),
                ];
              }
              (p.layoutTextSize = d["text-size"].possiblyEvaluate(
                new ea(l + 1),
                a,
              )),
                (p.layoutIconSize = d["icon-size"].possiblyEvaluate(
                  new ea(l + 1),
                  a,
                )),
                (p.textMaxSize = d["text-size"].possiblyEvaluate(
                  new ea(18),
                  a,
                ));
              const f =
                  "map" === u.get("text-rotation-alignment") &&
                  "point" !== u.get("symbol-placement"),
                m = u.get("text-size");
              let _ = !1;
              for (const t of e1.features)
                if (t.icon && t.icon.nameSecondary) {
                  _ = !0;
                  break;
                }
              for (const o of e1.features) {
                const l = u.get("text-font").evaluate(o, {}, a).join(","),
                  d = m.evaluate(o, {}, a),
                  g = p.layoutTextSize.evaluate(o, {}, a),
                  y =
                    (p.layoutIconSize.evaluate(o, {}, a),
                    {
                      horizontal: {},
                      vertical: void 0,
                    }),
                  x = o.text;
                let v,
                  b = [0, 0];
                if (x) {
                  const r = x.toString(),
                    s = u.get("text-letter-spacing").evaluate(o, {}, a) * r_,
                    c = u.get("text-line-height").evaluate(o, {}, a) * r_,
                    h = ks(r) ? s : 0,
                    p = u.get("text-anchor").evaluate(o, {}, a),
                    m = u.get("text-variable-anchor");
                  if (!m) {
                    const e1 = u.get("text-radial-offset").evaluate(o, {}, a);
                    b = e1
                      ? ug(p, [e1 * r_, cg])
                      : u
                          .get("text-offset")
                          .evaluate(o, {}, a)
                          .map((e1) => e1 * r_);
                  }
                  let _ = f
                    ? "center"
                    : u.get("text-justify").evaluate(o, {}, a);
                  const v = "point" === u.get("symbol-placement"),
                    w = v
                      ? u.get("text-max-width").evaluate(o, {}, a) * r_
                      : 1 / 0,
                    T = (o) => {
                      e1.allowVerticalPlacement &&
                        Ls(r) &&
                        (y.vertical = A_(
                          x,
                          t,
                          i,
                          n,
                          l,
                          w,
                          c,
                          p,
                          o,
                          h,
                          b,
                          w_.vertical,
                          !0,
                          g,
                          d,
                        ));
                    };
                  if (!f && m) {
                    const e1 = "auto" === _ ? m.map((e1) => pg(e1)) : [_];
                    let r = !1;
                    for (let o = 0; o < e1.length; o++) {
                      const s = e1[o];
                      if (!y.horizontal[s]) {
                        if (r) y.horizontal[s] = y.horizontal[0];
                        else {
                          const e1 = A_(
                            x,
                            t,
                            i,
                            n,
                            l,
                            w,
                            c,
                            "center",
                            s,
                            h,
                            b,
                            w_.horizontal,
                            !1,
                            g,
                            d,
                          );
                          e1 &&
                            ((y.horizontal[s] = e1),
                            (r = 1 === e1.positionedLines.length));
                        }
                      }
                    }
                    T("left");
                  } else {
                    if (
                      ("auto" === _ && (_ = pg(p)),
                      v ||
                        u.get("text-writing-mode").indexOf("horizontal") >= 0 ||
                        !Ls(r))
                    ) {
                      const e1 = A_(
                        x,
                        t,
                        i,
                        n,
                        l,
                        w,
                        c,
                        p,
                        _,
                        h,
                        b,
                        w_.horizontal,
                        !1,
                        g,
                        d,
                      );
                      e1 && (y.horizontal[_] = e1);
                    }
                    T(v ? "left" : _);
                  }
                }
                let w = !1;
                if (o.icon && o.icon.namePrimary) {
                  const t = r[o.icon.namePrimary];
                  t &&
                    ((v = O_(
                      n[o.icon.namePrimary],
                      o.icon.nameSecondary ? n[o.icon.nameSecondary] : void 0,
                      u.get("icon-offset").evaluate(o, {}, a),
                      u.get("icon-anchor").evaluate(o, {}, a),
                    )),
                    (w = t.sdf),
                    void 0 === e1.sdfIcons
                      ? (e1.sdfIcons = t.sdf)
                      : e1.sdfIcons !== t.sdf &&
                        W(
                          "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer",
                        ),
                    (t.pixelRatio !== e1.pixelRatio ||
                      0 !== u.get("icon-rotate").constantOr(1)) &&
                      (e1.iconsNeedLinear = !0));
                }
                const T = yg(y.horizontal) || y.vertical;
                e1.iconsInText || (e1.iconsInText = !!T && T.iconsInText),
                  (T || v) && fg(e1, o, y, v, r, p, g, 0, b, w, s, a, c, h, _);
              }
              o && e1.generateCollisionDebugBuffers(l, e1.collisionBoxArray);
            }
            function pg(e1) {
              switch (e1) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function fg(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f) {
              let m = o.textMaxSize.evaluate(t, {}, u);
              void 0 === m && (m = s);
              const _ = e1.layers[0].layout,
                g = _.get("icon-offset").evaluate(t, {}, u),
                y = yg(i.horizontal) || i.vertical,
                x = "globe" === d.name,
                v = r_,
                b = s / v,
                T = (e1.tilePixelRatio * m) / v,
                E =
                  ((P = e1.overscaling),
                  e1.zoom > 18 && P > 2 && (P >>= 1),
                  Math.max(sr / (512 * P), 1) * _.get("symbol-spacing")),
                M = _.get("text-padding") * e1.tilePixelRatio,
                A = _.get("icon-padding") * e1.tilePixelRatio,
                S = w(_.get("text-max-angle")),
                I =
                  "map" === _.get("text-rotation-alignment") &&
                  "point" !== _.get("symbol-placement"),
                C =
                  "map" === _.get("icon-rotation-alignment") &&
                  "point" !== _.get("symbol-placement"),
                z = _.get("symbol-placement"),
                D = E / 2;
              var P;
              const R = _.get("icon-text-fit").evaluate(t, {}, u),
                L = _.get("icon-text-fit-padding").evaluate(t, {}, u),
                k = "none" !== R;
              let O;
              !1 === e1.hasAnyIconTextFit && k && (e1.hasAnyIconTextFit = !0),
                r &&
                  k &&
                  (e1.allowVerticalPlacement &&
                    i.vertical &&
                    (O = B_(r, i.vertical, R, L, g, b)),
                  y && (r = B_(r, y, R, L, g, b)));
              const B = (s, a, m) => {
                if (a.x < 0 || a.x >= sr || a.y < 0 || a.y >= sr) return;
                let _ = null;
                if (x) {
                  const { x: e1, y: t, z: i } = d.projectTilePoint(a.x, a.y, m);
                  _ = {
                    anchor: new F_(e1, t, i, 0, void 0),
                    up: d.upVector(m, a.x, a.y),
                  };
                }
                !(function (
                  e1,
                  t,
                  i,
                  r,
                  n,
                  o,
                  s,
                  a,
                  l,
                  c,
                  h,
                  u,
                  d,
                  p,
                  f,
                  m,
                  _,
                  g,
                  y,
                  x,
                  v,
                  b,
                  w,
                  T,
                  E,
                  M,
                  A,
                ) {
                  const S = e1.addToLineVertexArray(t, r);
                  let I,
                    C,
                    z,
                    D,
                    P,
                    R,
                    L,
                    k = 0,
                    O = 0,
                    B = 0,
                    F = 0,
                    N = -1,
                    U = -1;
                  const V = {};
                  let j = wl("");
                  const G = i ? i.anchor : t,
                    q =
                      "none" !==
                      l.layout.get("icon-text-fit").evaluate(v, {}, E);
                  let Z = 0,
                    $ = 0;
                  if (
                    (void 0 ===
                    l._unevaluatedLayout.getValue("text-radial-offset")
                      ? ([Z, $] = l.layout
                          .get("text-offset")
                          .evaluate(v, {}, E)
                          .map((e1) => e1 * r_))
                      : ((Z =
                          l.layout
                            .get("text-radial-offset")
                            .evaluate(v, {}, E) * r_),
                        ($ = cg)),
                    e1.allowVerticalPlacement && n.vertical)
                  ) {
                    const e1 = n.vertical;
                    if (f) (R = vg(e1)), a && (L = vg(a));
                    else {
                      const i =
                        l.layout.get("text-rotate").evaluate(v, {}, E) + 90;
                      (z = xg(c, G, t, h, u, d, e1, p, i, m)),
                        a && (D = xg(c, G, t, h, u, d, a, g, i));
                    }
                  }
                  if (o) {
                    const r = l.layout.get("icon-rotate").evaluate(v, {}, E),
                      n = Q_(o, r, w, q),
                      s = a ? Q_(a, r, w, q) : void 0;
                    (C = xg(c, G, t, h, u, d, o, g, r)), (k = 4 * n.length);
                    const p = e1.iconSizeData;
                    let f = null;
                    "source" === p.kind
                      ? ((f = [
                          n_ * l.layout.get("icon-size").evaluate(v, {}, E),
                        ]),
                        f[0] > _g &&
                          W(
                            `${e1.layerIds[0]}: Value for "icon-size" is >= ${mg}. Reduce your "icon-size".`,
                          ))
                      : "composite" === p.kind &&
                        ((f = [
                          n_ * b.compositeIconSizes[0].evaluate(v, {}, E),
                          n_ * b.compositeIconSizes[1].evaluate(v, {}, E),
                        ]),
                        (f[0] > _g || f[1] > _g) &&
                          W(
                            `${e1.layerIds[0]}: Value for "icon-size" is >= ${mg}. Reduce your "icon-size".`,
                          )),
                      e1.addSymbols(
                        e1.icon,
                        n,
                        f,
                        x,
                        y,
                        v,
                        !1,
                        i,
                        t,
                        S.lineStartIndex,
                        S.lineLength,
                        -1,
                        T,
                        E,
                        M,
                        A,
                      ),
                      (N = e1.icon.placedSymbolArray.length - 1),
                      s &&
                        ((O = 4 * s.length),
                        e1.addSymbols(
                          e1.icon,
                          s,
                          f,
                          x,
                          y,
                          v,
                          w_.vertical,
                          i,
                          t,
                          S.lineStartIndex,
                          S.lineLength,
                          -1,
                          T,
                          E,
                          M,
                          A,
                        ),
                        (U = e1.icon.placedSymbolArray.length - 1));
                  }
                  for (const r in n.horizontal) {
                    const o = n.horizontal[r];
                    I ||
                      ((j = wl(o.text)),
                      f
                        ? (P = vg(o))
                        : (I = xg(
                            c,
                            G,
                            t,
                            h,
                            u,
                            d,
                            o,
                            p,
                            l.layout.get("text-rotate").evaluate(v, {}, E),
                            m,
                          )));
                    const a = 1 === o.positionedLines.length;
                    if (
                      ((B += gg(
                        e1,
                        i,
                        t,
                        o,
                        s,
                        l,
                        f,
                        v,
                        m,
                        S,
                        n.vertical ? w_.horizontal : w_.horizontalOnly,
                        a ? Object.keys(n.horizontal) : [r],
                        V,
                        N,
                        b,
                        T,
                        E,
                        M,
                      )),
                      a)
                    )
                      break;
                  }
                  n.vertical &&
                    (F += gg(
                      e1,
                      i,
                      t,
                      n.vertical,
                      s,
                      l,
                      f,
                      v,
                      m,
                      S,
                      w_.vertical,
                      ["vertical"],
                      V,
                      U,
                      b,
                      T,
                      E,
                      M,
                    ));
                  let H = -1;
                  const X = (e1, t) => (e1 ? Math.max(e1, t) : t);
                  (H = X(P, H)), (H = X(R, H)), (H = X(L, H));
                  const Y = H > -1 ? 1 : 0;
                  e1.glyphOffsetArray.length >= cy.MAX_GLYPHS &&
                    W(
                      "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907",
                    ),
                    void 0 !== v.sortKey &&
                      e1.addToSortKeyRanges(
                        e1.symbolInstances.length,
                        v.sortKey,
                      ),
                    e1.symbolInstances.emplaceBack(
                      t.x,
                      t.y,
                      G.x,
                      G.y,
                      G.z,
                      V.right >= 0 ? V.right : -1,
                      V.center >= 0 ? V.center : -1,
                      V.left >= 0 ? V.left : -1,
                      V.vertical >= 0 ? V.vertical : -1,
                      N,
                      U,
                      j,
                      void 0 !== I ? I : e1.collisionBoxArray.length,
                      void 0 !== I ? I + 1 : e1.collisionBoxArray.length,
                      void 0 !== z ? z : e1.collisionBoxArray.length,
                      void 0 !== z ? z + 1 : e1.collisionBoxArray.length,
                      void 0 !== C ? C : e1.collisionBoxArray.length,
                      void 0 !== C ? C + 1 : e1.collisionBoxArray.length,
                      D || e1.collisionBoxArray.length,
                      D ? D + 1 : e1.collisionBoxArray.length,
                      h,
                      B,
                      F,
                      k,
                      O,
                      Y,
                      0,
                      Z,
                      $,
                      H,
                      0,
                      q ? 1 : 0,
                    );
                })(
                  e1,
                  a,
                  _,
                  s,
                  i,
                  r,
                  n,
                  O,
                  e1.layers[0],
                  e1.collisionBoxArray,
                  t.index,
                  t.sourceLayerIndex,
                  e1.index,
                  M,
                  I,
                  l,
                  0,
                  A,
                  C,
                  g,
                  t,
                  o,
                  c,
                  h,
                  u,
                  p,
                  f,
                );
              };
              if ("line" === z)
                for (const n of $_(t.geometry, 0, 0, sr, sr)) {
                  const t = q_(
                    n,
                    E,
                    S,
                    i.vertical || y,
                    r,
                    v,
                    T,
                    e1.overscaling,
                    sr,
                  );
                  for (const i of t) (y && bg(e1, y.text, D, i)) || B(n, i, u);
                }
              else if ("line-center" === z) {
                for (const e1 of t.geometry)
                  if (e1.length > 1) {
                    const t = G_(e1, S, i.vertical || y, r, v, T);
                    t && B(e1, t, u);
                  }
              } else if ("Polygon" === t.type)
                for (const e1 of zf(t.geometry, 0)) {
                  const t = og(e1, 16);
                  B(e1[0], new F_(t.x, t.y, 0, 0, void 0), u);
                }
              else if ("LineString" === t.type)
                for (const e1 of t.geometry)
                  B(e1, new F_(e1[0].x, e1[0].y, 0, 0, void 0), u);
              else if ("Point" === t.type)
                for (const e1 of t.geometry)
                  for (const t of e1) B([t], new F_(t.x, t.y, 0, 0, void 0), u);
            }
            const mg = 255,
              _g = mg * n_;
            function gg(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m, _, g) {
              const x = (function (e1, t, i, r, n, o, s, a) {
                  const l = [];
                  if (0 === t.positionedLines.length) return l;
                  const c =
                      (r.layout.get("text-rotate").evaluate(o, {}) * Math.PI) /
                      180,
                    h = (function (e1) {
                      const t = e1[0],
                        i = e1[1],
                        r = t * i;
                      return r > 0
                        ? [t, -i]
                        : r < 0
                        ? [-t, i]
                        : 0 === t
                        ? [i, t]
                        : [i, -t];
                    })(i);
                  let u = Math.abs(t.top - t.bottom);
                  for (const e1 of t.positionedLines) u -= e1.lineOffset;
                  const d = t.positionedLines.length,
                    p = u / d;
                  let f = t.top - i[1];
                  for (let e1 = 0; e1 < d; ++e1) {
                    const r = t.positionedLines[e1];
                    f = ng(t, p, f, e1);
                    for (const e1 of r.positionedGlyphs) {
                      if (!e1.rect) continue;
                      const r = e1.rect || {};
                      let o = g_ + 1,
                        u = !0,
                        d = 1,
                        p = 0;
                      if (e1.imageName) {
                        const t = s[e1.imageName];
                        if (!t) continue;
                        if (t.sdf) {
                          W(
                            "SDF images are not supported in formatted text and will be ignored.",
                          );
                          continue;
                        }
                        (u = !1), (d = t.pixelRatio), (o = x_ / d);
                      }
                      const m = (n || a) && e1.vertical,
                        _ = (e1.metrics.advance * e1.scale) / 2,
                        g = e1.metrics,
                        x = e1.rect;
                      if (null === x) continue;
                      a &&
                        t.verticalizable &&
                        (p = e1.imageName
                          ? _ - (e1.metrics.width * e1.scale) / 2
                          : 0);
                      const v = n ? [e1.x + _, e1.y] : [0, 0];
                      let b = [0, 0],
                        w = [0, 0],
                        T = !1;
                      n ||
                        (m
                          ? ((w = [e1.x + _ + h[0], e1.y + h[1] - p]), (T = !0))
                          : (b = [e1.x + _ + i[0], e1.y + i[1] - p]));
                      const E =
                          (x.w * e1.scale) / (d * (e1.localGlyph ? Y_ : 1)),
                        M = (x.h * e1.scale) / (d * (e1.localGlyph ? Y_ : 1));
                      let A, S, I, C;
                      if (m) {
                        const t = e1.y - f,
                          i = new y(-_, _ - t),
                          r = -Math.PI / 2,
                          n = new y(...w);
                        (A = new y(-_ + b[0], b[1])),
                          A._rotateAround(r, i)._add(n),
                          (A.x += -t + _),
                          (A.y -= (g.left - o) * e1.scale);
                        const s = e1.imageName
                            ? g.advance * e1.scale
                            : r_ * e1.scale,
                          a = String.fromCodePoint(e1.glyph);
                        u_(a)
                          ? (A.x += (1 - o) * e1.scale)
                          : d_(a)
                          ? (A.x +=
                              s - g.height * e1.scale + (-o - 1) * e1.scale)
                          : (A.x +=
                              e1.imageName ||
                              (g.width + 2 * o === x.w &&
                                g.height + 2 * o === x.h)
                                ? (s - M) / 2
                                : (s - (g.height + 2 * o) * e1.scale) / 2),
                          (S = new y(A.x, A.y - E)),
                          (I = new y(A.x + M, A.y)),
                          (C = new y(A.x + M, A.y - E));
                      } else {
                        const t = (g.left - o) * e1.scale - _ + b[0],
                          i = (-g.top - o) * e1.scale + b[1],
                          r = t + E,
                          n = i + M;
                        (A = new y(t, i)),
                          (S = new y(r, i)),
                          (I = new y(t, n)),
                          (C = new y(r, n));
                      }
                      if (c) {
                        let e1;
                        (e1 = n
                          ? new y(0, 0)
                          : T
                          ? new y(h[0], h[1])
                          : new y(i[0], i[1])),
                          A._rotateAround(c, e1),
                          S._rotateAround(c, e1),
                          I._rotateAround(c, e1),
                          C._rotateAround(c, e1);
                      }
                      const z = new y(0, 0),
                        D = new y(0, 0);
                      l.push({
                        tl: A,
                        tr: S,
                        bl: I,
                        br: C,
                        texPrimary: r,
                        texSecondary: void 0,
                        writingMode: t.writingMode,
                        glyphOffset: v,
                        sectionIndex: e1.sectionIndex,
                        isSDF: u,
                        pixelOffsetTL: z,
                        pixelOffsetBR: D,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  }
                  return l;
                })(0, r, l, o, s, a, n, e1.allowVerticalPlacement),
                v = e1.textSizeData;
              let b = null;
              "source" === v.kind
                ? ((b = [n_ * o.layout.get("text-size").evaluate(a, {}, _)]),
                  b[0] > _g &&
                    W(
                      `${e1.layerIds[0]}: Value for "text-size" is >= ${mg}. Reduce your "text-size".`,
                    ))
                : "composite" === v.kind &&
                  ((b = [
                    n_ * f.compositeTextSizes[0].evaluate(a, {}, _),
                    n_ * f.compositeTextSizes[1].evaluate(a, {}, _),
                  ]),
                  (b[0] > _g || b[1] > _g) &&
                    W(
                      `${e1.layerIds[0]}: Value for "text-size" is >= ${mg}. Reduce your "text-size".`,
                    )),
                e1.addSymbols(
                  e1.text,
                  x,
                  b,
                  l,
                  s,
                  a,
                  h,
                  t,
                  i,
                  c.lineStartIndex,
                  c.lineLength,
                  p,
                  m,
                  _,
                  g,
                  !1,
                );
              for (const t of u) d[t] = e1.text.placedSymbolArray.length - 1;
              return 4 * x.length;
            }
            function yg(e1) {
              for (const t in e1) return e1[t];
              return null;
            }
            function xg(e1, t, i, r, n, o, s, a, l, c) {
              let h = s.top,
                u = s.bottom,
                d = s.left,
                p = s.right;
              const f = s.collisionPadding;
              if (
                (f && ((d -= f[0]), (h -= f[1]), (p += f[2]), (u += f[3])), l)
              ) {
                const e1 = new y(d, h),
                  t = new y(p, h),
                  i = new y(d, u),
                  r = new y(p, u),
                  n = w(l);
                let o = new y(0, 0);
                c && (o = new y(c[0], c[1])),
                  e1._rotateAround(n, o),
                  t._rotateAround(n, o),
                  i._rotateAround(n, o),
                  r._rotateAround(n, o),
                  (d = Math.min(e1.x, t.x, i.x, r.x)),
                  (p = Math.max(e1.x, t.x, i.x, r.x)),
                  (h = Math.min(e1.y, t.y, i.y, r.y)),
                  (u = Math.max(e1.y, t.y, i.y, r.y));
              }
              return (
                e1.emplaceBack(t.x, t.y, t.z, i.x, i.y, d, h, p, u, a, r, n, o),
                e1.length - 1
              );
            }
            function vg(e1) {
              e1.collisionPadding &&
                ((e1.top -= e1.collisionPadding[1]),
                (e1.bottom += e1.collisionPadding[3]));
              const t = e1.bottom - e1.top;
              return t > 0 ? Math.max(10, t) : null;
            }
            function bg(e1, t, i, r) {
              const n = e1.compareText;
              if (t in n) {
                const e1 = n[t];
                for (let t = e1.length - 1; t >= 0; t--)
                  if (r.dist(e1[t]) < i) return !0;
              } else n[t] = [];
              return n[t].push(r), !1;
            }
            function wg(e1, t) {
              const i = e1.fovAboveCenter,
                r = e1.elevation
                  ? e1.elevation.getMinElevationBelowMSL() * t
                  : 0,
                n =
                  (e1._camera.position[2] * e1.worldSize - r) /
                  Math.cos(e1._pitch),
                o =
                  (Math.sin(i) * n) /
                  Math.sin(Math.max(Math.PI / 2 - e1._pitch - i, 0.01)),
                s = Math.sin(e1._pitch) * o + n;
              return Math.min(1.01 * s, n * (1 / e1._horizonShift));
            }
            function Tg(e1, t) {
              if (!t.isReprojectedInTileSpace)
                return {
                  scale: 1 << e1.z,
                  x: e1.x,
                  y: e1.y,
                  x2: e1.x + 1,
                  y2: e1.y + 1,
                  projection: t,
                };
              const i = Math.pow(2, -e1.z),
                r = e1.x * i,
                n = (e1.x + 1) * i,
                o = e1.y * i,
                s = (e1.y + 1) * i,
                a = $d(r),
                l = $d(n),
                c = Hd(o),
                h = Hd(s),
                u = t.project(a, c),
                d = t.project(l, c),
                p = t.project(l, h),
                f = t.project(a, h);
              let m = Math.min(u.x, d.x, p.x, f.x),
                _ = Math.min(u.y, d.y, p.y, f.y),
                g = Math.max(u.x, d.x, p.x, f.x),
                y = Math.max(u.y, d.y, p.y, f.y);
              const x = i / 16;
              function v(e1, i, r, n, o, s) {
                const a = (r + o) / 2,
                  l = (n + s) / 2,
                  c = t.project($d(a), Hd(l)),
                  h = Math.max(0, m - c.x, _ - c.y, c.x - g, c.y - y);
                (m = Math.min(m, c.x)),
                  (g = Math.max(g, c.x)),
                  (_ = Math.min(_, c.y)),
                  (y = Math.max(y, c.y)),
                  h > x && (v(e1, c, r, n, a, l), v(c, i, a, l, o, s));
              }
              v(u, d, r, o, n, o),
                v(d, p, n, o, n, s),
                v(p, f, n, s, r, s),
                v(f, u, r, s, r, o),
                (m -= x),
                (_ -= x),
                (g += x),
                (y += x);
              const b = 1 / Math.max(g - m, y - _);
              return {
                scale: b,
                x: m * b,
                y: _ * b,
                x2: g * b,
                y2: y * b,
                projection: t,
              };
            }
            function Eg(e1, t, i, r, n, o, s, a, l) {
              if ("globe" === l.name) return ud(e1, t, new ku(i, r, n), !1);
              const c = Tg(
                {
                  z: i,
                  x: r,
                  y: n,
                },
                l,
              );
              return new Hu(
                [(o + c.x / c.scale) * t, t * (c.y / c.scale), s],
                [(o + c.x2 / c.scale) * t, t * (c.y2 / c.scale), a],
              );
            }
            function Mg(e1, { x: t, y: i }, r = 0) {
              return new y(
                ((t - r) * e1.scale - e1.x) * sr,
                (i * e1.scale - e1.y) * sr,
              );
            }
            function Ag(e1, t, i = 0) {
              return Mu.fromValues(
                ((t.x - i) * e1.scale - e1.x) * sr,
                (t.y * e1.scale - e1.y) * sr,
                Wd(t.z, t.y),
              );
            }
            const Sg = xu.identity(new Float32Array(16));
            class Ig {
              constructor(e1) {
                (this.spec = e1),
                  (this.name = e1.name),
                  (this.wrap = !1),
                  (this.requiresDraping = !1),
                  (this.supportsWorldCopies = !1),
                  (this.supportsTerrain = !1),
                  (this.supportsFog = !1),
                  (this.supportsFreeCamera = !1),
                  (this.zAxisUnit = "meters"),
                  (this.isReprojectedInTileSpace = !0),
                  (this.unsupportedLayers = ["custom"]),
                  (this.center = [0, 0]),
                  (this.range = [3.5, 7]);
              }
              project(e1, t) {
                return {
                  x: 0,
                  y: 0,
                  z: 0,
                };
              }
              unproject(e1, t) {
                return new Nd(0, 0);
              }
              projectTilePoint(e1, t, i) {
                return {
                  x: e1,
                  y: t,
                  z: 0,
                };
              }
              locationPoint(e1, t, i = !0) {
                return e1._coordinatePoint(e1.locationCoordinate(t), i);
              }
              pixelsPerMeter(e1, t) {
                return Zd(1, e1) * t;
              }
              pixelSpaceConversion(e1, t, i) {
                return 1;
              }
              farthestPixelDistance(e1) {
                return wg(e1, e1.pixelsPerMeter);
              }
              pointCoordinate(e1, t, i, r) {
                const n = e1.horizonLineFromTop(!1),
                  o = new y(t, Math.max(n, i));
                return e1.rayIntersectionCoordinate(
                  e1.pointRayIntersection(o, r),
                );
              }
              pointCoordinate3D(e1, t, i) {
                const r = new y(t, i);
                if (e1.elevation) return e1.elevation.pointCoordinate(r);
                {
                  const t = this.pointCoordinate(e1, r.x, r.y, 0);
                  return [t.x, t.y, t.z];
                }
              }
              isPointAboveHorizon(e1, t) {
                if (e1.elevation) return !this.pointCoordinate3D(e1, t.x, t.y);
                const i = e1.horizonLineFromTop();
                return t.y < i;
              }
              createInversionMatrix(e1, t) {
                return Sg;
              }
              createTileMatrix(e1, t, i) {
                let r, n, o;
                const s = i.canonical,
                  a = xu.identity(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                  const l = Tg(s, this);
                  (r = 1),
                    (n = l.x + i.wrap * l.scale),
                    (o = l.y),
                    xu.scale(a, a, [
                      r / l.scale,
                      r / l.scale,
                      e1.pixelsPerMeter / t,
                    ]);
                } else
                  (r = t / e1.zoomScale(s.z)),
                    (n = (s.x + Math.pow(2, s.z) * i.wrap) * r),
                    (o = s.y * r);
                return (
                  xu.translate(a, a, [n, o, 0]),
                  xu.scale(a, a, [r / sr, r / sr, 1]),
                  a
                );
              }
              upVector(e1, t, i) {
                return [0, 0, 1];
              }
              upVectorScale(e1, t, i) {
                return {
                  metersToTile: 1,
                };
              }
            }
            class Cg extends Ig {
              constructor(e1) {
                super(e1),
                  (this.range = [4, 7]),
                  (this.center = e1.center || [-96, 37.5]);
                const [t, i] = (this.parallels = e1.parallels || [29.5, 45.5]),
                  r = Math.sin(w(t));
                (this.n = (r + Math.sin(w(i))) / 2),
                  (this.c = 1 + r * (2 * this.n - r)),
                  (this.r0 = Math.sqrt(this.c) / this.n);
              }
              project(e1, t) {
                const { n: i, c: r, r0: n } = this,
                  o = w(e1 - this.center[0]),
                  s = w(t),
                  a = Math.sqrt(r - 2 * i * Math.sin(s)) / i;
                return {
                  x: a * Math.sin(o * i),
                  y: a * Math.cos(o * i) - n,
                  z: 0,
                };
              }
              unproject(e1, t) {
                const { n: i, c: r, r0: n } = this,
                  o = n + t;
                let s = Math.atan2(e1, Math.abs(o)) * Math.sign(o);
                o * i < 0 && (s -= Math.PI * Math.sign(e1) * Math.sign(o));
                const a = w(this.center[0]) * i;
                s = P(s, -Math.PI - a, Math.PI - a);
                const l = z(T(s / i) + this.center[0], -180, 180),
                  c = Math.asin(
                    z((r - (e1 * e1 + o * o) * i * i) / (2 * i), -1, 1),
                  ),
                  h = z(T(c), -Xd, Xd);
                return new Nd(l, h);
              }
            }
            const zg = 1.340264,
              Dg = -0.081106,
              Pg = 893e-6,
              Rg = 0.003796,
              Lg = Math.sqrt(3) / 2;
            class kg extends Ig {
              project(e1, t) {
                (t = (t / 180) * Math.PI), (e1 = (e1 / 180) * Math.PI);
                const i = Math.asin(Lg * Math.sin(t)),
                  r = i * i,
                  n = r * r * r;
                return {
                  x:
                    0.5 *
                    ((e1 * Math.cos(i)) /
                      (Lg * (zg + 3 * Dg * r + n * (7 * Pg + 9 * Rg * r))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((i * (zg + Dg * r + n * (Pg + Rg * r))) / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(e1, t) {
                e1 = (2 * e1 - 0.5) * Math.PI;
                let i = (t = (2 * (1 - t) - 1) * Math.PI),
                  r = i * i,
                  n = r * r * r;
                for (
                  let e1, o, s, a = 0;
                  a < 12 &&
                  ((o = i * (zg + Dg * r + n * (Pg + Rg * r)) - t),
                  (s = zg + 3 * Dg * r + n * (7 * Pg + 9 * Rg * r)),
                  (e1 = o / s),
                  (i = z(i - e1, -Math.PI / 3, Math.PI / 3)),
                  (r = i * i),
                  (n = r * r * r),
                  !(Math.abs(e1) < 1e-12));
                  ++a
                );
                const o =
                    (Lg * e1 * (zg + 3 * Dg * r + n * (7 * Pg + 9 * Rg * r))) /
                    Math.cos(i),
                  s = Math.asin(Math.sin(i) / Lg),
                  a = z((180 * o) / Math.PI, -180, 180),
                  l = z((180 * s) / Math.PI, -Xd, Xd);
                return new Nd(a, l);
              }
            }
            class Og extends Ig {
              constructor(e1) {
                super(e1), (this.wrap = !0), (this.supportsWorldCopies = !0);
              }
              project(e1, t) {
                return {
                  x: 0.5 + e1 / 360,
                  y: 0.5 - t / 360,
                  z: 0,
                };
              }
              unproject(e1, t) {
                const i = 360 * (e1 - 0.5),
                  r = z(360 * (0.5 - t), -Xd, Xd);
                return new Nd(i, r);
              }
            }
            const Bg = Math.PI / 2;
            function Fg(e1) {
              return Math.tan((Bg + e1) / 2);
            }
            class Ng extends Ig {
              constructor(e1) {
                super(e1), (this.center = e1.center || [0, 30]);
                const [t, i] = (this.parallels = e1.parallels || [30, 30]);
                let r = w(t),
                  n = w(i);
                (this.southernCenter = r + n < 0),
                  this.southernCenter && ((r = -r), (n = -n));
                const o = Math.cos(r),
                  s = Fg(r);
                (this.n =
                  r === n
                    ? Math.sin(r)
                    : Math.log(o / Math.cos(n)) / Math.log(Fg(n) / s)),
                  (this.f = (o * Math.pow(Fg(r), this.n)) / this.n);
              }
              project(e1, t) {
                (t = w(t)),
                  this.southernCenter && (t = -t),
                  (e1 = w(e1 - this.center[0]));
                const i = 1e-6,
                  { n: r, f: n } = this;
                n > 0
                  ? t < -Bg + i && (t = -Bg + i)
                  : t > Bg - i && (t = Bg - i);
                const o = n / Math.pow(Fg(t), r);
                let s = o * Math.sin(r * e1),
                  a = n - o * Math.cos(r * e1);
                return (
                  (s = 0.5 * (s / Math.PI + 0.5)),
                  (a = 0.5 * (a / Math.PI + 0.5)),
                  {
                    x: s,
                    y: this.southernCenter ? a : 1 - a,
                    z: 0,
                  }
                );
              }
              unproject(e1, t) {
                (e1 = (2 * e1 - 0.5) * Math.PI),
                  this.southernCenter && (t = 1 - t),
                  (t = (2 * (1 - t) - 0.5) * Math.PI);
                const { n: i, f: r } = this,
                  n = r - t,
                  o = Math.sign(n),
                  s = Math.sign(i) * Math.sqrt(e1 * e1 + n * n);
                let a = Math.atan2(e1, Math.abs(n)) * o;
                n * i < 0 && (a -= Math.PI * Math.sign(e1) * o);
                const l = z(T(a / i) + this.center[0], -180, 180),
                  c = z(T(2 * Math.atan(Math.pow(r / s, 1 / i)) - Bg), -Xd, Xd);
                return new Nd(l, this.southernCenter ? -c : c);
              }
            }
            class Ug extends Ig {
              constructor(e1) {
                super(e1),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0),
                  (this.supportsTerrain = !0),
                  (this.supportsFog = !0),
                  (this.supportsFreeCamera = !0),
                  (this.isReprojectedInTileSpace = !1),
                  (this.unsupportedLayers = []),
                  (this.range = null);
              }
              project(e1, t) {
                return {
                  x: Gd(e1),
                  y: qd(t),
                  z: 0,
                };
              }
              unproject(e1, t) {
                const i = $d(e1),
                  r = Hd(t);
                return new Nd(i, r);
              }
            }
            const Vg = w(Xd);
            class jg extends Ig {
              project(e1, t) {
                const i = (t = w(t)) * t,
                  r = i * i;
                return {
                  x:
                    0.5 *
                    (((e1 = w(e1)) *
                      (0.8707 -
                        0.131979 * i +
                        r * (r * (0.003971 * i - 0.001529 * r) - 0.013791))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((t *
                        (1.007226 +
                          i *
                            (0.015085 +
                              r * (0.028874 * i - 0.044475 - 0.005916 * r)))) /
                        Math.PI +
                        1),
                  z: 0,
                };
              }
              unproject(e1, t) {
                e1 = (2 * e1 - 0.5) * Math.PI;
                let i = (t = (2 * (1 - t) - 1) * Math.PI),
                  r = 25,
                  n = 0,
                  o = i * i;
                do {
                  o = i * i;
                  const e1 = o * o;
                  (n =
                    (i *
                      (1.007226 +
                        o *
                          (0.015085 +
                            e1 * (0.028874 * o - 0.044475 - 0.005916 * e1))) -
                      t) /
                    (1.007226 +
                      o *
                        (0.045255 +
                          e1 *
                            (0.259866 * o - 0.311325 - 0.005916 * 11 * e1)))),
                    (i = z(i - n, -Vg, Vg));
                } while (Math.abs(n) > 1e-6 && --r > 0);
                o = i * i;
                const s = z(
                    T(
                      e1 /
                        (0.8707 +
                          o *
                            (o *
                              (o * o * o * (0.003971 - 0.001529 * o) -
                                0.013791) -
                              0.131979)),
                    ),
                    -180,
                    180,
                  ),
                  a = T(i);
                return new Nd(s, a);
              }
            }
            const Gg = w(Xd);
            class qg extends Ig {
              project(e1, t) {
                (t = w(t)), (e1 = w(e1));
                const i = Math.cos(t),
                  r = 2 / Math.PI,
                  n = Math.acos(i * Math.cos(e1 / 2)),
                  o = Math.sin(n) / n,
                  s = 0.5 * (e1 * r + (2 * i * Math.sin(e1 / 2)) / o) || 0,
                  a = 0.5 * (t + Math.sin(t) / o) || 0;
                return {
                  x: 0.5 * (s / Math.PI + 0.5),
                  y: 1 - 0.5 * (a / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(e1, t) {
                let i = (e1 = (2 * e1 - 0.5) * Math.PI),
                  r = (t = (2 * (1 - t) - 1) * Math.PI),
                  n = 25;
                const o = 1e-6;
                let s = 0,
                  a = 0;
                do {
                  const n = Math.cos(r),
                    o = Math.sin(r),
                    l = 2 * o * n,
                    c = o * o,
                    h = n * n,
                    u = Math.cos(i / 2),
                    d = Math.sin(i / 2),
                    p = 2 * u * d,
                    f = d * d,
                    m = 1 - h * u * u,
                    _ = m ? 1 / m : 0,
                    g = m ? Math.acos(n * u) * Math.sqrt(1 / m) : 0,
                    y = 0.5 * (2 * g * n * d + (2 * i) / Math.PI) - e1,
                    x = 0.5 * (g * o + r) - t,
                    v = 0.5 * _ * (h * f + g * n * u * c) + 1 / Math.PI,
                    b = _ * ((p * l) / 4 - g * o * d),
                    w = 0.125 * _ * (l * d - g * o * h * p),
                    T = 0.5 * _ * (c * u + g * f * n) + 0.5,
                    E = b * w - T * v;
                  (s = (x * b - y * T) / E),
                    (a = (y * w - x * v) / E),
                    (i = z(i - s, -Math.PI, Math.PI)),
                    (r = z(r - a, -Gg, Gg));
                } while ((Math.abs(s) > o || Math.abs(a) > o) && --n > 0);
                return new Nd(T(i), T(r));
              }
            }
            class Zg extends Ig {
              constructor(e1) {
                super(e1),
                  (this.center = e1.center || [0, 0]),
                  (this.parallels = e1.parallels || [0, 0]),
                  (this.cosPhi = Math.max(
                    0.01,
                    Math.cos(w(this.parallels[0])),
                  )),
                  (this.scale =
                    1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi))),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0);
              }
              project(e1, t) {
                const { scale: i, cosPhi: r } = this;
                return {
                  x: w(e1) * r * i + 0.5,
                  y: (-Math.sin(w(t)) / r) * i + 0.5,
                  z: 0,
                };
              }
              unproject(e1, t) {
                const { scale: i, cosPhi: r } = this,
                  n = -(t - 0.5) / i,
                  o = z(T((e1 - 0.5) / i) / r, -180, 180),
                  s = Math.asin(z(n * r, -1, 1)),
                  a = z(T(s), -Xd, Xd);
                return new Nd(o, a);
              }
            }
            class $g extends Ug {
              constructor(e1) {
                super(e1),
                  (this.requiresDraping = !0),
                  (this.supportsWorldCopies = !1),
                  (this.supportsFog = !0),
                  (this.zAxisUnit = "pixels"),
                  (this.unsupportedLayers = ["debug"]),
                  (this.range = [3, 5]);
              }
              projectTilePoint(e1, t, i) {
                const r = _d(e1, t, i),
                  n = xd(ad(i));
                return (
                  Mu.transformMat4(r, r, n),
                  {
                    x: r[0],
                    y: r[1],
                    z: r[2],
                  }
                );
              }
              locationPoint(e1, t) {
                const i = md(t.lat, t.lng),
                  r = Mu.normalize([], i),
                  n = e1.elevation
                    ? e1.elevation.getAtPointOrZero(
                        e1.locationCoordinate(t),
                        e1._centerAltitude,
                      )
                    : e1._centerAltitude,
                  o = Zd(1, 0) * sr * n;
                Mu.scaleAndAdd(i, i, r, o);
                const s = xu.identity(new Float64Array(16));
                return (
                  xu.multiply(s, e1.pixelMatrix, e1.globeMatrix),
                  Mu.transformMat4(i, i, s),
                  new y(i[0], i[1])
                );
              }
              pixelsPerMeter(e1, t) {
                return Zd(1, 0) * t;
              }
              pixelSpaceConversion(e1, t, i) {
                const r = Zd(1, e1) * t,
                  n = Wr(Zd(1, 45) * t, r, i);
                return this.pixelsPerMeter(e1, t) / n;
              }
              createTileMatrix(e1, t, i) {
                const r = vd(ad(i.canonical));
                return xu.multiply(new Float64Array(16), e1.globeMatrix, r);
              }
              createInversionMatrix(e1, t) {
                const { center: i } = e1,
                  r = xd(ad(t));
                return (
                  xu.rotateY(r, r, w(i.lng)),
                  xu.rotateX(r, r, w(i.lat)),
                  xu.scale(r, r, [
                    e1._pixelsPerMercatorPixel,
                    e1._pixelsPerMercatorPixel,
                    1,
                  ]),
                  Float32Array.from(r)
                );
              }
              pointCoordinate(e1, t, i, r) {
                return nd(e1, t, i, !0) || new ep(0, 0);
              }
              pointCoordinate3D(e1, t, i) {
                const r = this.pointCoordinate(e1, t, i, 0);
                return [r.x, r.y, r.z];
              }
              isPointAboveHorizon(e1, t) {
                return !nd(e1, t.x, t.y, !1);
              }
              farthestPixelDistance(e1) {
                const t = (function (e1, t) {
                    const i = e1.cameraToCenterDistance,
                      r = e1._centerAltitude * t,
                      n = e1._camera,
                      o = e1._camera.forward(),
                      s = Mu.add([], Mu.scale([], o, -i), [0, 0, r]),
                      a = e1.worldSize / (2 * Math.PI),
                      l = [0, 0, -a],
                      c = e1.width / e1.height,
                      h = Math.tan(e1.fovAboveCenter),
                      u = Mu.scale([], n.up(), h),
                      d = Mu.scale([], n.right(), h * c),
                      p = Mu.normalize([], Mu.add([], Mu.add([], o, u), d)),
                      f = [];
                    let m;
                    if (new Uu(s, p).closestPointOnSphere(l, a, f)) {
                      const t = Mu.add([], f, l),
                        i = Mu.sub([], t, s);
                      m = Math.cos(e1.fovAboveCenter) * Mu.length(i);
                    } else {
                      const e1 = Mu.sub([], s, l),
                        t = Mu.sub([], l, s);
                      Mu.normalize(t, t);
                      const i = Mu.length(e1) - a;
                      m = Math.sqrt(i * (i + 2 * a));
                      const r =
                        Math.acos(m / (a + i)) - Math.acos(Mu.dot(o, t));
                      m *= Math.cos(r);
                    }
                    return 1.01 * m;
                  })(e1, this.pixelsPerMeter(e1.center.lat, e1.worldSize)),
                  i = Ed(e1.zoom);
                if (i > 0) {
                  const r = wg(e1, Zd(1, e1.center.lat) * e1.worldSize),
                    n = e1.worldSize / (2 * Math.PI),
                    o =
                      (Math.max(e1.width, e1.height) / e1.worldSize) * Math.PI;
                  return Wr(t, r + n * (1 - Math.cos(o)), Math.pow(i, 10));
                }
                return t;
              }
              upVector(e1, t, i) {
                return _d(t, i, e1, 1);
              }
              upVectorScale(e1) {
                return {
                  metersToTile: rd(gd(ad(e1))),
                };
              }
            }
            function Hg(e1) {
              const t = e1.parallels,
                i = !!t && Math.abs(t[0] + t[1]) < 0.01;
              switch (e1.name) {
                case "mercator":
                  return new Ug(e1);
                case "equirectangular":
                  return new Og(e1);
                case "naturalEarth":
                  return new jg(e1);
                case "equalEarth":
                  return new kg(e1);
                case "winkelTripel":
                  return new qg(e1);
                case "albers":
                  return i ? new Zg(e1) : new Cg(e1);
                case "lambertConformalConic":
                  return i ? new Zg(e1) : new Ng(e1);
                case "globe":
                  return new $g(e1);
              }
              throw new Error(`Invalid projection name: ${e1.name}`);
            }
            const Wg = new da({
              "symbol-placement": new ca(Ct.layout_symbol["symbol-placement"]),
              "symbol-spacing": new ca(Ct.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new ca(
                Ct.layout_symbol["symbol-avoid-edges"],
              ),
              "symbol-sort-key": new ha(Ct.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new ca(Ct.layout_symbol["symbol-z-order"]),
              "symbol-z-elevate": new ca(Ct.layout_symbol["symbol-z-elevate"]),
              "icon-allow-overlap": new ca(
                Ct.layout_symbol["icon-allow-overlap"],
              ),
              "icon-ignore-placement": new ca(
                Ct.layout_symbol["icon-ignore-placement"],
              ),
              "icon-optional": new ca(Ct.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new ca(
                Ct.layout_symbol["icon-rotation-alignment"],
              ),
              "icon-size": new ha(Ct.layout_symbol["icon-size"]),
              "icon-text-fit": new ha(Ct.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new ha(
                Ct.layout_symbol["icon-text-fit-padding"],
              ),
              "icon-image": new ha(Ct.layout_symbol["icon-image"]),
              "icon-rotate": new ha(Ct.layout_symbol["icon-rotate"]),
              "icon-padding": new ca(Ct.layout_symbol["icon-padding"]),
              "icon-keep-upright": new ca(
                Ct.layout_symbol["icon-keep-upright"],
              ),
              "icon-offset": new ha(Ct.layout_symbol["icon-offset"]),
              "icon-anchor": new ha(Ct.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new ca(
                Ct.layout_symbol["icon-pitch-alignment"],
              ),
              "text-pitch-alignment": new ca(
                Ct.layout_symbol["text-pitch-alignment"],
              ),
              "text-rotation-alignment": new ca(
                Ct.layout_symbol["text-rotation-alignment"],
              ),
              "text-field": new ha(Ct.layout_symbol["text-field"]),
              "text-font": new ha(Ct.layout_symbol["text-font"]),
              "text-size": new ha(Ct.layout_symbol["text-size"]),
              "text-max-width": new ha(Ct.layout_symbol["text-max-width"]),
              "text-line-height": new ha(Ct.layout_symbol["text-line-height"]),
              "text-letter-spacing": new ha(
                Ct.layout_symbol["text-letter-spacing"],
              ),
              "text-justify": new ha(Ct.layout_symbol["text-justify"]),
              "text-radial-offset": new ha(
                Ct.layout_symbol["text-radial-offset"],
              ),
              "text-variable-anchor": new ca(
                Ct.layout_symbol["text-variable-anchor"],
              ),
              "text-anchor": new ha(Ct.layout_symbol["text-anchor"]),
              "text-max-angle": new ca(Ct.layout_symbol["text-max-angle"]),
              "text-writing-mode": new ca(
                Ct.layout_symbol["text-writing-mode"],
              ),
              "text-rotate": new ha(Ct.layout_symbol["text-rotate"]),
              "text-padding": new ca(Ct.layout_symbol["text-padding"]),
              "text-keep-upright": new ca(
                Ct.layout_symbol["text-keep-upright"],
              ),
              "text-transform": new ha(Ct.layout_symbol["text-transform"]),
              "text-offset": new ha(Ct.layout_symbol["text-offset"]),
              "text-allow-overlap": new ca(
                Ct.layout_symbol["text-allow-overlap"],
              ),
              "text-ignore-placement": new ca(
                Ct.layout_symbol["text-ignore-placement"],
              ),
              "text-optional": new ca(Ct.layout_symbol["text-optional"]),
              visibility: new ca(Ct.layout_symbol.visibility),
            });
            var Xg = {
              paint: new da({
                "icon-opacity": new ha(Ct.paint_symbol["icon-opacity"]),
                "icon-emissive-strength": new ha(
                  Ct.paint_symbol["icon-emissive-strength"],
                ),
                "text-emissive-strength": new ha(
                  Ct.paint_symbol["text-emissive-strength"],
                ),
                "icon-color": new ha(Ct.paint_symbol["icon-color"]),
                "icon-halo-color": new ha(Ct.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new ha(Ct.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new ha(Ct.paint_symbol["icon-halo-blur"]),
                "icon-translate": new ca(Ct.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new ca(
                  Ct.paint_symbol["icon-translate-anchor"],
                ),
                "icon-image-cross-fade": new ha(
                  Ct.paint_symbol["icon-image-cross-fade"],
                ),
                "text-opacity": new ha(Ct.paint_symbol["text-opacity"]),
                "text-color": new ha(Ct.paint_symbol["text-color"], {
                  runtimeType: Gt,
                  getOverride: (e1) => e1.textColor,
                  hasOverride: (e1) => !!e1.textColor,
                }),
                "text-halo-color": new ha(Ct.paint_symbol["text-halo-color"]),
                "text-halo-width": new ha(Ct.paint_symbol["text-halo-width"]),
                "text-halo-blur": new ha(Ct.paint_symbol["text-halo-blur"]),
                "text-translate": new ca(Ct.paint_symbol["text-translate"]),
                "text-translate-anchor": new ca(
                  Ct.paint_symbol["text-translate-anchor"],
                ),
              }),
              layout: Wg,
            };
            class Yg {
              constructor(e1) {
                (this.type = e1.property.overrides
                  ? e1.property.overrides.runtimeType
                  : Nt),
                  (this.defaultValue = e1);
              }
              evaluate(e1) {
                if (e1.formattedSection) {
                  const t = this.defaultValue.property.overrides;
                  if (t && t.hasOverride(e1.formattedSection))
                    return t.getOverride(e1.formattedSection);
                }
                return e1.feature && e1.featureState
                  ? this.defaultValue.evaluate(e1.feature, e1.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(e1) {
                this.defaultValue.isConstant() ||
                  e1(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            Is(Yg, "FormatSectionOverride", {
              omit: ["defaultValue"],
            });
            class Kg extends _a {
              constructor(e1, t) {
                super(e1, Xg, t);
              }
              recalculate(e1, t) {
                super.recalculate(e1, t),
                  "auto" === this.layout.get("icon-rotation-alignment") &&
                    (this.layout._values["icon-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-rotation-alignment") &&
                    (this.layout._values["text-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-pitch-alignment") &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment")),
                  "auto" === this.layout.get("icon-pitch-alignment") &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment"));
                const i = this.layout.get("text-writing-mode");
                if (i) {
                  const e1 = [];
                  for (const t of i) e1.indexOf(t) < 0 && e1.push(t);
                  this.layout._values["text-writing-mode"] = e1;
                } else
                  this.layout._values["text-writing-mode"] =
                    "point" === this.layout.get("symbol-placement")
                      ? ["horizontal"]
                      : ["horizontal", "vertical"];
                this._setPaintOverrides();
              }
              getValueAndResolveTokens(e1, t, i, r) {
                const n = this.layout.get(e1).evaluate(t, {}, i, r),
                  o = this._unevaluatedLayout._values[e1];
                return o.isDataDriven() || yo(o.value) || !n
                  ? n
                  : (function (e1, t) {
                      return t.replace(/{([^{}]+)}/g, (t, i) =>
                        i in e1 ? String(e1[i]) : "",
                      );
                    })(t.properties, n);
              }
              createBucket(e1) {
                return new cy(e1);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                return !1;
              }
              _setPaintOverrides() {
                for (const e1 of Xg.paint.overridableProperties) {
                  if (!Kg.hasPaintOverride(this.layout, e1)) continue;
                  const t = this.paint.get(e1),
                    i = new Yg(t),
                    r = new go(i, t.property.specification);
                  let n = null;
                  (n =
                    "constant" === t.value.kind || "source" === t.value.kind
                      ? new vo("source", r)
                      : new bo(
                          "composite",
                          r,
                          t.value.zoomStops,
                          t.value._interpolationType,
                        )),
                    (this.paint._values[e1] = new aa(
                      t.property,
                      n,
                      t.parameters,
                    ));
                }
              }
              _handleOverridablePaintPropertyUpdate(e1, t, i) {
                return (
                  !(!this.layout || t.isDataDriven() || i.isDataDriven()) &&
                  Kg.hasPaintOverride(this.layout, e1)
                );
              }
              static hasPaintOverride(e1, t) {
                const i = e1.get("text-field"),
                  r = Xg.paint.properties[t];
                let n = !1;
                const o = (e1) => {
                  for (const t of e1)
                    if (r.overrides && r.overrides.hasOverride(t))
                      return void (n = !0);
                };
                if ("constant" === i.value.kind && i.value.value instanceof ui)
                  o(i.value.value.sections);
                else if ("source" === i.value.kind) {
                  const e1 = (t) => {
                      n ||
                        (t instanceof yi && mi(t.value) === Ht
                          ? o(t.value.sections)
                          : t instanceof Ti
                          ? o(t.sections)
                          : t.eachChild(e1));
                    },
                    t = i.value;
                  t._styleExpression && e1(t._styleExpression.expression);
                }
                return n;
              }
              getProgramIds() {
                const e1 = 0 !== this.paint.get("icon-opacity").constantOr(1),
                  t = 0 !== this.paint.get("text-opacity").constantOr(1),
                  i = [];
                return e1 && i.push("symbolIcon"), t && i.push("symbolSDF"), i;
              }
              getDefaultProgramParams(e1, t) {
                return {
                  config: new $l(this, t),
                  overrideFog: !1,
                };
              }
            }
            const Jg = im.types,
              Qg = [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint8",
                  offset: 0,
                },
              ];
            function ey(e1, t, i, r, n, o, s, a, l, c, h, u, d) {
              const p = a ? Math.min(_g, Math.round(a[0])) : 0,
                f = a ? Math.min(_g, Math.round(a[1])) : 0;
              e1.emplaceBack(
                t,
                i,
                Math.round(32 * r),
                Math.round(32 * n),
                o,
                s,
                (p << 1) + (l ? 1 : 0),
                f,
                16 * c,
                16 * h,
                256 * u,
                256 * d,
              );
            }
            function ty(e1, t, i) {
              e1.emplaceBack(t, i);
            }
            function iy(e1, t, i, r, n, o, s) {
              e1.emplaceBack(t, i, r, n, o, s);
            }
            function ry(e1, t, i, r, n) {
              const o = 5 * t + 2;
              (e1.float32[o + 0] = i),
                (e1.float32[o + 1] = r),
                (e1.float32[o + 2] = n);
            }
            function ny(e1, t, i, r, n) {
              e1.emplaceBack(t, i, r, n),
                e1.emplaceBack(t, i, r, n),
                e1.emplaceBack(t, i, r, n),
                e1.emplaceBack(t, i, r, n);
            }
            function oy(e1) {
              for (const t of e1.sections) if (Vs(t.text)) return !0;
              return !1;
            }
            class sy {
              constructor(e1) {
                (this.layoutVertexArray = new Pa()),
                  (this.indexArray = new Va()),
                  (this.programConfigurations = e1),
                  (this.segments = new dl()),
                  (this.dynamicLayoutVertexArray = new Ia()),
                  (this.opacityVertexArray = new La()),
                  (this.placedSymbolArray = new il()),
                  (this.iconTransitioningVertexArray = new ka()),
                  (this.globeExtVertexArray = new Ra()),
                  (this.zOffsetVertexArray = new qa());
              }
              isEmpty() {
                return (
                  0 === this.layoutVertexArray.length &&
                  0 === this.indexArray.length &&
                  0 === this.dynamicLayoutVertexArray.length &&
                  0 === this.opacityVertexArray.length &&
                  0 === this.iconTransitioningVertexArray.length
                );
              }
              upload(e1, t, i, r, n) {
                this.isEmpty() ||
                  (i &&
                    ((this.layoutVertexBuffer = e1.createVertexBuffer(
                      this.layoutVertexArray,
                      Wm.members,
                    )),
                    (this.indexBuffer = e1.createIndexBuffer(
                      this.indexArray,
                      t,
                    )),
                    (this.dynamicLayoutVertexBuffer = e1.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      Ym.members,
                      !0,
                    )),
                    (this.opacityVertexBuffer = e1.createVertexBuffer(
                      this.opacityVertexArray,
                      Qg,
                      !0,
                    )),
                    this.iconTransitioningVertexArray.length > 0 &&
                      (this.iconTransitioningVertexBuffer =
                        e1.createVertexBuffer(
                          this.iconTransitioningVertexArray,
                          Jm.members,
                          !0,
                        )),
                    this.globeExtVertexArray.length > 0 &&
                      (this.globeExtVertexBuffer = e1.createVertexBuffer(
                        this.globeExtVertexArray,
                        Xm.members,
                        !0,
                      )),
                    !this.zOffsetVertexBuffer &&
                      (this.zOffsetVertexArray.length > 0 || n) &&
                      (this.zOffsetVertexBuffer = e1.createVertexBuffer(
                        this.zOffsetVertexArray,
                        Km.members,
                        !0,
                      )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (i || r) && this.programConfigurations.upload(e1));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy(),
                  this.iconTransitioningVertexBuffer &&
                    this.iconTransitioningVertexBuffer.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy(),
                  this.zOffsetVertexBuffer &&
                    this.zOffsetVertexBuffer.destroy());
              }
            }
            Is(sy, "SymbolBuffers");
            class ay {
              constructor(e1, t, i) {
                (this.layoutVertexArray = new e1()),
                  (this.layoutAttributes = t),
                  (this.indexArray = new i()),
                  (this.segments = new dl()),
                  (this.collisionVertexArray = new Na()),
                  (this.collisionVertexArrayExt = new Ua());
              }
              upload(e1) {
                (this.layoutVertexBuffer = e1.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes,
                )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = e1.createVertexBuffer(
                    this.collisionVertexArray,
                    Qm.members,
                    !0,
                  )),
                  (this.collisionVertexBufferExt = e1.createVertexBuffer(
                    this.collisionVertexArrayExt,
                    e_.members,
                    !0,
                  ));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy(),
                  this.collisionVertexBufferExt.destroy());
              }
            }
            Is(ay, "CollisionBuffers");
            class ly {
              constructor(e1) {
                (this.collisionBoxArray = e1.collisionBoxArray),
                  (this.zoom = e1.zoom),
                  (this.overscaling = e1.overscaling),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.index = e1.index),
                  (this.pixelRatio = e1.pixelRatio),
                  (this.sourceLayerIndex = e1.sourceLayerIndex),
                  (this.hasPattern = !1),
                  (this.hasRTLText = !1),
                  (this.fullyClipped = !1),
                  (this.hasAnyIconTextFit = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []),
                  (this.placementInvProjMatrix = xu.identity([])),
                  (this.placementViewportMatrix = xu.identity([]));
                const t = this.layers[0]._unevaluatedLayout._values;
                (this.textSizeData = o_(this.zoom, t["text-size"])),
                  (this.iconSizeData = o_(this.zoom, t["icon-size"]));
                const i = this.layers[0].layout,
                  r = i.get("symbol-sort-key"),
                  n = i.get("symbol-z-order");
                (this.canOverlap =
                  i.get("text-allow-overlap") ||
                  i.get("icon-allow-overlap") ||
                  i.get("text-ignore-placement") ||
                  i.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    "viewport-y" !== n && void 0 !== r.constantOr(1)),
                  (this.sortFeaturesByY =
                    ("viewport-y" === n ||
                      ("auto" === n && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  (this.writingModes = i
                    .get("text-writing-mode")
                    .map((e1) => w_[e1])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id)),
                  (this.sourceID = e1.sourceID),
                  (this.projection = e1.projection),
                  (this.hasAnyZOffset = !1),
                  (this.zOffsetSortDirty = !1),
                  (this.zOffsetBuffersNeedUpload = i.get("symbol-z-elevate"));
              }
              createArrays() {
                (this.text = new sy(
                  new Hl(this.layers, this.zoom, (e1) => /^text/.test(e1)),
                )),
                  (this.icon = new sy(
                    new Hl(this.layers, this.zoom, (e1) => /^icon/.test(e1)),
                  )),
                  (this.glyphOffsetArray = new ol()),
                  (this.lineVertexArray = new sl()),
                  (this.symbolInstances = new nl());
              }
              calculateGlyphDependencies(e1, t, i, r, n) {
                for (let i = 0; i < e1.length; i++) {
                  const o = e1.codePointAt(i);
                  if (void 0 === o) break;
                  if (((t[o] = !0), r && n && o <= 65535)) {
                    const r = h_[e1.charAt(i)];
                    r && (t[r.charCodeAt(0)] = !0);
                  }
                }
              }
              populate(e1, t, i, r) {
                const n = this.layers[0],
                  o = n.layout,
                  s = "globe" === this.projection.name,
                  a = o.get("text-font"),
                  l = o.get("text-field"),
                  c = o.get("icon-image"),
                  h =
                    ("constant" !== l.value.kind ||
                      (l.value.value instanceof ui &&
                        !l.value.value.isEmpty()) ||
                      l.value.value.toString().length > 0) &&
                    ("constant" !== a.value.kind || a.value.value.length > 0),
                  u =
                    "constant" !== c.value.kind ||
                    !!c.value.value ||
                    Object.keys(c.parameters).length > 0,
                  d = o.get("symbol-sort-key");
                if (((this.features = []), !h && !u)) return;
                const p = t.iconDependencies,
                  f = t.glyphDependencies,
                  m = t.availableImages,
                  _ = new ea(this.zoom);
                for (const {
                  feature: t,
                  id: l,
                  index: c,
                  sourceLayerIndex: g,
                } of e1) {
                  const e1 = n._featureFilter.needGeometry,
                    y = cp(t, e1);
                  if (!n._featureFilter.filter(_, y, i)) continue;
                  if (
                    (e1 || (y.geometry = lp(t, i, r)),
                    s && 1 !== t.type && i.z <= 5)
                  ) {
                    const e1 = y.geometry,
                      t = 0.98078528056,
                      r = (e1, r) => {
                        const n = _d(e1.x, e1.y, i, 1),
                          o = _d(r.x, r.y, i, 1);
                        return Mu.dot(n, o) < t;
                      };
                    for (let t = 0; t < e1.length; t++) e1[t] = np(e1[t], r);
                  }
                  let x, v;
                  if (h) {
                    const e1 = n.getValueAndResolveTokens(
                        "text-field",
                        y,
                        i,
                        m,
                      ),
                      t = ui.factory(e1);
                    oy(t) && (this.hasRTLText = !0),
                      (!this.hasRTLText ||
                        "unavailable" === Ks() ||
                        (this.hasRTLText && Qs.isParsed())) &&
                        (x = c_(t, n, y));
                  }
                  if (u) {
                    const e1 = n.getValueAndResolveTokens(
                      "icon-image",
                      y,
                      i,
                      m,
                    );
                    v = e1 instanceof di ? e1 : di.fromString(e1);
                  }
                  if (!x && !v) continue;
                  const b = this.sortFeaturesByKey
                    ? d.evaluate(y, {}, i)
                    : void 0;
                  if (
                    (this.features.push({
                      id: l,
                      text: x,
                      icon: v,
                      index: c,
                      sourceLayerIndex: g,
                      geometry: y.geometry,
                      properties: t.properties,
                      type: Jg[t.type],
                      sortKey: b,
                    }),
                    v &&
                      ((p[v.namePrimary] = !0),
                      v.nameSecondary && (p[v.nameSecondary] = !0)),
                    x)
                  ) {
                    const e1 = a.evaluate(y, {}, i).join(","),
                      t =
                        "map" === o.get("text-rotation-alignment") &&
                        "point" !== o.get("symbol-placement");
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(w_.vertical) >= 0;
                    for (const i of x.sections)
                      if (i.image) p[i.image.namePrimary] = !0;
                      else {
                        const r = Ls(x.toString()),
                          n = i.fontStack || e1,
                          o = (f[n] = f[n] || {});
                        this.calculateGlyphDependencies(
                          i.text,
                          o,
                          t,
                          this.allowVerticalPlacement,
                          r,
                        );
                      }
                  }
                }
                "line" === o.get("symbol-placement") &&
                  (this.features = (function (e1) {
                    const t = {},
                      i = {},
                      r = [];
                    let n = 0;
                    function o(t) {
                      r.push(e1[t]), n++;
                    }
                    function s(e1, t, n) {
                      const o = i[e1];
                      return (
                        delete i[e1],
                        (i[t] = o),
                        r[o].geometry[0].pop(),
                        (r[o].geometry[0] = r[o].geometry[0].concat(n[0])),
                        o
                      );
                    }
                    function a(e1, i, n) {
                      const o = t[i];
                      return (
                        delete t[i],
                        (t[e1] = o),
                        r[o].geometry[0].shift(),
                        (r[o].geometry[0] = n[0].concat(r[o].geometry[0])),
                        o
                      );
                    }
                    function l(e1, t, i) {
                      const r = i ? t[0][t[0].length - 1] : t[0][0];
                      return `${e1}:${r.x}:${r.y}`;
                    }
                    for (let c = 0; c < e1.length; c++) {
                      const h = e1[c],
                        u = h.geometry,
                        d = h.text ? h.text.toString() : null;
                      if (!d) {
                        o(c);
                        continue;
                      }
                      const p = l(d, u),
                        f = l(d, u, !0);
                      if (p in i && f in t && i[p] !== t[f]) {
                        const e1 = a(p, f, u),
                          n = s(p, f, r[e1].geometry);
                        delete t[p],
                          delete i[f],
                          (i[l(d, r[n].geometry, !0)] = n),
                          (r[e1].geometry = null);
                      } else
                        p in i
                          ? s(p, f, u)
                          : f in t
                          ? a(p, f, u)
                          : (o(c), (t[p] = n - 1), (i[f] = n - 1));
                    }
                    return r.filter((e1) => e1.geometry);
                  })(this.features)),
                  this.sortFeaturesByKey &&
                    this.features.sort((e1, t) => e1.sortKey - t.sortKey);
              }
              update(e1, t, i, r, n) {
                const o = 0 !== Object.keys(e1).length;
                if (o && !this.stateDependentLayers.length) return;
                const s = o ? this.stateDependentLayers : this.layers;
                this.text.programConfigurations.updatePaintArrays(
                  e1,
                  t,
                  s,
                  i,
                  r,
                  n,
                ),
                  this.icon.programConfigurations.updatePaintArrays(
                    e1,
                    t,
                    s,
                    i,
                    r,
                    n,
                  );
              }
              updateZOffset() {
                const e1 = (e1, t, r) => {
                    (i += t), i > e1.length && e1.resize(i);
                    for (let n = -t; n < 0; n++) e1.emplace(n + i, r);
                  },
                  t = (e1, t, i) => {
                    (r += t), r > e1.length && e1.resize(r);
                    for (let n = -t; n < 0; n++) e1.emplace(n + r, i);
                  };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let i = 0,
                  r = 0;
                for (let i = 0; i < this.symbolInstances.length; i++) {
                  const r = this.symbolInstances.get(i),
                    {
                      numHorizontalGlyphVertices: n,
                      numVerticalGlyphVertices: o,
                      numIconVertices: s,
                    } = r,
                    a = r.zOffset,
                    l = s > 0;
                  if (
                    ((n > 0 || o > 0) &&
                      (e1(this.text.zOffsetVertexArray, n, a),
                      e1(this.text.zOffsetVertexArray, o, a)),
                    l)
                  ) {
                    const {
                      placedIconSymbolIndex: e1,
                      verticalPlacedIconSymbolIndex: i,
                    } = r;
                    e1 >= 0 && t(this.icon.zOffsetVertexArray, s, a),
                      i >= 0 &&
                        t(
                          this.icon.zOffsetVertexArray,
                          r.numVerticalIconVertices,
                          a,
                        );
                  }
                }
                this.text.zOffsetVertexBuffer &&
                  this.text.zOffsetVertexBuffer.updateData(
                    this.text.zOffsetVertexArray,
                  ),
                  this.icon.zOffsetVertexBuffer &&
                    this.icon.zOffsetVertexBuffer.updateData(
                      this.icon.zOffsetVertexArray,
                    );
              }
              isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(e1) {
                !this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(e1),
                  this.iconCollisionBox.upload(e1)),
                  this.text.upload(
                    e1,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload,
                    this.zOffsetBuffersNeedUpload,
                  ),
                  this.icon.upload(
                    e1,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload,
                    this.zOffsetBuffersNeedUpload,
                  ),
                  (this.uploaded = !0);
              }
              destroyDebugData() {
                this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy();
              }
              getProjection() {
                return (
                  this.projectionInstance ||
                    (this.projectionInstance = Hg(this.projection)),
                  this.projectionInstance
                );
              }
              destroy() {
                this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData();
              }
              addToLineVertexArray(e1, t) {
                const i = this.lineVertexArray.length;
                if (void 0 !== e1.segment)
                  for (const { x: e1, y: i } of t)
                    this.lineVertexArray.emplaceBack(e1, i);
                return {
                  lineStartIndex: i,
                  lineLength: this.lineVertexArray.length - i,
                };
              }
              addSymbols(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m) {
                const _ = e1.indexArray,
                  g = e1.layoutVertexArray,
                  y = e1.globeExtVertexArray,
                  x = e1.segments.prepareSegment(
                    4 * t.length,
                    g,
                    _,
                    this.canOverlap ? o.sortKey : void 0,
                  ),
                  v = this.glyphOffsetArray.length,
                  b = x.vertexLength,
                  w =
                    this.allowVerticalPlacement && s === w_.vertical
                      ? Math.PI / 2
                      : 0,
                  T = o.text && o.text.sections;
                for (let r = 0; r < t.length; r++) {
                  const {
                      tl: n,
                      tr: s,
                      bl: c,
                      br: h,
                      texPrimary: u,
                      texSecondary: v,
                      pixelOffsetTL: b,
                      pixelOffsetBR: E,
                      minFontScaleX: M,
                      minFontScaleY: A,
                      glyphOffset: S,
                      isSDF: I,
                      sectionIndex: C,
                    } = t[r],
                    z = x.vertexLength,
                    D = S[1];
                  if (
                    (ey(
                      g,
                      l.x,
                      l.y,
                      n.x,
                      D + n.y,
                      u.x,
                      u.y,
                      i,
                      I,
                      b.x,
                      b.y,
                      M,
                      A,
                    ),
                    ey(
                      g,
                      l.x,
                      l.y,
                      s.x,
                      D + s.y,
                      u.x + u.w,
                      u.y,
                      i,
                      I,
                      E.x,
                      b.y,
                      M,
                      A,
                    ),
                    ey(
                      g,
                      l.x,
                      l.y,
                      c.x,
                      D + c.y,
                      u.x,
                      u.y + u.h,
                      i,
                      I,
                      b.x,
                      E.y,
                      M,
                      A,
                    ),
                    ey(
                      g,
                      l.x,
                      l.y,
                      h.x,
                      D + h.y,
                      u.x + u.w,
                      u.y + u.h,
                      i,
                      I,
                      E.x,
                      E.y,
                      M,
                      A,
                    ),
                    a)
                  ) {
                    const { x: t, y: i, z: r } = a.anchor,
                      [n, o, s] = a.up;
                    iy(y, t, i, r, n, o, s),
                      iy(y, t, i, r, n, o, s),
                      iy(y, t, i, r, n, o, s),
                      iy(y, t, i, r, n, o, s),
                      ny(e1.dynamicLayoutVertexArray, t, i, r, w);
                  } else ny(e1.dynamicLayoutVertexArray, l.x, l.y, l.z, w);
                  if (m) {
                    const t = v || u;
                    ty(e1.iconTransitioningVertexArray, t.x, t.y),
                      ty(e1.iconTransitioningVertexArray, t.x + t.w, t.y),
                      ty(e1.iconTransitioningVertexArray, t.x, t.y + t.h),
                      ty(e1.iconTransitioningVertexArray, t.x + t.w, t.y + t.h);
                  }
                  _.emplaceBack(z, z + 1, z + 2),
                    _.emplaceBack(z + 1, z + 2, z + 3),
                    (x.vertexLength += 4),
                    (x.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(S[0]),
                    (r !== t.length - 1 && C === t[r + 1].sectionIndex) ||
                      e1.programConfigurations.populatePaintArrays(
                        g.length,
                        o,
                        o.index,
                        {},
                        d,
                        p,
                        f,
                        T && T[C],
                      );
                }
                const E = a ? a.anchor : l;
                e1.placedSymbolArray.emplaceBack(
                  E.x,
                  E.y,
                  E.z,
                  l.x,
                  l.y,
                  v,
                  this.glyphOffsetArray.length - v,
                  b,
                  c,
                  h,
                  l.segment,
                  i ? i[0] : 0,
                  i ? i[1] : 0,
                  r[0],
                  r[1],
                  s,
                  0,
                  !1,
                  0,
                  u,
                  0,
                );
              }
              _commitLayoutVertex(e1, t, i, r, n, o, s) {
                e1.emplaceBack(t, i, r, n, o, Math.round(s.x), Math.round(s.y));
              }
              _addCollisionDebugVertices(e1, t, i, r, n, o, s) {
                const a = i.segments.prepareSegment(
                    4,
                    i.layoutVertexArray,
                    i.indexArray,
                  ),
                  l = a.vertexLength,
                  c = s.tileAnchorX,
                  h = s.tileAnchorY;
                for (let e1 = 0; e1 < 4; e1++)
                  i.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                i.collisionVertexArrayExt.emplaceBack(
                  t,
                  -e1.padding,
                  -e1.padding,
                ),
                  i.collisionVertexArrayExt.emplaceBack(
                    t,
                    e1.padding,
                    -e1.padding,
                  ),
                  i.collisionVertexArrayExt.emplaceBack(
                    t,
                    e1.padding,
                    e1.padding,
                  ),
                  i.collisionVertexArrayExt.emplaceBack(
                    t,
                    -e1.padding,
                    e1.padding,
                  ),
                  this._commitLayoutVertex(
                    i.layoutVertexArray,
                    r,
                    n,
                    o,
                    c,
                    h,
                    new y(e1.x1, e1.y1),
                  ),
                  this._commitLayoutVertex(
                    i.layoutVertexArray,
                    r,
                    n,
                    o,
                    c,
                    h,
                    new y(e1.x2, e1.y1),
                  ),
                  this._commitLayoutVertex(
                    i.layoutVertexArray,
                    r,
                    n,
                    o,
                    c,
                    h,
                    new y(e1.x2, e1.y2),
                  ),
                  this._commitLayoutVertex(
                    i.layoutVertexArray,
                    r,
                    n,
                    o,
                    c,
                    h,
                    new y(e1.x1, e1.y2),
                  ),
                  (a.vertexLength += 4);
                const u = i.indexArray;
                u.emplaceBack(l, l + 1),
                  u.emplaceBack(l + 1, l + 2),
                  u.emplaceBack(l + 2, l + 3),
                  u.emplaceBack(l + 3, l),
                  (a.primitiveLength += 4);
              }
              _addTextDebugCollisionBoxes(e1, t, i, r, n, o) {
                for (let s = r; s < n; s++) {
                  const r = i.get(s),
                    n = this.getSymbolInstanceTextSize(e1, o, t, s);
                  this._addCollisionDebugVertices(
                    r,
                    n,
                    this.textCollisionBox,
                    r.projectedAnchorX,
                    r.projectedAnchorY,
                    r.projectedAnchorZ,
                    o,
                  );
                }
              }
              _addIconDebugCollisionBoxes(e1, t, i, r, n, o) {
                for (let s = r; s < n; s++) {
                  const r = i.get(s),
                    n = this.getSymbolInstanceIconSize(
                      e1,
                      t,
                      o.placedIconSymbolIndex,
                    );
                  this._addCollisionDebugVertices(
                    r,
                    n,
                    this.iconCollisionBox,
                    r.projectedAnchorX,
                    r.projectedAnchorY,
                    r.projectedAnchorZ,
                    o,
                  );
                }
              }
              generateCollisionDebugBuffers(e1, t) {
                this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new ay(Ba, t_.members, ka)),
                  (this.iconCollisionBox = new ay(Ba, t_.members, ka));
                const i = a_(this.iconSizeData, e1),
                  r = a_(this.textSizeData, e1);
                for (let n = 0; n < this.symbolInstances.length; n++) {
                  const o = this.symbolInstances.get(n);
                  this._addTextDebugCollisionBoxes(
                    r,
                    e1,
                    t,
                    o.textBoxStartIndex,
                    o.textBoxEndIndex,
                    o,
                  ),
                    this._addTextDebugCollisionBoxes(
                      r,
                      e1,
                      t,
                      o.verticalTextBoxStartIndex,
                      o.verticalTextBoxEndIndex,
                      o,
                    ),
                    this._addIconDebugCollisionBoxes(
                      i,
                      e1,
                      t,
                      o.iconBoxStartIndex,
                      o.iconBoxEndIndex,
                      o,
                    ),
                    this._addIconDebugCollisionBoxes(
                      i,
                      e1,
                      t,
                      o.verticalIconBoxStartIndex,
                      o.verticalIconBoxEndIndex,
                      o,
                    );
                }
              }
              getSymbolInstanceTextSize(e1, t, i, r) {
                const n = this.text.placedSymbolArray.get(
                    t.rightJustifiedTextSymbolIndex >= 0
                      ? t.rightJustifiedTextSymbolIndex
                      : t.centerJustifiedTextSymbolIndex >= 0
                      ? t.centerJustifiedTextSymbolIndex
                      : t.leftJustifiedTextSymbolIndex >= 0
                      ? t.leftJustifiedTextSymbolIndex
                      : t.verticalPlacedTextSymbolIndex >= 0
                      ? t.verticalPlacedTextSymbolIndex
                      : r,
                  ),
                  o = s_(this.textSizeData, e1, n) / r_;
                return this.tilePixelRatio * o;
              }
              getSymbolInstanceIconSize(e1, t, i) {
                const r = this.icon.placedSymbolArray.get(i),
                  n = s_(this.iconSizeData, e1, r);
                return this.tilePixelRatio * n;
              }
              _commitDebugCollisionVertexUpdate(e1, t, i) {
                e1.emplaceBack(t, -i, -i),
                  e1.emplaceBack(t, i, -i),
                  e1.emplaceBack(t, i, i),
                  e1.emplaceBack(t, -i, i);
              }
              _updateTextDebugCollisionBoxes(e1, t, i, r, n, o) {
                for (let s = r; s < n; s++) {
                  const r = i.get(s),
                    n = this.getSymbolInstanceTextSize(e1, o, t, s);
                  this._commitDebugCollisionVertexUpdate(
                    this.textCollisionBox.collisionVertexArrayExt,
                    n,
                    r.padding,
                  );
                }
              }
              _updateIconDebugCollisionBoxes(e1, t, i, r, n, o) {
                for (let s = r; s < n; s++) {
                  const r = i.get(s),
                    n = this.getSymbolInstanceIconSize(e1, t, o);
                  this._commitDebugCollisionVertexUpdate(
                    this.iconCollisionBox.collisionVertexArrayExt,
                    n,
                    r.padding,
                  );
                }
              }
              updateCollisionDebugBuffers(e1, t) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexArrayExt.clear(),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexArrayExt.clear();
                const i = a_(this.iconSizeData, e1),
                  r = a_(this.textSizeData, e1);
                for (let n = 0; n < this.symbolInstances.length; n++) {
                  const o = this.symbolInstances.get(n);
                  this._updateTextDebugCollisionBoxes(
                    r,
                    e1,
                    t,
                    o.textBoxStartIndex,
                    o.textBoxEndIndex,
                    o,
                  ),
                    this._updateTextDebugCollisionBoxes(
                      r,
                      e1,
                      t,
                      o.verticalTextBoxStartIndex,
                      o.verticalTextBoxEndIndex,
                      o,
                    ),
                    this._updateIconDebugCollisionBoxes(
                      i,
                      e1,
                      t,
                      o.iconBoxStartIndex,
                      o.iconBoxEndIndex,
                      o.placedIconSymbolIndex,
                    ),
                    this._updateIconDebugCollisionBoxes(
                      i,
                      e1,
                      t,
                      o.verticalIconBoxStartIndex,
                      o.verticalIconBoxEndIndex,
                      o.placedIconSymbolIndex,
                    );
                }
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexBufferExt &&
                  this.textCollisionBox.collisionVertexBufferExt.updateData(
                    this.textCollisionBox.collisionVertexArrayExt,
                  ),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexBufferExt &&
                    this.iconCollisionBox.collisionVertexBufferExt.updateData(
                      this.iconCollisionBox.collisionVertexArrayExt,
                    );
              }
              _deserializeCollisionBoxesForSymbol(e1, t, i, r, n, o, s, a, l) {
                const c = {};
                if (t < i) {
                  const {
                    x1: i,
                    y1: r,
                    x2: n,
                    y2: o,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                    featureIndex: p,
                  } = e1.get(t);
                  (c.textBox = {
                    x1: i,
                    y1: r,
                    x2: n,
                    y2: o,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                  }),
                    (c.textFeatureIndex = p);
                }
                if (r < n) {
                  const {
                    x1: t,
                    y1: i,
                    x2: n,
                    y2: o,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                    featureIndex: p,
                  } = e1.get(r);
                  (c.verticalTextBox = {
                    x1: t,
                    y1: i,
                    x2: n,
                    y2: o,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                  }),
                    (c.verticalTextFeatureIndex = p);
                }
                if (o < s) {
                  const {
                    x1: t,
                    y1: i,
                    x2: r,
                    y2: n,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                    featureIndex: p,
                  } = e1.get(o);
                  (c.iconBox = {
                    x1: t,
                    y1: i,
                    x2: r,
                    y2: n,
                    padding: s,
                    projectedAnchorX: a,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                  }),
                    (c.iconFeatureIndex = p);
                }
                if (a < l) {
                  const {
                    x1: t,
                    y1: i,
                    x2: r,
                    y2: n,
                    padding: o,
                    projectedAnchorX: s,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                    featureIndex: p,
                  } = e1.get(a);
                  (c.verticalIconBox = {
                    x1: t,
                    y1: i,
                    x2: r,
                    y2: n,
                    padding: o,
                    projectedAnchorX: s,
                    projectedAnchorY: l,
                    projectedAnchorZ: h,
                    tileAnchorX: u,
                    tileAnchorY: d,
                  }),
                    (c.verticalIconFeatureIndex = p);
                }
                return c;
              }
              deserializeCollisionBoxes(e1) {
                this.collisionArrays = [];
                for (let t = 0; t < this.symbolInstances.length; t++) {
                  const i = this.symbolInstances.get(t);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      e1,
                      i.textBoxStartIndex,
                      i.textBoxEndIndex,
                      i.verticalTextBoxStartIndex,
                      i.verticalTextBoxEndIndex,
                      i.iconBoxStartIndex,
                      i.iconBoxEndIndex,
                      i.verticalIconBoxStartIndex,
                      i.verticalIconBoxEndIndex,
                    ),
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              hasIconTextFit() {
                return this.hasAnyIconTextFit;
              }
              addIndicesForPlacedSymbol(e1, t) {
                const i = e1.placedSymbolArray.get(t),
                  r = i.vertexStartIndex + 4 * i.numGlyphs;
                for (let t = i.vertexStartIndex; t < r; t += 4)
                  e1.indexArray.emplaceBack(t, t + 1, t + 2),
                    e1.indexArray.emplaceBack(t + 1, t + 2, t + 3);
              }
              getSortedSymbolIndexes(e1) {
                if (
                  this.sortedAngle === e1 &&
                  void 0 !== this.symbolInstanceIndexes
                )
                  return this.symbolInstanceIndexes;
                const t = Math.sin(e1),
                  i = Math.cos(e1),
                  r = [],
                  n = [],
                  o = [];
                for (let e1 = 0; e1 < this.symbolInstances.length; ++e1) {
                  o.push(e1);
                  const s = this.symbolInstances.get(e1);
                  r.push(0 | Math.round(t * s.tileAnchorX + i * s.tileAnchorY)),
                    n.push(s.featureIndex);
                }
                return o.sort((e1, t) => r[e1] - r[t] || n[t] - n[e1]), o;
              }
              getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty)
                  return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                  this.symbolInstanceIndexesSortedZOffset = [];
                  for (let e1 = 0; e1 < this.symbolInstances.length; ++e1)
                    this.symbolInstanceIndexesSortedZOffset.push(e1);
                }
                return (
                  (this.zOffsetSortDirty = !1),
                  this.symbolInstanceIndexesSortedZOffset.sort(
                    (e1, t) =>
                      this.symbolInstances.get(t).zOffset -
                      this.symbolInstances.get(e1).zOffset,
                  )
                );
              }
              addToSortKeyRanges(e1, t) {
                const i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                i && i.sortKey === t
                  ? (i.symbolInstanceEnd = e1 + 1)
                  : this.sortKeyRanges.push({
                      sortKey: t,
                      symbolInstanceStart: e1,
                      symbolInstanceEnd: e1 + 1,
                    });
              }
              sortFeatures(e1) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== e1 &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  (this.symbolInstanceIndexes =
                    this.getSortedSymbolIndexes(e1)),
                    (this.sortedAngle = e1),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []);
                  for (const e1 of this.symbolInstanceIndexes) {
                    const t = this.symbolInstances.get(e1);
                    this.featureSortOrder.push(t.featureIndex);
                    const {
                      rightJustifiedTextSymbolIndex: i,
                      centerJustifiedTextSymbolIndex: r,
                      leftJustifiedTextSymbolIndex: n,
                      verticalPlacedTextSymbolIndex: o,
                      placedIconSymbolIndex: s,
                      verticalPlacedIconSymbolIndex: a,
                    } = t;
                    i >= 0 && this.addIndicesForPlacedSymbol(this.text, i),
                      r >= 0 &&
                        r !== i &&
                        this.addIndicesForPlacedSymbol(this.text, r),
                      n >= 0 &&
                        n !== r &&
                        n !== i &&
                        this.addIndicesForPlacedSymbol(this.text, n),
                      o >= 0 && this.addIndicesForPlacedSymbol(this.text, o),
                      s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s),
                      a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a);
                  }
                  this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
              }
            }
            Is(ly, "SymbolBucket", {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (ly.MAX_GLYPHS = 65535),
              (ly.addDynamicAttributes = ny);
            var cy = ly;
            const hy = ba(
                [
                  {
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16",
                  },
                  {
                    name: "a_data",
                    components: 4,
                    type: "Uint8",
                  },
                  {
                    name: "a_linesofar",
                    components: 1,
                    type: "Float32",
                  },
                ],
                4,
              ),
              { members: uy } = hy,
              dy = ba([
                {
                  name: "a_packed",
                  components: 4,
                  type: "Float32",
                },
              ]),
              { members: py } = dy,
              fy = im.types,
              my = Math.cos((Math.PI / 180) * 37.5);
            class _y {
              constructor(e1) {
                (this.zoom = e1.zoom),
                  (this.overscaling = e1.overscaling),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.index = e1.index),
                  (this.projection = e1.projection),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((e1) => {
                    this.gradients[e1.id] = {};
                  }),
                  (this.layoutVertexArray = new Sa()),
                  (this.layoutVertexArray2 = new Ia()),
                  (this.indexArray = new Va()),
                  (this.programConfigurations = new Hl(e1.layers, e1.zoom)),
                  (this.segments = new dl()),
                  (this.maxLineLength = 0),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id));
              }
              populate(e1, t, i, r) {
                this.hasPattern = Pf("line", this.layers, t);
                const n = this.layers[0].layout.get("line-sort-key"),
                  o = [];
                for (const {
                  feature: t,
                  id: s,
                  index: a,
                  sourceLayerIndex: l,
                } of e1) {
                  const e1 = this.layers[0]._featureFilter.needGeometry,
                    c = cp(t, e1);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ea(this.zoom),
                      c,
                      i,
                    )
                  )
                    continue;
                  const h = n ? n.evaluate(c, {}, i) : void 0,
                    u = {
                      id: s,
                      properties: t.properties,
                      type: t.type,
                      sourceLayerIndex: l,
                      index: a,
                      geometry: e1 ? c.geometry : lp(t, i, r),
                      patterns: {},
                      sortKey: h,
                    };
                  o.push(u);
                }
                n && o.sort((e1, t) => e1.sortKey - t.sortKey);
                const { lineAtlas: s, featureIndex: a } = t,
                  l = this.addConstantDashes(s);
                for (const r of o) {
                  const { geometry: n, index: o, sourceLayerIndex: c } = r;
                  if ((l && this.addFeatureDashes(r, s), this.hasPattern)) {
                    const e1 = Rf("line", this.layers, r, this.zoom, t);
                    this.patternFeatures.push(e1);
                  } else
                    this.addFeature(
                      r,
                      n,
                      o,
                      i,
                      s.positions,
                      t.availableImages,
                      t.brightness,
                    );
                  a.insert(e1[o].feature, n, o, c, this.index);
                }
              }
              addConstantDashes(e1) {
                let t = !1;
                for (const i of this.layers) {
                  const r = i.paint.get("line-dasharray").value,
                    n = i.layout.get("line-cap").value;
                  if ("constant" !== r.kind || "constant" !== n.kind) t = !0;
                  else {
                    const t = n.value,
                      i = r.value;
                    if (!i) continue;
                    e1.addDash(i, t);
                  }
                }
                return t;
              }
              addFeatureDashes(e1, t) {
                const i = this.zoom;
                for (const r of this.layers) {
                  const n = r.paint.get("line-dasharray").value,
                    o = r.layout.get("line-cap").value;
                  if ("constant" === n.kind && "constant" === o.kind) continue;
                  let s, a;
                  if ("constant" === n.kind) {
                    if (((s = n.value), !s)) continue;
                  } else
                    s = n.evaluate(
                      {
                        zoom: i,
                      },
                      e1,
                    );
                  (a =
                    "constant" === o.kind
                      ? o.value
                      : o.evaluate(
                          {
                            zoom: i,
                          },
                          e1,
                        )),
                    t.addDash(s, a),
                    (e1.patterns[r.id] = t.getKey(s, a));
                }
              }
              update(e1, t, i, r, n) {
                const o = 0 !== Object.keys(e1).length;
                (o && !this.stateDependentLayers.length) ||
                  this.programConfigurations.updatePaintArrays(
                    e1,
                    t,
                    o ? this.stateDependentLayers : this.layers,
                    i,
                    r,
                    n,
                  );
              }
              addFeatures(e1, t, i, r, n, o) {
                for (const e1 of this.patternFeatures)
                  this.addFeature(e1, e1.geometry, e1.index, t, i, r, o);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(e1) {
                this.uploaded ||
                  (0 !== this.layoutVertexArray2.length &&
                    (this.layoutVertexBuffer2 = e1.createVertexBuffer(
                      this.layoutVertexArray2,
                      py,
                    )),
                  (this.layoutVertexBuffer = e1.createVertexBuffer(
                    this.layoutVertexArray,
                    uy,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(e1),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(e1) {
                if (
                  e1.properties &&
                  e1.properties.hasOwnProperty("mapbox_clip_start") &&
                  e1.properties.hasOwnProperty("mapbox_clip_end")
                )
                  return {
                    start: +e1.properties.mapbox_clip_start,
                    end: +e1.properties.mapbox_clip_end,
                  };
              }
              addFeature(e1, t, i, r, n, o, s) {
                const a = this.layers[0].layout,
                  l = a.get("line-join").evaluate(e1, {}),
                  c = a.get("line-cap").evaluate(e1, {}),
                  h = a.get("line-miter-limit"),
                  u = a.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(e1);
                for (const i of t) this.addLine(i, e1, l, c, h, u);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e1,
                  i,
                  n,
                  o,
                  r,
                  s,
                );
              }
              addLine(e1, t, i, r, n, o) {
                if (
                  ((this.distance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (this.lineSoFar = 0),
                  this.lineClips)
                ) {
                  this.lineClipsArray.push(this.lineClips);
                  for (let t = 0; t < e1.length - 1; t++)
                    this.totalDistance += e1[t].dist(e1[t + 1]);
                  this.updateScaledDistance(),
                    (this.maxLineLength = Math.max(
                      this.maxLineLength,
                      this.totalDistance,
                    ));
                }
                const s = "Polygon" === fy[t.type];
                let a = e1.length;
                for (; a >= 2 && e1[a - 1].equals(e1[a - 2]); ) a--;
                let l = 0;
                for (; l < a - 1 && e1[l].equals(e1[l + 1]); ) l++;
                if (a < (s ? 3 : 2)) return;
                "bevel" === i && (n = 1.05);
                const c =
                    this.overscaling <= 16
                      ? (15 * sr) / (512 * this.overscaling)
                      : 0,
                  h = this.segments.prepareSegment(
                    10 * a,
                    this.layoutVertexArray,
                    this.indexArray,
                  );
                let u, d, p, f, m;
                (this.e1 = this.e2 = -1),
                  s && ((u = e1[a - 2]), (m = e1[l].sub(u)._unit()._perp()));
                for (let t = l; t < a; t++) {
                  if (
                    ((p = t === a - 1 ? (s ? e1[l + 1] : void 0) : e1[t + 1]),
                    p && e1[t].equals(p))
                  )
                    continue;
                  m && (f = m),
                    u && (d = u),
                    (u = e1[t]),
                    (m = p ? p.sub(u)._unit()._perp() : f),
                    (f = f || m);
                  let _ = f.add(m);
                  (0 === _.x && 0 === _.y) || _._unit();
                  const g = f.x * m.x + f.y * m.y,
                    y = _.x * m.x + _.y * m.y,
                    x = 0 !== y ? 1 / y : 1 / 0,
                    v = 2 * Math.sqrt(2 - 2 * y),
                    b = y < my && d && p,
                    w = f.x * m.y - f.y * m.x > 0;
                  if (b && t > l) {
                    const e1 = u.dist(d);
                    if (e1 > 2 * c) {
                      const t = u.sub(
                        u
                          .sub(d)
                          ._mult(c / e1)
                          ._round(),
                      );
                      this.updateDistance(d, t),
                        this.addCurrentVertex(t, f, 0, 0, h),
                        (d = t);
                    }
                  }
                  const T = d && p;
                  let E = T ? i : s ? "butt" : r;
                  if (
                    (T &&
                      "round" === E &&
                      (x < o ? (E = "miter") : x <= 2 && (E = "fakeround")),
                    "miter" === E && x > n && (E = "bevel"),
                    "bevel" === E &&
                      (x > 2 && (E = "flipbevel"), x < n && (E = "miter")),
                    d && this.updateDistance(d, u),
                    "miter" === E)
                  )
                    _._mult(x), this.addCurrentVertex(u, _, 0, 0, h);
                  else if ("flipbevel" === E) {
                    if (x > 100) _ = m.mult(-1);
                    else {
                      const e1 = (x * f.add(m).mag()) / f.sub(m).mag();
                      _._perp()._mult(e1 * (w ? -1 : 1));
                    }
                    this.addCurrentVertex(u, _, 0, 0, h),
                      this.addCurrentVertex(u, _.mult(-1), 0, 0, h);
                  } else if ("bevel" === E || "fakeround" === E) {
                    const e1 = -Math.sqrt(x * x - 1),
                      t = w ? e1 : 0,
                      i = w ? 0 : e1;
                    if (
                      (d && this.addCurrentVertex(u, f, t, i, h),
                      "fakeround" === E)
                    ) {
                      const e1 = Math.round((180 * v) / Math.PI / 20);
                      for (let t = 1; t < e1; t++) {
                        let i = t / e1;
                        if (0.5 !== i) {
                          const e1 = i - 0.5;
                          i +=
                            i *
                            e1 *
                            (i - 1) *
                            ((1.0904 +
                              g * (g * (3.55645 - 1.43519 * g) - 3.2452)) *
                              e1 *
                              e1 +
                              (0.848013 + g * (0.215638 * g - 1.06021)));
                        }
                        const r = m
                          .sub(f)
                          ._mult(i)
                          ._add(f)
                          ._unit()
                          ._mult(w ? -1 : 1);
                        this.addHalfVertex(u, r.x, r.y, !1, w, 0, h);
                      }
                    }
                    p && this.addCurrentVertex(u, m, -t, -i, h);
                  } else if ("butt" === E) this.addCurrentVertex(u, _, 0, 0, h);
                  else if ("square" === E) {
                    const e1 = d ? 1 : -1;
                    d || this.addCurrentVertex(u, _, e1, e1, h),
                      this.addCurrentVertex(u, _, 0, 0, h),
                      d && this.addCurrentVertex(u, _, e1, e1, h);
                  } else
                    "round" === E &&
                      (d &&
                        (this.addCurrentVertex(u, f, 0, 0, h),
                        this.addCurrentVertex(u, f, 1, 1, h, !0)),
                      p &&
                        (this.addCurrentVertex(u, m, -1, -1, h, !0),
                        this.addCurrentVertex(u, m, 0, 0, h)));
                  if (b && t < a - 1) {
                    const e1 = u.dist(p);
                    if (e1 > 2 * c) {
                      const t = u.add(
                        p
                          .sub(u)
                          ._mult(c / e1)
                          ._round(),
                      );
                      this.updateDistance(u, t),
                        this.addCurrentVertex(t, m, 0, 0, h),
                        (u = t);
                    }
                  }
                }
              }
              addCurrentVertex(e1, t, i, r, n, o = !1) {
                const s = t.y * r - t.x,
                  a = -t.y - t.x * r;
                this.addHalfVertex(
                  e1,
                  t.x + t.y * i,
                  t.y - t.x * i,
                  o,
                  !1,
                  i,
                  n,
                ),
                  this.addHalfVertex(e1, s, a, o, !0, -r, n);
              }
              addHalfVertex({ x: e1, y: t }, i, r, n, o, s, a) {
                this.layoutVertexArray.emplaceBack(
                  (e1 << 1) + (n ? 1 : 0),
                  (t << 1) + (o ? 1 : 0),
                  Math.round(63 * i) + 128,
                  Math.round(63 * r) + 128,
                  1 + (0 === s ? 0 : s < 0 ? -1 : 1),
                  0,
                  this.lineSoFar,
                ),
                  this.lineClips &&
                    this.layoutVertexArray2.emplaceBack(
                      this.scaledDistance,
                      this.lineClipsArray.length,
                      this.lineClips.start,
                      this.lineClips.end,
                    );
                const l = a.vertexLength++;
                this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, this.e2, l),
                  a.primitiveLength++),
                  o ? (this.e2 = l) : (this.e1 = l);
              }
              updateScaledDistance() {
                if (this.lineClips) {
                  const e1 =
                    this.totalDistance /
                    (this.lineClips.end - this.lineClips.start);
                  (this.scaledDistance = this.distance / this.totalDistance),
                    (this.lineSoFar =
                      e1 * this.lineClips.start + this.distance);
                } else this.lineSoFar = this.distance;
              }
              updateDistance(e1, t) {
                (this.distance += e1.dist(t)), this.updateScaledDistance();
              }
            }
            Is(_y, "LineBucket", {
              omit: ["layers", "patternFeatures"],
            });
            class gy {
              constructor(e1, t, i, r) {
                (this.context = e1),
                  (this.format = i),
                  (this.texture = e1.gl.createTexture()),
                  this.update(t, r);
              }
              update(e1, i, r) {
                const { width: n, height: o } = e1,
                  { context: s } = this,
                  { gl: a } = s,
                  {
                    HTMLImageElement: l,
                    HTMLCanvasElement: c,
                    HTMLVideoElement: h,
                    ImageData: u,
                    ImageBitmap: d,
                  } = t;
                if (
                  (a.bindTexture(a.TEXTURE_2D, this.texture),
                  s.pixelStoreUnpackFlipY.set(!1),
                  s.pixelStoreUnpack.set(1),
                  s.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === a.RGBA && (!i || !1 !== i.premultiply),
                  ),
                  r || (this.size && this.size[0] === n && this.size[1] === o))
                ) {
                  const { x: t, y: i } = r || {
                    x: 0,
                    y: 0,
                  };
                  if (
                    e1 instanceof l ||
                    e1 instanceof c ||
                    e1 instanceof h ||
                    e1 instanceof u ||
                    (d && e1 instanceof d)
                  )
                    a.texSubImage2D(
                      a.TEXTURE_2D,
                      0,
                      t,
                      i,
                      a.RGBA,
                      a.UNSIGNED_BYTE,
                      e1,
                    );
                  else {
                    let r = this.format,
                      s = a.UNSIGNED_BYTE;
                    this.format === a.R32F && ((r = a.RED), (s = a.FLOAT)),
                      a.texSubImage2D(
                        a.TEXTURE_2D,
                        0,
                        t,
                        i,
                        n,
                        o,
                        r,
                        s,
                        e1.data,
                      );
                  }
                } else if (
                  ((this.size = [n, o]),
                  e1 instanceof l ||
                    e1 instanceof c ||
                    e1 instanceof h ||
                    e1 instanceof u ||
                    (d && e1 instanceof d))
                ) {
                  let t = this.format;
                  this.format === a.R8 && (t = a.RED),
                    a.texImage2D(
                      a.TEXTURE_2D,
                      0,
                      this.format,
                      t,
                      a.UNSIGNED_BYTE,
                      e1,
                    );
                } else {
                  let t = this.format,
                    i = this.format,
                    r = a.UNSIGNED_BYTE;
                  this.format === a.DEPTH_COMPONENT &&
                    ((t = a.DEPTH_COMPONENT16), (r = a.UNSIGNED_SHORT)),
                    this.format === a.R32F && ((r = a.FLOAT), (i = a.RED)),
                    a.texImage2D(a.TEXTURE_2D, 0, t, n, o, 0, i, r, e1.data);
                }
                (this.useMipmap = Boolean(i && i.useMipmap)),
                  this.useMipmap && a.generateMipmap(a.TEXTURE_2D);
              }
              bind(e1, t) {
                const { context: i } = this,
                  { gl: r } = i;
                r.bindTexture(r.TEXTURE_2D, this.texture),
                  e1 !== this.minFilter &&
                    (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, e1),
                    r.texParameteri(
                      r.TEXTURE_2D,
                      r.TEXTURE_MIN_FILTER,
                      this.useMipmap
                        ? e1 === r.NEAREST
                          ? r.NEAREST_MIPMAP_NEAREST
                          : r.LINEAR_MIPMAP_NEAREST
                        : e1,
                    ),
                    (this.minFilter = e1)),
                  t !== this.wrapS &&
                    (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, t),
                    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, t),
                    (this.wrapS = t));
              }
              bindExtraParam(e1, t, i, r) {
                const { context: n } = this,
                  { gl: o } = n;
                o.bindTexture(o.TEXTURE_2D, this.texture),
                  t !== this.magFilter &&
                    (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, t),
                    (this.magFilter = t)),
                  e1 !== this.minFilter &&
                    (o.texParameteri(
                      o.TEXTURE_2D,
                      o.TEXTURE_MIN_FILTER,
                      this.useMipmap
                        ? e1 === o.NEAREST
                          ? o.NEAREST_MIPMAP_NEAREST
                          : o.LINEAR_MIPMAP_NEAREST
                        : e1,
                    ),
                    (this.minFilter = e1)),
                  i !== this.wrapS &&
                    (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, i),
                    (this.wrapS = i)),
                  r !== this.wrapT &&
                    (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, r),
                    (this.wrapT = r));
              }
              destroy() {
                const { gl: e1 } = this.context;
                e1.deleteTexture(this.texture), (this.texture = null);
              }
            }
            class yy {
              constructor(e1, t) {
                (this.context = e1), (this.texture = t);
              }
              bind(e1, t) {
                const { context: i } = this,
                  { gl: r } = i;
                r.bindTexture(r.TEXTURE_2D, this.texture),
                  e1 !== this.minFilter &&
                    (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, e1),
                    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, e1),
                    (this.minFilter = e1)),
                  t !== this.wrapS &&
                    (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, t),
                    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, t),
                    (this.wrapS = t));
              }
            }
            const xy = 32,
              vy = 33,
              by = new Uint16Array(8184);
            for (let e1 = 0; e1 < 2046; e1++) {
              let t = e1 + 2,
                i = 0,
                r = 0,
                n = 0,
                o = 0,
                s = 0,
                a = 0;
              for (
                1 & t ? (n = o = s = xy) : (i = r = a = xy);
                (t >>= 1) > 1;

              ) {
                const e1 = (i + n) >> 1,
                  l = (r + o) >> 1;
                1 & t
                  ? ((n = i), (o = r), (i = s), (r = a))
                  : ((i = n), (r = o), (n = s), (o = a)),
                  (s = e1),
                  (a = l);
              }
              const l = 4 * e1;
              (by[l + 0] = i),
                (by[l + 1] = r),
                (by[l + 2] = n),
                (by[l + 3] = o);
            }
            const wy = new Uint16Array(2178),
              Ty = new Uint8Array(1089),
              Ey = new Uint16Array(1089);
            function My(e1) {
              return 0 === e1 ? -0.03125 : 32 === e1 ? 0.03125 : 0;
            }
            var Ay = ba([
              {
                name: "a_pos",
                type: "Int16",
                components: 2,
              },
              {
                name: "a_texture_pos",
                type: "Int16",
                components: 2,
              },
            ]);
            const Sy = {
              type: 2,
              extent: sr,
              loadGeometry: () => [
                [
                  new y(0, 0),
                  new y(sr + 1, 0),
                  new y(sr + 1, sr + 1),
                  new y(0, sr + 1),
                  new y(0, 0),
                ],
              ],
            };
            class Iy {
              constructor(e1, t, i, r, n) {
                (this.tileID = e1),
                  (this.uid = F()),
                  (this.uses = 0),
                  (this.tileSize = t),
                  (this.tileZoom = i),
                  (this.buckets = {}),
                  (this.expirationTime = null),
                  (this.queryPadding = 0),
                  (this.hasSymbolBuckets = !1),
                  (this.hasRTLText = !1),
                  (this.dependencies = {}),
                  (this.isRaster = n),
                  r &&
                    r.style &&
                    (this._lastUpdatedBrightness = r.style.getBrightness()),
                  (this.expiredRequestCount = 0),
                  (this.state = "loading"),
                  r &&
                    r.transform &&
                    (this.projection = r.transform.projection);
              }
              registerFadeDuration(e1) {
                const t = e1 + this.timeAdded;
                t < ht.now() ||
                  (this.fadeEndTime && t < this.fadeEndTime) ||
                  (this.fadeEndTime = t);
              }
              wasRequested() {
                return (
                  "errored" === this.state ||
                  "loaded" === this.state ||
                  "reloading" === this.state
                );
              }
              get tileTransform() {
                return (
                  this._tileTransform ||
                    (this._tileTransform = Tg(
                      this.tileID.canonical,
                      this.projection,
                    )),
                  this._tileTransform
                );
              }
              loadVectorData(e1, t, i) {
                if ((this.unloadVectorData(), (this.state = "loaded"), e1)) {
                  e1.featureIndex &&
                    ((this.latestFeatureIndex = e1.featureIndex),
                    e1.rawTileData
                      ? ((this.latestRawTileData = e1.rawTileData),
                        (this.latestFeatureIndex.rawTileData = e1.rawTileData))
                      : this.latestRawTileData &&
                        (this.latestFeatureIndex.rawTileData =
                          this.latestRawTileData)),
                    (this.collisionBoxArray = e1.collisionBoxArray),
                    (this.buckets = (function (e1, t) {
                      const i = {};
                      if (!t) return i;
                      for (const r of e1) {
                        const e1 = r.layerIds
                          .map((e1) => t.getLayer(e1))
                          .filter(Boolean);
                        if (0 !== e1.length) {
                          (r.layers = e1),
                            r.stateDependentLayerIds &&
                              (r.stateDependentLayers =
                                r.stateDependentLayerIds.map(
                                  (t) => e1.filter((e1) => e1.id === t)[0],
                                ));
                          for (const t of e1) i[t.fqid] = r;
                        }
                      }
                      return i;
                    })(e1.buckets, t.style)),
                    (this.hasSymbolBuckets = !1);
                  for (const e1 in this.buckets) {
                    const t = this.buckets[e1];
                    if (t instanceof cy) {
                      if (((this.hasSymbolBuckets = !0), !i)) break;
                      t.justReloaded = !0;
                    }
                  }
                  if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                    for (const e1 in this.buckets) {
                      const t = this.buckets[e1];
                      if (t instanceof cy && t.hasRTLText) {
                        (this.hasRTLText = !0),
                          Qs.isLoading() ||
                            Qs.isLoaded() ||
                            "deferred" !== Ks() ||
                            Js();
                        break;
                      }
                    }
                  this.queryPadding = 0;
                  for (const e1 in this.buckets) {
                    const i = this.buckets[e1],
                      r = t.style.getOwnLayer(e1);
                    if (!r) continue;
                    const n = r.queryRadius(i);
                    this.queryPadding = Math.max(this.queryPadding, n);
                  }
                  e1.imageAtlas && (this.imageAtlas = e1.imageAtlas),
                    e1.glyphAtlasImage &&
                      (this.glyphAtlasImage = e1.glyphAtlasImage),
                    e1.lineAtlas && (this.lineAtlas = e1.lineAtlas),
                    (this._lastUpdatedBrightness = e1.brightness);
                } else this.collisionBoxArray = new el();
              }
              unloadVectorData() {
                if (this.hasData()) {
                  for (const e1 in this.buckets) this.buckets[e1].destroy();
                  (this.buckets = {}),
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                    this._tileBoundsBuffer &&
                      (this._tileBoundsBuffer.destroy(),
                      this._tileBoundsIndexBuffer.destroy(),
                      this._tileBoundsSegments.destroy(),
                      (this._tileBoundsBuffer = null)),
                    this._tileDebugBuffer &&
                      (this._tileDebugBuffer.destroy(),
                      this._tileDebugSegments.destroy(),
                      (this._tileDebugBuffer = null)),
                    this._tileDebugIndexBuffer &&
                      (this._tileDebugIndexBuffer.destroy(),
                      (this._tileDebugIndexBuffer = null)),
                    this._globeTileDebugBorderBuffer &&
                      (this._globeTileDebugBorderBuffer.destroy(),
                      (this._globeTileDebugBorderBuffer = null)),
                    this._tileDebugTextBuffer &&
                      (this._tileDebugTextBuffer.destroy(),
                      this._tileDebugTextSegments.destroy(),
                      this._tileDebugTextIndexBuffer.destroy(),
                      (this._tileDebugTextBuffer = null)),
                    this._globeTileDebugTextBuffer &&
                      (this._globeTileDebugTextBuffer.destroy(),
                      (this._globeTileDebugTextBuffer = null)),
                    (this.latestFeatureIndex = null),
                    (this.state = "unloaded");
                }
              }
              getBucket(e1) {
                return this.buckets[e1.fqid];
              }
              upload(e1) {
                for (const t in this.buckets) {
                  const i = this.buckets[t];
                  i.uploadPending() && i.upload(e1);
                }
                const t = e1.gl;
                this.imageAtlas &&
                  !this.imageAtlas.uploaded &&
                  ((this.imageAtlasTexture = new gy(
                    e1,
                    this.imageAtlas.image,
                    t.RGBA,
                  )),
                  (this.imageAtlas.uploaded = !0)),
                  this.glyphAtlasImage &&
                    ((this.glyphAtlasTexture = new gy(
                      e1,
                      this.glyphAtlasImage,
                      t.ALPHA,
                    )),
                    (this.glyphAtlasImage = null)),
                  this.lineAtlas &&
                    !this.lineAtlas.uploaded &&
                    ((this.lineAtlasTexture = new gy(
                      e1,
                      this.lineAtlas.image,
                      t.ALPHA,
                    )),
                    (this.lineAtlas.uploaded = !0));
              }
              prepare(e1, t, i) {
                if (
                  (this.imageAtlas &&
                    this.imageAtlas.patchUpdatedImages(
                      e1,
                      this.imageAtlasTexture,
                      i,
                    ),
                  !t ||
                    !this.latestFeatureIndex ||
                    !this.latestFeatureIndex.rawTileData)
                )
                  return;
                const r = t.style.getBrightness();
                (this._lastUpdatedBrightness || r) &&
                  ((this._lastUpdatedBrightness &&
                    r &&
                    Math.abs(this._lastUpdatedBrightness - r) < 0.001) ||
                    ((this._lastUpdatedBrightness = r),
                    this.updateBuckets(void 0, t)));
              }
              queryRenderedFeatures(e1, t, i, r, n, o, s, a) {
                return this.latestFeatureIndex &&
                  this.latestFeatureIndex.rawTileData
                  ? this.latestFeatureIndex.query(
                      {
                        tileResult: r,
                        pixelPosMatrix: s,
                        transform: o,
                        params: n,
                        tileTransform: this.tileTransform,
                      },
                      e1,
                      t,
                      i,
                    )
                  : {};
              }
              querySourceFeatures(e1, t) {
                const i = this.latestFeatureIndex;
                if (!i || !i.rawTileData) return;
                const r = i.loadVTLayers(),
                  n = t ? t.sourceLayer : "",
                  o = r._geojsonTileLayer || r[n];
                if (!o) return;
                const s = Ro(t && t.filter),
                  { z: a, x: l, y: c } = this.tileID.canonical,
                  h = {
                    z: a,
                    x: l,
                    y: c,
                  };
                for (let t = 0; t < o.length; t++) {
                  const r = o.feature(t);
                  if (s.needGeometry) {
                    const e1 = cp(r, !0);
                    if (
                      !s.filter(
                        new ea(this.tileID.overscaledZ),
                        e1,
                        this.tileID.canonical,
                      )
                    )
                      continue;
                  } else if (!s.filter(new ea(this.tileID.overscaledZ), r))
                    continue;
                  const u = i.getId(r, n),
                    d = new Cm(r, a, l, c, u);
                  (d.tile = h), e1.push(d);
                }
              }
              hasData() {
                return (
                  "loaded" === this.state ||
                  "reloading" === this.state ||
                  "expired" === this.state
                );
              }
              bucketsLoaded() {
                for (const e1 in this.buckets)
                  if (this.buckets[e1].uploadPending()) return !1;
                return !0;
              }
              patternsLoaded() {
                return (
                  !!this.imageAtlas &&
                  !!Object.keys(this.imageAtlas.patternPositions).length
                );
              }
              setExpiryData(e1) {
                const t = this.expirationTime;
                if (e1.cacheControl) {
                  const t = ee(e1.cacheControl);
                  t["max-age"] &&
                    (this.expirationTime = Date.now() + 1e3 * t["max-age"]);
                } else
                  e1.expires &&
                    (this.expirationTime = new Date(e1.expires).getTime());
                if (this.expirationTime) {
                  const e1 = Date.now();
                  let i = !1;
                  if (this.expirationTime > e1) i = !1;
                  else if (t) {
                    if (this.expirationTime < t) i = !0;
                    else {
                      const r = this.expirationTime - t;
                      r
                        ? (this.expirationTime = e1 + Math.max(r, 3e4))
                        : (i = !0);
                    }
                  } else i = !0;
                  i
                    ? (this.expiredRequestCount++, (this.state = "expired"))
                    : (this.expiredRequestCount = 0);
                }
              }
              getExpiryTimeout() {
                if (this.expirationTime)
                  return this.expiredRequestCount
                    ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                    : Math.min(
                        this.expirationTime - new Date().getTime(),
                        Math.pow(2, 31) - 1,
                      );
              }
              setFeatureState(e1, t) {
                this.latestFeatureIndex &&
                  this.latestFeatureIndex.rawTileData &&
                  0 !== Object.keys(e1).length &&
                  t &&
                  this.updateBuckets(e1, t);
              }
              updateBuckets(e1, t) {
                if (!this.latestFeatureIndex) return;
                const i = this.latestFeatureIndex.loadVTLayers(),
                  r = t.style.listImages(),
                  n = t.style.getBrightness();
                for (const o in this.buckets) {
                  if (!t.style.hasLayer(o)) continue;
                  const s = this.buckets[o],
                    a = s.layers[0].sourceLayer || "_geojsonTileLayer",
                    l = i[a];
                  let c = {};
                  if (
                    e1 &&
                    ((c = e1[a]), !l || !c || 0 === Object.keys(c).length)
                  )
                    continue;
                  if (
                    (s.update(
                      c,
                      l,
                      r,
                      (this.imageAtlas && this.imageAtlas.patternPositions) ||
                        {},
                      n,
                    ),
                    s instanceof _y || s instanceof Lf)
                  ) {
                    const e1 = t.style.getOwnSourceCache(s.layers[0].source);
                    t._terrain &&
                      t._terrain.enabled &&
                      e1 &&
                      s.programConfigurations.needsUpload &&
                      t._terrain._clearRenderCacheForTile(e1.id, this.tileID);
                  }
                  const h = t && t.style && t.style.getOwnLayer(o);
                  h &&
                    (this.queryPadding = Math.max(
                      this.queryPadding,
                      h.queryRadius(s),
                    ));
                }
              }
              holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
              }
              symbolFadeFinished() {
                return (
                  !this.symbolFadeHoldUntil ||
                  this.symbolFadeHoldUntil < ht.now()
                );
              }
              clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
              }
              setHoldDuration(e1) {
                this.symbolFadeHoldUntil = ht.now() + e1;
              }
              setTexture(e1, t) {
                const i = t.context,
                  r = i.gl;
                (this.texture = this.texture || t.getTileTexture(e1.width)),
                  this.texture
                    ? this.texture.update(e1, {
                        useMipmap: !0,
                      })
                    : ((this.texture = new gy(i, e1, r.RGBA, {
                        useMipmap: !0,
                      })),
                      this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
              }
              setDependencies(e1, t) {
                const i = {};
                for (const e1 of t) i[e1] = !0;
                this.dependencies[e1] = i;
              }
              hasDependency(e1, t) {
                for (const i of e1) {
                  const e1 = this.dependencies[i];
                  if (e1) {
                    for (const i of t) if (e1[i]) return !0;
                  }
                }
                return !1;
              }
              clearQueryDebugViz() {}
              _makeDebugTileBoundsBuffers(e1, t) {
                if (!t || "mercator" === t.name || this._tileDebugBuffer)
                  return;
                const i = lp(Sy, this.tileID.canonical, this.tileTransform)[0],
                  r = new Ta(),
                  n = new Wa();
                for (let e1 = 0; e1 < i.length; e1++) {
                  const { x: t, y: o } = i[e1];
                  r.emplaceBack(t, o), n.emplaceBack(e1);
                }
                n.emplaceBack(0),
                  (this._tileDebugIndexBuffer = e1.createIndexBuffer(n)),
                  (this._tileDebugBuffer = e1.createVertexBuffer(
                    r,
                    Pu.members,
                  )),
                  (this._tileDebugSegments = dl.simpleSegment(
                    0,
                    0,
                    r.length,
                    n.length,
                  ));
              }
              _makeTileBoundsBuffers(e1, t) {
                if (this._tileBoundsBuffer || !t || "mercator" === t.name)
                  return;
                const i = lp(Sy, this.tileID.canonical, this.tileTransform)[0];
                let r, n;
                if (this.isRaster) {
                  const e1 = (function (e1, t) {
                    const i = Tg(e1, t),
                      r = Math.pow(2, e1.z);
                    for (let n = 0; n < vy; n++)
                      for (let o = 0; o < vy; o++) {
                        const s = $d((e1.x + (o + My(o)) / xy) / r),
                          a = Hd((e1.y + (n + My(n)) / xy) / r),
                          l = t.project(s, a),
                          c = n * vy + o;
                        (wy[2 * c + 0] = Math.round(
                          (l.x * i.scale - i.x) * sr,
                        )),
                          (wy[2 * c + 1] = Math.round(
                            (l.y * i.scale - i.y) * sr,
                          ));
                      }
                    Ty.fill(0), Ey.fill(0);
                    for (let e1 = 2045; e1 >= 0; e1--) {
                      const t = 4 * e1,
                        i = by[t + 0],
                        r = by[t + 1],
                        n = by[t + 2],
                        o = by[t + 3],
                        s = (i + n) >> 1,
                        a = (r + o) >> 1,
                        l = s + a - r,
                        c = a + i - s,
                        h = r * vy + i,
                        u = o * vy + n,
                        d = a * vy + s,
                        p =
                          Math.hypot(
                            (wy[2 * h + 0] + wy[2 * u + 0]) / 2 - wy[2 * d + 0],
                            (wy[2 * h + 1] + wy[2 * u + 1]) / 2 - wy[2 * d + 1],
                          ) >= 16;
                      (Ty[d] = Ty[d] || (p ? 1 : 0)),
                        e1 < 1022 &&
                          (Ty[d] =
                            Ty[d] ||
                            Ty[((r + c) >> 1) * vy + ((i + l) >> 1)] ||
                            Ty[((o + c) >> 1) * vy + ((n + l) >> 1)]);
                    }
                    const n = new Ma(),
                      o = new Va();
                    let s = 0;
                    function a(e1, t) {
                      const i = t * vy + e1;
                      return (
                        0 === Ey[i] &&
                          (n.emplaceBack(
                            wy[2 * i + 0],
                            wy[2 * i + 1],
                            (e1 * sr) / xy,
                            (t * sr) / xy,
                          ),
                          (Ey[i] = ++s)),
                        Ey[i] - 1
                      );
                    }
                    function l(e1, t, i, r, n, s) {
                      const c = (e1 + i) >> 1,
                        h = (t + r) >> 1;
                      if (
                        Math.abs(e1 - n) + Math.abs(t - s) > 1 &&
                        Ty[h * vy + c]
                      )
                        l(n, s, e1, t, c, h), l(i, r, n, s, c, h);
                      else {
                        const l = a(e1, t),
                          c = a(i, r),
                          h = a(n, s);
                        o.emplaceBack(l, c, h);
                      }
                    }
                    return (
                      l(0, 0, xy, xy, xy, 0),
                      l(xy, xy, 0, 0, 0, xy),
                      {
                        vertices: n,
                        indices: o,
                      }
                    );
                  })(this.tileID.canonical, t);
                  (r = e1.vertices), (n = e1.indices);
                } else {
                  (r = new Ma()), (n = new Va());
                  for (const { x: e1, y: t } of i) r.emplaceBack(e1, t, 0, 0);
                  const e1 = Cf(r.int16, void 0, 4);
                  for (let t = 0; t < e1.length; t += 3)
                    n.emplaceBack(e1[t], e1[t + 1], e1[t + 2]);
                }
                (this._tileBoundsBuffer = e1.createVertexBuffer(r, Ay.members)),
                  (this._tileBoundsIndexBuffer = e1.createIndexBuffer(n)),
                  (this._tileBoundsSegments = dl.simpleSegment(
                    0,
                    0,
                    r.length,
                    n.length,
                  ));
              }
              _makeGlobeTileDebugBuffers(e1, t) {
                const i = t.projection;
                if (!i || "globe" !== i.name || t.freezeTileCoverage) return;
                const r = this.tileID.canonical,
                  n = xd(cd(r, t)),
                  o = Ed(t.zoom);
                let s;
                o > 0 && (s = xu.invert(new Float64Array(16), t.globeMatrix)),
                  this._makeGlobeTileDebugBorderBuffer(e1, r, t, n, s, o),
                  this._makeGlobeTileDebugTextBuffer(e1, r, t, n, s, o);
              }
              _globePoint(e1, t, i, r, n, o, s) {
                let a = _d(e1, t, i);
                if (o) {
                  const n = 1 << i.z,
                    l = Gd(r.center.lng),
                    c = qd(r.center.lat),
                    h = (i.x + 0.5) / n - l;
                  let u = 0;
                  h > 0.5 ? (u = -1) : h < -0.5 && (u = 1);
                  let d = (e1 / sr + i.x) / n + u,
                    p = (t / sr + i.y) / n;
                  (d = (d - l) * r._pixelsPerMercatorPixel + l),
                    (p = (p - c) * r._pixelsPerMercatorPixel + c);
                  const f = [d * r.worldSize, p * r.worldSize, 0];
                  Mu.transformMat4(f, f, o), (a = ld(a, f, s));
                }
                return Mu.transformMat4(a, a, n);
              }
              _makeGlobeTileDebugBorderBuffer(e1, t, i, r, n, o) {
                const s = new Ta(),
                  a = new Wa(),
                  l = new Ea(),
                  c = (e1, c, h, u, d) => {
                    const p = (h - e1) / (d - 1),
                      f = (u - c) / (d - 1),
                      m = s.length;
                    for (let h = 0; h < d; h++) {
                      const u = e1 + h * p,
                        d = c + h * f;
                      s.emplaceBack(u, d);
                      const _ = this._globePoint(u, d, t, i, r, n, o);
                      l.emplaceBack(_[0], _[1], _[2]), a.emplaceBack(m + h);
                    }
                  },
                  h = sr;
                c(0, 0, h, 0, 16),
                  c(h, 0, h, h, 16),
                  c(h, h, 0, h, 16),
                  c(0, h, 0, 0, 16),
                  (this._tileDebugIndexBuffer = e1.createIndexBuffer(a)),
                  (this._tileDebugBuffer = e1.createVertexBuffer(
                    s,
                    Pu.members,
                  )),
                  (this._globeTileDebugBorderBuffer = e1.createVertexBuffer(
                    l,
                    Du.members,
                  )),
                  (this._tileDebugSegments = dl.simpleSegment(
                    0,
                    0,
                    s.length,
                    a.length,
                  ));
              }
              _makeGlobeTileDebugTextBuffer(e1, t, i, r, n, o) {
                const s = sr / 4,
                  a = new Ta(),
                  l = new Va(),
                  c = new Ea(),
                  h = 25;
                l.reserve(32), a.reserve(h), c.reserve(h);
                const u = (e1, t) => h * e1 + t;
                for (let e1 = 0; e1 < h; e1++) {
                  const l = e1 * s;
                  for (let e1 = 0; e1 < h; e1++) {
                    const h = e1 * s;
                    a.emplaceBack(h, l);
                    const u = this._globePoint(h, l, t, i, r, n, o);
                    c.emplaceBack(u[0], u[1], u[2]);
                  }
                }
                for (let e1 = 0; e1 < 4; e1++)
                  for (let t = 0; t < 4; t++) {
                    const i = u(e1, t),
                      r = u(e1, t + 1),
                      n = u(e1 + 1, t),
                      o = u(e1 + 1, t + 1);
                    l.emplaceBack(i, r, n), l.emplaceBack(n, r, o);
                  }
                (this._tileDebugTextIndexBuffer = e1.createIndexBuffer(l)),
                  (this._tileDebugTextBuffer = e1.createVertexBuffer(
                    a,
                    Pu.members,
                  )),
                  (this._globeTileDebugTextBuffer = e1.createVertexBuffer(
                    c,
                    Du.members,
                  )),
                  (this._tileDebugTextSegments = dl.simpleSegment(0, 0, h, 32));
              }
            }
            class Cy {
              constructor(e1, t) {
                (this.max = e1), (this.onRemove = t), this.reset();
              }
              reset() {
                for (const e1 in this.data)
                  for (const t of this.data[e1])
                    t.timeout && clearTimeout(t.timeout),
                      this.onRemove(t.value);
                return (this.data = {}), (this.order = []), this;
              }
              add(e1, t, i) {
                const r = e1.wrapped().key;
                void 0 === this.data[r] && (this.data[r] = []);
                const n = {
                  value: t,
                  timeout: void 0,
                };
                if (
                  (void 0 !== i &&
                    (n.timeout = setTimeout(() => {
                      this.remove(e1, n);
                    }, i)),
                  this.data[r].push(n),
                  this.order.push(r),
                  this.order.length > this.max)
                ) {
                  const e1 = this._getAndRemoveByKey(this.order[0]);
                  e1 && this.onRemove(e1);
                }
                return this;
              }
              has(e1) {
                return e1.wrapped().key in this.data;
              }
              getAndRemove(e1) {
                return this.has(e1)
                  ? this._getAndRemoveByKey(e1.wrapped().key)
                  : null;
              }
              _getAndRemoveByKey(e1) {
                const t = this.data[e1].shift();
                return (
                  t.timeout && clearTimeout(t.timeout),
                  0 === this.data[e1].length && delete this.data[e1],
                  this.order.splice(this.order.indexOf(e1), 1),
                  t.value
                );
              }
              getByKey(e1) {
                const t = this.data[e1];
                return t ? t[0].value : null;
              }
              get(e1) {
                return this.has(e1)
                  ? this.data[e1.wrapped().key][0].value
                  : null;
              }
              remove(e1, t) {
                if (!this.has(e1)) return this;
                const i = e1.wrapped().key,
                  r = void 0 === t ? 0 : this.data[i].indexOf(t),
                  n = this.data[i][r];
                return (
                  this.data[i].splice(r, 1),
                  n.timeout && clearTimeout(n.timeout),
                  0 === this.data[i].length && delete this.data[i],
                  this.onRemove(n.value),
                  this.order.splice(this.order.indexOf(i), 1),
                  this
                );
              }
              setMaxSize(e1) {
                for (this.max = e1; this.order.length > this.max; ) {
                  const e1 = this._getAndRemoveByKey(this.order[0]);
                  e1 && this.onRemove(e1);
                }
                return this;
              }
              filter(e1) {
                const t = [];
                for (const i in this.data)
                  for (const r of this.data[i]) e1(r.value) || t.push(r);
                for (const e1 of t) this.remove(e1.value.tileID, e1);
              }
            }
            class zy {
              constructor(e1, t, i, r) {
                (this.id = zy.uniqueIdxCounter),
                  zy.uniqueIdxCounter++,
                  (this.context = e1);
                const n = e1.gl;
                (this.buffer = n.createBuffer()),
                  (this.dynamicDraw = Boolean(i)),
                  this.context.unbindVAO(),
                  e1.bindElementBuffer.set(this.buffer),
                  n.bufferData(
                    n.ELEMENT_ARRAY_BUFFER,
                    t.arrayBuffer,
                    this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW,
                  ),
                  this.dynamicDraw || r || t.destroy();
              }
              bind() {
                this.context.bindElementBuffer.set(this.buffer);
              }
              updateData(e1) {
                (this.id = zy.uniqueIdxCounter), zy.uniqueIdxCounter++;
                const t = this.context.gl;
                this.context.unbindVAO(),
                  this.bind(),
                  t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e1.arrayBuffer);
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            zy.uniqueIdxCounter = 0;
            const Dy = {
              Int8: "BYTE",
              Uint8: "UNSIGNED_BYTE",
              Int16: "SHORT",
              Uint16: "UNSIGNED_SHORT",
              Int32: "INT",
              Uint32: "UNSIGNED_INT",
              Float32: "FLOAT",
            };
            class Py {
              constructor(e1, t, i, r, n, o) {
                (this.length = t.length),
                  (this.attributes = i),
                  (this.itemSize = t.bytesPerElement),
                  (this.dynamicDraw = r),
                  (this.instanceCount = o),
                  (this.context = e1);
                const s = e1.gl;
                (this.buffer = s.createBuffer()),
                  e1.bindVertexBuffer.set(this.buffer),
                  s.bufferData(
                    s.ARRAY_BUFFER,
                    t.arrayBuffer,
                    this.dynamicDraw ? s.DYNAMIC_DRAW : s.STATIC_DRAW,
                  ),
                  this.dynamicDraw || n || t.destroy();
              }
              bind() {
                this.context.bindVertexBuffer.set(this.buffer);
              }
              updateData(e1) {
                const t = this.context.gl;
                this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e1.arrayBuffer);
              }
              enableAttributes(e1, t) {
                for (let i = 0; i < this.attributes.length; i++) {
                  const r = t.attributes[this.attributes[i].name];
                  void 0 !== r && e1.enableVertexAttribArray(r);
                }
              }
              setVertexAttribPointers(e1, t, i) {
                for (let r = 0; r < this.attributes.length; r++) {
                  const n = this.attributes[r],
                    o = t.attributes[n.name];
                  void 0 !== o &&
                    e1.vertexAttribPointer(
                      o,
                      n.components,
                      e1[Dy[n.type]],
                      !1,
                      this.itemSize,
                      n.offset + this.itemSize * (i || 0),
                    );
                }
              }
              setVertexAttribDivisor(e1, t, i) {
                for (let r = 0; r < this.attributes.length; r++) {
                  const n = t.attributes[this.attributes[r].name];
                  void 0 !== n &&
                    this.instanceCount &&
                    this.instanceCount > 0 &&
                    e1.vertexAttribDivisor(n, i);
                }
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            class Ry {
              constructor(e1) {
                (this.gl = e1.gl),
                  (this.default = this.getDefault()),
                  (this.current = this.default),
                  (this.dirty = !1);
              }
              get() {
                return this.current;
              }
              set(e1) {}
              getDefault() {
                return this.default;
              }
              setDefault() {
                this.set(this.default);
              }
            }
            class Ly extends Ry {
              getDefault() {
                return li.transparent;
              }
              set(e1) {
                const t = this.current;
                (e1.r !== t.r ||
                  e1.g !== t.g ||
                  e1.b !== t.b ||
                  e1.a !== t.a ||
                  this.dirty) &&
                  (this.gl.clearColor(e1.r, e1.g, e1.b, e1.a),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class ky extends Ry {
              getDefault() {
                return 1;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.clearDepth(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Oy extends Ry {
              getDefault() {
                return 0;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.clearStencil(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class By extends Ry {
              getDefault() {
                return [!0, !0, !0, !0];
              }
              set(e1) {
                const t = this.current;
                (e1[0] !== t[0] ||
                  e1[1] !== t[1] ||
                  e1[2] !== t[2] ||
                  e1[3] !== t[3] ||
                  this.dirty) &&
                  (this.gl.colorMask(e1[0], e1[1], e1[2], e1[3]),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Fy extends Ry {
              getDefault() {
                return !0;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.depthMask(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Ny extends Ry {
              getDefault() {
                return 255;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.stencilMask(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Uy extends Ry {
              getDefault() {
                return {
                  func: this.gl.ALWAYS,
                  ref: 0,
                  mask: 255,
                };
              }
              set(e1) {
                const t = this.current;
                (e1.func !== t.func ||
                  e1.ref !== t.ref ||
                  e1.mask !== t.mask ||
                  this.dirty) &&
                  (this.gl.stencilFunc(e1.func, e1.ref, e1.mask),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Vy extends Ry {
              getDefault() {
                const e1 = this.gl;
                return [e1.KEEP, e1.KEEP, e1.KEEP];
              }
              set(e1) {
                const t = this.current;
                (e1[0] !== t[0] ||
                  e1[1] !== t[1] ||
                  e1[2] !== t[2] ||
                  this.dirty) &&
                  (this.gl.stencilOp(e1[0], e1[1], e1[2]),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class jy extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                e1 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class Gy extends Ry {
              getDefault() {
                return [0, 1];
              }
              set(e1) {
                const t = this.current;
                (e1[0] !== t[0] || e1[1] !== t[1] || this.dirty) &&
                  (this.gl.depthRange(e1[0], e1[1]),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class qy extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                e1 ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class Zy extends Ry {
              getDefault() {
                return this.gl.LESS;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.depthFunc(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class $y extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                e1 ? t.enable(t.BLEND) : t.disable(t.BLEND),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class Hy extends Ry {
              getDefault() {
                const e1 = this.gl;
                return [e1.ONE, e1.ZERO, e1.ONE, e1.ZERO];
              }
              set(e1) {
                const t = this.current;
                (e1[0] !== t[0] ||
                  e1[1] !== t[1] ||
                  e1[2] !== t[2] ||
                  e1[3] !== t[3] ||
                  this.dirty) &&
                  (this.gl.blendFuncSeparate(e1[0], e1[1], e1[2], e1[3]),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Wy extends Ry {
              getDefault() {
                return li.transparent;
              }
              set(e1) {
                const t = this.current;
                (e1.r !== t.r ||
                  e1.g !== t.g ||
                  e1.b !== t.b ||
                  e1.a !== t.a ||
                  this.dirty) &&
                  (this.gl.blendColor(e1.r, e1.g, e1.b, e1.a),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Xy extends Ry {
              getDefault() {
                return this.gl.FUNC_ADD;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.blendEquationSeparate(e1, e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Yy extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                e1 ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class Ky extends Ry {
              getDefault() {
                return this.gl.BACK;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.cullFace(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class Jy extends Ry {
              getDefault() {
                return this.gl.CCW;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.frontFace(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            let Qy = class extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.useProgram(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            };
            class ex extends Ry {
              getDefault() {
                return this.gl.TEXTURE0;
              }
              set(e1) {
                (e1 !== this.current || this.dirty) &&
                  (this.gl.activeTexture(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class tx extends Ry {
              getDefault() {
                const e1 = this.gl;
                return [0, 0, e1.drawingBufferWidth, e1.drawingBufferHeight];
              }
              set(e1) {
                const t = this.current;
                (e1[0] !== t[0] ||
                  e1[1] !== t[1] ||
                  e1[2] !== t[2] ||
                  e1[3] !== t[3] ||
                  this.dirty) &&
                  (this.gl.viewport(e1[0], e1[1], e1[2], e1[3]),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class ix extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.bindFramebuffer(t.FRAMEBUFFER, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class rx extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.bindRenderbuffer(t.RENDERBUFFER, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class nx extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.bindTexture(t.TEXTURE_2D, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class ox extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.bindBuffer(t.ARRAY_BUFFER, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class sx extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                const t = this.gl;
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class ax extends Ry {
              getDefault() {
                return null;
              }
              set(e1) {
                this.gl &&
                  (e1 !== this.current || this.dirty) &&
                  (this.gl.bindVertexArray(e1),
                  (this.current = e1),
                  (this.dirty = !1));
              }
            }
            class lx extends Ry {
              getDefault() {
                return 4;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.pixelStorei(t.UNPACK_ALIGNMENT, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class cx extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class hx extends Ry {
              getDefault() {
                return !1;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t = this.gl;
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e1),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class ux extends Ry {
              constructor(e1, t) {
                super(e1), (this.context = e1), (this.parent = t);
              }
              getDefault() {
                return null;
              }
            }
            class dx extends ux {
              setDirty() {
                this.dirty = !0;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t = this.gl;
                t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_2D,
                  e1,
                  0,
                ),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class px extends ux {
              attachment() {
                return this.gl.DEPTH_ATTACHMENT;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t = this.gl;
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  this.attachment(),
                  t.RENDERBUFFER,
                  e1,
                ),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class fx extends ux {
              attachment() {
                return this.gl.DEPTH_ATTACHMENT;
              }
              set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t = this.gl;
                t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  this.attachment(),
                  t.TEXTURE_2D,
                  e1,
                  0,
                ),
                  (this.current = e1),
                  (this.dirty = !1);
              }
            }
            class mx extends px {
              attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
              }
            }
            class _x {
              constructor(e1, t, i, r, n) {
                (this.context = e1), (this.width = t), (this.height = i);
                const o = (this.framebuffer = e1.gl.createFramebuffer());
                r && (this.colorAttachment = new dx(e1, o)),
                  n &&
                    ((this.depthAttachmentType = n),
                    (this.depthAttachment =
                      "renderbuffer" === n ? new px(e1, o) : new fx(e1, o)));
              }
              destroy() {
                const e1 = this.context.gl;
                if (this.colorAttachment) {
                  const t = this.colorAttachment.get();
                  t && e1.deleteTexture(t);
                }
                if (this.depthAttachment && this.depthAttachmentType) {
                  if ("renderbuffer" === this.depthAttachmentType) {
                    const t = this.depthAttachment.get();
                    t && e1.deleteRenderbuffer(t);
                  } else {
                    const t = this.depthAttachment.get();
                    t && e1.deleteTexture(t);
                  }
                }
                e1.deleteFramebuffer(this.framebuffer);
              }
            }
            class gx {
              constructor(e1, t, i) {
                (this.func = e1), (this.mask = t), (this.range = i);
              }
            }
            (gx.ReadOnly = !1),
              (gx.ReadWrite = !0),
              (gx.disabled = new gx(519, gx.ReadOnly, [0, 1]));
            const yx = 7680;
            class xx {
              constructor(e1, t, i, r, n, o) {
                (this.test = e1),
                  (this.ref = t),
                  (this.mask = i),
                  (this.fail = r),
                  (this.depthFail = n),
                  (this.pass = o);
              }
            }
            xx.disabled = new xx(
              {
                func: 519,
                mask: 0,
              },
              0,
              0,
              yx,
              yx,
              yx,
            );
            const vx = 771;
            class bx {
              constructor(e1, t, i, r) {
                (this.blendFunction = e1),
                  (this.blendColor = t),
                  (this.mask = i),
                  (this.blendEquation = r);
              }
            }
            (bx.Replace = [1, 0, 1, 0]),
              (bx.disabled = new bx(bx.Replace, li.transparent, [
                !1,
                !1,
                !1,
                !1,
              ])),
              (bx.unblended = new bx(bx.Replace, li.transparent, [
                !0,
                !0,
                !0,
                !0,
              ])),
              (bx.alphaBlended = new bx([1, vx, 1, vx], li.transparent, [
                !0,
                !0,
                !0,
                !0,
              ])),
              (bx.multiply = new bx([774, 0, 774, 0], li.transparent, [
                !0,
                !0,
                !0,
                !0,
              ]));
            const wx = 1029,
              Tx = 2305;
            class Ex {
              constructor(e1, t, i) {
                (this.enable = e1), (this.mode = t), (this.frontFace = i);
              }
            }
            (Ex.disabled = new Ex(!1, wx, Tx)),
              (Ex.backCCW = new Ex(!0, wx, Tx)),
              (Ex.backCW = new Ex(!0, wx, 2304)),
              (Ex.frontCW = new Ex(!0, 1028, 2304)),
              (Ex.frontCCW = new Ex(!0, 1028, Tx));
            class Mx {
              constructor(e1) {
                (this.gl = e1),
                  (this.clearColor = new Ly(this)),
                  (this.clearDepth = new ky(this)),
                  (this.clearStencil = new Oy(this)),
                  (this.colorMask = new By(this)),
                  (this.depthMask = new Fy(this)),
                  (this.stencilMask = new Ny(this)),
                  (this.stencilFunc = new Uy(this)),
                  (this.stencilOp = new Vy(this)),
                  (this.stencilTest = new jy(this)),
                  (this.depthRange = new Gy(this)),
                  (this.depthTest = new qy(this)),
                  (this.depthFunc = new Zy(this)),
                  (this.blend = new $y(this)),
                  (this.blendFunc = new Hy(this)),
                  (this.blendColor = new Wy(this)),
                  (this.blendEquation = new Xy(this)),
                  (this.cullFace = new Yy(this)),
                  (this.cullFaceSide = new Ky(this)),
                  (this.frontFace = new Jy(this)),
                  (this.program = new Qy(this)),
                  (this.activeTexture = new ex(this)),
                  (this.viewport = new tx(this)),
                  (this.bindFramebuffer = new ix(this)),
                  (this.bindRenderbuffer = new rx(this)),
                  (this.bindTexture = new nx(this)),
                  (this.bindVertexBuffer = new ox(this)),
                  (this.bindElementBuffer = new sx(this)),
                  (this.bindVertexArrayOES = new ax(this)),
                  (this.pixelStoreUnpack = new lx(this)),
                  (this.pixelStoreUnpackPremultiplyAlpha = new cx(this)),
                  (this.pixelStoreUnpackFlipY = new hx(this)),
                  (this.extTextureFilterAnisotropic =
                    e1.getExtension("EXT_texture_filter_anisotropic") ||
                    e1.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    e1.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                  this.extTextureFilterAnisotropic &&
                    (this.extTextureFilterAnisotropicMax = e1.getParameter(
                      this.extTextureFilterAnisotropic
                        .MAX_TEXTURE_MAX_ANISOTROPY_EXT,
                    )),
                  (this.extTextureFilterAnisotropicForceOff = !1),
                  (this.extStandardDerivativesForceOff = !1),
                  (this.extDebugRendererInfo = e1.getExtension(
                    "WEBGL_debug_renderer_info",
                  )),
                  this.extDebugRendererInfo &&
                    ((this.renderer = e1.getParameter(
                      this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL,
                    )),
                    (this.vendor = e1.getParameter(
                      this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL,
                    ))),
                  (this.extTextureFloatLinear = e1.getExtension(
                    "OES_texture_float_linear",
                  )),
                  (this.extRenderToTextureHalfFloat = e1.getExtension(
                    "EXT_color_buffer_half_float",
                  )),
                  (this.extTimerQuery = e1.getExtension(
                    "EXT_disjoint_timer_query_webgl2",
                  )),
                  (this.maxTextureSize = e1.getParameter(e1.MAX_TEXTURE_SIZE));
              }
              setDefault() {
                this.unbindVAO(),
                  this.clearColor.setDefault(),
                  this.clearDepth.setDefault(),
                  this.clearStencil.setDefault(),
                  this.colorMask.setDefault(),
                  this.depthMask.setDefault(),
                  this.stencilMask.setDefault(),
                  this.stencilFunc.setDefault(),
                  this.stencilOp.setDefault(),
                  this.stencilTest.setDefault(),
                  this.depthRange.setDefault(),
                  this.depthTest.setDefault(),
                  this.depthFunc.setDefault(),
                  this.blend.setDefault(),
                  this.blendFunc.setDefault(),
                  this.blendColor.setDefault(),
                  this.blendEquation.setDefault(),
                  this.cullFace.setDefault(),
                  this.cullFaceSide.setDefault(),
                  this.frontFace.setDefault(),
                  this.program.setDefault(),
                  this.activeTexture.setDefault(),
                  this.bindFramebuffer.setDefault(),
                  this.pixelStoreUnpack.setDefault(),
                  this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.pixelStoreUnpackFlipY.setDefault();
              }
              setDirty() {
                (this.clearColor.dirty = !0),
                  (this.clearDepth.dirty = !0),
                  (this.clearStencil.dirty = !0),
                  (this.colorMask.dirty = !0),
                  (this.depthMask.dirty = !0),
                  (this.stencilMask.dirty = !0),
                  (this.stencilFunc.dirty = !0),
                  (this.stencilOp.dirty = !0),
                  (this.stencilTest.dirty = !0),
                  (this.depthRange.dirty = !0),
                  (this.depthTest.dirty = !0),
                  (this.depthFunc.dirty = !0),
                  (this.blend.dirty = !0),
                  (this.blendFunc.dirty = !0),
                  (this.blendColor.dirty = !0),
                  (this.blendEquation.dirty = !0),
                  (this.cullFace.dirty = !0),
                  (this.cullFaceSide.dirty = !0),
                  (this.frontFace.dirty = !0),
                  (this.program.dirty = !0),
                  (this.activeTexture.dirty = !0),
                  (this.viewport.dirty = !0),
                  (this.bindFramebuffer.dirty = !0),
                  (this.bindRenderbuffer.dirty = !0),
                  (this.bindTexture.dirty = !0),
                  (this.bindVertexBuffer.dirty = !0),
                  (this.bindElementBuffer.dirty = !0),
                  (this.bindVertexArrayOES.dirty = !0),
                  (this.pixelStoreUnpack.dirty = !0),
                  (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                  (this.pixelStoreUnpackFlipY.dirty = !0);
              }
              createIndexBuffer(e1, t, i) {
                return new zy(this, e1, t, i);
              }
              createVertexBuffer(e1, t, i, r, n) {
                return new Py(this, e1, t, i, r, n);
              }
              createRenderbuffer(e1, t, i) {
                const r = this.gl,
                  n = r.createRenderbuffer();
                return (
                  this.bindRenderbuffer.set(n),
                  r.renderbufferStorage(r.RENDERBUFFER, e1, t, i),
                  this.bindRenderbuffer.set(null),
                  n
                );
              }
              createFramebuffer(e1, t, i, r) {
                return new _x(this, e1, t, i, r);
              }
              clear({ color: e1, depth: t, stencil: i, colorMask: r }) {
                const n = this.gl;
                let o = 0;
                e1 &&
                  ((o |= n.COLOR_BUFFER_BIT),
                  this.clearColor.set(e1),
                  this.colorMask.set(r || [!0, !0, !0, !0])),
                  void 0 !== t &&
                    ((o |= n.DEPTH_BUFFER_BIT),
                    this.depthRange.set([0, 1]),
                    this.clearDepth.set(t),
                    this.depthMask.set(!0)),
                  void 0 !== i &&
                    ((o |= n.STENCIL_BUFFER_BIT),
                    this.clearStencil.set(i),
                    this.stencilMask.set(255)),
                  n.clear(o);
              }
              setCullFace(e1) {
                !1 === e1.enable
                  ? this.cullFace.set(!1)
                  : (this.cullFace.set(!0),
                    this.cullFaceSide.set(e1.mode),
                    this.frontFace.set(e1.frontFace));
              }
              setDepthMode(e1) {
                e1.func !== this.gl.ALWAYS || e1.mask
                  ? (this.depthTest.set(!0),
                    this.depthFunc.set(e1.func),
                    this.depthMask.set(e1.mask),
                    this.depthRange.set(e1.range))
                  : this.depthTest.set(!1);
              }
              setStencilMode(e1) {
                e1.test.func !== this.gl.ALWAYS || e1.mask
                  ? (this.stencilTest.set(!0),
                    this.stencilMask.set(e1.mask),
                    this.stencilOp.set([e1.fail, e1.depthFail, e1.pass]),
                    this.stencilFunc.set({
                      func: e1.test.func,
                      ref: e1.ref,
                      mask: e1.test.mask,
                    }))
                  : this.stencilTest.set(!1);
              }
              setColorMode(e1) {
                x(e1.blendFunction, bx.Replace)
                  ? this.blend.set(!1)
                  : (this.blend.set(!0),
                    this.blendFunc.set(e1.blendFunction),
                    this.blendColor.set(e1.blendColor),
                    e1.blendEquation
                      ? this.blendEquation.set(e1.blendEquation)
                      : this.blendEquation.setDefault()),
                  this.colorMask.set(e1.mask);
              }
              unbindVAO() {
                this.bindVertexArrayOES.set(null);
              }
            }
            class Ax extends It {
              constructor(e1, t, i) {
                super(),
                  (this.id = e1),
                  (this._onlySymbols = i),
                  t.on("data", (e1) => {
                    "source" === e1.dataType &&
                      "metadata" === e1.sourceDataType &&
                      (this._sourceLoaded = !0),
                      this._sourceLoaded &&
                        !this._paused &&
                        "source" === e1.dataType &&
                        "content" === e1.sourceDataType &&
                        (this.reload(),
                        this.transform && this.update(this.transform));
                  }),
                  t.on("error", () => {
                    this._sourceErrored = !0;
                  }),
                  (this._source = t),
                  (this._tiles = {}),
                  (this._cache = new Cy(0, this._unloadTile.bind(this))),
                  (this._timers = {}),
                  (this._cacheTimers = {}),
                  (this._minTileCacheSize = t.minTileCacheSize),
                  (this._maxTileCacheSize = t.maxTileCacheSize),
                  (this._loadedParentTiles = {}),
                  (this.castsShadows = !1),
                  (this._coveredTiles = {}),
                  (this._shadowCasterTiles = {}),
                  (this._state = new zm()),
                  (this._isRaster =
                    "raster" === this._source.type ||
                    "raster-dem" === this._source.type ||
                    ("custom" === this._source.type &&
                      "raster" === this._source._dataType));
              }
              onAdd(e1) {
                (this.map = e1),
                  (this._minTileCacheSize =
                    void 0 === this._minTileCacheSize && e1
                      ? e1._minTileCacheSize
                      : this._minTileCacheSize),
                  (this._maxTileCacheSize =
                    void 0 === this._maxTileCacheSize && e1
                      ? e1._maxTileCacheSize
                      : this._maxTileCacheSize);
              }
              loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for (const e1 in this._tiles) {
                  const t = this._tiles[e1];
                  if (
                    "errored" !== t.state &&
                    ("loaded" !== t.state || !t.bucketsLoaded())
                  )
                    return !1;
                }
                return !0;
              }
              getSource() {
                return this._source;
              }
              pause() {
                this._paused = !0;
              }
              resume() {
                if (!this._paused) return;
                const e1 = this._shouldReloadOnResume;
                (this._paused = !1),
                  (this._shouldReloadOnResume = !1),
                  e1 && this.reload(),
                  this.transform && this.update(this.transform);
              }
              _loadTile(e1, t) {
                return (
                  (e1.isSymbolTile = this._onlySymbols),
                  (e1.isExtraShadowCaster =
                    this._shadowCasterTiles[e1.tileID.key]),
                  this._source.loadTile(e1, t)
                );
              }
              _unloadTile(e1) {
                if (this._source.unloadTile)
                  return this._source.unloadTile(e1, () => {});
              }
              _abortTile(e1) {
                if (this._source.abortTile)
                  return this._source.abortTile(e1, () => {});
              }
              serialize() {
                return this._source.serialize();
              }
              prepare(e1) {
                this._source.prepare && this._source.prepare(),
                  this._state.coalesceChanges(
                    this._tiles,
                    this.map ? this.map.painter : null,
                  );
                for (const t in this._tiles) {
                  const i = this._tiles[t];
                  i.upload(e1),
                    i.prepare(
                      this.map.style.imageManager,
                      this.map ? this.map.painter : null,
                      this._source.scope,
                    );
                }
              }
              getIds() {
                return L(this._tiles)
                  .map((e1) => e1.tileID)
                  .sort(Sx)
                  .map((e1) => e1.key);
              }
              getRenderableIds(e1, t) {
                const i = [];
                for (const r in this._tiles)
                  this._isIdRenderable(+r, e1, t) && i.push(this._tiles[r]);
                return e1
                  ? i
                      .sort((e1, t) => {
                        const i = e1.tileID,
                          r = t.tileID,
                          n = new y(i.canonical.x, i.canonical.y)._rotate(
                            this.transform.angle,
                          ),
                          o = new y(r.canonical.x, r.canonical.y)._rotate(
                            this.transform.angle,
                          );
                        return (
                          i.overscaledZ - r.overscaledZ ||
                          o.y - n.y ||
                          o.x - n.x
                        );
                      })
                      .map((e1) => e1.tileID.key)
                  : i
                      .map((e1) => e1.tileID)
                      .sort(Sx)
                      .map((e1) => e1.key);
              }
              hasRenderableParent(e1) {
                const t = this.findLoadedParent(e1, 0);
                return !!t && this._isIdRenderable(t.tileID.key);
              }
              _isIdRenderable(e1, t, i) {
                return (
                  this._tiles[e1] &&
                  this._tiles[e1].hasData() &&
                  !this._coveredTiles[e1] &&
                  (t || !this._tiles[e1].holdingForFade()) &&
                  (i || !this._shadowCasterTiles[e1])
                );
              }
              reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                  this._cache.reset();
                  for (const e1 in this._tiles)
                    "errored" !== this._tiles[e1].state &&
                      this._reloadTile(+e1, "reloading");
                }
              }
              _reloadTile(e1, t) {
                const i = this._tiles[e1];
                i &&
                  ("loading" !== i.state && (i.state = t),
                  this._loadTile(i, this._tileLoaded.bind(this, i, e1, t)));
              }
              _tileLoaded(e1, t, i, r) {
                if (r) {
                  if (((e1.state = "errored"), 404 !== r.status))
                    this._source.fire(
                      new St(r, {
                        tile: e1,
                      }),
                    );
                  else if (
                    "raster-dem" === this._source.type &&
                    this.usedForTerrain &&
                    this.map.painter.terrain
                  ) {
                    const e1 = this.map.painter.terrain;
                    this.update(this.transform, e1.getScaledDemTileSize(), !0),
                      e1.resetTileLookupCache(this.id);
                  } else this.update(this.transform);
                } else
                  (e1.timeAdded = ht.now()),
                    "expired" === i && (e1.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(t, e1),
                    "raster-dem" === this._source.type &&
                      e1.dem &&
                      this._backfillDEM(e1),
                    this._state.initializeTileState(
                      e1,
                      this.map ? this.map.painter : null,
                    ),
                    this._source.fire(
                      new At("data", {
                        dataType: "source",
                        tile: e1,
                        coord: e1.tileID,
                        sourceCacheId: this.id,
                      }),
                    );
              }
              _backfillDEM(e1) {
                const t = this.getRenderableIds();
                for (let r = 0; r < t.length; r++) {
                  const n = t[r];
                  if (e1.neighboringTiles && e1.neighboringTiles[n]) {
                    const t = this.getTileByID(n);
                    i(e1, t), i(t, e1);
                  }
                }
                function i(e1, t) {
                  if (!e1.dem || e1.dem.borderReady) return;
                  (e1.needsHillshadePrepare = !0),
                    (e1.needsDEMTextureUpload = !0);
                  let i = t.tileID.canonical.x - e1.tileID.canonical.x;
                  const r = t.tileID.canonical.y - e1.tileID.canonical.y,
                    n = Math.pow(2, e1.tileID.canonical.z),
                    o = t.tileID.key;
                  (0 === i && 0 === r) ||
                    Math.abs(r) > 1 ||
                    (Math.abs(i) > 1 &&
                      (1 === Math.abs(i + n)
                        ? (i += n)
                        : 1 === Math.abs(i - n) && (i -= n)),
                    t.dem &&
                      e1.dem &&
                      (e1.dem.backfillBorder(t.dem, i, r),
                      e1.neighboringTiles &&
                        e1.neighboringTiles[o] &&
                        (e1.neighboringTiles[o].backfilled = !0)));
                }
              }
              getTile(e1) {
                return this.getTileByID(e1.key);
              }
              getTileByID(e1) {
                return this._tiles[e1];
              }
              _retainLoadedChildren(e1, t, i, r) {
                for (const n in this._tiles) {
                  let o = this._tiles[n];
                  if (
                    r[n] ||
                    !o.hasData() ||
                    o.tileID.overscaledZ <= t ||
                    o.tileID.overscaledZ > i
                  )
                    continue;
                  let s = o.tileID;
                  for (; o && o.tileID.overscaledZ > t + 1; ) {
                    const e1 = o.tileID.scaledTo(o.tileID.overscaledZ - 1);
                    (o = this._tiles[e1.key]), o && o.hasData() && (s = e1);
                  }
                  let a = s;
                  for (; a.overscaledZ > t; )
                    if (((a = a.scaledTo(a.overscaledZ - 1)), e1[a.key])) {
                      r[s.key] = s;
                      break;
                    }
                }
              }
              findLoadedParent(e1, t) {
                if (e1.key in this._loadedParentTiles) {
                  const i = this._loadedParentTiles[e1.key];
                  return i && i.tileID.overscaledZ >= t ? i : null;
                }
                for (let i = e1.overscaledZ - 1; i >= t; i--) {
                  const t = e1.scaledTo(i),
                    r = this._getLoadedTile(t);
                  if (r) return r;
                }
              }
              _getLoadedTile(e1) {
                const t = this._tiles[e1.key];
                return t && t.hasData()
                  ? t
                  : this._cache.getByKey(
                      this._source.reparseOverscaled
                        ? e1.wrapped().key
                        : e1.canonical.key,
                    );
              }
              updateCacheSize(e1, t) {
                t = t || this._source.tileSize;
                const i = Math.ceil(e1.width / t) + 1,
                  r = Math.ceil(e1.height / t) + 1,
                  n = Math.floor(i * r * 5),
                  o =
                    "number" == typeof this._minTileCacheSize
                      ? Math.max(this._minTileCacheSize, n)
                      : n,
                  s =
                    "number" == typeof this._maxTileCacheSize
                      ? Math.min(this._maxTileCacheSize, o)
                      : o;
                this._cache.setMaxSize(s);
              }
              handleWrapJump(e1) {
                const t = Math.round(
                  (e1 - (void 0 === this._prevLng ? e1 : this._prevLng)) / 360,
                );
                if (((this._prevLng = e1), t)) {
                  const e1 = {};
                  for (const i in this._tiles) {
                    const r = this._tiles[i];
                    (r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t)),
                      (e1[r.tileID.key] = r);
                  }
                  this._tiles = e1;
                  for (const e1 in this._timers)
                    clearTimeout(this._timers[e1]), delete this._timers[e1];
                  for (const e1 in this._tiles)
                    this._setTileReloadTimer(+e1, this._tiles[e1]);
                }
              }
              update(e1, t, i, r) {
                if (
                  ((this.transform = e1),
                  !this._sourceLoaded ||
                    this._paused ||
                    this.transform.freezeTileCoverage)
                )
                  return;
                if (this.usedForTerrain && !i) return;
                let n;
                if (
                  (this.updateCacheSize(e1, t),
                  "globe" !== this.transform.projection.name &&
                    this.handleWrapJump(this.transform.center.lng),
                  (this._shadowCasterTiles = {}),
                  (this._coveredTiles = {}),
                  this.used || this.usedForTerrain
                    ? this._source.tileID
                      ? (n = e1
                          .getVisibleUnwrappedCoordinates(this._source.tileID)
                          .map(
                            (e1) =>
                              new Bu(
                                e1.canonical.z,
                                e1.wrap,
                                e1.canonical.z,
                                e1.canonical.x,
                                e1.canonical.y,
                              ),
                          ))
                      : ((n = e1.coveringTiles({
                          tileSize: t || this._source.tileSize,
                          minzoom: this._source.minzoom,
                          maxzoom: this._source.maxzoom,
                          roundZoom: this._source.roundZoom && !i,
                          reparseOverscaled: this._source.reparseOverscaled,
                          isTerrainDEM: this.usedForTerrain,
                        })),
                        this._source.hasTile &&
                          (n = n.filter((e1) => this._source.hasTile(e1))))
                    : (n = []),
                  n.length > 0 &&
                    this.castsShadows &&
                    r &&
                    "globe" !== this.transform.projection.name &&
                    !this.usedForTerrain &&
                    !Ix(this._source.type))
                ) {
                  const o = e1.coveringZoomLevel({
                      tileSize: t || this._source.tileSize,
                      roundZoom: this._source.roundZoom && !i,
                    }),
                    s = Math.min(o, this._source.maxzoom),
                    a = e1.extendTileCoverForShadows(n, r, s);
                  for (const e1 of a)
                    (this._shadowCasterTiles[e1.key] = !0), n.push(e1);
                }
                const o = this._updateRetainedTiles(n);
                if (Ix(this._source.type) && 0 !== n.length) {
                  const e1 = {},
                    t = {},
                    i = Object.keys(o);
                  for (const r of i) {
                    const i = o[r],
                      n = this._tiles[r];
                    if (!n || (n.fadeEndTime && n.fadeEndTime <= ht.now()))
                      continue;
                    const s = this.findLoadedParent(
                      i,
                      Math.max(
                        i.overscaledZ - Ax.maxOverzooming,
                        this._source.minzoom,
                      ),
                    );
                    s &&
                      (this._addTile(s.tileID), (e1[s.tileID.key] = s.tileID)),
                      (t[r] = i);
                  }
                  const r = n[n.length - 1].overscaledZ;
                  for (const e1 in this._tiles) {
                    const i = this._tiles[e1];
                    if (o[e1] || !i.hasData()) continue;
                    let n = i.tileID;
                    for (; n.overscaledZ > r; ) {
                      n = n.scaledTo(n.overscaledZ - 1);
                      const r = this._tiles[n.key];
                      if (r && r.hasData() && t[n.key]) {
                        o[e1] = i.tileID;
                        break;
                      }
                    }
                  }
                  for (const t in e1)
                    o[t] || ((this._coveredTiles[t] = !0), (o[t] = e1[t]));
                }
                for (const e1 in o) this._tiles[e1].clearFadeHold();
                const s = (function (e1, t) {
                  const i = [];
                  for (const r in e1) r in t || i.push(r);
                  return i;
                })(this._tiles, o);
                for (const e1 of s) {
                  const t = this._tiles[e1];
                  t.hasSymbolBuckets && !t.holdingForFade()
                    ? t.setHoldDuration(this.map._fadeDuration)
                    : (t.hasSymbolBuckets && !t.symbolFadeFinished()) ||
                      this._removeTile(+e1);
                }
                this._updateLoadedParentTileCache(),
                  this._onlySymbols &&
                    this._source.afterUpdate &&
                    this._source.afterUpdate();
              }
              releaseSymbolFadeTiles() {
                for (const e1 in this._tiles)
                  this._tiles[e1].holdingForFade() && this._removeTile(+e1);
              }
              _updateRetainedTiles(e1) {
                const t = {};
                if (0 === e1.length) return t;
                const i = {},
                  r = e1.reduce((e1, t) => Math.min(e1, t.overscaledZ), 1 / 0),
                  n = e1[0].overscaledZ,
                  o = Math.max(n - Ax.maxOverzooming, this._source.minzoom),
                  s = Math.max(n + Ax.maxUnderzooming, this._source.minzoom),
                  a = {};
                for (const i of e1) {
                  const e1 = this._addTile(i);
                  (t[i.key] = i),
                    e1.hasData() ||
                      (r < this._source.maxzoom && (a[i.key] = i));
                }
                this._retainLoadedChildren(a, r, s, t);
                for (const r of e1) {
                  let e1 = this._tiles[r.key];
                  if (e1.hasData()) continue;
                  if (r.canonical.z >= this._source.maxzoom) {
                    const e1 = r.children(this._source.maxzoom)[0],
                      i = this.getTile(e1);
                    if (i && i.hasData()) {
                      t[e1.key] = e1;
                      continue;
                    }
                  } else {
                    const e1 = r.children(this._source.maxzoom);
                    if (
                      t[e1[0].key] &&
                      t[e1[1].key] &&
                      t[e1[2].key] &&
                      t[e1[3].key]
                    )
                      continue;
                  }
                  let n = e1.wasRequested();
                  for (let s = r.overscaledZ - 1; s >= o; --s) {
                    const o = r.scaledTo(s);
                    if (i[o.key]) break;
                    if (
                      ((i[o.key] = !0),
                      (e1 = this.getTile(o)),
                      !e1 && n && (e1 = this._addTile(o)),
                      e1 &&
                        ((t[o.key] = o), (n = e1.wasRequested()), e1.hasData()))
                    )
                      break;
                  }
                }
                return t;
              }
              _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const e1 in this._tiles) {
                  const t = [];
                  let i,
                    r = this._tiles[e1].tileID;
                  for (; r.overscaledZ > 0; ) {
                    if (r.key in this._loadedParentTiles) {
                      i = this._loadedParentTiles[r.key];
                      break;
                    }
                    t.push(r.key);
                    const e1 = r.scaledTo(r.overscaledZ - 1);
                    if (((i = this._getLoadedTile(e1)), i)) break;
                    r = e1;
                  }
                  for (const e1 of t) this._loadedParentTiles[e1] = i;
                }
              }
              _addTile(e1) {
                let t = this._tiles[e1.key];
                if (t)
                  return (
                    !0 !== t.isExtraShadowCaster ||
                      !!this._shadowCasterTiles[e1.key] ||
                      this._reloadTile(e1.key, "reloading"),
                    t
                  );
                (t = this._cache.getAndRemove(e1)),
                  t &&
                    (this._setTileReloadTimer(e1.key, t),
                    (t.tileID = e1),
                    this._state.initializeTileState(
                      t,
                      this.map ? this.map.painter : null,
                    ),
                    this._cacheTimers[e1.key] &&
                      (clearTimeout(this._cacheTimers[e1.key]),
                      delete this._cacheTimers[e1.key],
                      this._setTileReloadTimer(e1.key, t)));
                const i = Boolean(t);
                if (!i) {
                  const i = this.map ? this.map.painter : null;
                  (t = new Iy(
                    e1,
                    this._source.tileSize * e1.overscaleFactor(),
                    this.transform.tileZoom,
                    i,
                    this._isRaster,
                  )),
                    this._loadTile(
                      t,
                      this._tileLoaded.bind(this, t, e1.key, t.state),
                    );
                }
                return t
                  ? (t.uses++,
                    (this._tiles[e1.key] = t),
                    i ||
                      this._source.fire(
                        new At("dataloading", {
                          tile: t,
                          coord: t.tileID,
                          dataType: "source",
                        }),
                      ),
                    t)
                  : null;
              }
              _setTileReloadTimer(e1, t) {
                e1 in this._timers &&
                  (clearTimeout(this._timers[e1]), delete this._timers[e1]);
                const i = t.getExpiryTimeout();
                i &&
                  (this._timers[e1] = setTimeout(() => {
                    this._reloadTile(e1, "expired"), delete this._timers[e1];
                  }, i));
              }
              _removeTile(e1) {
                const t = this._tiles[e1];
                t &&
                  (t.uses--,
                  delete this._tiles[e1],
                  this._timers[e1] &&
                    (clearTimeout(this._timers[e1]), delete this._timers[e1]),
                  t.uses > 0 ||
                    (t.hasData() && "reloading" !== t.state
                      ? this._cache.add(t.tileID, t, t.getExpiryTimeout())
                      : ((t.aborted = !0),
                        this._abortTile(t),
                        this._unloadTile(t))));
              }
              clearTiles() {
                (this._shouldReloadOnResume = !1), (this._paused = !1);
                for (const e1 in this._tiles) this._removeTile(+e1);
                this._source._clear && this._source._clear(),
                  this._cache.reset(),
                  this.map &&
                    this.usedForTerrain &&
                    this.map.painter.terrain &&
                    this.map.painter.terrain.resetTileLookupCache(this.id);
              }
              tilesIn(e1, t, i) {
                const r = [],
                  n = this.transform;
                if (!n) return r;
                const o = "globe" === n.projection.name,
                  s = Gd(n.center.lng);
                for (const a in this._tiles) {
                  const l = this._tiles[a];
                  if ((i && l.clearQueryDebugViz(), l.holdingForFade()))
                    continue;
                  let c;
                  if (o) {
                    const e1 = l.tileID.canonical;
                    if (0 === e1.z) {
                      const t = [
                        Math.abs(z(s, ...Cx(e1, -1)) - s),
                        Math.abs(z(s, ...Cx(e1, 1)) - s),
                      ];
                      c = [0, 2 * t.indexOf(Math.min(...t)) - 1];
                    } else {
                      const t = [
                        Math.abs(z(s, ...Cx(e1, -1)) - s),
                        Math.abs(z(s, ...Cx(e1, 0)) - s),
                        Math.abs(z(s, ...Cx(e1, 1)) - s),
                      ];
                      c = [t.indexOf(Math.min(...t)) - 1];
                    }
                  } else c = [0];
                  for (const i of c) {
                    const o = e1.containsTile(l, n, t, i);
                    o && r.push(o);
                  }
                }
                return r;
              }
              getShadowCasterCoordinates() {
                return this._getRenderableCoordinates(!1, !0);
              }
              getVisibleCoordinates(e1) {
                return this._getRenderableCoordinates(e1);
              }
              _getRenderableCoordinates(e1, t) {
                const i = this.getRenderableIds(e1, t).map(
                  (e1) => this._tiles[e1].tileID,
                );
                for (const e1 of i)
                  e1.projMatrix = this.transform.calculateProjMatrix(
                    e1.toUnwrapped(),
                  );
                return i;
              }
              sortCoordinatesByDistance(e1) {
                const t = e1.slice(),
                  i = this.transform._camera.position,
                  r = this.transform._camera.forward(),
                  n = {};
                for (const e1 of t) {
                  const t = 1 / (1 << e1.canonical.z);
                  n[e1.key] =
                    ((e1.canonical.x + 0.5) * t + e1.wrap - i[0]) * r[0] +
                    ((e1.canonical.y + 0.5) * t - i[1]) * r[1] -
                    i[2] * r[2];
                }
                return t.sort((e1, t) => n[e1.key] - n[t.key]), t;
              }
              hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (Ix(this._source.type))
                  for (const e1 in this._tiles) {
                    const t = this._tiles[e1];
                    if (void 0 !== t.fadeEndTime && t.fadeEndTime >= ht.now())
                      return !0;
                  }
                return !1;
              }
              setFeatureState(e1, t, i) {
                this._state.updateState((e1 = e1 || "_geojsonTileLayer"), t, i);
              }
              removeFeatureState(e1, t, i) {
                this._state.removeFeatureState(
                  (e1 = e1 || "_geojsonTileLayer"),
                  t,
                  i,
                );
              }
              getFeatureState(e1, t) {
                return this._state.getState(
                  (e1 = e1 || "_geojsonTileLayer"),
                  t,
                );
              }
              setDependencies(e1, t, i) {
                const r = this._tiles[e1];
                r && r.setDependencies(t, i);
              }
              reloadTilesForDependencies(e1, t) {
                for (const i in this._tiles)
                  this._tiles[i].hasDependency(e1, t) &&
                    this._reloadTile(+i, "reloading");
                this._cache.filter((i) => !i.hasDependency(e1, t));
              }
              _preloadTiles(e1, t) {
                if (!this._sourceLoaded) {
                  const i = () => {
                    this._sourceLoaded &&
                      (this._source.off("data", i), this._preloadTiles(e1, t));
                  };
                  return void this._source.on("data", i);
                }
                const i = new Map(),
                  r = Array.isArray(e1) ? e1 : [e1],
                  n = this.map.painter.terrain,
                  o =
                    this.usedForTerrain && n
                      ? n.getScaledDemTileSize()
                      : this._source.tileSize;
                for (const e1 of r) {
                  const t = e1.coveringTiles({
                    tileSize: o,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !this.usedForTerrain,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain,
                  });
                  for (const e1 of t) i.set(e1.key, e1);
                  this.usedForTerrain && e1.updateElevation(!1);
                }
                R(
                  Array.from(i.values()),
                  (e1, t) => {
                    const i = new Iy(
                      e1,
                      this._source.tileSize * e1.overscaleFactor(),
                      this.transform.tileZoom,
                      this.map.painter,
                      this._isRaster,
                    );
                    this._loadTile(i, (e1) => {
                      "raster-dem" === this._source.type &&
                        i.dem &&
                        this._backfillDEM(i),
                        t(e1, i);
                    });
                  },
                  t,
                );
              }
            }
            function Sx(e1, t) {
              const i = Math.abs(2 * e1.wrap) - +(e1.wrap < 0),
                r = Math.abs(2 * t.wrap) - +(t.wrap < 0);
              return (
                e1.overscaledZ - t.overscaledZ ||
                r - i ||
                t.canonical.y - e1.canonical.y ||
                t.canonical.x - e1.canonical.x
              );
            }
            function Ix(e1) {
              return (
                "raster" === e1 ||
                "image" === e1 ||
                "video" === e1 ||
                "custom" === e1
              );
            }
            function Cx(e1, t) {
              const i = 1 << e1.z;
              return [e1.x / i + t, (e1.x + 1) / i + t];
            }
            (Ax.maxOverzooming = 10), (Ax.maxUnderzooming = 3);
            const zx = ba([
                {
                  name: "a_pos_3f",
                  components: 3,
                  type: "Float32",
                },
              ]),
              Dx = ba([
                {
                  name: "a_color_3f",
                  components: 3,
                  type: "Float32",
                },
              ]),
              Px = ba([
                {
                  name: "a_color_4f",
                  components: 4,
                  type: "Float32",
                },
              ]),
              Rx = ba([
                {
                  name: "a_uv_2f",
                  components: 2,
                  type: "Float32",
                },
              ]),
              Lx = ba([
                {
                  name: "a_normal_3f",
                  components: 3,
                  type: "Float32",
                },
              ]),
              kx = ba([
                {
                  name: "a_normal_matrix0",
                  components: 4,
                  type: "Float32",
                },
                {
                  name: "a_normal_matrix1",
                  components: 4,
                  type: "Float32",
                },
                {
                  name: "a_normal_matrix2",
                  components: 4,
                  type: "Float32",
                },
                {
                  name: "a_normal_matrix3",
                  components: 4,
                  type: "Float32",
                },
              ]),
              Ox = ba([
                {
                  name: "a_pbr",
                  components: 4,
                  type: "Uint16",
                },
                {
                  name: "a_heightBasedEmissiveStrength",
                  components: 3,
                  type: "Float32",
                },
              ]);
            class Bx {
              constructor(e1 = 0, t = 0, i = 0, r = 0) {
                if (
                  isNaN(e1) ||
                  e1 < 0 ||
                  isNaN(t) ||
                  t < 0 ||
                  isNaN(i) ||
                  i < 0 ||
                  isNaN(r) ||
                  r < 0
                )
                  throw new Error(
                    "Invalid value for edge-insets, top, bottom, left and right must all be numbers",
                  );
                (this.top = e1),
                  (this.bottom = t),
                  (this.left = i),
                  (this.right = r);
              }
              interpolate(e1, t, i) {
                return (
                  null != t.top &&
                    null != e1.top &&
                    (this.top = Wr(e1.top, t.top, i)),
                  null != t.bottom &&
                    null != e1.bottom &&
                    (this.bottom = Wr(e1.bottom, t.bottom, i)),
                  null != t.left &&
                    null != e1.left &&
                    (this.left = Wr(e1.left, t.left, i)),
                  null != t.right &&
                    null != e1.right &&
                    (this.right = Wr(e1.right, t.right, i)),
                  this
                );
              }
              getCenter(e1, t) {
                const i = z((this.left + e1 - this.right) / 2, 0, e1),
                  r = z((this.top + t - this.bottom) / 2, 0, t);
                return new y(i, r);
              }
              equals(e1) {
                return (
                  this.top === e1.top &&
                  this.bottom === e1.bottom &&
                  this.left === e1.left &&
                  this.right === e1.right
                );
              }
              clone() {
                return new Bx(this.top, this.bottom, this.left, this.right);
              }
              toJSON() {
                return {
                  top: this.top,
                  bottom: this.bottom,
                  left: this.left,
                  right: this.right,
                };
              }
            }
            function Fx(e1, t) {
              const i = ne(e1, 3);
              xu.fromQuat(e1, t), oe(e1, 3, i);
            }
            function Nx(e1, t) {
              const i = bu.identity([]);
              return bu.rotateZ(i, i, -t), bu.rotateX(i, i, -e1), i;
            }
            function Ux(e1, t) {
              const i = [e1[0], e1[1], 0],
                r = [t[0], t[1], 0];
              if (Mu.length(i) >= 1e-15) {
                const e1 = Mu.normalize([], i);
                Mu.scale(r, e1, Mu.dot(r, e1)), (t[0] = r[0]), (t[1] = r[1]);
              }
              const n = Mu.cross([], t, e1);
              if (Mu.len(n) < 1e-15) return null;
              const o = Math.atan2(-n[1], n[0]);
              return Nx(
                Math.atan2(Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]), -e1[2]),
                o,
              );
            }
            class Vx {
              constructor(e1, t) {
                (this.position = e1), (this.orientation = t);
              }
              get position() {
                return this._position;
              }
              set position(e1) {
                if (e1) {
                  const t = e1 instanceof ep ? e1 : new ep(e1[0], e1[1], e1[2]);
                  this._renderWorldCopies && (t.x = P(t.x, 0, 1)),
                    (this._position = t);
                } else this._position = null;
              }
              lookAtPoint(e1, t) {
                if (((this.orientation = null), !this.position)) return;
                const i = this.position,
                  r = this._elevation
                    ? this._elevation.getAtPointOrZero(ep.fromLngLat(e1))
                    : 0,
                  n = ep.fromLngLat(e1, r),
                  o = [n.x - i.x, n.y - i.y, n.z - i.z];
                t || (t = [0, 0, 1]),
                  (t[2] = Math.abs(t[2])),
                  (this.orientation = Ux(o, t));
              }
              setPitchBearing(e1, t) {
                this.orientation = Nx(w(e1), w(-t));
              }
            }
            class jx {
              constructor(e1, t) {
                (this._transform = xu.identity([])),
                  (this.orientation = t),
                  (this.position = e1);
              }
              get mercatorPosition() {
                const e1 = this.position;
                return new ep(e1[0], e1[1], e1[2]);
              }
              get position() {
                const e1 = ne(this._transform, 3);
                return [e1[0], e1[1], e1[2]];
              }
              set position(e1) {
                var t;
                e1 && oe(this._transform, 3, [(t = e1)[0], t[1], t[2], 1]);
              }
              get orientation() {
                return this._orientation;
              }
              set orientation(e1) {
                (this._orientation = e1 || bu.identity([])),
                  e1 && Fx(this._transform, this._orientation);
              }
              getPitchBearing() {
                const e1 = this.forward(),
                  t = this.right();
                return {
                  bearing: Math.atan2(-t[1], t[0]),
                  pitch: Math.atan2(
                    Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]),
                    -e1[2],
                  ),
                };
              }
              setPitchBearing(e1, t) {
                (this._orientation = Nx(e1, t)),
                  Fx(this._transform, this._orientation);
              }
              forward() {
                const e1 = ne(this._transform, 2);
                return [-e1[0], -e1[1], -e1[2]];
              }
              up() {
                const e1 = ne(this._transform, 1);
                return [-e1[0], -e1[1], -e1[2]];
              }
              right() {
                const e1 = ne(this._transform, 0);
                return [e1[0], e1[1], e1[2]];
              }
              getCameraToWorld(e1, t) {
                const i = new Float64Array(16);
                return xu.invert(i, this.getWorldToCamera(e1, t)), i;
              }
              getCameraToWorldMercator() {
                return this._transform;
              }
              getWorldToCameraPosition(e1, t, i) {
                const r = this.position;
                Mu.scale(r, r, -e1);
                const n = new Float64Array(16);
                return (
                  xu.fromScaling(n, [i, i, i]),
                  xu.translate(n, n, r),
                  (n[10] *= t),
                  n
                );
              }
              getWorldToCamera(e1, t) {
                const i = new Float64Array(16),
                  r = new Float64Array(4),
                  n = this.position;
                return (
                  bu.conjugate(r, this._orientation),
                  Mu.scale(n, n, -e1),
                  xu.fromQuat(i, r),
                  xu.translate(i, i, n),
                  (i[1] *= -1),
                  (i[5] *= -1),
                  (i[9] *= -1),
                  (i[13] *= -1),
                  (i[8] *= t),
                  (i[9] *= t),
                  (i[10] *= t),
                  (i[11] *= t),
                  i
                );
              }
              getCameraToClipPerspective(e1, t, i, r) {
                const n = new Float64Array(16);
                return xu.perspective(n, e1, t, i, r), n;
              }
              getCameraToClipOrthographic(e1, t, i, r, n, o) {
                const s = new Float64Array(16);
                return xu.ortho(s, e1, t, i, r, n, o), s;
              }
              getDistanceToElevation(e1, t = !1) {
                const i =
                    0 === e1
                      ? 0
                      : Zd(e1, t ? Hd(this.position[1]) : this.position[1]),
                  r = this.forward();
                return (i - this.position[2]) / r[2];
              }
              clone() {
                return new jx([...this.position], [...this.orientation]);
              }
            }
            function Gx(e1, t) {
              const i = Zx(e1.projection, e1.zoom, e1.width, e1.height),
                r = (function (e1, t, i, r, n) {
                  const o = new Nd(i.lng - 180 * $x, i.lat),
                    s = new Nd(i.lng + 180 * $x, i.lat),
                    a = e1.project(o.lng, o.lat),
                    l = e1.project(s.lng, s.lat),
                    c = -Math.atan2(l.y - a.y, l.x - a.x),
                    h = ep.fromLngLat(i);
                  h.y = z(h.y, -1 + $x, 1 - $x);
                  const u = h.toLngLat(),
                    d = e1.project(u.lng, u.lat),
                    p = ep.fromLngLat(u);
                  p.x += $x;
                  const f = p.toLngLat(),
                    m = e1.project(f.lng, f.lat),
                    _ = Wx(m.x - d.x, m.y - d.y, c),
                    g = ep.fromLngLat(u);
                  g.y += $x;
                  const y = g.toLngLat(),
                    x = e1.project(y.lng, y.lat),
                    v = Wx(x.x - d.x, x.y - d.y, c),
                    b = Math.abs(_.x) / Math.abs(v.y),
                    w = xu.identity([]);
                  xu.rotateZ(w, w, -c * (1 - (n ? 0 : r)));
                  const T = xu.identity([]);
                  return (
                    xu.scale(T, T, [1, 1 - (1 - b) * r, 1]),
                    (T[4] = (-v.x / v.y) * r),
                    xu.rotateZ(T, T, c),
                    xu.multiply(T, w, T),
                    T
                  );
                })(e1.projection, 0, e1.center, i, t),
                n = qx(e1);
              return xu.scale(r, r, [n, n, 1]), r;
            }
            function qx(e1) {
              const t = e1.projection,
                i = Zx(e1.projection, e1.zoom, e1.width, e1.height),
                r = Hx(t, e1.center),
                n = Hx(t, Nd.convert(t.center));
              return Math.pow(2, r * i + (1 - i) * n);
            }
            function Zx(e1, t, i, r, n = 1 / 0) {
              const o = e1.range;
              if (!o) return 0;
              const s = Math.min(n, Math.max(i, r)),
                a = Math.log(s / 1024) / Math.LN2;
              return D(o[0] + a, o[1] + a, t);
            }
            const $x = 1 / 4e4;
            function Hx(e1, t) {
              const i = z(t.lat, -Xd, Xd),
                r = new Nd(t.lng - 180 * $x, i),
                n = new Nd(t.lng + 180 * $x, i),
                o = e1.project(r.lng, i),
                s = e1.project(n.lng, i),
                a = ep.fromLngLat(r),
                l = ep.fromLngLat(n),
                c = s.x - o.x,
                h = s.y - o.y,
                u = l.x - a.x,
                d = l.y - a.y,
                p = Math.sqrt((u * u + d * d) / (c * c + h * h));
              return Math.log(p) / Math.LN2;
            }
            function Wx(e1, t, i) {
              const r = Math.cos(i),
                n = Math.sin(i);
              return {
                x: e1 * r - t * n,
                y: e1 * n + t * r,
              };
            }
            function Xx(e1, t, i) {
              return (
                t *
                (sr / (e1.tileSize * Math.pow(2, i - e1.tileID.overscaledZ)))
              );
            }
            const Yx = {
                unknown: 0,
                flipRequired: 1,
                flipNotRequired: 2,
              },
              Kx = Math.tan((85 * Math.PI) / 180);
            function Jx(e1, t, i, r, n, o, s) {
              const a = xu.create();
              if (i) {
                if ("globe" === o.name) {
                  const e1 = (function (e1, t) {
                    const { x: i, y: r } = e1.point,
                      n = Td(
                        i,
                        r,
                        e1.worldSize / e1._pixelsPerMercatorPixel,
                        0,
                        0,
                      );
                    return xu.multiply(n, n, vd(ad(t)));
                  })(n, t);
                  xu.multiply(a, a, e1);
                } else {
                  const e1 = fu.invert([], s);
                  (a[0] = e1[0]),
                    (a[1] = e1[1]),
                    (a[4] = e1[2]),
                    (a[5] = e1[3]),
                    r || xu.rotateZ(a, a, n.angle);
                }
              } else xu.multiply(a, n.labelPlaneMatrix, e1);
              return a;
            }
            function Qx(e1, t, i, r, n, o, s) {
              const a = Jx(e1, t, i, r, n, o, s);
              return (
                ("globe" === o.name && i) || (a[2] = a[6] = a[10] = a[14] = 0),
                a
              );
            }
            function ev(e1, t, i, r, n, o, s) {
              if (i) {
                if ("globe" === o.name) {
                  const a = Jx(e1, t, i, r, n, o, s);
                  return xu.invert(a, a), xu.multiply(a, e1, a), a;
                }
                {
                  const t = xu.clone(e1),
                    i = xu.identity([]);
                  return (
                    (i[0] = s[0]),
                    (i[1] = s[1]),
                    (i[4] = s[2]),
                    (i[5] = s[3]),
                    xu.multiply(t, t, i),
                    r || xu.rotateZ(t, t, -n.angle),
                    t
                  );
                }
              }
              return n.glCoordMatrix;
            }
            function tv(e1, t, i, r) {
              const n = [e1, t, i, 1];
              i ? uu.transformMat4(n, n, r) : dv(n, n, r);
              const o = n[3];
              return (n[0] /= o), (n[1] /= o), (n[2] /= o), n;
            }
            function iv(e1, t) {
              return Math.min(0.5 + (e1 / t) * 0.5, 1.5);
            }
            function rv(e1, t) {
              const i = e1[0] / e1[3],
                r = e1[1] / e1[3];
              return i >= -t[0] && i <= t[0] && r >= -t[1] && r <= t[1];
            }
            function nv(e1, t, i, r, n, o, s, a, l, c) {
              const h = i.transform,
                u = r ? e1.textSizeData : e1.iconSizeData,
                d = a_(u, i.transform.zoom),
                p = "globe" === h.projection.name,
                f = [(256 / i.width) * 2 + 1, (256 / i.height) * 2 + 1],
                m = r
                  ? e1.text.dynamicLayoutVertexArray
                  : e1.icon.dynamicLayoutVertexArray;
              m.clear();
              let _ = null;
              p &&
                (_ = r
                  ? e1.text.globeExtVertexArray
                  : e1.icon.globeExtVertexArray);
              const g = e1.lineVertexArray,
                x = r ? e1.text.placedSymbolArray : e1.icon.placedSymbolArray,
                v = i.transform.width / i.transform.height;
              let b,
                w = !1;
              for (let r = 0; r < x.length; r++) {
                const p = x.get(r),
                  { numGlyphs: T, writingMode: E } = p;
                if (
                  (E !== w_.vertical || w || b === w_.horizontal || (w = !0),
                  (b = E),
                  (p.hidden || E === w_.vertical) && !w)
                ) {
                  uv(T, m);
                  continue;
                }
                w = !1;
                const M = new y(p.tileAnchorX, p.tileAnchorY);
                let {
                  x: A,
                  y: S,
                  z: I,
                } = h.projection.projectTilePoint(M.x, M.y, c.canonical);
                if (l) {
                  const [e1, t, i] = l(M);
                  (A += e1), (S += t), (I += i);
                }
                const C = [A, S, I, 1];
                if ((uu.transformMat4(C, C, t), !rv(C, f))) {
                  uv(T, m);
                  continue;
                }
                const z = C[3],
                  D = iv(
                    i.transform.getCameraToCenterDistance(h.projection),
                    z,
                  ),
                  P = s_(u, d, p),
                  R = s ? P / D : P * D,
                  L = tv(A, S, I, n);
                if (L[3] <= 0) {
                  uv(T, m);
                  continue;
                }
                let k = {};
                const O = s ? null : l,
                  B = av(
                    p,
                    R,
                    !1,
                    a,
                    t,
                    n,
                    o,
                    e1.glyphOffsetArray,
                    g,
                    m,
                    _,
                    L,
                    M,
                    k,
                    v,
                    O,
                    h.projection,
                    c,
                    s,
                  );
                (w = B.useVertical),
                  O && B.needsFlipping && (k = {}),
                  (B.notEnoughRoom ||
                    w ||
                    (B.needsFlipping &&
                      av(
                        p,
                        R,
                        !0,
                        a,
                        t,
                        n,
                        o,
                        e1.glyphOffsetArray,
                        g,
                        m,
                        _,
                        L,
                        M,
                        k,
                        v,
                        O,
                        h.projection,
                        c,
                        s,
                      ).notEnoughRoom)) &&
                    uv(T, m);
              }
              r
                ? (e1.text.dynamicLayoutVertexBuffer.updateData(m),
                  _ &&
                    e1.text.globeExtVertexBuffer &&
                    e1.text.globeExtVertexBuffer.updateData(_))
                : (e1.icon.dynamicLayoutVertexBuffer.updateData(m),
                  _ &&
                    e1.icon.globeExtVertexBuffer &&
                    e1.icon.globeExtVertexBuffer.updateData(_));
            }
            function ov(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m) {
              const { lineStartIndex: _, glyphStartIndex: g, segment: y } = a,
                x = g + a.numGlyphs,
                v = _ + a.lineLength,
                b = t.getoffsetX(g),
                w = t.getoffsetX(x - 1),
                T = hv(
                  e1 * b,
                  i,
                  r,
                  n,
                  o,
                  s,
                  y,
                  _,
                  v,
                  l,
                  c,
                  h,
                  u,
                  d,
                  !0,
                  p,
                  f,
                  m,
                );
              if (!T) return null;
              const E = hv(
                e1 * w,
                i,
                r,
                n,
                o,
                s,
                y,
                _,
                v,
                l,
                c,
                h,
                u,
                d,
                !0,
                p,
                f,
                m,
              );
              return E
                ? {
                    first: T,
                    last: E,
                  }
                : null;
            }
            function sv(e1, t, i, r) {
              return e1 === w_.horizontal && Math.abs(r) > Math.abs(i)
                ? {
                    useVertical: !0,
                  }
                : e1 === w_.vertical
                ? r > 0
                  ? {
                      needsFlipping: !0,
                    }
                  : null
                : t !== Yx.unknown &&
                  (function (e1, t) {
                    return 0 === e1 || Math.abs(t / e1) > Kx;
                  })(i, r)
                ? t === Yx.flipRequired
                  ? {
                      needsFlipping: !0,
                    }
                  : null
                : i < 0
                ? {
                    needsFlipping: !0,
                  }
                : null;
            }
            function av(
              e1,
              t,
              i,
              r,
              n,
              o,
              s,
              a,
              l,
              c,
              h,
              u,
              d,
              p,
              f,
              m,
              _,
              g,
              x,
            ) {
              const v = t / 24,
                b = e1.lineOffsetX * v,
                w = e1.lineOffsetY * v,
                {
                  lineStartIndex: T,
                  glyphStartIndex: E,
                  numGlyphs: M,
                  segment: A,
                  writingMode: S,
                  flipState: I,
                } = e1,
                C = T + e1.lineLength,
                z = (e1) => {
                  if (h) {
                    const [t, i, r] = e1.up,
                      n = c.length;
                    ry(h, n + 0, t, i, r),
                      ry(h, n + 1, t, i, r),
                      ry(h, n + 2, t, i, r),
                      ry(h, n + 3, t, i, r);
                  }
                  const [t, i, r] = e1.point;
                  ny(c, t, i, r, e1.angle);
                };
              if (M > 1) {
                const t = ov(v, a, b, w, i, u, d, e1, l, o, p, m, !1, _, g, x);
                if (!t)
                  return {
                    notEnoughRoom: !0,
                  };
                if (r && !i) {
                  let [i, r, n] = t.first.point,
                    [o, a, l] = t.last.point;
                  ([i, r] = tv(i, r, n, s)), ([o, a] = tv(o, a, l, s));
                  const c = sv(S, I, (o - i) * f, a - r);
                  if (
                    ((e1.flipState =
                      c && c.needsFlipping
                        ? Yx.flipRequired
                        : Yx.flipNotRequired),
                    c)
                  )
                    return c;
                }
                z(t.first);
                for (let e1 = E + 1; e1 < E + M - 1; e1++) {
                  const t = hv(
                    v * a.getoffsetX(e1),
                    b,
                    w,
                    i,
                    u,
                    d,
                    A,
                    T,
                    C,
                    l,
                    o,
                    p,
                    m,
                    !1,
                    !1,
                    _,
                    g,
                    x,
                  );
                  if (!t)
                    return (
                      (c.length -= 4 * (e1 - E)),
                      {
                        notEnoughRoom: !0,
                      }
                    );
                  z(t);
                }
                z(t.last);
              } else {
                if (r && !i) {
                  const t = tv(d.x, d.y, 0, n),
                    i = T + A + 1,
                    r = new y(l.getx(i), l.gety(i)),
                    o = tv(r.x, r.y, 0, n),
                    s =
                      o[3] > 0 ? o : cv(d, r, t, 1, n, void 0, _, g.canonical),
                    a = sv(S, I, (s[0] - t[0]) * f, s[1] - t[1]);
                  if (
                    ((e1.flipState =
                      a && a.needsFlipping
                        ? Yx.flipRequired
                        : Yx.flipNotRequired),
                    a)
                  )
                    return a;
                }
                const t = hv(
                  v * a.getoffsetX(E),
                  b,
                  w,
                  i,
                  u,
                  d,
                  A,
                  T,
                  C,
                  l,
                  o,
                  p,
                  m,
                  !1,
                  !1,
                  _,
                  g,
                  x,
                );
                if (!t)
                  return {
                    notEnoughRoom: !0,
                  };
                z(t);
              }
              return {};
            }
            function lv(e1, t, i, r, n) {
              const { x: o, y: s, z: a } = r.projectTilePoint(e1.x, e1.y, t);
              if (!n) return tv(o, s, a, i);
              const [l, c, h] = n(e1);
              return tv(o + l, s + c, a + h, i);
            }
            function cv(e1, t, i, r, n, o, s, a) {
              const l = lv(e1.sub(t)._unit()._add(e1), a, n, s, o);
              return (
                Mu.sub(l, i, l), Mu.normalize(l, l), Mu.scaleAndAdd(l, i, l, r)
              );
            }
            function hv(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m, _, g) {
              const x = r ? e1 - t : e1 + t;
              let v = x > 0 ? 1 : -1,
                b = 0;
              r && ((v *= -1), (b = Math.PI)), v < 0 && (b += Math.PI);
              let w = (a + s + (v > 0 ? 0 : 1)) | 0,
                T = n,
                E = n,
                M = 0,
                A = 0;
              const S = Math.abs(x),
                I = [],
                C = [];
              let z = o,
                D = z;
              const P = () => cv(D, z, E, S - M + 1, h, d, m, _.canonical);
              for (; M + A <= S; ) {
                if (((w += v), w < a || w >= l)) return null;
                if (
                  ((E = T),
                  (D = z),
                  I.push(E),
                  p && C.push(D),
                  (z = new y(c.getx(w), c.gety(w))),
                  (T = u[w]),
                  !T)
                ) {
                  const e1 = lv(z, _.canonical, h, m, d);
                  T = e1[3] > 0 ? (u[w] = e1) : P();
                }
                (M += A), (A = Mu.distance(E, T));
              }
              f &&
                d &&
                (u[w] && ((T = P()), (A = Mu.distance(E, T))), (u[w] = T));
              const R = (S - M) / A,
                L = z.sub(D)._mult(R)._add(D),
                k = Mu.sub([], T, E),
                O = Mu.scaleAndAdd([], E, k, R);
              let B = [0, 0, 1],
                F = k[0],
                N = k[1];
              if (
                g &&
                ((B = m.upVector(_.canonical, L.x, L.y)),
                0 !== B[0] || 0 !== B[1] || 1 !== B[2])
              ) {
                const e1 = [B[2], 0, -B[0]],
                  t = Mu.cross([], B, e1);
                Mu.normalize(e1, e1),
                  Mu.normalize(t, t),
                  (F = Mu.dot(k, e1)),
                  (N = Mu.dot(k, t));
              }
              if (i) {
                const e1 = Mu.cross([], B, k);
                Mu.normalize(e1, e1), Mu.scaleAndAdd(O, O, e1, i * v);
              }
              const U = b + Math.atan2(N, F);
              return (
                I.push(O),
                p && C.push(L),
                {
                  point: O,
                  angle: U,
                  path: I,
                  tilePath: C,
                  up: B,
                }
              );
            }
            function uv(e1, t) {
              const i = t.length,
                r = i + 4 * e1;
              t.resize(r), t.float32.fill(-1 / 0, 4 * i, 4 * r);
            }
            function dv(e1, t, i) {
              const r = t[0],
                n = t[1];
              return (
                (e1[0] = i[0] * r + i[4] * n + i[12]),
                (e1[1] = i[1] * r + i[5] * n + i[13]),
                (e1[3] = i[3] * r + i[7] * n + i[15]),
                e1
              );
            }
            const pv = (e1, t, i) => (1 - i) * e1 + i * t,
              fv = (e1) => e1 * e1 * e1 * e1 * e1;
            class mv {
              constructor(e1, t, i, r, n, o, s) {
                (this.tileSize = 512),
                  (this._renderWorldCopies = void 0 === n || n),
                  (this._minZoom = e1 || 0),
                  (this._maxZoom = t || 22),
                  (this._minPitch = null == i ? 0 : i),
                  (this._maxPitch = null == r ? 60 : r),
                  this.setProjection(o),
                  this.setMaxBounds(s),
                  (this.width = 0),
                  (this.height = 0),
                  (this._center = new Nd(0, 0)),
                  (this.zoom = 0),
                  (this.angle = 0),
                  (this._fov = 0.6435011087932844),
                  (this._pitch = 0),
                  (this._nearZ = 0),
                  (this._farZ = 0),
                  (this._unmodified = !0),
                  (this._edgeInsets = new Bx()),
                  (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._fogTileMatrixCache = {}),
                  (this._distanceTileDataCache = {}),
                  (this._camera = new jx()),
                  (this._centerAltitude = 0),
                  (this._averageElevation = 0),
                  (this.cameraElevationReference = "ground"),
                  (this._pixelsPerMercatorPixel = 1),
                  (this.globeRadius = 0),
                  (this.globeCenterInViewSpace = [0, 0, 0]),
                  (this._horizonShift = 0.1),
                  (this._orthographicProjectionAtLowPitch = !1);
              }
              clone() {
                const e1 = new mv(
                  this._minZoom,
                  this._maxZoom,
                  this._minPitch,
                  this.maxPitch,
                  this._renderWorldCopies,
                  this.getProjection(),
                );
                return (
                  (e1._elevation = this._elevation),
                  (e1._centerAltitude = this._centerAltitude),
                  (e1._centerAltitudeValidForExaggeration =
                    this._centerAltitudeValidForExaggeration),
                  (e1.tileSize = this.tileSize),
                  (e1.mercatorFromTransition = this.mercatorFromTransition),
                  (e1.width = this.width),
                  (e1.height = this.height),
                  (e1.cameraElevationReference = this.cameraElevationReference),
                  (e1._center = this._center),
                  e1._setZoom(this.zoom),
                  (e1._seaLevelZoom = this._seaLevelZoom),
                  (e1.angle = this.angle),
                  (e1._fov = this._fov),
                  (e1._pitch = this._pitch),
                  (e1._nearZ = this._nearZ),
                  (e1._farZ = this._farZ),
                  (e1._averageElevation = this._averageElevation),
                  (e1._unmodified = this._unmodified),
                  (e1._edgeInsets = this._edgeInsets.clone()),
                  (e1._camera = this._camera.clone()),
                  e1._calcMatrices(),
                  (e1.freezeTileCoverage = this.freezeTileCoverage),
                  (e1.frustumCorners = this.frustumCorners),
                  e1
                );
              }
              get isOrthographic() {
                return (
                  "globe" !== this.projection.name &&
                  this._orthographicProjectionAtLowPitch &&
                  this.pitch < 15
                );
              }
              get elevation() {
                return this._elevation;
              }
              set elevation(e1) {
                this._elevation !== e1 &&
                  ((this._elevation = e1),
                  this._updateCameraOnTerrain(),
                  this._calcMatrices());
              }
              get depthOcclusionForSymbolsAndCircles() {
                return "globe" !== this.projection.name && !this.isOrthographic;
              }
              updateElevation(e1, t = !1) {
                const i =
                  this._elevation &&
                  this._elevation.exaggeration() !==
                    this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) &&
                  this._updateCameraOnTerrain(),
                  (e1 || i) && this._constrainCamera(t),
                  this._calcMatrices();
              }
              getProjection() {
                return O(this.projection, ["name", "center", "parallels"]);
              }
              setProjection(e1) {
                this.projectionOptions = e1 || {
                  name: "mercator",
                };
                const t = this.projection ? this.getProjection() : void 0;
                this.projection = Hg(this.projectionOptions);
                const i = !x(t, this.getProjection());
                return (
                  i && this._calcMatrices(),
                  (this.mercatorFromTransition = !1),
                  i
                );
              }
              setOrthographicProjectionAtLowPitch(e1) {
                return (
                  this._orthographicProjectionAtLowPitch !== e1 &&
                  ((this._orthographicProjectionAtLowPitch = e1),
                  this._calcMatrices(),
                  !0)
                );
              }
              setMercatorFromTransition() {
                const e1 = this.projection.name;
                (this.mercatorFromTransition = !0),
                  (this.projectionOptions = {
                    name: "mercator",
                  }),
                  (this.projection = Hg({
                    name: "mercator",
                  }));
                const t = e1 !== this.projection.name;
                return t && this._calcMatrices(), t;
              }
              get minZoom() {
                return this._minZoom;
              }
              set minZoom(e1) {
                this._minZoom !== e1 &&
                  ((this._minZoom = e1), (this.zoom = Math.max(this.zoom, e1)));
              }
              get maxZoom() {
                return this._maxZoom;
              }
              set maxZoom(e1) {
                this._maxZoom !== e1 &&
                  ((this._maxZoom = e1), (this.zoom = Math.min(this.zoom, e1)));
              }
              get minPitch() {
                return this._minPitch;
              }
              set minPitch(e1) {
                this._minPitch !== e1 &&
                  ((this._minPitch = e1),
                  (this.pitch = Math.max(this.pitch, e1)));
              }
              get maxPitch() {
                return this._maxPitch;
              }
              set maxPitch(e1) {
                this._maxPitch !== e1 &&
                  ((this._maxPitch = e1),
                  (this.pitch = Math.min(this.pitch, e1)));
              }
              get renderWorldCopies() {
                return (
                  this._renderWorldCopies &&
                  !0 === this.projection.supportsWorldCopies
                );
              }
              set renderWorldCopies(e1) {
                void 0 === e1 ? (e1 = !0) : null === e1 && (e1 = !1),
                  (this._renderWorldCopies = e1);
              }
              get worldSize() {
                return this.tileSize * this.scale;
              }
              get cameraWorldSizeForFog() {
                const e1 = Math.max(
                  this._camera.getDistanceToElevation(this._averageElevation),
                  Number.EPSILON,
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
              }
              get cameraWorldSize() {
                const e1 = Math.max(
                  this._camera.getDistanceToElevation(
                    this._averageElevation,
                    !0,
                  ),
                  Number.EPSILON,
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
              }
              get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(
                  this.center.lat,
                  this.worldSize,
                );
              }
              get cameraPixelsPerMeter() {
                return Zd(1, this.center.lat) * this.cameraWorldSizeForFog;
              }
              get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
              }
              get size() {
                return new y(this.width, this.height);
              }
              get bearing() {
                return P(this.rotation, -180, 180);
              }
              set bearing(e1) {
                this.rotation = e1;
              }
              get rotation() {
                return (-this.angle / Math.PI) * 180;
              }
              set rotation(e1) {
                const t = (-e1 * Math.PI) / 180;
                this.angle !== t &&
                  ((this._unmodified = !1),
                  (this.angle = t),
                  this._calcMatrices(),
                  (this.rotationMatrix = fu.create()),
                  fu.rotate(
                    this.rotationMatrix,
                    this.rotationMatrix,
                    this.angle,
                  ));
              }
              get pitch() {
                return (this._pitch / Math.PI) * 180;
              }
              set pitch(e1) {
                const t = (z(e1, this.minPitch, this.maxPitch) / 180) * Math.PI;
                this._pitch !== t &&
                  ((this._unmodified = !1),
                  (this._pitch = t),
                  this._calcMatrices());
              }
              get aspect() {
                return this.width / this.height;
              }
              get fov() {
                return (this._fov / Math.PI) * 180;
              }
              get fovX() {
                return this._fov;
              }
              get fovY() {
                const e1 = 1 / Math.tan(0.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e1);
              }
              set fov(e1) {
                (e1 = Math.max(0.01, Math.min(60, e1))),
                  this._fov !== e1 &&
                    ((this._unmodified = !1),
                    (this._fov = w(e1)),
                    this._calcMatrices());
              }
              get averageElevation() {
                return this._averageElevation;
              }
              set averageElevation(e1) {
                (this._averageElevation = e1),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {});
              }
              get zoom() {
                return this._zoom;
              }
              set zoom(e1) {
                const t = Math.min(Math.max(e1, this.minZoom), this.maxZoom);
                this._zoom !== t &&
                  ((this._unmodified = !1),
                  this._setZoom(t),
                  this._updateSeaLevelZoom(),
                  this._constrain(),
                  this._calcMatrices());
              }
              _setZoom(e1) {
                (this._zoom = e1),
                  (this.scale = this.zoomScale(e1)),
                  (this.tileZoom = Math.floor(e1)),
                  (this.zoomFraction = e1 - this.tileZoom);
              }
              _updateCameraOnTerrain() {
                const e1 = this.elevation
                    ? this.elevation.getAtPoint(
                        this.locationCoordinate(this.center),
                        Number.NEGATIVE_INFINITY,
                      )
                    : Number.NEGATIVE_INFINITY,
                  t =
                    this.elevation &&
                    e1 === Number.NEGATIVE_INFINITY &&
                    this.elevation.visibleDemTiles.length > 0 &&
                    this.elevation.exaggeration() > 0 &&
                    this._centerAltitudeValidForExaggeration;
                if (
                  !this._elevation ||
                  (e1 === Number.NEGATIVE_INFINITY &&
                    (!t || !this._centerAltitude))
                )
                  return (
                    (this._centerAltitude = 0),
                    (this._seaLevelZoom = null),
                    void (this._centerAltitudeValidForExaggeration = void 0)
                  );
                const i = this._elevation;
                t ||
                (this._centerAltitude &&
                  this._centerAltitudeValidForExaggeration &&
                  i.exaggeration() &&
                  this._centerAltitudeValidForExaggeration !== i.exaggeration())
                  ? ((this._centerAltitude =
                      (this._centerAltitude /
                        this._centerAltitudeValidForExaggeration) *
                      i.exaggeration()),
                    (this._centerAltitudeValidForExaggeration =
                      i.exaggeration()))
                  : ((this._centerAltitude = e1 || 0),
                    (this._centerAltitudeValidForExaggeration =
                      i.exaggeration())),
                  this._updateSeaLevelZoom();
              }
              _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration &&
                  (this._seaLevelZoom = this._zoomFromMercatorZ(
                    (this.pixelsPerMeter * this._centerAltitude +
                      this.cameraToCenterDistance) /
                      this.worldSize,
                  ));
              }
              sampleAverageElevation() {
                if (!this._elevation) return 0;
                const e1 = this._elevation,
                  t = [
                    [0.5, 0.2],
                    [0.3, 0.5],
                    [0.5, 0.5],
                    [0.7, 0.5],
                    [0.5, 0.8],
                  ],
                  i = this.horizonLineFromTop();
                let r = 0,
                  n = 0;
                for (let o = 0; o < t.length; o++) {
                  const s = new y(
                      t[o][0] * this.width,
                      i + t[o][1] * (this.height - i),
                    ),
                    a = e1.pointCoordinate(s);
                  if (!a) continue;
                  const l =
                    1 /
                    Math.hypot(
                      a[0] - this._camera.position[0],
                      a[1] - this._camera.position[1],
                    );
                  (r += a[3] * l), (n += l);
                }
                return 0 === n ? NaN : r / n;
              }
              get center() {
                return this._center;
              }
              set center(e1) {
                (e1.lat === this._center.lat && e1.lng === this._center.lng) ||
                  ((this._unmodified = !1),
                  (this._center = e1),
                  this._terrainEnabled() &&
                    ("ground" === this.cameraElevationReference
                      ? this._updateCameraOnTerrain()
                      : this._updateZoomFromElevation()),
                  this._constrain(),
                  this._calcMatrices());
              }
              _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e1 = this._seaLevelZoom,
                  t = this._elevation.getAtPointOrZero(
                    this.locationCoordinate(this.center),
                  ),
                  i = (this.pixelsPerMeter / this.worldSize) * t,
                  r = this._mercatorZfromZoom(e1),
                  n = this._mercatorZfromZoom(this._maxZoom),
                  o = Math.max(r - i, n);
                this._setZoom(this._zoomFromMercatorZ(o));
              }
              get padding() {
                return this._edgeInsets.toJSON();
              }
              set padding(e1) {
                this._edgeInsets.equals(e1) ||
                  ((this._unmodified = !1),
                  this._edgeInsets.interpolate(this._edgeInsets, e1, 1),
                  this._calcMatrices());
              }
              computeZoomRelativeTo(e1) {
                const t = this.rayIntersectionCoordinate(
                  this.pointRayIntersection(this.centerPoint, e1.toAltitude()),
                );
                let i;
                i =
                  e1.z < this._camera.position[2]
                    ? [t.x, t.y, t.z]
                    : [e1.x, e1.y, e1.z];
                const r = Mu.length(Mu.sub([], this._camera.position, i));
                return z(
                  this._zoomFromMercatorZ(r),
                  this._minZoom,
                  this._maxZoom,
                );
              }
              setFreeCameraOptions(e1) {
                if (!this.height) return;
                if (!e1.position && !e1.orientation) return;
                this._updateCameraState();
                let t = !1;
                if (
                  (e1.orientation &&
                    !bu.exactEquals(e1.orientation, this._camera.orientation) &&
                    (t = this._setCameraOrientation(e1.orientation)),
                  e1.position)
                ) {
                  const i = [e1.position.x, e1.position.y, e1.position.z];
                  Mu.exactEquals(i, this._camera.position) ||
                    (this._setCameraPosition(i), (t = !0));
                }
                t && (this._updateStateFromCamera(), this.recenterOnTerrain());
              }
              getFreeCameraOptions() {
                this._updateCameraState();
                const e1 = this._camera.position,
                  t = new Vx();
                return (
                  (t.position = new ep(e1[0], e1[1], e1[2])),
                  (t.orientation = this._camera.orientation),
                  (t._elevation = this.elevation),
                  (t._renderWorldCopies = this.renderWorldCopies),
                  t
                );
              }
              _setCameraOrientation(e1) {
                if (!bu.length(e1)) return !1;
                bu.normalize(e1, e1);
                const t = Mu.transformQuat([], [0, 0, -1], e1),
                  i = Mu.transformQuat([], [0, -1, 0], e1);
                if (i[2] < 0) return !1;
                const r = Ux(t, i);
                return !!r && ((this._camera.orientation = r), !0);
              }
              _setCameraPosition(e1) {
                const t = this.zoomScale(this.minZoom) * this.tileSize,
                  i = this.zoomScale(this.maxZoom) * this.tileSize,
                  r = this.cameraToCenterDistance;
                (e1[2] = z(e1[2], r / i, r / t)), (this._camera.position = e1);
              }
              get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
              }
              get fovAboveCenter() {
                return this._fov * (0.5 + this.centerOffset.y / this.height);
              }
              isPaddingEqual(e1) {
                return this._edgeInsets.equals(e1);
              }
              interpolatePadding(e1, t, i) {
                (this._unmodified = !1),
                  this._edgeInsets.interpolate(e1, t, i),
                  this._constrain(),
                  this._calcMatrices();
              }
              coveringZoomLevel(e1) {
                const t = (e1.roundZoom ? Math.round : Math.floor)(
                  this.zoom + this.scaleZoom(this.tileSize / e1.tileSize),
                );
                return Math.max(0, t);
              }
              getVisibleUnwrappedCoordinates(e1) {
                const t = [new Ou(0, e1)];
                if (this.renderWorldCopies) {
                  const i = this.pointCoordinate(new y(0, 0)),
                    r = this.pointCoordinate(new y(this.width, 0)),
                    n = this.pointCoordinate(new y(this.width, this.height)),
                    o = this.pointCoordinate(new y(0, this.height)),
                    s = Math.floor(Math.min(i.x, r.x, n.x, o.x)),
                    a = Math.floor(Math.max(i.x, r.x, n.x, o.x)),
                    l = 1;
                  for (let i = s - l; i <= a + l; i++)
                    0 !== i && t.push(new Ou(i, e1));
                }
                return t;
              }
              isLODDisabled(e1) {
                return (
                  (!e1 || this.pitch <= 60) &&
                  this._edgeInsets.top <= this._edgeInsets.bottom &&
                  !this._elevation &&
                  !this.projection.isReprojectedInTileSpace
                );
              }
              extendTileCoverForShadows(e1, t, i) {
                let r = [];
                if (0 === t[0] && 0 === t[1]) return r;
                for (const i of e1) {
                  const e1 = i.canonical,
                    n = i.overscaledZ,
                    o = i.wrap,
                    s = 1 << e1.z,
                    a = e1.x + 1 < s,
                    l = e1.x > 0,
                    c = e1.y + 1 < s,
                    h = e1.y > 0,
                    u = i.wrap - (l ? 0 : 1),
                    d = i.wrap + (a ? 0 : 1),
                    p = l ? e1.x - 1 : s - 1,
                    f = a ? e1.x + 1 : 0;
                  t[0] < 0
                    ? (r.push(new Bu(n, d, e1.z, f, e1.y)),
                      t[1] < 0 &&
                        c &&
                        (r.push(new Bu(n, o, e1.z, e1.x, e1.y + 1)),
                        r.push(new Bu(n, d, e1.z, f, e1.y + 1))),
                      t[1] > 0 &&
                        h &&
                        (r.push(new Bu(n, o, e1.z, e1.x, e1.y - 1)),
                        r.push(new Bu(n, d, e1.z, f, e1.y - 1))))
                    : t[0] > 0
                    ? (r.push(new Bu(n, u, e1.z, p, e1.y)),
                      t[1] < 0 &&
                        c &&
                        (r.push(new Bu(n, o, e1.z, e1.x, e1.y + 1)),
                        r.push(new Bu(n, u, e1.z, p, e1.y + 1))),
                      t[1] > 0 &&
                        h &&
                        (r.push(new Bu(n, o, e1.z, e1.x, e1.y - 1)),
                        r.push(new Bu(n, u, e1.z, p, e1.y - 1))))
                    : t[1] < 0 && c
                    ? r.push(new Bu(n, o, e1.z, e1.x, e1.y + 1))
                    : h && r.push(new Bu(n, o, e1.z, e1.x, e1.y - 1));
                }
                if (r.length > 1) {
                  r.sort(
                    (e1, t) =>
                      e1.overscaledZ - t.overscaledZ ||
                      e1.wrap - t.wrap ||
                      e1.canonical.z - t.canonical.z ||
                      e1.canonical.x - t.canonical.x ||
                      e1.canonical.y - t.canonical.y,
                  );
                  let e1 = 0,
                    t = 0;
                  for (; t < r.length; )
                    r[t].equals(r[e1]) ? ++t : (r[++e1] = r[t++]);
                  r.length = e1 + 1;
                }
                const n = [];
                for (const e1 of r)
                  r.some((t) => e1.isChildOf(t)) || n.push(e1);
                return (
                  (r = n.filter(
                    (t) =>
                      !e1.some(
                        (e1) =>
                          !!(t.overscaledZ < i && e1.isChildOf(t)) ||
                          t.equals(e1) ||
                          t.isChildOf(e1),
                      ),
                  )),
                  r
                );
              }
              coveringTiles(e1) {
                let t = this.coveringZoomLevel(e1);
                const i = t,
                  r = this.elevation && this.elevation.exaggeration(),
                  n = r && !e1.isTerrainDEM,
                  o = "mercator" === this.projection.name;
                if (void 0 !== e1.minzoom && t < e1.minzoom) return [];
                void 0 !== e1.maxzoom && t > e1.maxzoom && (t = e1.maxzoom);
                const s = this.locationCoordinate(this.center),
                  a = this.center.lat,
                  l = 1 << t,
                  c = [l * s.x, l * s.y, 0],
                  h = "globe" === this.projection.name,
                  u = !h,
                  d = $u.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    t,
                    u,
                  ),
                  p = h
                    ? this._camera.mercatorPosition
                    : this.pointCoordinate(this.getCameraPoint()),
                  f = l * Zd(1, this.center.lat),
                  m = this._camera.position[2] / Zd(1, this.center.lat),
                  _ = [l * p.x, l * p.y, m * (u ? 1 : f)],
                  g = h || r,
                  y =
                    (this.cameraToCenterDistance / e1.tileSize) *
                    (e1.roundZoom ? 1 : 0.502),
                  x = this.isLODDisabled(!0) ? t : 0,
                  v =
                    e1.isTerrainDEM && this._elevation
                      ? 1e4 * this._elevation.exaggeration()
                      : this._centerAltitude,
                  b = e1.isTerrainDEM
                    ? -v
                    : this._elevation
                    ? this._elevation.getMinElevationBelowMSL()
                    : 0,
                  w = this.projection.isReprojectedInTileSpace ? qx(this) : 1,
                  T = (e1) => {
                    const t = 1 / 4e4,
                      i = new ep(e1.x + t, e1.y, e1.z),
                      r = new ep(e1.x, e1.y + t, e1.z),
                      n = e1.toLngLat(),
                      o = i.toLngLat(),
                      s = r.toLngLat(),
                      a = this.locationCoordinate(n),
                      l = this.locationCoordinate(o),
                      c = this.locationCoordinate(s),
                      h = Math.hypot(l.x - a.x, l.y - a.y),
                      u = Math.hypot(c.x - a.x, c.y - a.y);
                    return (Math.sqrt(h * u) * w) / t;
                  },
                  M = (e1) => {
                    const t = v,
                      i = b;
                    return {
                      aabb: Eg(this, l, 0, 0, 0, e1, i, t, this.projection),
                      zoom: 0,
                      x: 0,
                      y: 0,
                      minZ: i,
                      maxZ: t,
                      wrap: e1,
                      fullyVisible: !1,
                    };
                  },
                  A = [];
                let S = [];
                const I = t,
                  C = e1.reparseOverscaled ? i : t,
                  z = (e1) => e1 * e1,
                  D = z((m - this._centerAltitude) * f),
                  P = (e1) => {
                    if (!this._elevation || !e1.tileID || !o) return;
                    const t = this._elevation.getMinMaxForTile(e1.tileID),
                      i = e1.aabb;
                    t
                      ? ((i.min[2] = t.min),
                        (i.max[2] = t.max),
                        (i.center[2] = (i.min[2] + i.max[2]) / 2))
                      : ((e1.shouldSplit = R(e1)),
                        e1.shouldSplit ||
                          (i.min[2] =
                            i.max[2] =
                            i.center[2] =
                              this._centerAltitude));
                  },
                  R = (e1) => {
                    if (e1.zoom < x) return !0;
                    if (e1.zoom === I) return !1;
                    if (null != e1.shouldSplit) return e1.shouldSplit;
                    const t = e1.aabb.distanceX(_),
                      r = e1.aabb.distanceY(_);
                    let o = D,
                      s = 1;
                    if (h) {
                      o = z(e1.aabb.distanceZ(_));
                      const t = Math.pow(2, e1.zoom),
                        i = Hd((e1.y + 1) / t),
                        r = Hd(e1.y / t),
                        n = Math.min(Math.max(a, i), r),
                        l = jd(n) / jd(a);
                      if (
                        ((s =
                          n === a
                            ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3)
                            : Math.min(1, l / this._mercatorScaleRatio)),
                        this.zoom <= Wu && e1.zoom === I - 1 && l >= 0.9)
                      )
                        return !0;
                    } else if (
                      (n && (o = z(e1.aabb.distanceZ(_) * f)),
                      this.projection.isReprojectedInTileSpace && i <= 5)
                    ) {
                      const t = Math.pow(2, e1.zoom),
                        i = T(new ep((e1.x + 0.5) / t, (e1.y + 0.5) / t));
                      s = i > 0.85 ? 1 : i;
                    }
                    const l = t * t + r * r + o,
                      c = z(
                        (1 << (I - e1.zoom)) *
                          y *
                          s *
                          ((e1, t) => {
                            if (t * z(0.707) < e1) return 1;
                            const i = Math.sqrt(t / e1);
                            return (
                              i /
                              (1.4144271570014144 +
                                (Math.pow(1.1, i - 1.4144271570014144 + 1) -
                                  1) /
                                  (1.1 - 1) -
                                1)
                            );
                          })(Math.max(o, D), l),
                      );
                    return l < c;
                  };
                if (this.renderWorldCopies)
                  for (let e1 = 1; e1 <= 3; e1++) A.push(M(-e1)), A.push(M(e1));
                for (A.push(M(0)); A.length > 0; ) {
                  const i = A.pop(),
                    r = i.x,
                    s = i.y;
                  let a = i.fullyVisible;
                  const u = () =>
                    "globe" === this.projection.name &&
                    (0 === i.y || i.y === (1 << i.zoom) - 1);
                  if (!a) {
                    let e1 = g
                      ? i.aabb.intersects(d)
                      : i.aabb.intersectsFlat(d);
                    if (0 === e1 && u()) {
                      const t = new ku(i.zoom, r, s);
                      e1 = ud(this, l, t, !0).intersects(d);
                    }
                    if (0 === e1) continue;
                    a = 2 === e1;
                  }
                  if (i.zoom !== I && R(i))
                    for (let e1 = 0; e1 < 4; e1++) {
                      const t = (r << 1) + (e1 % 2),
                        c = (s << 1) + (e1 >> 1),
                        u = {
                          aabb: o
                            ? i.aabb.quadrant(e1)
                            : Eg(
                                this,
                                l,
                                i.zoom + 1,
                                t,
                                c,
                                i.wrap,
                                i.minZ,
                                i.maxZ,
                                this.projection,
                              ),
                          zoom: i.zoom + 1,
                          x: t,
                          y: c,
                          wrap: i.wrap,
                          fullyVisible: a,
                          tileID: void 0,
                          shouldSplit: void 0,
                          minZ: i.minZ,
                          maxZ: i.maxZ,
                        };
                      n &&
                        !h &&
                        ((u.tileID = new Bu(
                          i.zoom + 1 === I ? C : i.zoom + 1,
                          i.wrap,
                          i.zoom + 1,
                          t,
                          c,
                        )),
                        P(u)),
                        A.push(u);
                    }
                  else {
                    const n = i.zoom === I ? C : i.zoom;
                    if (e1.minzoom && e1.minzoom > n) continue;
                    if (!a) {
                      let e1 = g
                        ? i.aabb.intersectsPrecise(d)
                        : i.aabb.intersectsPreciseFlat(d);
                      if (0 === e1 && u()) {
                        const t = new ku(i.zoom, r, s);
                        e1 = ud(this, l, t, !0).intersectsPrecise(d);
                      }
                      if (0 === e1) continue;
                    }
                    const o =
                        c[0] -
                        (0.5 + r + (i.wrap << i.zoom)) * (1 << (t - i.zoom)),
                      h = c[1] - 0.5 - s,
                      p = i.tileID ? i.tileID : new Bu(n, i.wrap, i.zoom, r, s);
                    S.push({
                      tileID: p,
                      distanceSq: o * o + h * h,
                    });
                  }
                }
                if (this.fogCullDistSq) {
                  const t = this.fogCullDistSq,
                    i = this.horizonLineFromTop();
                  S = S.filter((r) => {
                    const n = [0, 0, 0, 1],
                      o = [sr, sr, 0, 1],
                      s = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                    uu.transformMat4(n, n, s), uu.transformMat4(o, o, s);
                    const a = (function (e1, t, i) {
                      let r = 0;
                      for (let i = 0; i < 2; ++i) {
                        const n = 0;
                        e1[i] > n && (r += (e1[i] - n) * (e1[i] - n)),
                          t[i] < n && (r += (n - t[i]) * (n - t[i]));
                      }
                      return r;
                    })(uu.min([], n, o), uu.max([], n, o));
                    if (0 === a) return !0;
                    let l = !1;
                    const c = this._elevation;
                    if (c && a > t && 0 !== i) {
                      const t = this.calculateProjMatrix(
                        r.tileID.toUnwrapped(),
                      );
                      let n;
                      e1.isTerrainDEM || (n = c.getMinMaxForTile(r.tileID)),
                        n ||
                          (n = {
                            min: b,
                            max: v,
                          });
                      const o = (function (e1) {
                          const t =
                            Math.round(((e1 + 45 + 360) % 360) / 90) % 4;
                          return E[t];
                        })(this.rotation),
                        s = [o[0] * sr, o[1] * sr, n.max];
                      Mu.transformMat4(s, s, t),
                        (l = (1 - s[1]) * this.height * 0.5 < i);
                    }
                    return a < t || l;
                  });
                }
                return S.sort((e1, t) => e1.distanceSq - t.distanceSq).map(
                  (e1) => e1.tileID,
                );
              }
              resize(e1, t) {
                (this.width = e1),
                  (this.height = t),
                  (this.pixelsToGLUnits = [2 / e1, -2 / t]),
                  this._constrain(),
                  this._calcMatrices();
              }
              get unmodified() {
                return this._unmodified;
              }
              zoomScale(e1) {
                return Math.pow(2, e1);
              }
              scaleZoom(e1) {
                return Math.log(e1) / Math.LN2;
              }
              project(e1) {
                const t = z(e1.lat, -Xd, Xd),
                  i = this.projection.project(e1.lng, t);
                return new y(i.x * this.worldSize, i.y * this.worldSize);
              }
              unproject(e1) {
                return this.projection.unproject(
                  e1.x / this.worldSize,
                  e1.y / this.worldSize,
                );
              }
              get point() {
                return this.project(this.center);
              }
              get pointMerc() {
                return this.point._div(this.worldSize);
              }
              get pixelsPerMeterRatio() {
                return (
                  this.pixelsPerMeter / Zd(1, this.center.lat) / this.worldSize
                );
              }
              setLocationAtPoint(e1, t) {
                let i, r;
                const n = this.centerPoint;
                if ("globe" === this.projection.name) {
                  const e1 = this.worldSize;
                  (i = (t.x - n.x) / e1), (r = (t.y - n.y) / e1);
                } else {
                  const e1 = this.pointCoordinate(t),
                    o = this.pointCoordinate(n);
                  (i = e1.x - o.x), (r = e1.y - o.y);
                }
                const o = this.locationCoordinate(e1);
                this.setLocation(new ep(o.x - i, o.y - r));
              }
              setLocation(e1) {
                (this.center = this.coordinateLocation(e1)),
                  this.projection.wrap && (this.center = this.center.wrap());
              }
              locationPoint(e1) {
                return this.projection.locationPoint(this, e1);
              }
              locationPoint3D(e1) {
                return this.projection.locationPoint(this, e1, !0);
              }
              pointLocation(e1) {
                return this.coordinateLocation(this.pointCoordinate(e1));
              }
              pointLocation3D(e1) {
                return this.coordinateLocation(this.pointCoordinate3D(e1));
              }
              locationCoordinate(e1, t) {
                const i = t ? Zd(t, e1.lat) : void 0,
                  r = this.projection.project(e1.lng, e1.lat);
                return new ep(r.x, r.y, i);
              }
              coordinateLocation(e1) {
                return this.projection.unproject(e1.x, e1.y);
              }
              pointRayIntersection(e1, t) {
                const i = null != t ? t : this._centerAltitude,
                  r = [e1.x, e1.y, 0, 1],
                  n = [e1.x, e1.y, 1, 1];
                uu.transformMat4(r, r, this.pixelMatrixInverse),
                  uu.transformMat4(n, n, this.pixelMatrixInverse);
                const o = n[3];
                uu.scale(r, r, 1 / r[3]), uu.scale(n, n, 1 / o);
                const s = r[2],
                  a = n[2];
                return {
                  p0: r,
                  p1: n,
                  t: s === a ? 0 : (i - s) / (a - s),
                };
              }
              screenPointToMercatorRay(e1) {
                const t = [e1.x, e1.y, 0, 1],
                  i = [e1.x, e1.y, 1, 1];
                return (
                  uu.transformMat4(t, t, this.pixelMatrixInverse),
                  uu.transformMat4(i, i, this.pixelMatrixInverse),
                  uu.scale(t, t, 1 / t[3]),
                  uu.scale(i, i, 1 / i[3]),
                  (t[2] = Zd(t[2], this._center.lat) * this.worldSize),
                  (i[2] = Zd(i[2], this._center.lat) * this.worldSize),
                  uu.scale(t, t, 1 / this.worldSize),
                  uu.scale(i, i, 1 / this.worldSize),
                  new Uu([t[0], t[1], t[2]], Mu.normalize([], Mu.sub([], i, t)))
                );
              }
              rayIntersectionCoordinate(e1) {
                const { p0: t, p1: i, t: r } = e1,
                  n = Zd(t[2], this._center.lat),
                  o = Zd(i[2], this._center.lat);
                return new ep(
                  Wr(t[0], i[0], r) / this.worldSize,
                  Wr(t[1], i[1], r) / this.worldSize,
                  Wr(n, o, r),
                );
              }
              pointCoordinate(e1, t = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e1.x, e1.y, t);
              }
              pointCoordinate3D(e1) {
                if (!this.elevation) return this.pointCoordinate(e1);
                let t = this.projection.pointCoordinate3D(this, e1.x, e1.y);
                if (t) return new ep(t[0], t[1], t[2]);
                let i = 0,
                  r = this.horizonLineFromTop();
                if (e1.y > r) return this.pointCoordinate(e1);
                const n = 0.02 * r,
                  o = e1.clone();
                for (let e1 = 0; e1 < 10 && r - i > n; e1++) {
                  o.y = Wr(i, r, 0.66);
                  const e1 = this.projection.pointCoordinate3D(this, o.x, o.y);
                  e1 ? ((r = o.y), (t = e1)) : (i = o.y);
                }
                return t ? new ep(t[0], t[1], t[2]) : this.pointCoordinate(e1);
              }
              isPointAboveHorizon(e1) {
                return this.projection.isPointAboveHorizon(this, e1);
              }
              isPointOnSurface(e1) {
                if (
                  e1.y < 0 ||
                  e1.y > this.height ||
                  e1.x < 0 ||
                  e1.x > this.width
                )
                  return !1;
                if (this.elevation || this.zoom >= Xu)
                  return !this.isPointAboveHorizon(e1);
                const t = this.pointCoordinate(e1);
                return t.y >= 0 && t.y <= 1;
              }
              _coordinatePoint(e1, t) {
                const i =
                    t && this.elevation
                      ? this.elevation.getAtPointOrZero(
                          e1,
                          this._centerAltitude,
                        )
                      : this._centerAltitude,
                  r = [
                    e1.x * this.worldSize,
                    e1.y * this.worldSize,
                    i + e1.toAltitude(),
                    1,
                  ];
                return (
                  uu.transformMat4(r, r, this.pixelMatrix),
                  r[3] > 0
                    ? new y(r[0] / r[3], r[1] / r[3])
                    : new y(Number.MAX_VALUE, Number.MAX_VALUE)
                );
              }
              _getBoundsNonRectangular() {
                const { top: e1, left: t } = this._edgeInsets,
                  i = this.height - this._edgeInsets.bottom,
                  r = this.width - this._edgeInsets.right,
                  n = this.pointLocation3D(new y(t, e1)),
                  o = this.pointLocation3D(new y(r, e1)),
                  s = this.pointLocation3D(new y(r, i)),
                  a = this.pointLocation3D(new y(t, i));
                let l = Math.min(n.lng, o.lng, s.lng, a.lng),
                  c = Math.max(n.lng, o.lng, s.lng, a.lng),
                  h = Math.min(n.lat, o.lat, s.lat, a.lat),
                  u = Math.max(n.lat, o.lat, s.lat, a.lat);
                const d = (Math.pow(2, -this.zoom) / 16) * 270,
                  p = "globe" === this.projection.name ? 1 : 4,
                  f = (e1, t, i, r, n) => {
                    const o = (e1 + i) / 2,
                      s = (t + r) / 2,
                      a = new y(o, s),
                      { lng: m, lat: _ } = this.pointLocation3D(a),
                      g = Math.max(0, l - m, h - _, m - c, _ - u);
                    (l = Math.min(l, m)),
                      (c = Math.max(c, m)),
                      (h = Math.min(h, _)),
                      (u = Math.max(u, _)),
                      (n < p || g > d) &&
                        (f(e1, t, o, s, n + 1), f(o, s, i, r, n + 1));
                  };
                if (
                  (f(t, e1, r, e1, 1),
                  f(r, e1, r, i, 1),
                  f(r, i, t, i, 1),
                  f(t, i, t, e1, 1),
                  "globe" === this.projection.name)
                ) {
                  const [e1, t] = (function (e1) {
                    const t = xu.identity(new Float64Array(16));
                    xu.multiply(t, e1.pixelMatrix, e1.globeMatrix);
                    const i = [0, ed, 0],
                      r = [0, td, 0];
                    return (
                      Mu.transformMat4(i, i, t),
                      Mu.transformMat4(r, r, t),
                      [
                        i[0] > 0 &&
                          i[0] <= e1.width &&
                          i[1] > 0 &&
                          i[1] <= e1.height &&
                          !Dd(e1, new Nd(e1.center.lat, 90)),
                        r[0] > 0 &&
                          r[0] <= e1.width &&
                          r[1] > 0 &&
                          r[1] <= e1.height &&
                          !Dd(e1, new Nd(e1.center.lat, -90)),
                      ]
                    );
                  })(this);
                  e1
                    ? ((u = 90), (c = 180), (l = -180))
                    : t && ((h = -90), (c = 180), (l = -180));
                }
                return new Ql(new Nd(l, h), new Nd(c, u));
              }
              _getBoundsRectangular(e1, t) {
                const { top: i, left: r } = this._edgeInsets,
                  n = this.height - this._edgeInsets.bottom,
                  o = this.width - this._edgeInsets.right,
                  s = new y(r, i),
                  a = new y(o, i),
                  l = new y(o, n),
                  c = new y(r, n);
                let h = this.pointCoordinate(s, e1),
                  u = this.pointCoordinate(a, e1);
                const d = this.pointCoordinate(l, t),
                  p = this.pointCoordinate(c, t),
                  f = (e1, t) => (t.y - e1.y) / (t.x - e1.x);
                return (
                  h.y > 1 && u.y >= 0
                    ? (h = new ep((1 - p.y) / f(p, h) + p.x, 1))
                    : h.y < 0 &&
                      u.y <= 1 &&
                      (h = new ep(-p.y / f(p, h) + p.x, 0)),
                  u.y > 1 && h.y >= 0
                    ? (u = new ep((1 - d.y) / f(d, u) + d.x, 1))
                    : u.y < 0 &&
                      h.y <= 1 &&
                      (u = new ep(-d.y / f(d, u) + d.x, 0)),
                  new Ql()
                    .extend(this.coordinateLocation(h))
                    .extend(this.coordinateLocation(u))
                    .extend(this.coordinateLocation(p))
                    .extend(this.coordinateLocation(d))
                );
              }
              _getBoundsRectangularTerrain() {
                const e1 = this.elevation;
                if (!e1.visibleDemTiles.length || e1.isUsingMockSource())
                  return this._getBoundsRectangular(0, 0);
                const t = e1.visibleDemTiles.reduce(
                  (e1, t) => {
                    if (t.dem) {
                      const i = t.dem.tree;
                      (e1.min = Math.min(e1.min, i.minimums[0])),
                        (e1.max = Math.max(e1.max, i.maximums[0]));
                    }
                    return e1;
                  },
                  {
                    min: Number.MAX_VALUE,
                    max: 0,
                  },
                );
                return this._getBoundsRectangular(
                  t.min * e1.exaggeration(),
                  t.max * e1.exaggeration(),
                );
              }
              getBounds() {
                return "mercator" === this.projection.name ||
                  "equirectangular" === this.projection.name
                  ? this._terrainEnabled()
                    ? this._getBoundsRectangularTerrain()
                    : this._getBoundsRectangular(0, 0)
                  : this._getBoundsNonRectangular();
              }
              horizonLineFromTop(e1 = !0) {
                const t =
                    this.height /
                      2 /
                      Math.tan(this._fov / 2) /
                      Math.tan(Math.max(this._pitch, 0.1)) -
                    this.centerOffset.y,
                  i = this.height / 2 - t * (1 - this._horizonShift);
                return e1 ? Math.max(0, i) : i;
              }
              getMaxBounds() {
                return this.maxBounds;
              }
              setMaxBounds(e1) {
                (this.maxBounds = e1),
                  (this.minLat = -Xd),
                  (this.maxLat = Xd),
                  (this.minLng = -180),
                  (this.maxLng = 180),
                  e1 &&
                    ((this.minLat = e1.getSouth()),
                    (this.maxLat = e1.getNorth()),
                    (this.minLng = e1.getWest()),
                    (this.maxLng = e1.getEast()),
                    this.maxLng < this.minLng && (this.maxLng += 360)),
                  (this.worldMinX = Gd(this.minLng) * this.tileSize),
                  (this.worldMaxX = Gd(this.maxLng) * this.tileSize),
                  (this.worldMinY = qd(this.maxLat) * this.tileSize),
                  (this.worldMaxY = qd(this.minLat) * this.tileSize),
                  this._constrain();
              }
              calculatePosMatrix(e1, t) {
                return this.projection.createTileMatrix(this, t, e1);
              }
              calculateDistanceTileData(e1) {
                const t = e1.key,
                  i = this._distanceTileDataCache;
                if (i[t]) return i[t];
                const r = e1.canonical,
                  n = 1 / this.height,
                  o = this.cameraWorldSize,
                  s = o / this.zoomScale(r.z),
                  a = (r.x + Math.pow(2, r.z) * e1.wrap) * s,
                  l = r.y * s,
                  c = this.point;
                (c.x *= o / this.worldSize), (c.y *= o / this.worldSize);
                const h = this.angle,
                  u = Math.sin(-h),
                  d = -Math.cos(-h);
                return (
                  (i[t] = {
                    bearing: [u, d],
                    center: [(c.x - a) * n, (c.y - l) * n],
                    scale: (s / sr) * n,
                  }),
                  i[t]
                );
              }
              calculateFogTileMatrix(e1) {
                const t = e1.key,
                  i = this._fogTileMatrixCache;
                if (i[t]) return i[t];
                const r = this.projection.createTileMatrix(
                  this,
                  this.cameraWorldSizeForFog,
                  e1,
                );
                return (
                  xu.multiply(r, this.worldToFogMatrix, r),
                  (i[t] = new Float32Array(r)),
                  i[t]
                );
              }
              calculateProjMatrix(e1, t = !1) {
                const i = e1.key,
                  r = t ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (r[i]) return r[i];
                const n = this.calculatePosMatrix(e1, this.worldSize);
                return (
                  xu.multiply(
                    n,
                    this.projection.isReprojectedInTileSpace
                      ? this.mercatorMatrix
                      : t
                      ? this.alignedProjMatrix
                      : this.projMatrix,
                    n,
                  ),
                  (r[i] = new Float32Array(n)),
                  r[i]
                );
              }
              calculatePixelsToTileUnitsMatrix(e1) {
                const t = e1.tileID.key,
                  i = this._pixelsToTileUnitsCache;
                if (i[t]) return i[t];
                const r = (function (e1, t) {
                  const { scale: i } = e1.tileTransform,
                    r =
                      (i * sr) /
                      (e1.tileSize *
                        Math.pow(
                          2,
                          t.zoom -
                            e1.tileID.overscaledZ +
                            e1.tileID.canonical.z,
                        ));
                  return fu.scale(
                    new Float32Array(4),
                    t.inverseAdjustmentMatrix,
                    [r, r],
                  );
                })(e1, this);
                return (i[t] = r), i[t];
              }
              customLayerMatrix() {
                return this.mercatorMatrix.slice();
              }
              globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                  const e1 = 1 / this.worldSize,
                    t = xu.fromScaling([], [e1, e1, e1]);
                  return xu.multiply(t, t, this.globeMatrix), t;
                }
              }
              recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name)
                  return;
                const e1 = this._elevation;
                this._updateCameraState();
                const t = Zd(1, this._center.lat) * this.worldSize,
                  i = this._computeCameraPosition(t),
                  r = this._camera.forward(),
                  n = Zd(1, this._center.lat);
                (i[2] /= n), (r[2] /= n), Mu.normalize(r, r);
                const o = e1.raycast(i, r, e1.exaggeration());
                if (o) {
                  const e1 = Mu.scaleAndAdd([], i, r, o),
                    t = new ep(e1[0], e1[1], Zd(e1[2], Hd(e1[1]))),
                    s =
                      (t.z +
                        Mu.length([t.x - i[0], t.y - i[1], t.z - i[2] * n])) *
                      this._pixelsPerMercatorPixel;
                  (this._seaLevelZoom = this._zoomFromMercatorZ(s)),
                    (this._centerAltitude = t.toAltitude()),
                    (this._center = this.coordinateLocation(t)),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices();
                }
              }
              _constrainCamera(e1 = !1) {
                if (!this._elevation) return;
                const t = this._elevation,
                  i = Zd(1, this._center.lat) * this.worldSize,
                  r = this._computeCameraPosition(i),
                  n = t.getAtPointOrZero(new ep(...r)),
                  o = (this.pixelsPerMeter / this.worldSize) * n,
                  s = this._minimumHeightOverTerrain(),
                  a = r[2] - o;
                if (a <= s) {
                  if (a < 0 || e1) {
                    const e1 = this.locationCoordinate(
                        this._center,
                        this._centerAltitude,
                      ),
                      t = [r[0], r[1], e1.z - r[2]],
                      i = Mu.length(t);
                    t[2] -= (s - a) / this._pixelsPerMercatorPixel;
                    const n = Mu.length(t);
                    if (0 === n) return;
                    Mu.scale(t, t, (i / n) * this._pixelsPerMercatorPixel),
                      (this._camera.position = [
                        r[0],
                        r[1],
                        e1.z * this._pixelsPerMercatorPixel - t[2],
                      ]),
                      this._updateStateFromCamera();
                  } else this._isCameraConstrained = !0;
                }
              }
              _constrain() {
                if (
                  !this.center ||
                  !this.width ||
                  !this.height ||
                  this._constraining
                )
                  return;
                this._constraining = !0;
                const e1 =
                  "globe" === this.projection.name ||
                  this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || e1) {
                  const t = this.center;
                  return (
                    (t.lat = z(t.lat, this.minLat, this.maxLat)),
                    (this.maxBounds || (!this.renderWorldCopies && !e1)) &&
                      (t.lng = z(t.lng, this.minLng, this.maxLng)),
                    (this.center = t),
                    void (this._constraining = !1)
                  );
                }
                const t = this._unmodified,
                  { x: i, y: r } = this.point;
                let n = 0,
                  o = i,
                  s = r;
                const a = this.width / 2,
                  l = this.height / 2,
                  c = this.worldMinY * this.scale,
                  h = this.worldMaxY * this.scale;
                if (
                  (r - l < c && (s = c + l),
                  r + l > h && (s = h - l),
                  h - c < this.height &&
                    ((n = Math.max(n, this.height / (h - c))),
                    (s = (h + c) / 2)),
                  this.maxBounds ||
                    !this._renderWorldCopies ||
                    !this.projection.wrap)
                ) {
                  const e1 = this.worldMinX * this.scale,
                    t = this.worldMaxX * this.scale,
                    r = this.worldSize / 2 - (e1 + t) / 2;
                  (o = ((i + r + this.worldSize) % this.worldSize) - r),
                    o - a < e1 && (o = e1 + a),
                    o + a > t && (o = t - a),
                    t - e1 < this.width &&
                      ((n = Math.max(n, this.width / (t - e1))),
                      (o = (t + e1) / 2));
                }
                (o === i && s === r) ||
                  (this.center = this.unproject(new y(o, s))),
                  n && (this.zoom += this.scaleZoom(n)),
                  this._constrainCamera(),
                  (this._unmodified = t),
                  (this._constraining = !1);
              }
              _minZoomForBounds() {
                let e1 = Math.max(
                  0,
                  this.scaleZoom(
                    this.height / (this.worldMaxY - this.worldMinY),
                  ),
                );
                return (
                  this.maxBounds &&
                    (e1 = Math.max(
                      e1,
                      this.scaleZoom(
                        this.width / (this.worldMaxX - this.worldMinX),
                      ),
                    )),
                  e1
                );
              }
              _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
              }
              _calcMatrices() {
                if (!this.height) return;
                const e1 = this.centerOffset,
                  t = "globe" === this.projection.name,
                  i = this.pixelsPerMeter;
                "globe" === this.projection.name &&
                  (this._mercatorScaleRatio =
                    Zd(1, this.center.lat) / Zd(1, 45));
                const r = Zx(
                  this.projection,
                  this.zoom,
                  this.width,
                  this.height,
                  1024,
                );
                (this._pixelsPerMercatorPixel =
                  this.projection.pixelSpaceConversion(
                    this.center.lat,
                    this.worldSize,
                    r,
                  )),
                  (this.cameraToCenterDistance =
                    (0.5 / Math.tan(0.5 * this._fov)) *
                    this.height *
                    this._pixelsPerMercatorPixel),
                  this._updateCameraState(),
                  (this._farZ = this.projection.farthestPixelDistance(this)),
                  (this._nearZ = this.height / 50);
                const n = "meters" === this.projection.zAxisUnit ? i : 1,
                  o = this._camera.getWorldToCamera(this.worldSize, n);
                let s;
                const a = this._camera.getCameraToClipPerspective(
                  this._fov,
                  this.width / this.height,
                  this._nearZ,
                  this._farZ,
                );
                if (
                  ((a[8] = (2 * -e1.x) / this.width),
                  (a[9] = (2 * e1.y) / this.height),
                  this.isOrthographic)
                ) {
                  let t =
                      ((0.5 * this.height) / Math.tan(this._fov / 2)) *
                      1 *
                      Math.tan(0.5 * this._fov),
                    i = t * this.aspect,
                    r = -i,
                    n = -t;
                  (i -= e1.x),
                    (r -= e1.x),
                    (t += e1.y),
                    (n += e1.y),
                    (s = this._camera.getCameraToClipOrthographic(
                      r,
                      i,
                      n,
                      t,
                      this._nearZ,
                      this._farZ,
                    )),
                    ((e1, t, i, r) => {
                      for (let n = 0; n < 16; n++) e1[n] = pv(t[n], i[n], r);
                    })(s, s, a, fv(this.pitch >= 15 ? 1 : this.pitch / 15));
                } else s = a;
                const l = xu.mul([], a, o);
                let c = xu.mul([], s, o);
                if (this.projection.isReprojectedInTileSpace) {
                  const e1 = this.locationCoordinate(this.center),
                    t = xu.identity([]);
                  xu.translate(t, t, [
                    e1.x * this.worldSize,
                    e1.y * this.worldSize,
                    0,
                  ]),
                    xu.multiply(t, t, Gx(this)),
                    xu.translate(t, t, [
                      -e1.x * this.worldSize,
                      -e1.y * this.worldSize,
                      0,
                    ]),
                    xu.multiply(c, c, t),
                    xu.multiply(l, l, t),
                    (this.inverseAdjustmentMatrix = (function (e1) {
                      const t = Gx(e1, !0);
                      return fu.invert([], [t[0], t[1], t[4], t[5]]);
                    })(this));
                } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                (this.mercatorMatrix = xu.scale([], c, [
                  this.worldSize,
                  this.worldSize,
                  this.worldSize / n,
                  1,
                ])),
                  (this.projMatrix = c),
                  (this.invProjMatrix = xu.invert(
                    new Float64Array(16),
                    this.projMatrix,
                  ));
                const h = xu.invert([], s);
                (this.frustumCorners = Vu.fromInvProjectionMatrix(
                  h,
                  this.horizonLineFromTop(),
                  this.height,
                )),
                  (this.cameraFrustum = $u.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    0,
                    !t,
                  ));
                const u = new Float32Array(16);
                xu.identity(u),
                  xu.scale(u, u, [1, -1, 1]),
                  xu.rotateX(u, u, this._pitch),
                  xu.rotateZ(u, u, this.angle);
                const d = xu.perspective(
                  new Float32Array(16),
                  this._fov,
                  this.width / this.height,
                  this._nearZ,
                  this._farZ,
                );
                this.starsProjMatrix = xu.clone(d);
                const p =
                  (Math.PI / 2 - this._pitch) *
                  (this.height / this._fov) *
                  this._horizonShift;
                (d[8] = (2 * -e1.x) / this.width),
                  (d[9] = (2 * (e1.y + p)) / this.height),
                  (this.skyboxMatrix = xu.multiply(u, d, u));
                const f = this.point,
                  m = f.x,
                  _ = f.y,
                  g = (this.width % 2) / 2,
                  y = (this.height % 2) / 2,
                  x = Math.cos(this.angle),
                  v = Math.sin(this.angle),
                  b = m - Math.round(m) + x * g + v * y,
                  w = _ - Math.round(_) + x * y + v * g,
                  T = new Float64Array(c);
                if (
                  (xu.translate(T, T, [
                    b > 0.5 ? b - 1 : b,
                    w > 0.5 ? w - 1 : w,
                    0,
                  ]),
                  (this.alignedProjMatrix = T),
                  (c = xu.create()),
                  xu.scale(c, c, [this.width / 2, -this.height / 2, 1]),
                  xu.translate(c, c, [1, -1, 0]),
                  (this.labelPlaneMatrix = c),
                  (c = xu.create()),
                  xu.scale(c, c, [1, -1, 1]),
                  xu.translate(c, c, [-1, -1, 0]),
                  xu.scale(c, c, [2 / this.width, 2 / this.height, 1]),
                  (this.glCoordMatrix = c),
                  (this.pixelMatrix = xu.multiply(
                    new Float64Array(16),
                    this.labelPlaneMatrix,
                    l,
                  )),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {}),
                  (c = xu.invert(new Float64Array(16), this.pixelMatrix)),
                  !c)
                )
                  throw new Error("failed to invert matrix");
                if (
                  ((this.pixelMatrixInverse = c),
                  "globe" === this.projection.name ||
                    this.mercatorFromTransition)
                ) {
                  this.globeMatrix = (function (e1) {
                    const { x: t, y: i } = e1.point,
                      { lng: r, lat: n } = e1._center;
                    return Td(t, i, e1.worldSize, r, n);
                  })(this);
                  const e1 = [
                    this.globeMatrix[12],
                    this.globeMatrix[13],
                    this.globeMatrix[14],
                  ];
                  (this.globeCenterInViewSpace = Mu.transformMat4(e1, e1, o)),
                    (this.globeRadius = this.worldSize / 2 / Math.PI - 1);
                } else this.globeMatrix = c;
                (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._pixelsToTileUnitsCache = {});
              }
              _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const e1 = this.cameraWorldSizeForFog,
                  t = this.cameraPixelsPerMeter,
                  i = this._camera.position,
                  r = 1 / this.height / this._pixelsPerMercatorPixel,
                  n = [e1, e1, t];
                Mu.scale(n, n, r), Mu.scale(i, i, -1), Mu.multiply(i, i, n);
                const o = xu.create();
                xu.translate(o, o, i),
                  xu.scale(o, o, n),
                  (this.mercatorFogMatrix = o),
                  (this.worldToFogMatrix =
                    this._camera.getWorldToCameraPosition(e1, t, r));
              }
              _computeCameraPosition(e1) {
                const t =
                    (e1 = e1 || this.pixelsPerMeter) / this.pixelsPerMeter,
                  i = this._camera.forward(),
                  r = this.point,
                  n =
                    this._mercatorZfromZoom(
                      this._seaLevelZoom ? this._seaLevelZoom : this._zoom,
                    ) *
                      t -
                    (e1 / this.worldSize) * this._centerAltitude;
                return [
                  r.x / this.worldSize - i[0] * n,
                  r.y / this.worldSize - i[1] * n,
                  (e1 / this.worldSize) * this._centerAltitude - i[2] * n,
                ];
              }
              _updateCameraState() {
                this.height &&
                  (this._camera.setPitchBearing(this._pitch, this.angle),
                  (this._camera.position = this._computeCameraPosition()));
              }
              _translateCameraConstrained(e1) {
                const t =
                    this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                  i = this._camera.position[2],
                  r = e1[2];
                let n = 1;
                this.projection.wrap && (this.center = this.center.wrap()),
                  r > 0 && (n = Math.min((t - i) / r, 1)),
                  (this._camera.position = Mu.scaleAndAdd(
                    [],
                    this._camera.position,
                    e1,
                    n,
                  )),
                  this._updateStateFromCamera();
              }
              _updateStateFromCamera() {
                const e1 = this._camera.position,
                  t = this._camera.forward(),
                  { pitch: i, bearing: r } = this._camera.getPitchBearing(),
                  n =
                    Zd(this._centerAltitude, this.center.lat) *
                    this._pixelsPerMercatorPixel,
                  o =
                    this._mercatorZfromZoom(this._maxZoom) *
                    Math.cos(w(this._maxPitch)),
                  s = Math.max((e1[2] - n) / Math.cos(i), o),
                  a = this._zoomFromMercatorZ(s);
                Mu.scaleAndAdd(e1, e1, t, s),
                  (this._pitch = z(i, w(this.minPitch), w(this.maxPitch))),
                  (this.angle = P(r, -Math.PI, Math.PI)),
                  this._setZoom(z(a, this._minZoom, this._maxZoom)),
                  this._updateSeaLevelZoom(),
                  (this._center = this.coordinateLocation(
                    new ep(e1[0], e1[1], e1[2]),
                  )),
                  (this._unmodified = !1),
                  this._constrain(),
                  this._calcMatrices();
              }
              _worldSizeFromZoom(e1) {
                return Math.pow(2, e1) * this.tileSize;
              }
              _mercatorZfromZoom(e1) {
                return (
                  this.cameraToCenterDistance / this._worldSizeFromZoom(e1)
                );
              }
              _minimumHeightOverTerrain() {
                const e1 = Math.min(
                  (null != this._seaLevelZoom
                    ? this._seaLevelZoom
                    : this._zoom) + 4,
                  this._maxZoom,
                );
                return this._mercatorZfromZoom(e1);
              }
              _zoomFromMercatorZ(e1) {
                return this.scaleZoom(
                  this.cameraToCenterDistance / (e1 * this.tileSize),
                );
              }
              zoomFromMercatorZAdjusted(e1) {
                let t = 0,
                  i = Xu,
                  r = 0,
                  n = 1 / 0;
                for (; i - t > 1e-6 && i > t; ) {
                  const o = t + 0.5 * (i - t),
                    s = this.tileSize * Math.pow(2, o),
                    a = this.getCameraToCenterDistance(this.projection, o, s),
                    l = this.scaleZoom(a / (e1 * this.tileSize)),
                    c = Math.abs(o - l);
                  c < n && ((n = c), (r = o)), o < l ? (t = o) : (i = o);
                }
                return r;
              }
              _terrainEnabled() {
                return !(
                  !this._elevation ||
                  (!this.projection.supportsTerrain &&
                    (W(
                      "Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.",
                    ),
                    1))
                );
              }
              anyCornerOffEdge(e1, t) {
                const i = Math.min(e1.x, t.x),
                  r = Math.max(e1.x, t.x),
                  n = Math.min(e1.y, t.y),
                  o = Math.max(e1.y, t.y);
                if (n < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const s = [new y(i, n), new y(r, o), new y(i, o), new y(r, n)],
                  a = this.renderWorldCopies ? -3 : 0,
                  l = this.renderWorldCopies ? 4 : 1;
                for (const e1 of s) {
                  const t = this.pointRayIntersection(e1);
                  if (t.t < 0) return !0;
                  const i = this.rayIntersectionCoordinate(t);
                  if (i.x < a || i.y < 0 || i.x > l || i.y > 1) return !0;
                }
                return !1;
              }
              isHorizonVisible() {
                return (
                  this.pitch + T(this.fovAboveCenter) > 88 ||
                  this.anyCornerOffEdge(
                    new y(0, 0),
                    new y(this.width, this.height),
                  )
                );
              }
              zoomDeltaToMovement(e1, t) {
                const i = Mu.length(Mu.sub([], this._camera.position, e1)),
                  r = this._zoomFromMercatorZ(i) + t;
                return i - this._mercatorZfromZoom(r);
              }
              getCameraPoint() {
                if ("globe" === this.projection.name) {
                  const e1 = (function ([e1, t, i], r) {
                    const n = [e1, t, i, 1];
                    uu.transformMat4(n, n, r);
                    const o = (n[3] = Math.max(n[3], 1e-6));
                    return (n[0] /= o), (n[1] /= o), (n[2] /= o), n;
                  })(
                    [
                      this.globeMatrix[12],
                      this.globeMatrix[13],
                      this.globeMatrix[14],
                    ],
                    this.pixelMatrix,
                  );
                  return new y(e1[0], e1[1]);
                }
                {
                  const e1 =
                    Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                  return this.centerPoint.add(new y(0, e1));
                }
              }
              getCameraToCenterDistance(e1, t = this.zoom, i = this.worldSize) {
                const r = Zx(e1, t, this.width, this.height, 1024),
                  n = e1.pixelSpaceConversion(this.center.lat, i, r);
                let o = (0.5 / Math.tan(0.5 * this._fov)) * this.height * n;
                return (
                  this.isOrthographic &&
                    (o = pv(1, o, fv(this.pitch >= 15 ? 1 : this.pitch / 15))),
                  o
                );
              }
              getWorldToCameraMatrix() {
                const e1 = this._camera.getWorldToCamera(
                  this.worldSize,
                  "meters" === this.projection.zAxisUnit
                    ? this.pixelsPerMeter
                    : 1,
                );
                return (
                  "globe" === this.projection.name &&
                    xu.multiply(e1, e1, this.globeMatrix),
                  e1
                );
              }
              getFrustum(e1) {
                return $u.fromInvProjectionMatrix(
                  this.invProjMatrix,
                  this.worldSize,
                  e1,
                  "meters" === this.projection.zAxisUnit,
                );
              }
            }
            function _v(e1, t, i) {
              xu.identity(e1),
                xu.rotateZ(e1, e1, w(t[2])),
                xu.rotateX(e1, e1, w(t[0])),
                xu.rotateY(e1, e1, w(t[1])),
                xu.scale(e1, e1, i),
                xu.multiply(
                  e1,
                  e1,
                  [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                );
            }
            function gv(e1, t, i, r, n, o, s, a) {
              const l = [i[0] - t[0], i[1] - t[1], 0],
                c = [r[0] - t[0], r[1] - t[1], 0];
              if (Mu.length(l) < 1e-12 || Mu.length(c) < 1e-12)
                return bu.identity(e1);
              const h = Mu.cross([], l, c);
              Mu.normalize(h, h),
                Mu.subtract(c, r, t),
                (l[2] = (o - n) * a),
                (c[2] = (s - n) * a);
              const u = l;
              return (
                Mu.cross(u, l, c), Mu.normalize(u, u), bu.rotationTo(e1, h, u)
              );
            }
            function yv(e1, t, i = !1) {
              const r = Ed(t.zoom),
                n = (function (e1, t, i) {
                  const r = t.worldSize,
                    n = [e1[12], e1[13], e1[14]],
                    o = Hd(n[1] / r),
                    s = $d(n[0] / r),
                    a = xu.identity([]),
                    l = Zd(1, o) * r,
                    c = Zd(1, 0) * r * Kd(o, t.zoom),
                    h = 1 / bd(r);
                  let u = c * h;
                  if (i) {
                    const e1 = Zx(
                      t.projection,
                      t.zoom,
                      t.width,
                      t.height,
                      1024,
                    );
                    u =
                      h *
                      t.projection.pixelSpaceConversion(t.center.lat, r, e1);
                  }
                  const d = md(o, s);
                  Mu.add(d, d, Mu.scale([], Mu.normalize([], d), l * u * n[2]));
                  const p = (function (e1) {
                    const t = [e1[0], e1[1], e1[2]];
                    let i = [0, 1, 0];
                    const r = Mu.cross([], i, t);
                    return (
                      Mu.cross(i, t, r),
                      0 === Mu.squaredLength(i) &&
                        ((i = [0, 1, 0]), Mu.cross(r, t, i)),
                      Mu.normalize(r, r),
                      Mu.normalize(i, i),
                      Mu.normalize(t, t),
                      [
                        r[0],
                        r[1],
                        r[2],
                        0,
                        i[0],
                        i[1],
                        i[2],
                        0,
                        t[0],
                        t[1],
                        t[2],
                        0,
                        e1[0],
                        e1[1],
                        e1[2],
                        1,
                      ]
                    );
                  })(d);
                  xu.scale(a, a, [u, u, u * l]),
                    xu.translate(a, a, [-n[0], -n[1], -n[2]]);
                  const f = xu.multiply([], t.globeMatrix, p);
                  return xu.multiply(f, f, a), xu.multiply(f, f, e1), f;
                })(e1, t, i);
              if (r > 0) {
                const i = (function (e1, t) {
                  const i = t.worldSize,
                    r = (Zd(1, 0) * i * Kd(t.center.lat, t.zoom)) / bd(i),
                    n = Zd(1, t.center.lat) * i,
                    o = xu.identity([]);
                  return (
                    xu.rotateY(o, o, w(t.center.lng)),
                    xu.rotateX(o, o, w(t.center.lat)),
                    xu.translate(o, o, [0, 0, Yu]),
                    xu.scale(o, o, [r, r, r * n]),
                    xu.translate(o, o, [
                      t.point.x - 0.5 * i,
                      t.point.y - 0.5 * i,
                      0,
                    ]),
                    xu.multiply(o, o, e1),
                    xu.multiply(o, t.globeMatrix, o)
                  );
                })(e1, t);
                return (function (e1, t, i) {
                  const r = (e1, t, i) => {
                      const r = Mu.length(e1),
                        n = Mu.length(t),
                        o = ld(e1, t, i);
                      return Mu.scale(o, o, (1 / Mu.length(o)) * Wr(r, n, i));
                    },
                    n = r([e1[0], e1[1], e1[2]], [t[0], t[1], t[2]], i),
                    o = r([e1[4], e1[5], e1[6]], [t[4], t[5], t[6]], i),
                    s = r([e1[8], e1[9], e1[10]], [t[8], t[9], t[10]], i),
                    a = ld([e1[12], e1[13], e1[14]], [t[12], t[13], t[14]], i);
                  return [
                    n[0],
                    n[1],
                    n[2],
                    0,
                    o[0],
                    o[1],
                    o[2],
                    0,
                    s[0],
                    s[1],
                    s[2],
                    0,
                    a[0],
                    a[1],
                    a[2],
                    1,
                  ];
                })(n, i, r);
              }
              return n;
            }
            const xv = 64,
              vv = [1, 1, 1];
            class bv {
              constructor(e1, t, i, r) {
                (this.id = e1),
                  (this.position =
                    null != t ? new Nd(t[0], t[1]) : new Nd(0, 0)),
                  (this.orientation = null != i ? i : [0, 0, 0]),
                  (this.nodes = r),
                  (this.uploaded = !1),
                  (this.aabb = new Hu(
                    [1 / 0, 1 / 0, 1 / 0],
                    [-1 / 0, -1 / 0, -1 / 0],
                  )),
                  (this.matrix = []);
              }
              _applyTransformations(e1, t) {
                if ((xu.multiply(e1.matrix, t, e1.matrix), e1.meshes))
                  for (const t of e1.meshes) {
                    const i = Hu.applyTransform(t.aabb, e1.matrix);
                    this.aabb.encapsulate(i);
                  }
                if (e1.children)
                  for (const t of e1.children)
                    this._applyTransformations(t, e1.matrix);
              }
              computeBoundsAndApplyParent() {
                const e1 = xu.identity([]);
                for (const t of this.nodes) this._applyTransformations(t, e1);
              }
              _positionModelOnTerrain(e1, t) {
                const i = e1.elevation;
                if (!i) return 0;
                const r = Hu.projectAabbCorners(this.aabb, this.matrix),
                  n = Zd(1, this.position.lat) * e1.worldSize,
                  o = (function (e1, t) {
                    const i = [0, 0, 1],
                      r = [
                        {
                          corners: [0, 1, 3, 2],
                          dotProductWithUp: 0,
                        },
                        {
                          corners: [1, 5, 2, 6],
                          dotProductWithUp: 0,
                        },
                        {
                          corners: [0, 4, 1, 5],
                          dotProductWithUp: 0,
                        },
                        {
                          corners: [2, 6, 3, 7],
                          dotProductWithUp: 0,
                        },
                        {
                          corners: [4, 7, 5, 6],
                          dotProductWithUp: 0,
                        },
                        {
                          corners: [0, 3, 4, 7],
                          dotProductWithUp: 0,
                        },
                      ];
                    for (const n of r) {
                      const r = e1[n.corners[0]],
                        o = e1[n.corners[1]],
                        s = e1[n.corners[2]],
                        a = [o[0] - r[0], o[1] - r[1], t * (o[2] - r[2])],
                        l = Mu.cross(a, a, [
                          s[0] - r[0],
                          s[1] - r[1],
                          t * (s[2] - r[2]),
                        ]);
                      Mu.normalize(l, l), (n.dotProductWithUp = Mu.dot(l, i));
                    }
                    return (
                      r.sort(
                        (e1, t) => e1.dotProductWithUp - t.dotProductWithUp,
                      ),
                      r[0].corners
                    );
                  })(r, n),
                  s = r[o[0]],
                  a = r[o[1]],
                  l = r[o[2]],
                  c = r[o[3]],
                  h = i.getAtPointOrZero(
                    new ep(s[0] / e1.worldSize, s[1] / e1.worldSize),
                    0,
                  ),
                  u = i.getAtPointOrZero(
                    new ep(a[0] / e1.worldSize, a[1] / e1.worldSize),
                    0,
                  ),
                  d = i.getAtPointOrZero(
                    new ep(l[0] / e1.worldSize, l[1] / e1.worldSize),
                    0,
                  ),
                  p = i.getAtPointOrZero(
                    new ep(c[0] / e1.worldSize, c[1] / e1.worldSize),
                    0,
                  ),
                  f = (h + p) / 2,
                  m = (u + d) / 2;
                return (
                  f > m
                    ? u < d
                      ? gv(t, a, c, s, u, p, h, n)
                      : gv(t, l, s, c, d, h, p, n)
                    : h < p
                    ? gv(t, s, a, l, h, u, d, n)
                    : gv(t, c, l, a, p, d, u, n),
                  Math.max(f, m)
                );
              }
              computeModelMatrix(e1, t, i, r, n, o, s = !1) {
                const a = e1.transform,
                  l = a.zoom,
                  c = a.project(this.position),
                  h = Kd(this.position.lat, l),
                  u = 1 / h;
                xu.identity(this.matrix),
                  xu.translate(this.matrix, this.matrix, [
                    c.x + r[0] * u,
                    c.y + r[1] * u,
                    r[2],
                  ]);
                let d = 1,
                  p = 1;
                const f = a.worldSize;
                if (s) {
                  if ("mercator" === a.projection.name) {
                    let e1 = 0;
                    a.elevation &&
                      (e1 = a.elevation.getAtPointOrZero(
                        new ep(c.x / f, c.y / f),
                        0,
                      ));
                    const t =
                      uu.transformMat4([], [c.x, c.y, e1, 1], a.projMatrix)[3] /
                      a.cameraToCenterDistance;
                    (d = t), (p = t * Kd(a.center.lat, l));
                  } else if ("globe" === a.projection.name) {
                    const e1 = yv(this.matrix, a),
                      t = xu.multiply([], a.projMatrix, e1),
                      i = [0, 0, 0, 1];
                    uu.transformMat4(i, i, t);
                    const r = i[3] / a.cameraToCenterDistance,
                      n = Ed(l),
                      o =
                        a.projection.pixelsPerMeter(this.position.lat, f) *
                        Kd(this.position.lat, l),
                      s =
                        a.projection.pixelsPerMeter(a.center.lat, f) *
                        Kd(a.center.lat, l);
                    (d = r / Wr(o, Yd(a.center.lat), n)),
                      (p = (r * h) / o),
                      (d *= s),
                      (p *= s);
                  }
                } else d = u;
                xu.scale(this.matrix, this.matrix, [d, d, p]);
                const m = [...this.matrix],
                  _ = this.orientation,
                  g = [];
                if (
                  (_v(g, [_[0] + t[0], _[1] + t[1], _[2] + t[2]], i),
                  xu.multiply(this.matrix, m, g),
                  n && a.elevation)
                ) {
                  let e1 = 0;
                  const t = [];
                  if (o && a.elevation) {
                    e1 = this._positionModelOnTerrain(a, t);
                    const i = xu.fromQuat([], t),
                      r = xu.multiply([], i, g);
                    xu.multiply(this.matrix, m, r);
                  } else
                    e1 = a.elevation.getAtPointOrZero(
                      new ep(c.x / f, c.y / f),
                      0,
                    );
                  0 !== e1 && (this.matrix[14] += e1);
                }
              }
              upload(e1) {
                if (!this.uploaded) {
                  for (const t of this.nodes) Ev(t, e1);
                  for (const e1 of this.nodes) Mv(e1);
                  this.uploaded = !0;
                }
              }
              destroy() {
                for (const e1 of this.nodes) Av(e1);
              }
            }
            function wv(e1, t, i = !1) {
              e1.uploaded ||
                ((e1.gfxTexture = new gy(t, e1.image, i ? t.gl.R8 : t.gl.RGBA, {
                  useMipmap:
                    e1.sampler.minFilter >= t.gl.NEAREST_MIPMAP_NEAREST,
                })),
                (e1.uploaded = !0),
                (e1.image = null));
            }
            function Tv(e1, t, i) {
              (e1.indexBuffer = t.createIndexBuffer(e1.indexArray, !1, !0)),
                (e1.vertexBuffer = t.createVertexBuffer(
                  e1.vertexArray,
                  zx.members,
                  !1,
                  !0,
                )),
                e1.normalArray &&
                  (e1.normalBuffer = t.createVertexBuffer(
                    e1.normalArray,
                    Lx.members,
                    !1,
                    !0,
                  )),
                e1.texcoordArray &&
                  (e1.texcoordBuffer = t.createVertexBuffer(
                    e1.texcoordArray,
                    Rx.members,
                    !1,
                    !0,
                  )),
                e1.colorArray &&
                  (e1.colorBuffer = t.createVertexBuffer(
                    e1.colorArray,
                    (12 === e1.colorArray.bytesPerElement ? Dx : Px).members,
                    !1,
                    !0,
                  )),
                e1.featureArray &&
                  (e1.pbrBuffer = t.createVertexBuffer(
                    e1.featureArray,
                    Ox.members,
                    !0,
                  )),
                (e1.segments = dl.simpleSegment(
                  0,
                  0,
                  e1.vertexArray.length,
                  e1.indexArray.length,
                ));
              const r = e1.material;
              r.pbrMetallicRoughness.baseColorTexture &&
                wv(r.pbrMetallicRoughness.baseColorTexture, t),
                r.pbrMetallicRoughness.metallicRoughnessTexture &&
                  wv(r.pbrMetallicRoughness.metallicRoughnessTexture, t),
                r.normalTexture && wv(r.normalTexture, t),
                r.occlusionTexture && wv(r.occlusionTexture, t, i),
                r.emissionTexture && wv(r.emissionTexture, t);
            }
            function Ev(e1, t, i) {
              if (e1.meshes) for (const r of e1.meshes) Tv(r, t, i);
              if (e1.children) for (const r of e1.children) Ev(r, t, i);
            }
            function Mv(e1) {
              if (e1.meshes)
                for (const t of e1.meshes)
                  t.indexArray.destroy(),
                    t.vertexArray.destroy(),
                    t.colorArray && t.colorArray.destroy(),
                    t.normalArray && t.normalArray.destroy(),
                    t.texcoordArray && t.texcoordArray.destroy(),
                    t.featureArray && t.featureArray.destroy();
              if (e1.children) for (const t of e1.children) Mv(t);
            }
            function Av(e1) {
              if (e1.meshes)
                for (const i of e1.meshes)
                  i.vertexBuffer &&
                    (i.vertexBuffer.destroy(),
                    i.indexBuffer.destroy(),
                    i.normalBuffer && i.normalBuffer.destroy(),
                    i.texcoordBuffer && i.texcoordBuffer.destroy(),
                    i.colorBuffer && i.colorBuffer.destroy(),
                    i.pbrBuffer && i.pbrBuffer.destroy(),
                    i.segments.destroy(),
                    i.material &&
                      ((t = i.material).pbrMetallicRoughness.baseColorTexture &&
                        t.pbrMetallicRoughness.baseColorTexture.gfxTexture &&
                        t.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(),
                      t.pbrMetallicRoughness.metallicRoughnessTexture &&
                        t.pbrMetallicRoughness.metallicRoughnessTexture
                          .gfxTexture &&
                        t.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(),
                      t.normalTexture &&
                        t.normalTexture.gfxTexture &&
                        t.normalTexture.gfxTexture.destroy(),
                      t.emissionTexture &&
                        t.emissionTexture.gfxTexture &&
                        t.emissionTexture.gfxTexture.destroy(),
                      t.occlusionTexture &&
                        t.occlusionTexture.gfxTexture &&
                        t.occlusionTexture.gfxTexture.destroy()));
              var t;
              if (e1.children) for (const t of e1.children) Av(t);
            }
            class Sv {
              constructor(e1, t) {
                (this.feature = e1),
                  (this.instancedDataOffset = t),
                  (this.instancedDataCount = 0),
                  (this.rotation = [0, 0, 0]),
                  (this.scale = [1, 1, 1]),
                  (this.translation = [0, 0, 0]);
              }
            }
            class Iv {
              constructor() {
                (this.instancedDataArray = new Ya()),
                  (this.instancesEvaluatedElevation = []),
                  (this.features = []),
                  (this.idToFeaturesIndex = {});
              }
            }
            class Cv {
              constructor(e1) {
                (this.zoom = e1.zoom),
                  (this.canonical = e1.canonical),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.projection = e1.projection),
                  (this.index = e1.index),
                  (this.hasZoomDependentProperties =
                    this.layers[0].isZoomDependent()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id)),
                  (this.hasPattern = !1),
                  (this.instancesPerModel = {}),
                  (this.validForExaggeration = 0),
                  (this.maxVerticalOffset = 0),
                  (this.maxScale = 0),
                  (this.maxHeight = 0),
                  (this.lookupDim =
                    this.zoom > this.canonical.z
                      ? 256
                      : this.zoom > 15
                      ? 75
                      : 100),
                  (this.instanceCount = 0),
                  (this.terrainElevationMin = 0),
                  (this.terrainElevationMax = 0),
                  (this.validForDEMTile = {
                    id: null,
                    timestamp: 0,
                  });
              }
              populate(e1, t, i, r) {
                this.tileToMeter = Qd(i);
                const n = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const {
                  feature: o,
                  id: s,
                  index: a,
                  sourceLayerIndex: l,
                } of e1) {
                  const e1 = cp(o, n);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ea(this.zoom),
                      e1,
                      i,
                    )
                  )
                    continue;
                  const c = {
                      id: s,
                      sourceLayerIndex: l,
                      index: a,
                      geometry: n ? e1.geometry : lp(o, i, r),
                      properties: o.properties,
                      type: o.type,
                      patterns: {},
                    },
                    h = this.addFeature(c, c.geometry, e1);
                  h &&
                    t.featureIndex.insert(
                      o,
                      c.geometry,
                      a,
                      l,
                      this.index,
                      this.instancesPerModel[h].instancedDataArray.length,
                    );
                }
                this.lookup = null;
              }
              update(e1, t, i, r) {
                for (const t in this.instancesPerModel) {
                  const i = this.instancesPerModel[t];
                  for (const t in e1)
                    i.idToFeaturesIndex.hasOwnProperty(t) &&
                      this.evaluate(
                        i.features[i.idToFeaturesIndex[t]],
                        e1[t],
                        i,
                        !0,
                      );
                }
                this.maxHeight = 0;
              }
              updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let e1 = !1;
                for (const t in this.instancesPerModel) {
                  const i = this.instancesPerModel[t];
                  for (const t of i.features) {
                    const r = this.layers[0],
                      n = t.feature,
                      o = this.canonical,
                      s = r.paint.get("model-rotation").evaluate(n, {}, o),
                      a = r.paint.get("model-scale").evaluate(n, {}, o),
                      l = r.paint.get("model-translation").evaluate(n, {}, o);
                    (Mu.exactEquals(t.rotation, s) &&
                      Mu.exactEquals(t.scale, a) &&
                      Mu.exactEquals(t.translation, l)) ||
                      (this.evaluate(t, t.featureStates, i, !0), (e1 = !0));
                  }
                }
                return e1;
              }
              isEmpty() {
                for (const e1 in this.instancesPerModel)
                  if (
                    0 !== this.instancesPerModel[e1].instancedDataArray.length
                  )
                    return !1;
                return !0;
              }
              uploadPending() {
                return !this.uploaded;
              }
              upload(e1) {
                if (!this.uploaded)
                  for (const t in this.instancesPerModel) {
                    const i = this.instancesPerModel[t];
                    i.instancedDataArray.length < 0 ||
                      0 === i.instancedDataArray.length ||
                      (i.instancedDataBuffer
                        ? i.instancedDataBuffer.updateData(i.instancedDataArray)
                        : (i.instancedDataBuffer = e1.createVertexBuffer(
                            i.instancedDataArray,
                            kx.members,
                            !0,
                            void 0,
                            this.instanceCount,
                          )));
                  }
                this.uploaded = !0;
              }
              destroy() {
                for (const e1 in this.instancesPerModel) {
                  const t = this.instancesPerModel[e1];
                  0 !== t.instancedDataArray.length &&
                    t.instancedDataBuffer &&
                    t.instancedDataBuffer.destroy();
                }
              }
              addFeature(e1, t, i) {
                const r = this.layers[0],
                  n = r.layout.get("model-id").evaluate(i, {}, this.canonical);
                if (!n)
                  return (
                    W(
                      `modelId is not evaluated for layer ${r.id} and it is not going to get rendered.`,
                    ),
                    n
                  );
                this.instancesPerModel[n] ||
                  (this.instancesPerModel[n] = new Iv());
                const o = this.instancesPerModel[n],
                  s = o.instancedDataArray,
                  a = new Sv(i, s.length);
                for (const e1 of t)
                  for (const t of e1) {
                    if (t.x < 0 || t.x >= sr || t.y < 0 || t.y >= sr) continue;
                    const e1 = (this.lookupDim - 1) / sr,
                      i = (this.lookupDim * ((t.y * e1) | 0) + t.x * e1) | 0;
                    if (this.lookup) {
                      if (0 !== this.lookup[i]) continue;
                      this.lookup[i] = 1;
                    }
                    this.instanceCount++;
                    const r = s.length;
                    s.resize(r + 1),
                      o.instancesEvaluatedElevation.push(0),
                      (s.float32[16 * r] = t.x),
                      (s.float32[16 * r + 1] = t.y);
                  }
                return (
                  (a.instancedDataCount =
                    o.instancedDataArray.length - a.instancedDataOffset),
                  a.instancedDataCount > 0 &&
                    (e1.id && (o.idToFeaturesIndex[e1.id] = o.features.length),
                    o.features.push(a),
                    this.evaluate(a, {}, o, !1)),
                  n
                );
              }
              evaluate(e1, t, i, r) {
                const n = this.layers[0],
                  o = e1.feature,
                  s = this.canonical,
                  a = (e1.rotation = n.paint
                    .get("model-rotation")
                    .evaluate(o, t, s)),
                  l = (e1.scale = n.paint.get("model-scale").evaluate(o, t, s)),
                  c = (e1.translation = n.paint
                    .get("model-translation")
                    .evaluate(o, t, s)),
                  h = n.paint.get("model-color").evaluate(o, t, s);
                h.a = n.paint
                  .get("model-color-mix-intensity")
                  .evaluate(o, t, s);
                const u = [];
                this.maxVerticalOffset < c[2] &&
                  (this.maxVerticalOffset = c[2]),
                  (this.maxScale = Math.max(
                    Math.max(this.maxScale, l[0]),
                    Math.max(l[1], l[2]),
                  )),
                  _v(u, a, l);
                const d = Math.round(100 * h.a) + h.b / 1.05;
                for (let t = 0; t < e1.instancedDataCount; ++t) {
                  const n = e1.instancedDataOffset + t,
                    o = 16 * n,
                    a = i.instancedDataArray.float32;
                  let l = 0;
                  r && (l = a[o + 6] - i.instancesEvaluatedElevation[n]);
                  const p = 0 | a[o + 1];
                  (a[o] = (0 | a[o]) + h.r / 1.05),
                    (a[o + 1] = p + h.g / 1.05),
                    (a[o + 2] = d),
                    (a[o + 3] = 1 / (s.z > 10 ? this.tileToMeter : Qd(s, p))),
                    (a[o + 4] = c[0]),
                    (a[o + 5] = c[1]),
                    (a[o + 6] = c[2] + l),
                    (a[o + 7] = u[0]),
                    (a[o + 8] = u[1]),
                    (a[o + 9] = u[2]),
                    (a[o + 10] = u[4]),
                    (a[o + 11] = u[5]),
                    (a[o + 12] = u[6]),
                    (a[o + 13] = u[8]),
                    (a[o + 14] = u[9]),
                    (a[o + 15] = u[10]),
                    (i.instancesEvaluatedElevation[n] = c[2]);
                }
              }
            }
            Is(Cv, "ModelBucket", {
              omit: ["layers"],
            }),
              Is(Iv, "PerModelAttributes"),
              Is(Sv, "ModelFeature");
            const zv = new da({
              visibility: new ca(Ct.layout_model.visibility),
              "model-id": new ha(Ct.layout_model["model-id"]),
            });
            var Dv = {
              paint: new da({
                "model-opacity": new ca(Ct.paint_model["model-opacity"]),
                "model-rotation": new ha(Ct.paint_model["model-rotation"]),
                "model-scale": new ha(Ct.paint_model["model-scale"]),
                "model-translation": new ha(
                  Ct.paint_model["model-translation"],
                ),
                "model-color": new ha(Ct.paint_model["model-color"]),
                "model-color-mix-intensity": new ha(
                  Ct.paint_model["model-color-mix-intensity"],
                ),
                "model-type": new ca(Ct.paint_model["model-type"]),
                "model-cast-shadows": new ca(
                  Ct.paint_model["model-cast-shadows"],
                ),
                "model-receive-shadows": new ca(
                  Ct.paint_model["model-receive-shadows"],
                ),
                "model-ambient-occlusion-intensity": new ca(
                  Ct.paint_model["model-ambient-occlusion-intensity"],
                ),
                "model-emissive-strength": new ha(
                  Ct.paint_model["model-emissive-strength"],
                ),
                "model-roughness": new ha(Ct.paint_model["model-roughness"]),
                "model-height-based-emissive-strength-multiplier": new ha(
                  Ct.paint_model[
                    "model-height-based-emissive-strength-multiplier"
                  ],
                ),
                "model-cutoff-fade-range": new ca(
                  Ct.paint_model["model-cutoff-fade-range"],
                ),
              }),
              layout: zv,
            };
            const Pv = new Float32Array(262144),
              Rv = new Uint8Array(262144);
            function Lv(e1) {
              let t = 0;
              if (e1.meshes)
                for (const i of e1.meshes) t = Math.max(t, i.aabb.max[2]);
              if (e1.children)
                for (const i of e1.children) t = Math.max(t, Lv(i));
              return t;
            }
            const kv = ["", "wall", "door", "roof", "window", "lamp", "logo"];
            class Ov {
              constructor(e1) {
                (this.node = e1),
                  (this.evaluatedRMEA = [
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [0.4, 1, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                  ]),
                  (this.hiddenByReplacement = !1),
                  (this.evaluatedScale = [1, 1, 1]),
                  (this.evaluatedColor = []),
                  (this.emissionHeightBasedParams = []),
                  (this.feature = {
                    type: "Point",
                    id: e1.id,
                    geometry: [],
                    properties: {
                      height: Lv(e1),
                    },
                  });
              }
            }
            class Bv {
              constructor(e1, t, i, r) {
                (this.nodes = e1),
                  (this.id = t),
                  (this.modelTraits |= 1),
                  (this.uploaded = !1),
                  (this.hasPattern = !1),
                  i && (this.modelTraits |= 4),
                  (this.zoom = -1),
                  (this.terrainExaggeration = 1),
                  (this.projection = {
                    name: "mercator",
                  }),
                  (this.replacementUpdateTime = 0),
                  (this.elevationReadFromZ = 255),
                  (this.brightness = r),
                  (this.dirty = !0),
                  (this.needsUpload = !1);
              }
              update() {
                console.log("Update 3D model bucket");
              }
              populate() {
                console.log("populate 3D model bucket");
              }
              uploadPending() {
                return !this.uploaded || this.needsUpload;
              }
              upload(e1) {
                if (!this.needsUpload) return;
                const t = this.getNodesInfo();
                for (const i of t) {
                  const t = i.node;
                  this.uploaded ? this.updatePbrBuffer(t) : Ev(t, e1, !0);
                }
                for (const e1 of t) Mv(e1.node);
                (this.uploaded = !0), (this.needsUpload = !1);
              }
              updatePbrBuffer(e1) {
                let t = !1;
                if (!e1.meshes) return t;
                for (const i of e1.meshes)
                  i.pbrBuffer &&
                    (i.pbrBuffer.updateData(i.featureArray), (t = !0));
                return t;
              }
              needsReEvaluation(e1, t, i) {
                const r = e1.transform.projectionOptions,
                  n = e1.style.getBrightness(),
                  o = this.brightness !== n;
                return (
                  !!(
                    !this.uploaded ||
                    this.dirty ||
                    r.name !== this.projection.name ||
                    Fv(i.paint.get("model-color").value, o) ||
                    Fv(i.paint.get("model-color-mix-intensity").value, o) ||
                    Fv(i.paint.get("model-roughness").value, o) ||
                    Fv(i.paint.get("model-emissive-strength").value, o) ||
                    Fv(
                      i.paint.get(
                        "model-height-based-emissive-strength-multiplier",
                      ).value,
                      o,
                    )
                  ) && ((this.projection = r), (this.brightness = n), !0)
                );
              }
              evaluateScale(e1, t) {
                if (e1.transform.zoom === this.zoom) return;
                this.zoom = e1.transform.zoom;
                const i = this.getNodesInfo(),
                  r = this.id.canonical;
                for (const e1 of i) {
                  const i = e1.feature;
                  e1.evaluatedScale = t.paint
                    .get("model-scale")
                    .evaluate(i, {}, r);
                }
              }
              evaluate(e1) {
                const t = this.getNodesInfo();
                for (const i of t) {
                  if (!i.node.meshes) continue;
                  const t = i.feature,
                    r = i.node.meshes && i.node.meshes[0].featureData,
                    n = i.evaluatedColor[2],
                    o = i.evaluatedRMEA[2],
                    s = this.id.canonical;
                  if (((i.hasTranslucentParts = !1), r)) {
                    for (let r = 0; r < kv.length; r++) {
                      const n = kv[r];
                      n.length && (t.properties.part = n);
                      const o = e1.paint.get("model-color").evaluate(t, {}, s),
                        a = e1.paint
                          .get("model-color-mix-intensity")
                          .evaluate(t, {}, s);
                      (i.evaluatedColor[r] = [o.r, o.g, o.b, a]),
                        (i.evaluatedRMEA[r][0] = e1.paint
                          .get("model-roughness")
                          .evaluate(t, {}, s)),
                        (i.evaluatedRMEA[r][2] = e1.paint
                          .get("model-emissive-strength")
                          .evaluate(t, {}, s)),
                        (i.evaluatedRMEA[r][3] = o.a),
                        (i.emissionHeightBasedParams[r] = e1.paint
                          .get(
                            "model-height-based-emissive-strength-multiplier",
                          )
                          .evaluate(t, {}, s)),
                        !i.hasTranslucentParts &&
                          o.a < 1 &&
                          (i.hasTranslucentParts = !0);
                    }
                    delete t.properties.part,
                      Uv(
                        i,
                        n !== i.evaluatedColor[2] || o !== i.evaluatedRMEA[2],
                      );
                  }
                  (i.evaluatedScale = e1.paint
                    .get("model-scale")
                    .evaluate(t, {}, s)),
                    this.updatePbrBuffer(i.node) || (this.needsUpload = !0);
                }
                this.dirty = !1;
              }
              elevationUpdate(e1, t, i, r) {
                const n = e1.findDEMTileFor(i);
                if (
                  n &&
                  (n.tileID.canonical !== this.terrainTile ||
                    t !== this.terrainExaggeration)
                ) {
                  if (
                    n.dem &&
                    n.tileID.overscaledZ !== this.elevationReadFromZ
                  ) {
                    this.elevationReadFromZ = n.tileID.overscaledZ;
                    const t = qm.create(e1, i, n);
                    if (!t) return;
                    4 & this.modelTraits && this.updateDEM(e1, t, i, r);
                    for (const e1 of this.getNodesInfo()) {
                      const i = e1.node;
                      if (
                        !i.footprint ||
                        !i.footprint.vertices ||
                        !i.footprint.vertices.length
                      )
                        continue;
                      const r = i.footprint.vertices;
                      let n = t.getElevationAt(r[0].x, r[0].y, !0, !0);
                      for (let e1 = 1; e1 < r.length; e1++)
                        n = Math.min(
                          n,
                          t.getElevationAt(r[e1].x, r[e1].y, !0, !0),
                        );
                      i.elevation = n;
                    }
                  }
                  (this.terrainTile = n.tileID.canonical),
                    (this.terrainExaggeration = t);
                }
              }
              updateDEM(e1, t, i, r) {
                let n = t._dem._modifiedForSources[r];
                if (
                  (void 0 === n &&
                    ((t._dem._modifiedForSources[r] = []),
                    (n = t._dem._modifiedForSources[r])),
                  n.includes(i.canonical))
                )
                  return;
                const o = t._dem.dim;
                n.push(i.canonical);
                let s = !1;
                for (const e1 of this.getNodesInfo()) {
                  const i = e1.node;
                  if (!i.footprint || !i.footprint.grid) continue;
                  const r = i.footprint.grid,
                    n = t.tileCoordToPixel(r.min.x, r.min.y),
                    a = t.tileCoordToPixel(r.max.x, r.max.y),
                    l = Math.min(
                      Math.min(o - a.y, n.x),
                      Math.min(n.y, o - a.x),
                    );
                  if (l < 0) continue;
                  const c = z(l, 2, 5);
                  let h = Math.max(0, n.x - c),
                    u = Math.max(0, n.y - c),
                    d = Math.min(a.x + c, o - 1),
                    p = Math.min(a.y + c, o - 1);
                  for (let e1 = u; e1 <= p; ++e1)
                    for (let t = h; t <= d; ++t) Rv[e1 * o + t] = 255;
                  let f = 0,
                    m = 0;
                  for (let e1 = 0; e1 < r.cellsY; ++e1)
                    for (let i = 0; i < r.cellsX; ++i) {
                      if (!r.cells[e1 * r.cellsX + i]) continue;
                      const n = t.tileCoordToPixel(
                          r.min.x + i / r.xScale,
                          r.min.y + e1 / r.yScale,
                        ),
                        s = t.tileCoordToPixel(
                          r.min.x + (i + 1) / r.xScale,
                          r.min.y + (e1 + 1) / r.yScale,
                        );
                      for (let e1 = n.y; e1 <= Math.min(s.y + 1, o - 1); ++e1)
                        for (let i = n.x; i <= Math.min(s.x + 1, o - 1); ++i)
                          255 === Rv[e1 * o + i] &&
                            ((Rv[e1 * o + i] = 0),
                            (f += t.getElevationAtPixel(i, e1)),
                            m++);
                    }
                  const _ = f / m;
                  (h = Math.max(1, n.x - c)),
                    (u = Math.max(1, n.y - c)),
                    (d = Math.min(a.x + c, o - 2)),
                    (p = Math.min(a.y + c, o - 2)),
                    (s = !0);
                  for (let e1 = u; e1 <= p; ++e1)
                    for (let i = h; i <= d; ++i)
                      0 === Rv[e1 * o + i] &&
                        (Pv[e1 * o + i] = t._dem.set(i, e1, _));
                  for (let e1 = 1; e1 < c; ++e1) {
                    (h = Math.max(1, n.x - e1)),
                      (u = Math.max(1, n.y - e1)),
                      (d = Math.min(a.x + e1, o - 2)),
                      (p = Math.min(a.y + e1, o - 2));
                    for (let i = u; i <= p; ++i)
                      for (let r = h; r <= d; ++r) {
                        const n = i * o + r;
                        if (255 === Rv[n]) {
                          let s = 0,
                            a = 0,
                            l = -1,
                            h = -1;
                          for (let t = -1; t <= 1; ++t)
                            for (let n = -1; n <= 1; ++n) {
                              const c = (i + t) * o + r + n;
                              if (Rv[c] >= e1) continue;
                              const u = Pv[c],
                                d = Math.abs(u);
                              d > a && ((s = u), (a = d), (l = n), (h = t));
                            }
                          if (a > 0.1) {
                            const o = 1 - (e1 + 0.5 * Math.abs(l * h)) / c;
                            let a = t._dem.get(r, i) + s * o;
                            const u = t._dem.get(r + l, i + h),
                              d = t._dem.get(r - l, i - h, !0);
                            (a - u) * (a - d) > 0 && (a = (u + d) / 2),
                              (Pv[n] = t._dem.set(r, i, a)),
                              (Rv[n] = e1);
                          }
                        }
                      }
                  }
                }
                s &&
                  ((t._demTile.needsDEMTextureUpload = !0),
                  (t._dem._timestamp = ht.now()));
              }
              getNodesInfo() {
                if (!this.nodesInfo) {
                  this.nodesInfo = [];
                  for (const e1 of this.nodes) this.nodesInfo.push(new Ov(e1));
                  this.freeNodes();
                }
                return this.nodesInfo;
              }
              freeNodes() {
                if (this.nodes) {
                  for (const e1 of this.nodes) Av(e1);
                  this.nodes.splice(0, this.nodes.length);
                }
              }
              destroy() {
                this.freeNodes();
                const e1 = this.getNodesInfo();
                for (const t of e1) Mv(t.node), Av(t.node);
              }
              isEmpty() {
                return !this.nodes.length;
              }
              updateReplacement(e1, t) {
                if (t.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = t.updateTime;
                const i = t.getReplacementRegionsForTile(e1.toUnwrapped()),
                  r = this.getNodesInfo();
                for (let e1 = 0; e1 < this.nodesInfo.length; e1++) {
                  const t = r[e1].node;
                  r[e1].hiddenByReplacement =
                    !!t.footprint &&
                    !i.find((e1) => e1.footprint === t.footprint);
                }
              }
              getHeightAtTileCoord(e1, t) {
                const i = this.getNodesInfo(),
                  r = [];
                for (let n = 0; n < this.nodesInfo.length; n++) {
                  const o = i[n],
                    s = o.node.meshes[0];
                  if (
                    e1 < s.aabb.min[0] ||
                    t < s.aabb.min[1] ||
                    e1 > s.aabb.max[0] ||
                    t > s.aabb.max[1]
                  )
                    continue;
                  const a =
                      (((e1 - s.aabb.min[0]) /
                        (s.aabb.max[0] - s.aabb.min[0])) *
                        xv) |
                      0,
                    l =
                      Math.min(
                        63,
                        (((t - s.aabb.min[1]) /
                          (s.aabb.max[1] - s.aabb.min[1])) *
                          xv) |
                          0,
                      ) *
                        xv +
                      Math.min(63, a);
                  if (!(s.heightmap[l] < 0 && o.node.footprint)) {
                    if (o.hiddenByReplacement) return;
                    return {
                      height: s.heightmap[l],
                      maxHeight: o.feature.properties.height,
                      hidden: !1,
                      verticalScale: o.evaluatedScale[2],
                    };
                  }
                  if (
                    (o.node.footprint.grid.query(new y(e1, t), new y(e1, t), r),
                    r.length > 0)
                  )
                    return {
                      height: void 0,
                      maxHeight: o.feature.properties.height,
                      hidden: o.hiddenByReplacement,
                      verticalScale: o.evaluatedScale[2],
                    };
                }
              }
            }
            function Fv(e1, t) {
              return !e1.isLightConstant && t;
            }
            function Nv(e1, t, i, r, n, o, s, a) {
              let l = ((61440 & t) | ((61440 & t) >> 4)) >> 8,
                c = ((3840 & t) | ((3840 & t) >> 4)) >> 4,
                h = (240 & t) | ((240 & t) >> 4);
              i[3] > 0 &&
                ((l = Wr(l, 255 * i[0], i[3])),
                (c = Wr(c, 255 * i[1], i[3])),
                (h = Wr(h, 255 * i[2], i[3])));
              const u = (l << 8) | c,
                d = (h << 8) | Math.floor(255 * r[3]),
                p =
                  ((function (e1) {
                    const t = z(e1, 0, 2);
                    return Math.min(Math.round(0.5 * t * 255), 255);
                  })(r[2]) <<
                    8) |
                  ((15 * r[0]) << 4) |
                  (15 * r[1]),
                f = z(n[0], 0, 1),
                m = z(n[1], 0, 1),
                _ = z(n[2], 0, 1),
                g = z(n[3], 0, 1);
              let y, x, v, b;
              if (f !== m && s !== o && m !== f) {
                const e1 = s - o;
                (x = 1 / (e1 * (m - f))), (v = -(o + e1 * f) / (e1 * (m - f)));
                const t = z(n[4], -1, 1);
                (b = Math.pow(10, t)), (y = ((255 * _) << 8) | (255 * g));
              } else (y = 65535), (x = 0), (v = 1), (b = 1);
              if ((e1.emplaceBack(u, d, p, y, x, v, b), a)) {
                const e1 = a.length;
                a.clear();
                for (let t = 0; t < e1; t++) a.emplaceBack(u, d, p, y, x, v, b);
              }
            }
            function Uv(e1, t) {
              const i = e1.node;
              let r = 0;
              for (const n of i.meshes) {
                if (i.lights && i.lightMeshIndex === r) continue;
                if (!n.featureData) continue;
                (n.featureArray = new Ka()),
                  n.featureArray.reserve(n.featureData.length);
                let o = t;
                for (const t of n.featureData) {
                  let r;
                  const s = 65535 & t,
                    a = (15 & s) < 8 ? 15 & s : 0,
                    l = (t >> 16) & 65535,
                    c = e1.evaluatedRMEA[a],
                    h = e1.evaluatedColor[a],
                    u = e1.emissionHeightBasedParams[a];
                  if (
                    (o &&
                      2 === a &&
                      i.lights &&
                      ((r = new Ka()), r.resize(10 * i.lights.length)),
                    Nv(
                      n.featureArray,
                      l,
                      h,
                      c,
                      u,
                      n.aabb.min[2],
                      n.aabb.max[2],
                      r,
                    ),
                    r && o)
                  ) {
                    o = !1;
                    const e1 = i.meshes[i.lightMeshIndex];
                    (e1.featureArray = r), e1.featureArray._trim();
                  }
                }
                n.featureArray._trim(), r++;
              }
            }
            Is(Bv, "Tiled3dModelBucket", {
              omit: ["layers"],
            }),
              Is(Ov, "Tiled3dModelFeature");
            class Vv {
              constructor() {
                (this._updateTime = 0),
                  (this._sourceIds = []),
                  (this._activeRegions = []),
                  (this._prevRegions = []);
              }
              clear() {
                this._activeRegions.length > 0 && ++this._updateTime,
                  (this._activeRegions = []),
                  (this._prevRegions = []);
              }
              get updateTime() {
                return this._updateTime;
              }
              getReplacementRegionsForTile(e1) {
                const t = Zv(new y(0, 0), new y(sr, sr), e1),
                  i = [];
                for (const r of this._activeRegions) {
                  if (r.hiddenByOverlap) continue;
                  if (!qv(t, r)) continue;
                  const n = $v(r.min, r.max, e1);
                  i.push({
                    min: n.min,
                    max: n.max,
                    sourceId: this._sourceIds[r.priority],
                    footprint: r.footprint,
                    footprintTileId: r.tileId,
                  });
                }
                return i;
              }
              setSources(e1) {
                this._setSources(
                  e1.map((e1) => ({
                    getSourceId: () => e1.cache.id,
                    getFootprints: () => {
                      const t = [];
                      for (const i of e1.cache.getVisibleCoordinates()) {
                        const r = e1.cache.getTile(i).buckets[e1.layer];
                        if (r)
                          for (const e1 of r.getNodesInfo()) {
                            const r = e1.node;
                            r.footprint &&
                              t.push({
                                footprint: r.footprint,
                                id: i.toUnwrapped(),
                              });
                          }
                      }
                      return t;
                    },
                  })),
                );
              }
              _addSource(e1) {
                const t = e1.getFootprints();
                if (0 !== t.length) {
                  for (const e1 of t) {
                    if (!e1.footprint) continue;
                    const t = Zv(e1.footprint.min, e1.footprint.max, e1.id);
                    this._activeRegions.push({
                      min: t.min,
                      max: t.max,
                      hiddenByOverlap: !1,
                      priority: this._sourceIds.length,
                      tileId: e1.id,
                      footprint: e1.footprint,
                    });
                  }
                  this._sourceIds.push(e1.getSourceId());
                }
              }
              _computeReplacement() {
                this._activeRegions.sort(
                  (e1, t) =>
                    e1.priority - t.priority ||
                    jv(e1.min, t.min) ||
                    jv(e1.max, t.max),
                );
                let e1 =
                  this._activeRegions.length !== this._prevRegions.length;
                if (!e1) {
                  let t = 0,
                    i = 0;
                  for (; !e1 && t !== this._activeRegions.length; ) {
                    const r = this._activeRegions[t],
                      n = this._prevRegions[i];
                    (e1 = r.priority !== n.priority || !Gv(r, n)), ++t, ++i;
                  }
                }
                if (e1) {
                  ++this._updateTime;
                  const e1 = (e1) => {
                    const t = this._activeRegions;
                    if (e1 >= t.length) return e1;
                    const i = t[e1].priority;
                    for (; e1 < t.length && t[e1].priority === i; ) ++e1;
                    return e1;
                  };
                  if (this._sourceIds.length > 1) {
                    let t = 0,
                      i = e1(t);
                    for (; t !== i; ) {
                      let r = t;
                      const n = t;
                      for (; r !== i; ) {
                        const e1 = this._activeRegions[r];
                        e1.hiddenByOverlap = !1;
                        for (let t = 0; t < n; t++) {
                          const i = this._activeRegions[t];
                          if (
                            !i.hiddenByOverlap &&
                            qv(e1, i) &&
                            ((e1.hiddenByOverlap = Wv(
                              e1.footprint,
                              e1.tileId,
                              i.footprint,
                              i.tileId,
                            )),
                            e1.hiddenByOverlap)
                          )
                            break;
                        }
                        ++r;
                      }
                      (t = i), (i = e1(t));
                    }
                  }
                }
              }
              _setSources(e1) {
                ([this._prevRegions, this._activeRegions] = [
                  this._activeRegions,
                  [],
                ]),
                  (this._sourceIds = []);
                for (let t = e1.length - 1; t >= 0; t--) this._addSource(e1[t]);
                this._computeReplacement();
              }
            }
            function jv(e1, t) {
              return e1.x - t.x || e1.y - t.y;
            }
            function Gv(e1, t) {
              return 0 === jv(e1.min, t.min) && 0 === jv(e1.max, t.max);
            }
            function qv(e1, t) {
              return !(
                e1.min.x > t.max.x ||
                e1.max.x < t.min.x ||
                e1.min.y > t.max.y ||
                e1.max.y < t.min.y
              );
            }
            function Zv(e1, t, i) {
              const r = 1 / sr,
                n = 1 / (1 << i.canonical.z),
                o = (t.x * r + i.canonical.x) * n + i.wrap,
                s = (t.y * r + i.canonical.y) * n;
              return {
                min: new y(
                  (e1.x * r + i.canonical.x) * n + i.wrap,
                  (e1.y * r + i.canonical.y) * n,
                ),
                max: new y(o, s),
              };
            }
            function $v(e1, t, i) {
              const r = 1 << i.canonical.z,
                n = ((t.x - i.wrap) * r - i.canonical.x) * sr,
                o = (t.y * r - i.canonical.y) * sr;
              return {
                min: new y(
                  ((e1.x - i.wrap) * r - i.canonical.x) * sr,
                  (e1.y * r - i.canonical.y) * sr,
                ),
                max: new y(n, o),
              };
            }
            function Hv(e1, t, i, r, n, o, s) {
              const a = e1.indices,
                l = e1.vertices,
                c = [];
              for (let h = r; h < r + n; h += 3) {
                const r = t[i[h + 0] + o],
                  n = t[i[h + 1] + o],
                  u = t[i[h + 2] + o],
                  d = Math.min(r.x, n.x, u.x),
                  p = Math.max(r.x, n.x, u.x),
                  f = Math.min(r.y, n.y, u.y),
                  m = Math.max(r.y, n.y, u.y);
                (c.length = 0), e1.grid.query(new y(d, f), new y(p, m), c);
                for (let e1 = 0; e1 < c.length; e1++) {
                  const t = c[e1];
                  if (
                    Ap(
                      l[a[3 * t + 0]],
                      l[a[3 * t + 1]],
                      l[a[3 * t + 2]],
                      r,
                      n,
                      u,
                      s,
                    )
                  )
                    return !0;
                }
              }
              return !1;
            }
            function Wv(e1, t, i, r) {
              if (!e1 || !i) return !1;
              let n = e1.vertices;
              if (!t.canonical.equals(r.canonical) || t.wrap !== r.wrap) {
                if (i.vertices.length < e1.vertices.length)
                  return Wv(i, r, e1, t);
                const o = t.canonical,
                  s = r.canonical,
                  a = Math.pow(2, s.z - o.z);
                n = e1.vertices.map(
                  (e1) =>
                    new y(
                      e1.x * o.x * sr * a - s.x * sr,
                      e1.y * o.y * sr * a - s.y * sr,
                    ),
                );
              }
              return Hv(i, n, e1.indices, 0, e1.indices.length, 0, 0);
            }
            const Xv = im.types,
              Yv = [
                "fill-extrusion-base",
                "fill-extrusion-height",
                "fill-extrusion-color",
                "fill-extrusion-pattern",
                "fill-extrusion-flood-light-wall-radius",
              ],
              Kv = ["fill-extrusion-flood-light-ground-radius"],
              Jv = Math.pow(2, 13),
              Qv = Math.pow(2, 15) - 1,
              eb = new y(0, 1),
              tb = 2147483648;
            function ib(e1, t, i, r, n, o, s, a) {
              e1.emplaceBack(
                (t << 1) + s,
                (i << 1) + o,
                (Math.floor(r * Jv) << 1) + n,
                Math.round(a),
              );
            }
            function rb(e1, t, i, r, n, o) {
              e1.emplaceBack(t.x, t.y, (i.x << 1) + r, (i.y << 1) + n, o);
            }
            function nb(e1, t, i) {
              const r = 16384;
              e1.emplaceBack(t.x, t.y, t.z, i[0] * r, i[1] * r, i[2] * r);
            }
            class ob {
              constructor() {
                (this.vertexOffset = 0),
                  (this.vertexCount = 0),
                  (this.indexOffset = 0),
                  (this.indexCount = 0);
              }
            }
            class sb {
              constructor() {
                (this.centroidXY = new y(0, 0)),
                  (this.vertexArrayOffset = 0),
                  (this.vertexCount = 0),
                  (this.groundVertexArrayOffset = 0),
                  (this.groundVertexCount = 0),
                  (this.flags = 0),
                  (this.footprintSegIdx = -1),
                  (this.footprintSegLen = 0),
                  (this.min = new y(Number.MAX_VALUE, Number.MAX_VALUE)),
                  (this.max = new y(-Number.MAX_VALUE, -Number.MAX_VALUE)),
                  (this.height = 0);
              }
              span() {
                return new y(this.max.x - this.min.x, this.max.y - this.min.y);
              }
            }
            class ab {
              constructor() {
                (this.acc = new y(0, 0)),
                  (this.accCount = 0),
                  (this.centroidDataIndex = 0);
              }
              startRing(e1, t) {
                e1.min.x === Number.MAX_VALUE &&
                  ((e1.min.x = e1.max.x = t.x), (e1.min.y = e1.max.y = t.y));
              }
              appendEdge(e1, t, i) {
                this.accCount++, this.acc._add(t);
                let r = !!this.borders;
                t.x < e1.min.x
                  ? ((e1.min.x = t.x), (r = !0))
                  : t.x > e1.max.x && ((e1.max.x = t.x), (r = !0)),
                  t.y < e1.min.y
                    ? ((e1.min.y = t.y), (r = !0))
                    : t.y > e1.max.y && ((e1.max.y = t.y), (r = !0)),
                  ((0 === t.x || t.x === sr) && t.x === i.x) !=
                    ((0 === t.y || t.y === sr) && t.y === i.y) &&
                    this.processBorderOverlap(t, i),
                  r && this.checkBorderIntersection(t, i);
              }
              checkBorderIntersection(e1, t) {
                t.x < 0 != e1.x < 0 &&
                  this.addBorderIntersection(
                    0,
                    Wr(t.y, e1.y, (0 - t.x) / (e1.x - t.x)),
                  ),
                  t.x > sr != e1.x > sr &&
                    this.addBorderIntersection(
                      1,
                      Wr(t.y, e1.y, (sr - t.x) / (e1.x - t.x)),
                    ),
                  t.y < 0 != e1.y < 0 &&
                    this.addBorderIntersection(
                      2,
                      Wr(t.x, e1.x, (0 - t.y) / (e1.y - t.y)),
                    ),
                  t.y > sr != e1.y > sr &&
                    this.addBorderIntersection(
                      3,
                      Wr(t.x, e1.x, (sr - t.y) / (e1.y - t.y)),
                    );
              }
              addBorderIntersection(e1, t) {
                this.borders ||
                  (this.borders = [
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                  ]);
                const i = this.borders[e1];
                t < i[0] && (i[0] = t), t > i[1] && (i[1] = t);
              }
              processBorderOverlap(e1, t) {
                if (e1.x === t.x) {
                  if (e1.y === t.y) return;
                  const i = 0 === e1.x ? 0 : 1;
                  this.addBorderIntersection(i, t.y),
                    this.addBorderIntersection(i, e1.y);
                } else {
                  const i = 0 === e1.y ? 2 : 3;
                  this.addBorderIntersection(i, t.x),
                    this.addBorderIntersection(i, e1.x);
                }
              }
              centroid() {
                return 0 === this.accCount
                  ? new y(0, 0)
                  : new y(
                      Math.floor(Math.max(0, this.acc.x) / this.accCount),
                      Math.floor(Math.max(0, this.acc.y) / this.accCount),
                    );
              }
              intersectsCount() {
                return this.borders
                  ? this.borders.reduce(
                      (e1, t) => e1 + +(t[0] !== Number.MAX_VALUE),
                      0,
                    )
                  : 0;
              }
            }
            function lb(e1, t) {
              const i = e1.add(t)._unit(),
                r = z(e1.x * i.x + e1.y * i.y, -1, 1);
              var n, o, s;
              return (
                (n = Math.acos(r)),
                (Math.min(4, Math.max(-4, Math.tan(n))) / 4) *
                  Qv *
                  ((o = e1).x * (s = t).y - o.y * s.x < 0 ? -1 : 1)
              );
            }
            const cb = [
              (e1) => e1.x < 0,
              (e1) => e1.x > sr,
              (e1) => e1.y < 0,
              (e1) => e1.y > sr,
            ];
            function hb(e1, t, i, r) {
              const n = [4];
              if (0 === r) return n;
              i._mult(r);
              const o = e1.sub(i),
                s = t.sub(i),
                a = [e1, t, o, s];
              for (let e1 = 0; e1 < 4; e1++)
                for (const t of a)
                  if (cb[e1](t)) {
                    n.push(e1);
                    break;
                  }
              return n;
            }
            class ub {
              constructor(e1) {
                (this.vertexArray = new Aa()),
                  (this.indexArray = new Va()),
                  (this.programConfigurations = new Hl(
                    e1.layers,
                    e1.zoom,
                    (e1) => Kv.includes(e1),
                  )),
                  (this._segments = new dl()),
                  (this.hiddenByLandmarkVertexArray = new Ja()),
                  (this._segmentToGroundQuads = {}),
                  (this._segmentToGroundQuads[0] = []),
                  (this._segmentToRegionTriCounts = {}),
                  (this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0]),
                  (this.regionSegments = {}),
                  (this.regionSegments[4] = new dl());
              }
              getDefaultSegment() {
                return this.regionSegments[4];
              }
              hasData() {
                return 0 !== this.vertexArray.length;
              }
              addData(e1, t, i, r = !1) {
                const n = e1.length;
                if (n > 2) {
                  let o = Math.max(0, this._segments.get().length - 1);
                  const s = this._segments._prepareSegment(
                    4 * n,
                    this.vertexArray.length,
                    2 * this._segmentToGroundQuads[o].length,
                  );
                  let a;
                  o !== this._segments.get().length - 1 &&
                    (o++,
                    (this._segmentToGroundQuads[o] = []),
                    (this._segmentToRegionTriCounts[o] = [0, 0, 0, 0, 0]));
                  {
                    const t = e1[0],
                      i = e1[1];
                    a = lb(
                      t
                        .sub(e1[n - 1])
                        ._perp()
                        ._unit(),
                      i.sub(t)._perp()._unit(),
                    );
                  }
                  for (let l = 0; l < n; l++) {
                    const c = l === n - 1 ? 0 : l + 1,
                      h = e1[l],
                      u = e1[c],
                      d = e1[c === n - 1 ? 0 : c + 1],
                      p = u.sub(h)._perp()._unit(),
                      f = lb(p, d.sub(u)._perp()._unit()),
                      m = a,
                      _ = f;
                    if (_b(h, u, t) || (r && gb(h, t) && gb(u, t))) {
                      a = f;
                      continue;
                    }
                    const g = s.vertexLength;
                    rb(this.vertexArray, h, u, 1, 1, m),
                      rb(this.vertexArray, h, u, 1, 0, m),
                      rb(this.vertexArray, h, u, 0, 1, _),
                      rb(this.vertexArray, h, u, 0, 0, _),
                      (s.vertexLength += 4);
                    const y = hb(h, u, p, i);
                    for (const e1 of y)
                      this._segmentToGroundQuads[o].push({
                        id: g,
                        region: e1,
                      }),
                        (this._segmentToRegionTriCounts[o][e1] += 2),
                        (s.primitiveLength += 2);
                    a = f;
                  }
                }
              }
              prepareBorderSegments() {
                if (!this.hasData()) return;
                const e1 = this._segments.get(),
                  t = e1.length;
                for (let e1 = 0; e1 < t; e1++)
                  this._segmentToGroundQuads[e1].sort(
                    (e1, t) => e1.region - t.region,
                  );
                for (let i = 0; i < t; i++) {
                  const t = this._segmentToGroundQuads[i],
                    r = e1[i],
                    n = this._segmentToRegionTriCounts[i];
                  n.reduce((e1, t) => e1 + t, 0);
                  let o = 0;
                  for (let e1 = 0; e1 <= 4; e1++) {
                    const t = n[e1];
                    if (0 !== t) {
                      let i = this.regionSegments[e1];
                      i || (i = this.regionSegments[e1] = new dl());
                      const n = {
                        vertexOffset: r.vertexOffset,
                        primitiveOffset: r.primitiveOffset + o,
                        vertexLength: r.vertexLength,
                        primitiveLength: t,
                      };
                      i.get().push(n);
                    }
                    o += t;
                  }
                  for (let e1 = 0; e1 < t.length; e1++) {
                    const i = t[e1].id;
                    this.indexArray.emplaceBack(i, i + 1, i + 3),
                      this.indexArray.emplaceBack(i, i + 3, i + 2);
                  }
                }
                (this._segmentToGroundQuads = null),
                  (this._segmentToRegionTriCounts = null),
                  this._segments.destroy(),
                  (this._segments = null);
              }
              addPaintPropertiesData(e1, t, i, r, n, o) {
                this.hasData() &&
                  this.programConfigurations.populatePaintArrays(
                    this.vertexArray.length,
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                  );
              }
              upload(e1) {
                this.hasData() &&
                  ((this.vertexBuffer = e1.createVertexBuffer(
                    this.vertexArray,
                    Ff.members,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray)));
              }
              uploadPaintProperties(e1) {
                this.hasData() && this.programConfigurations.upload(e1);
              }
              update(e1, t, i, r, n, o) {
                this.hasData() &&
                  this.programConfigurations.updatePaintArrays(
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                  );
              }
              updateHiddenByLandmark(e1) {
                if (!this.hasData()) return;
                const t = e1.groundVertexCount + e1.groundVertexArrayOffset;
                if (0 === e1.groundVertexCount) return;
                const i = e1.flags & tb ? 1 : 0;
                for (let r = e1.groundVertexArrayOffset; r < t; ++r)
                  this.hiddenByLandmarkVertexArray.emplace(r, i);
                this._needsHiddenByLandmarkUpdate = !0;
              }
              uploadHiddenByLandmark(e1) {
                this.hasData() &&
                  this._needsHiddenByLandmarkUpdate &&
                  (!this.hiddenByLandmarkVertexBuffer &&
                  this.hiddenByLandmarkVertexArray.length > 0
                    ? (this.hiddenByLandmarkVertexBuffer =
                        e1.createVertexBuffer(
                          this.hiddenByLandmarkVertexArray,
                          Uf.members,
                          !0,
                        ))
                    : this.hiddenByLandmarkVertexBuffer &&
                      this.hiddenByLandmarkVertexBuffer.updateData(
                        this.hiddenByLandmarkVertexArray,
                      ),
                  (this._needsHiddenByLandmarkUpdate = !1));
              }
              destroy() {
                if (this.vertexBuffer) {
                  this.vertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.hiddenByLandmarkVertexBuffer &&
                      this.hiddenByLandmarkVertexBuffer.destroy(),
                    this._segments && this._segments.destroy(),
                    this.programConfigurations.destroy();
                  for (let e1 = 0; e1 <= 4; e1++) {
                    const t = this.regionSegments[e1];
                    t && t.destroy();
                  }
                }
              }
            }
            class db {
              constructor(e1) {
                (this.zoom = e1.zoom),
                  (this.canonical = e1.canonical),
                  (this.overscaling = e1.overscaling),
                  (this.layers = e1.layers),
                  (this.layerIds = this.layers.map((e1) => e1.fqid)),
                  (this.index = e1.index),
                  (this.hasPattern = !1),
                  (this.edgeRadius = 0),
                  (this.projection = e1.projection),
                  (this.activeReplacements = []),
                  (this.replacementUpdateTime = 0),
                  (this.centroidData = []),
                  (this.footprintIndices = new Va()),
                  (this.footprintVertices = new Ta()),
                  (this.footprintSegments = []),
                  (this.layoutVertexArray = new Ma()),
                  (this.centroidVertexArray = new cl()),
                  (this.indexArray = new Va()),
                  (this.programConfigurations = new Hl(
                    e1.layers,
                    e1.zoom,
                    (e1) => Yv.includes(e1),
                  )),
                  (this.segments = new dl()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((e1) => e1.isStateDependent())
                    .map((e1) => e1.id)),
                  (this.groundEffect = new ub(e1)),
                  (this.maxHeight = 0),
                  (this.partLookup = {});
              }
              populate(e1, t, i, r) {
                (this.features = []),
                  (this.hasPattern = Pf("fill-extrusion", this.layers, t)),
                  (this.featuresOnBorder = []),
                  (this.borderFeatureIndices = [[], [], [], []]),
                  (this.borderDoneWithNeighborZ = [-1, -1, -1, -1]),
                  (this.tileToMeter = Qd(i)),
                  (this.edgeRadius =
                    this.layers[0].layout.get("fill-extrusion-edge-radius") /
                    this.tileToMeter);
                for (const {
                  feature: n,
                  id: o,
                  index: s,
                  sourceLayerIndex: a,
                } of e1) {
                  const e1 = this.layers[0]._featureFilter.needGeometry,
                    l = cp(n, e1);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ea(this.zoom),
                      l,
                      i,
                    )
                  )
                    continue;
                  const c = {
                      id: o,
                      sourceLayerIndex: a,
                      index: s,
                      geometry: e1 ? l.geometry : lp(n, i, r),
                      properties: n.properties,
                      type: n.type,
                      patterns: {},
                    },
                    h = this.layoutVertexArray.length;
                  this.hasPattern
                    ? this.features.push(
                        Rf("fill-extrusion", this.layers, c, this.zoom, t),
                      )
                    : this.addFeature(
                        c,
                        c.geometry,
                        s,
                        i,
                        {},
                        t.availableImages,
                        r,
                        t.brightness,
                      ),
                    t.featureIndex.insert(n, c.geometry, s, a, this.index, h);
                }
                this.sortBorders(), this.groundEffect.prepareBorderSegments();
              }
              addFeatures(e1, t, i, r, n, o) {
                for (const e1 of this.features) {
                  const { geometry: s } = e1;
                  this.addFeature(e1, s, e1.index, t, i, r, n, o);
                }
                this.sortBorders();
              }
              update(e1, t, i, r, n) {
                const o = 0 !== Object.keys(e1).length;
                if (o && !this.stateDependentLayers.length) return;
                const s = o ? this.stateDependentLayers : this.layers;
                this.programConfigurations.updatePaintArrays(e1, t, s, i, r, n),
                  this.groundEffect.update(e1, t, s, i, r, n);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.programConfigurations.needsUpload ||
                  this.groundEffect.programConfigurations.needsUpload
                );
              }
              upload(e1) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = e1.createVertexBuffer(
                    this.layoutVertexArray,
                    jf,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indexArray)),
                  this.layoutVertexExtArray &&
                    (this.layoutVertexExtBuffer = e1.createVertexBuffer(
                      this.layoutVertexExtArray,
                      Vf.members,
                      !0,
                    )),
                  this.groundEffect.upload(e1)),
                  this.groundEffect.uploadPaintProperties(e1),
                  this.programConfigurations.upload(e1),
                  (this.uploaded = !0);
              }
              uploadCentroid(e1) {
                this.groundEffect.uploadHiddenByLandmark(e1),
                  this.needsCentroidUpdate &&
                    (!this.centroidVertexBuffer &&
                    this.centroidVertexArray.length > 0
                      ? (this.centroidVertexBuffer = e1.createVertexBuffer(
                          this.centroidVertexArray,
                          Nf.members,
                          !0,
                        ))
                      : this.centroidVertexBuffer &&
                        this.centroidVertexBuffer.updateData(
                          this.centroidVertexArray,
                        ),
                    (this.needsCentroidUpdate = !1));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.centroidVertexBuffer &&
                    this.centroidVertexBuffer.destroy(),
                  this.layoutVertexExtBuffer &&
                    this.layoutVertexExtBuffer.destroy(),
                  this.groundEffect.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(e1, t, i, r, n, o, s, a) {
                const l =
                    this.layers[0].paint
                      .get("fill-extrusion-flood-light-ground-radius")
                      .evaluate(e1, {}) / this.tileToMeter,
                  c = [new y(0, 0), new y(sr, sr)],
                  h = s.projection,
                  u = "globe" === h.name,
                  d = "Polygon" === Xv[e1.type],
                  p = new ab();
                p.centroidDataIndex = this.centroidData.length;
                const f = new sb(),
                  m =
                    this.layers[0].paint
                      .get("fill-extrusion-base")
                      .evaluate(e1, {}, r) <= 0,
                  _ = this.layers[0].paint
                    .get("fill-extrusion-height")
                    .evaluate(e1, {}, r);
                (f.height = _),
                  (f.vertexArrayOffset = this.layoutVertexArray.length),
                  (f.groundVertexArrayOffset =
                    this.groundEffect.vertexArray.length),
                  u &&
                    !this.layoutVertexExtArray &&
                    (this.layoutVertexExtArray = new Da());
                const g = zf(t, 500);
                for (let e1 = g.length - 1; e1 >= 0; e1--) {
                  const t = g[e1];
                  (0 === t.length ||
                    (x = t[0]).every((e1) => e1.x <= 0) ||
                    x.every((e1) => e1.x >= sr) ||
                    x.every((e1) => e1.y <= 0) ||
                    x.every((e1) => e1.y >= sr)) &&
                    g.splice(e1, 1);
                }
                var x;
                let v;
                if (u) v = bb(g, c, r);
                else {
                  v = [];
                  for (const e1 of g)
                    v.push({
                      polygon: e1,
                      bounds: c,
                    });
                }
                const b = d ? this.edgeRadius : 0,
                  w = b > 0 && this.zoom < 17,
                  T = (e1, t) => {
                    if (0 === e1.length) return !1;
                    const i = e1[e1.length - 1];
                    return t.x === i.x && t.y === i.y;
                  };
                for (const { polygon: e1, bounds: t } of v) {
                  let i = 0,
                    n = 0;
                  for (const t of e1)
                    d && !t[0].equals(t[t.length - 1]) && t.push(t[0]),
                      (n += d ? t.length - 1 : t.length);
                  const o = this.segments.prepareSegment(
                    (d ? 5 : 4) * n,
                    this.layoutVertexArray,
                    this.indexArray,
                  );
                  f.footprintSegIdx < 0 &&
                    (f.footprintSegIdx = this.footprintSegments.length);
                  const s = new ob();
                  if (
                    ((s.vertexOffset = this.footprintVertices.length),
                    (s.indexOffset = 3 * this.footprintIndices.length),
                    (s.ringIndices = []),
                    d)
                  ) {
                    const n = [],
                      a = [];
                    i = o.vertexLength;
                    for (let i = 0; i < e1.length; i++) {
                      const c = e1[i];
                      c.length && 0 !== i && a.push(n.length / 2);
                      const d = [];
                      let p, f;
                      (p = c[1].sub(c[0])._perp()._unit()),
                        s.ringIndices.push(c.length - 1);
                      for (let e1 = 1; e1 < c.length; e1++) {
                        const t = c[e1],
                          i = c[e1 === c.length - 1 ? 1 : e1 + 1],
                          s = t.clone();
                        if (b) {
                          f = i.sub(t)._perp()._unit();
                          const e1 = p.add(f)._unit(),
                            r = b * Math.min(4, 1 / (p.x * e1.x + p.y * e1.y));
                          (s.x += r * e1.x),
                            (s.y += r * e1.y),
                            (s.x = Math.round(s.x)),
                            (s.y = Math.round(s.y)),
                            (p = f);
                        }
                        !m || (0 !== b && !w) || T(d, s) || d.push(s),
                          ib(this.layoutVertexArray, s.x, s.y, 0, 0, 1, 1, 0),
                          o.vertexLength++,
                          this.footprintVertices.emplaceBack(t.x, t.y),
                          n.push(t.x, t.y),
                          u &&
                            nb(
                              this.layoutVertexExtArray,
                              h.projectTilePoint(s.x, s.y, r),
                              h.upVector(r, s.x, s.y),
                            );
                      }
                      m &&
                        (0 === b || w) &&
                        (0 !== d.length && T(d, d[0]) && d.pop(),
                        this.groundEffect.addData(d, t, l));
                    }
                    const c = Cf(n, a);
                    for (let e1 = 0; e1 < c.length; e1 += 3)
                      this.footprintIndices.emplaceBack(
                        s.vertexOffset + c[e1 + 0],
                        s.vertexOffset + c[e1 + 1],
                        s.vertexOffset + c[e1 + 2],
                      ),
                        this.indexArray.emplaceBack(
                          i + c[e1],
                          i + c[e1 + 2],
                          i + c[e1 + 1],
                        ),
                        o.primitiveLength++;
                    (s.indexCount += c.length),
                      (s.vertexCount +=
                        this.footprintVertices.length - s.vertexOffset);
                  }
                  for (let n = 0; n < e1.length; n++) {
                    const s = e1[n];
                    p.startRing(f, s[0]);
                    let a = s.length > 4 && yb(s[s.length - 2], s[0], s[1]),
                      c = b ? fb(s[s.length - 2], s[0], s[1], b) : 0;
                    const _ = [];
                    let g, y, x;
                    y = s[1].sub(s[0])._perp()._unit();
                    let v = !0;
                    for (let e1 = 1, n = 0; e1 < s.length; e1++) {
                      let l = s[e1 - 1],
                        d = s[e1];
                      const w = s[e1 === s.length - 1 ? 1 : e1 + 1];
                      if ((p.appendEdge(f, d, l), _b(d, l, t))) {
                        b && ((y = w.sub(d)._perp()._unit()), (v = !v));
                        continue;
                      }
                      const E = d.sub(l)._perp(),
                        M = E.x / (Math.abs(E.x) + Math.abs(E.y)),
                        A = E.y > 0 ? 1 : 0,
                        S = l.dist(d);
                      if ((n + S > 32768 && (n = 0), b)) {
                        x = w.sub(d)._perp()._unit();
                        let e1 = mb(l, d, w, pb(y, x), b);
                        isNaN(e1) && (e1 = 0);
                        const t = d.sub(l)._unit();
                        (l = l.add(t.mult(c))._round()),
                          (d = d.add(t.mult(-e1))._round()),
                          (c = e1),
                          (y = x),
                          m &&
                            this.zoom >= 17 &&
                            (T(_, l) || _.push(l), T(_, d) || _.push(d));
                      }
                      const I = o.vertexLength,
                        C = s.length > 4 && yb(l, d, w);
                      let z = xb(n, a, v);
                      if (
                        (ib(this.layoutVertexArray, l.x, l.y, M, A, 0, 0, z),
                        ib(this.layoutVertexArray, l.x, l.y, M, A, 0, 1, z),
                        (n += S),
                        (z = xb(n, C, !v)),
                        (a = C),
                        ib(this.layoutVertexArray, d.x, d.y, M, A, 0, 0, z),
                        ib(this.layoutVertexArray, d.x, d.y, M, A, 0, 1, z),
                        (o.vertexLength += 4),
                        this.indexArray.emplaceBack(I + 0, I + 1, I + 2),
                        this.indexArray.emplaceBack(I + 1, I + 3, I + 2),
                        (o.primitiveLength += 2),
                        b)
                      ) {
                        const r = i + (1 === e1 ? s.length - 2 : e1 - 2),
                          n = 1 === e1 ? i : r + 1;
                        if (
                          (this.indexArray.emplaceBack(I + 1, r, I + 3),
                          this.indexArray.emplaceBack(r, n, I + 3),
                          (o.primitiveLength += 2),
                          void 0 === g && (g = I),
                          !_b(w, s[e1], t))
                        ) {
                          const t = e1 === s.length - 1 ? g : o.vertexLength;
                          this.indexArray.emplaceBack(I + 2, I + 3, t),
                            this.indexArray.emplaceBack(I + 3, t + 1, t),
                            this.indexArray.emplaceBack(I + 3, n, t + 1),
                            (o.primitiveLength += 3);
                        }
                        v = !v;
                      }
                      if (u) {
                        const e1 = this.layoutVertexExtArray,
                          t = h.projectTilePoint(l.x, l.y, r),
                          i = h.projectTilePoint(d.x, d.y, r),
                          n = h.upVector(r, l.x, l.y),
                          o = h.upVector(r, d.x, d.y);
                        nb(e1, t, n), nb(e1, t, n), nb(e1, i, o), nb(e1, i, o);
                      }
                    }
                    d && (i += s.length - 1),
                      m &&
                        b &&
                        this.zoom >= 17 &&
                        (0 !== _.length && T(_, _[0]) && _.pop(),
                        this.groundEffect.addData(_, t, l, b > 0));
                  }
                  this.footprintSegments.push(s), ++f.footprintSegLen;
                }
                if (
                  ((f.vertexCount =
                    this.layoutVertexArray.length - f.vertexArrayOffset),
                  (f.groundVertexCount =
                    this.groundEffect.vertexArray.length -
                    f.groundVertexArrayOffset),
                  0 !== f.vertexCount)
                ) {
                  if (
                    ((f.centroidXY = p.borders
                      ? eb
                      : this.encodeCentroid(p, f)),
                    this.centroidData.push(f),
                    p.borders)
                  ) {
                    this.featuresOnBorder.push(p);
                    const e1 = this.featuresOnBorder.length - 1;
                    for (let t = 0; t < p.borders.length; t++)
                      p.borders[t][0] !== Number.MAX_VALUE &&
                        this.borderFeatureIndices[t].push(e1);
                  }
                  this.programConfigurations.populatePaintArrays(
                    this.layoutVertexArray.length,
                    e1,
                    i,
                    n,
                    o,
                    r,
                    a,
                  ),
                    this.groundEffect.addPaintPropertiesData(e1, i, n, o, r, a),
                    (this.maxHeight = Math.max(this.maxHeight, _));
                }
              }
              sortBorders() {
                for (let e1 = 0; e1 < this.borderFeatureIndices.length; e1++)
                  this.borderFeatureIndices[e1].sort(
                    (t, i) =>
                      this.featuresOnBorder[t].borders[e1][0] -
                      this.featuresOnBorder[i].borders[e1][0],
                  );
              }
              encodeCentroid(e1, t) {
                const i = e1.centroid(),
                  r = t.span(),
                  n = Math.min(7, Math.round((r.x * this.tileToMeter) / 10)),
                  o = Math.min(7, Math.round((r.y * this.tileToMeter) / 10));
                return new y(
                  (z(i.x, 1, sr - 1) << 3) | n,
                  (z(i.y, 1, sr - 1) << 3) | o,
                );
              }
              showCentroid(e1) {
                const t = this.centroidData[e1.centroidDataIndex];
                (t.flags &= tb),
                  (t.centroidXY.x = 0),
                  (t.centroidXY.y = 0),
                  this.writeCentroidToBuffer(t);
              }
              writeCentroidToBuffer(e1) {
                this.groundEffect.updateHiddenByLandmark(e1);
                const t = e1.vertexArrayOffset,
                  i = e1.vertexCount + e1.vertexArrayOffset,
                  r = e1.flags & tb ? eb : e1.centroidXY,
                  n = this.centroidVertexArray.geta_centroid_pos0(t);
                if (
                  this.centroidVertexArray.geta_centroid_pos1(t) !== r.y ||
                  n !== r.x
                ) {
                  for (let e1 = t; e1 < i; ++e1)
                    this.centroidVertexArray.emplace(e1, r.x, r.y);
                  this.needsCentroidUpdate = !0;
                }
              }
              createCentroidsBuffer() {
                this.centroidVertexArray.resize(this.layoutVertexArray.length),
                  this.groundEffect.hiddenByLandmarkVertexArray.resize(
                    this.groundEffect.vertexArray.length,
                  );
                for (const e1 of this.centroidData)
                  this.writeCentroidToBuffer(e1);
              }
              updateReplacement(e1, t) {
                if (t.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = t.updateTime;
                const i = t.getReplacementRegionsForTile(e1.toUnwrapped());
                if (
                  (function (e1, t) {
                    if (e1.length !== t.length) return !1;
                    for (let i = 0; i < e1.length; i++)
                      if (e1[i].sourceId !== t[i].sourceId || !Gv(e1[i], t[i]))
                        return !1;
                    return !0;
                  })(this.activeReplacements, i)
                )
                  return;
                if (
                  ((this.activeReplacements = i),
                  0 === this.centroidVertexArray.length)
                )
                  this.createCentroidsBuffer();
                else for (const e1 of this.centroidData) e1.flags &= 2147483647;
                const r = [];
                for (const t of this.activeReplacements) {
                  const i = Math.pow(
                    2,
                    t.footprintTileId.canonical.z - e1.canonical.z,
                  );
                  for (const n of this.centroidData)
                    if (
                      !(
                        n.flags & tb ||
                        t.min.x > n.max.x ||
                        n.min.x > t.max.x ||
                        t.min.y > n.max.y ||
                        n.min.y > t.max.y
                      )
                    )
                      for (let o = 0; o < n.footprintSegLen; o++) {
                        const s = this.footprintSegments[n.footprintSegIdx + o];
                        if (
                          ((r.length = 0),
                          wb(
                            this.footprintVertices,
                            s.vertexOffset,
                            s.vertexCount,
                            t.footprintTileId.canonical,
                            e1.canonical,
                            r,
                          ),
                          Hv(
                            t.footprint,
                            r,
                            this.footprintIndices.uint16,
                            s.indexOffset,
                            s.indexCount,
                            -s.vertexOffset,
                            -i,
                          ))
                        ) {
                          n.flags |= tb;
                          break;
                        }
                      }
                }
                for (const e1 of this.centroidData)
                  this.writeCentroidToBuffer(e1);
                this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
              }
              footprintContainsPoint(e1, t, i) {
                let r = !1;
                for (let n = 0; n < i.footprintSegLen; n++) {
                  const o = this.footprintSegments[i.footprintSegIdx + n];
                  let s = 0;
                  for (const i of o.ringIndices) {
                    for (let n = s, a = i + s - 1; n < i + s; a = n++) {
                      const i =
                          this.footprintVertices.int16[
                            2 * (n + o.vertexOffset) + 0
                          ],
                        s =
                          this.footprintVertices.int16[
                            2 * (n + o.vertexOffset) + 1
                          ],
                        l =
                          this.footprintVertices.int16[
                            2 * (a + o.vertexOffset) + 1
                          ];
                      s > t != l > t &&
                        e1 <
                          ((this.footprintVertices.int16[
                            2 * (a + o.vertexOffset) + 0
                          ] -
                            i) *
                            (t - s)) /
                            (l - s) +
                            i &&
                        (r = !r);
                    }
                    s = i;
                  }
                }
                return r;
              }
              getHeightAtTileCoord(e1, t) {
                let i = Number.NEGATIVE_INFINITY,
                  r = !0;
                const n = 4 * (e1 + sr) * sr + (t + sr);
                if (this.partLookup.hasOwnProperty(n)) {
                  const e1 = this.partLookup[n];
                  return e1
                    ? {
                        height: e1.height,
                        hidden: !!(e1.flags & tb),
                      }
                    : void 0;
                }
                for (const o of this.centroidData)
                  e1 > o.max.x ||
                    o.min.x > e1 ||
                    t > o.max.y ||
                    o.min.y > t ||
                    (this.footprintContainsPoint(e1, t, o) &&
                      o &&
                      o.height > i &&
                      ((i = o.height),
                      (this.partLookup[n] = o),
                      (r = !!(o.flags & tb))));
                if (i !== Number.NEGATIVE_INFINITY)
                  return {
                    height: i,
                    hidden: r,
                  };
                this.partLookup[n] = void 0;
              }
            }
            function pb(e1, t) {
              const i = e1.add(t)._unit();
              return e1.x * i.x + e1.y * i.y;
            }
            function fb(e1, t, i, r) {
              const n = t.sub(e1)._perp()._unit(),
                o = i.sub(t)._perp()._unit();
              return mb(e1, t, i, pb(n, o), r);
            }
            function mb(e1, t, i, r, n) {
              const o = Math.sqrt(1 - r * r);
              return Math.min(e1.dist(t) / 3, t.dist(i) / 3, (n * o) / r);
            }
            function _b(e1, t, i) {
              return (
                (e1.x < i[0].x && t.x < i[0].x) ||
                (e1.x > i[1].x && t.x > i[1].x) ||
                (e1.y < i[0].y && t.y < i[0].y) ||
                (e1.y > i[1].y && t.y > i[1].y)
              );
            }
            function gb(e1, t) {
              return (
                e1.x < t[0].x || e1.x > t[1].x || e1.y < t[0].y || e1.y > t[1].y
              );
            }
            function yb(e1, t, i) {
              if (
                e1.x < 0 ||
                e1.x >= sr ||
                t.x < 0 ||
                t.x >= sr ||
                i.x < 0 ||
                i.x >= sr
              )
                return !1;
              const r = i.sub(t),
                n = r.perp(),
                o = e1.sub(t);
              return (
                (r.x * o.x + r.y * o.y) /
                  Math.sqrt((r.x * r.x + r.y * r.y) * (o.x * o.x + o.y * o.y)) >
                  -0.866 && n.x * o.x + n.y * o.y < 0
              );
            }
            function xb(e1, t, i) {
              const r = t ? 2 | e1 : -3 & e1;
              return i ? 1 | r : -2 & r;
            }
            function vb() {
              const e1 = Math.PI / 32,
                t = Math.tan(e1),
                i = Od;
              return i * Math.sqrt(1 + 2 * t * t) - i;
            }
            function bb(e1, t, i) {
              const r = 1 << i.z,
                n = $d(i.x / r),
                o = $d((i.x + 1) / r),
                s = Hd(i.y / r),
                a = Hd((i.y + 1) / r);
              return (function (e1, t, i, r, n = 0, o) {
                const s = [];
                if (!e1.length || !i || !r) return s;
                const a = (e1, t) => {
                    for (const i of e1)
                      s.push({
                        polygon: i,
                        bounds: t,
                      });
                  },
                  l = Math.ceil(Math.log2(i)),
                  c = Math.ceil(Math.log2(r)),
                  h = l - c,
                  u = [];
                for (let e1 = 0; e1 < Math.abs(h); e1++) u.push(h > 0 ? 0 : 1);
                for (let e1 = 0; e1 < Math.min(l, c); e1++)
                  u.push(0), u.push(1);
                let d = e1;
                if (
                  ((d = rm(d, t[0].y - n, t[1].y + n, 1)),
                  (d = rm(d, t[0].x - n, t[1].x + n, 0)),
                  !d.length)
                )
                  return s;
                const p = [];
                for (
                  u.length
                    ? p.push({
                        polygons: d,
                        bounds: t,
                        depth: 0,
                      })
                    : a(d, t);
                  p.length;

                ) {
                  const e1 = p.pop(),
                    t = e1.depth,
                    i = u[t],
                    r = e1.bounds[0],
                    s = e1.bounds[1],
                    l = 0 === i ? r.x : r.y,
                    c = 0 === i ? s.x : s.y,
                    h = o ? o(i, l, c) : 0.5 * (l + c),
                    d = rm(e1.polygons, l - n, h + n, i),
                    f = rm(e1.polygons, h - n, c + n, i);
                  if (d.length) {
                    const e1 = [r, new y(0 === i ? h : s.x, 1 === i ? h : s.y)];
                    u.length > t + 1
                      ? p.push({
                          polygons: d,
                          bounds: e1,
                          depth: t + 1,
                        })
                      : a(d, e1);
                  }
                  if (f.length) {
                    const e1 = [new y(0 === i ? h : r.x, 1 === i ? h : r.y), s];
                    u.length > t + 1
                      ? p.push({
                          polygons: f,
                          bounds: e1,
                          depth: t + 1,
                        })
                      : a(f, e1);
                  }
                }
                return s;
              })(
                e1,
                t,
                Math.ceil((o - n) / 11.25),
                Math.ceil((s - a) / 11.25),
                1,
                (e1, t, n) => {
                  if (0 === e1) return 0.5 * (t + n);
                  {
                    const e1 = Hd((i.y + t / sr) / r);
                    return (
                      (qd(0.5 * (Hd((i.y + n / sr) / r) + e1)) * r - i.y) * sr
                    );
                  }
                },
              );
            }
            function wb(e1, t, i, r, n, o) {
              const s = Math.pow(2, r.z - n.z);
              for (let a = 0; a < i; a++) {
                let i = e1.int16[2 * (a + t) + 0],
                  l = e1.int16[2 * (a + t) + 1];
                (i = (i + n.x * sr) * s - r.x * sr),
                  (l = (l + n.y * sr) * s - r.y * sr),
                  o.push(new y(i, l));
              }
            }
            Is(db, "FillExtrusionBucket", {
              omit: ["layers", "features"],
            }),
              Is(sb, "PartData"),
              Is(ob, "FootprintSegment"),
              Is(ab, "BorderCentroidData"),
              Is(ub, "GroundEffect");
            const Tb = new da({
              visibility: new ca(Ct["layout_fill-extrusion"].visibility),
              "fill-extrusion-edge-radius": new ca(
                Ct["layout_fill-extrusion"]["fill-extrusion-edge-radius"],
              ),
            });
            var Eb = {
              paint: new da({
                "fill-extrusion-opacity": new ca(
                  Ct["paint_fill-extrusion"]["fill-extrusion-opacity"],
                ),
                "fill-extrusion-color": new ha(
                  Ct["paint_fill-extrusion"]["fill-extrusion-color"],
                ),
                "fill-extrusion-translate": new ca(
                  Ct["paint_fill-extrusion"]["fill-extrusion-translate"],
                ),
                "fill-extrusion-translate-anchor": new ca(
                  Ct["paint_fill-extrusion"]["fill-extrusion-translate-anchor"],
                ),
                "fill-extrusion-pattern": new ha(
                  Ct["paint_fill-extrusion"]["fill-extrusion-pattern"],
                ),
                "fill-extrusion-height": new ha(
                  Ct["paint_fill-extrusion"]["fill-extrusion-height"],
                ),
                "fill-extrusion-base": new ha(
                  Ct["paint_fill-extrusion"]["fill-extrusion-base"],
                ),
                "fill-extrusion-vertical-gradient": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-vertical-gradient"
                  ],
                ),
                "fill-extrusion-ambient-occlusion-intensity": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-intensity"
                  ],
                ),
                "fill-extrusion-ambient-occlusion-radius": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-radius"
                  ],
                ),
                "fill-extrusion-ambient-occlusion-wall-radius": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-wall-radius"
                  ],
                ),
                "fill-extrusion-ambient-occlusion-ground-radius": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-ground-radius"
                  ],
                ),
                "fill-extrusion-ambient-occlusion-ground-attenuation": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-ground-attenuation"
                  ],
                ),
                "fill-extrusion-flood-light-color": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-flood-light-color"
                  ],
                ),
                "fill-extrusion-flood-light-intensity": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-flood-light-intensity"
                  ],
                ),
                "fill-extrusion-flood-light-wall-radius": new ha(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-flood-light-wall-radius"
                  ],
                ),
                "fill-extrusion-flood-light-ground-radius": new ha(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-flood-light-ground-radius"
                  ],
                ),
                "fill-extrusion-flood-light-ground-attenuation": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-flood-light-ground-attenuation"
                  ],
                ),
                "fill-extrusion-vertical-scale": new ca(
                  Ct["paint_fill-extrusion"]["fill-extrusion-vertical-scale"],
                ),
                "fill-extrusion-rounded-roof": new ca(
                  Ct["paint_fill-extrusion"]["fill-extrusion-rounded-roof"],
                ),
                "fill-extrusion-cutoff-fade-range": new ca(
                  Ct["paint_fill-extrusion"][
                    "fill-extrusion-cutoff-fade-range"
                  ],
                ),
              }),
              layout: Tb,
            };
            class Mb extends y {
              constructor(e1, t, i) {
                super(e1, t), (this.z = i);
              }
            }
            function Ab(e1, t) {
              return e1.x * t.x + e1.y * t.y;
            }
            function Sb(e1, t) {
              if (1 === e1.length) {
                let i = 0;
                const r = t[i++];
                let n;
                for (; !n || r.equals(n); )
                  if (((n = t[i++]), !n)) return 1 / 0;
                for (; i < t.length; i++) {
                  const o = t[i],
                    s = e1[0],
                    a = n.sub(r),
                    l = o.sub(r),
                    c = s.sub(r),
                    h = Ab(a, a),
                    u = Ab(a, l),
                    d = Ab(l, l),
                    p = Ab(c, a),
                    f = Ab(c, l),
                    m = h * d - u * u,
                    _ = (d * p - u * f) / m,
                    g = (h * f - u * p) / m,
                    y = r.z * (1 - _ - g) + n.z * _ + o.z * g;
                  if (isFinite(y)) return y;
                }
                return 1 / 0;
              }
              {
                let e1 = 1 / 0;
                for (const i of t) e1 = Math.min(e1, i.z);
                return e1;
              }
            }
            function Ib(e1, t, i, r, n, o, s, a) {
              const l = s * n.getElevationAt(e1, t, !0, !0),
                c = 0 !== o[0],
                h = c
                  ? 0 === o[1]
                    ? s * (o[0] / 7 - 450)
                    : s *
                      (function (e1, t, i) {
                        const r = Math.floor(t[0] / 8),
                          n = Math.floor(t[1] / 8),
                          o = 10 * (t[0] - 8 * r),
                          s = 10 * (t[1] - 8 * n),
                          a = e1.getElevationAt(r, n, !0, !0),
                          l = e1.getMeterToDEM(i),
                          c = Math.floor(0.5 * (o * l - 1)),
                          h = Math.floor(0.5 * (s * l - 1)),
                          u = e1.tileCoordToPixel(r, n),
                          d = 2 * c + 1,
                          p = 2 * h + 1,
                          f = (function (e1, t, i, r, n) {
                            return [
                              e1.getElevationAtPixel(t, i, !0),
                              e1.getElevationAtPixel(t + n, i, !0),
                              e1.getElevationAtPixel(t, i + n, !0),
                              e1.getElevationAtPixel(t + r, i + n, !0),
                            ];
                          })(e1, u.x - c, u.y - h, d, p),
                          m = Math.abs(f[0] - f[1]),
                          _ = Math.abs(f[2] - f[3]),
                          g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]),
                          y = Math.min(0.25, (0.5 * l * (m + _)) / d),
                          x = Math.min(0.25, (0.5 * l * g) / p);
                        return a + Math.max(y * o, x * s);
                      })(n, o, a)
                  : l;
              return {
                base: l + (0 === i) ? -1 : i,
                top: c ? Math.max(h + r, l + i + 2) : l + r,
              };
            }
            const Cb = new da({
              "line-cap": new ha(Ct.layout_line["line-cap"]),
              "line-join": new ha(Ct.layout_line["line-join"]),
              "line-miter-limit": new ca(Ct.layout_line["line-miter-limit"]),
              "line-round-limit": new ca(Ct.layout_line["line-round-limit"]),
              "line-sort-key": new ha(Ct.layout_line["line-sort-key"]),
              visibility: new ca(Ct.layout_line.visibility),
            });
            var zb = {
              paint: new da({
                "line-opacity": new ha(Ct.paint_line["line-opacity"]),
                "line-color": new ha(Ct.paint_line["line-color"]),
                "line-translate": new ca(Ct.paint_line["line-translate"]),
                "line-translate-anchor": new ca(
                  Ct.paint_line["line-translate-anchor"],
                ),
                "line-width": new ha(Ct.paint_line["line-width"]),
                "line-gap-width": new ha(Ct.paint_line["line-gap-width"]),
                "line-offset": new ha(Ct.paint_line["line-offset"]),
                "line-blur": new ha(Ct.paint_line["line-blur"]),
                "line-dasharray": new ha(Ct.paint_line["line-dasharray"]),
                "line-pattern": new ha(Ct.paint_line["line-pattern"]),
                "line-gradient": new ua(Ct.paint_line["line-gradient"]),
                "line-trim-offset": new ca(Ct.paint_line["line-trim-offset"]),
                "line-emissive-strength": new ca(
                  Ct.paint_line["line-emissive-strength"],
                ),
                "line-border-width": new ha(Ct.paint_line["line-border-width"]),
                "line-border-color": new ha(Ct.paint_line["line-border-color"]),
              }),
              layout: Cb,
            };
            const Db = (e1, t, i, r, n, o, s) => {
                const a = e1.transform,
                  l = a.calculatePixelsToTileUnitsMatrix(t);
                return {
                  u_matrix: Lb(e1, t, i, r),
                  u_pixels_to_tile_units: l,
                  u_device_pixel_ratio: o,
                  u_units_to_pixels: [
                    1 / a.pixelsToGLUnits[0],
                    1 / a.pixelsToGLUnits[1],
                  ],
                  u_dash_image: 0,
                  u_gradient_image: 1,
                  u_image_height: n,
                  u_texsize: Ob(i) ? t.lineAtlasTexture.size : [0, 0],
                  u_tile_units_to_pixels: Rb(t, e1.transform),
                  u_alpha_discard_threshold: 0,
                  u_trim_offset: s,
                  u_emissive_strength: i.paint.get("line-emissive-strength"),
                };
              },
              Pb = (e1, t, i, r, n) => {
                const o = e1.transform;
                return {
                  u_matrix: Lb(e1, t, i, r),
                  u_texsize: t.imageAtlasTexture.size,
                  u_pixels_to_tile_units: o.calculatePixelsToTileUnitsMatrix(t),
                  u_device_pixel_ratio: n,
                  u_image: 0,
                  u_tile_units_to_pixels: Rb(t, o),
                  u_units_to_pixels: [
                    1 / o.pixelsToGLUnits[0],
                    1 / o.pixelsToGLUnits[1],
                  ],
                  u_alpha_discard_threshold: 0,
                };
              };
            function Rb(e1, t) {
              return 1 / Xx(e1, 1, t.tileZoom);
            }
            function Lb(e1, t, i, r) {
              return e1.translatePosMatrix(
                r || t.tileID.projMatrix,
                t,
                i.paint.get("line-translate"),
                i.paint.get("line-translate-anchor"),
              );
            }
            const kb = (e1) => {
              const t = [];
              Ob(e1) && t.push("RENDER_LINE_DASH"),
                e1.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT");
              const i = e1.paint.get("line-trim-offset");
              return (
                (0 === i[0] && 0 === i[1]) || t.push("RENDER_LINE_TRIM_OFFSET"),
                0 !== e1.paint.get("line-border-width").constantOr(1) &&
                  t.push("RENDER_LINE_BORDER"),
                t
              );
            };
            function Ob(e1) {
              const t = e1.paint.get("line-dasharray").value;
              return t.value || "constant" !== t.kind;
            }
            const Bb = new (class extends ha {
              possiblyEvaluate(e1, t) {
                return (
                  (t = new ea(Math.floor(t.zoom), {
                    now: t.now,
                    fadeDuration: t.fadeDuration,
                    transition: t.transition,
                  })),
                  super.possiblyEvaluate(e1, t)
                );
              }
              evaluate(e1, t, i, r) {
                return (
                  (t = k({}, t, {
                    zoom: Math.floor(t.zoom),
                  })),
                  super.evaluate(e1, t, i, r)
                );
              }
            })(zb.paint.properties["line-width"].specification);
            function Fb(e1, t) {
              return t > 0 ? t + 2 * e1 : e1;
            }
            Bb.useIntegerZoom = !0;
            const Nb = new da({
              visibility: new ca(Ct.layout_background.visibility),
            });
            var Ub = {
              paint: new da({
                "background-color": new ca(
                  Ct.paint_background["background-color"],
                ),
                "background-pattern": new ca(
                  Ct.paint_background["background-pattern"],
                ),
                "background-opacity": new ca(
                  Ct.paint_background["background-opacity"],
                ),
                "background-emissive-strength": new ca(
                  Ct.paint_background["background-emissive-strength"],
                ),
              }),
              layout: Nb,
            };
            const Vb = new da({
              visibility: new ca(Ct.layout_raster.visibility),
            });
            var jb = {
              paint: new da({
                "raster-opacity": new ca(Ct.paint_raster["raster-opacity"]),
                "raster-color": new ua(Ct.paint_raster["raster-color"]),
                "raster-color-mix": new ca(Ct.paint_raster["raster-color-mix"]),
                "raster-color-range": new ca(
                  Ct.paint_raster["raster-color-range"],
                ),
                "raster-hue-rotate": new ca(
                  Ct.paint_raster["raster-hue-rotate"],
                ),
                "raster-brightness-min": new ca(
                  Ct.paint_raster["raster-brightness-min"],
                ),
                "raster-brightness-max": new ca(
                  Ct.paint_raster["raster-brightness-max"],
                ),
                "raster-saturation": new ca(
                  Ct.paint_raster["raster-saturation"],
                ),
                "raster-contrast": new ca(Ct.paint_raster["raster-contrast"]),
                "raster-resampling": new ca(
                  Ct.paint_raster["raster-resampling"],
                ),
                "raster-fade-duration": new ca(
                  Ct.paint_raster["raster-fade-duration"],
                ),
              }),
              layout: Vb,
            };
            function Gb(e1, t, i, r, n, o, s, a) {
              const l = [e1, i, n, t, r, o, 1, 1, 1],
                c = [s, a, 1],
                h = gu.adjoint([], l),
                [u, d, p] = Mu.transformMat3(c, c, gu.transpose(h, h));
              return gu.multiply(l, [u, 0, 0, 0, d, 0, 0, 0, p], l);
            }
            class qb extends It {
              constructor(e1, t, i, r) {
                super(),
                  (this.id = e1),
                  (this.dispatcher = i),
                  (this.coordinates = t.coordinates),
                  (this.type = "image"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.tileSize = 512),
                  (this.tiles = {}),
                  (this._loaded = !1),
                  (this.onNorthPole = !1),
                  (this.onSouthPole = !1),
                  this.setEventedParent(r),
                  (this.options = t),
                  (this._dirty = !1);
              }
              load(e1, i) {
                if (
                  ((this._loaded = i || !1),
                  this.fire(
                    new At("dataloading", {
                      dataType: "source",
                    }),
                  ),
                  (this.url = this.options.url),
                  !this.url)
                )
                  return (
                    e1 && (this.coordinates = e1),
                    (this._loaded = !0),
                    void this._finishLoading()
                  );
                this._imageRequest = Ie(
                  this.map._requestManager.transformRequest(this.url, ye.Image),
                  (i, r) => {
                    if (((this._imageRequest = null), (this._loaded = !0), i))
                      this.fire(new St(i));
                    else if (r) {
                      const { HTMLImageElement: i } = t;
                      (this.image = r instanceof i ? ht.getImageData(r) : r),
                        (this._dirty = !0),
                        (this.width = this.image.width),
                        (this.height = this.image.height),
                        e1 && (this.coordinates = e1),
                        this._finishLoading();
                    }
                  },
                );
              }
              loaded() {
                return this._loaded;
              }
              updateImage(e1) {
                return this.image && e1.url
                  ? (this._imageRequest &&
                      e1.url !== this.options.url &&
                      (this._imageRequest.cancel(),
                      (this._imageRequest = null)),
                    (this.options.url = e1.url),
                    this.load(e1.coordinates, this._loaded),
                    this)
                  : this;
              }
              setTexture(e1) {
                if (!(e1.handle instanceof WebGLTexture))
                  throw new Error(
                    "The provided handle is not a WebGLTexture instance",
                  );
                return (
                  (this.texture = new yy(this.map.painter.context, e1.handle)),
                  (this.width = e1.dimensions[0]),
                  (this.height = e1.dimensions[1]),
                  (this._dirty = !1),
                  (this._loaded = !0),
                  this._finishLoading(),
                  this
                );
              }
              _finishLoading() {
                this.map &&
                  (this.setCoordinates(this.coordinates),
                  this.fire(
                    new At("data", {
                      dataType: "source",
                      sourceDataType: "metadata",
                    }),
                  ));
              }
              onAdd(e1) {
                (this.map = e1), this.load();
              }
              onRemove() {
                this._imageRequest &&
                  (this._imageRequest.cancel(), (this._imageRequest = null)),
                  !this.texture ||
                    this.texture instanceof yy ||
                    this.texture.destroy();
              }
              setCoordinates(e1) {
                if (
                  ((this.coordinates = e1),
                  (this._boundsArray = void 0),
                  !e1.length)
                )
                  return this;
                (this.onNorthPole = !1), (this.onSouthPole = !1);
                let t = e1[0][1],
                  i = e1[0][1];
                for (const r of e1)
                  r[1] > i && (i = r[1]), r[1] < t && (t = r[1]);
                const r = (i + t) / 2;
                if (
                  (r > Xd
                    ? (this.onNorthPole = !0)
                    : r < -Xd && (this.onSouthPole = !0),
                  !this.onNorthPole && !this.onSouthPole)
                ) {
                  const t = e1.map(ep.fromLngLat);
                  (this.tileID = (function (e1) {
                    let t = 1 / 0,
                      i = 1 / 0,
                      r = -1 / 0,
                      n = -1 / 0;
                    for (const o of e1)
                      (t = Math.min(t, o.x)),
                        (i = Math.min(i, o.y)),
                        (r = Math.max(r, o.x)),
                        (n = Math.max(n, o.y));
                    const o = Math.max(r - t, n - i),
                      s = Math.max(0, Math.floor(-Math.log(o) / Math.LN2)),
                      a = Math.pow(2, s);
                    return new ku(
                      s,
                      Math.floor(((t + r) / 2) * a),
                      Math.floor(((i + n) / 2) * a),
                    );
                  })(t)),
                    (this.minzoom = this.maxzoom = this.tileID.z);
                }
                return (
                  this.fire(
                    new At("data", {
                      dataType: "source",
                      sourceDataType: "content",
                    }),
                  ),
                  this
                );
              }
              _clear() {
                this._boundsArray = void 0;
              }
              _prepareData(e1) {
                for (const e1 in this.tiles) {
                  const t = this.tiles[e1];
                  "loaded" !== t.state &&
                    ((t.state = "loaded"), (t.texture = this.texture));
                }
                if (this._boundsArray) return;
                const t = Tg(this.tileID, this.map.transform.projection),
                  [i, r, n, o] = this.coordinates.map((e1) => {
                    const i = t.projection.project(e1[0], e1[1]);
                    return Mg(t, i)._round();
                  });
                this.perspectiveTransform = (function (
                  e1,
                  t,
                  i,
                  r,
                  n,
                  o,
                  s,
                  a,
                  l,
                  c,
                ) {
                  const h = Gb(0, 0, e1, 0, 0, t, e1, t),
                    u = Gb(i, r, n, o, s, a, l, c);
                  return (
                    gu.multiply(u, gu.adjoint(h, h), u),
                    [((u[6] / u[8]) * e1) / sr, ((u[7] / u[8]) * t) / sr]
                  );
                })(
                  this.width,
                  this.height,
                  i.x,
                  i.y,
                  r.x,
                  r.y,
                  o.x,
                  o.y,
                  n.x,
                  n.y,
                );
                const s = (this._boundsArray = new Ma());
                s.emplaceBack(i.x, i.y, 0, 0),
                  s.emplaceBack(r.x, r.y, sr, 0),
                  s.emplaceBack(o.x, o.y, 0, sr),
                  s.emplaceBack(n.x, n.y, sr, sr),
                  this.boundsBuffer && this.boundsBuffer.destroy(),
                  (this.boundsBuffer = e1.createVertexBuffer(s, Ay.members)),
                  (this.boundsSegments = dl.simpleSegment(0, 0, 4, 2));
              }
              prepare() {
                const e1 = 0 !== Object.keys(this.tiles).length;
                if (this.tileID && !e1) return;
                const t = this.map.painter.context,
                  i = t.gl;
                !this._dirty ||
                  this.texture instanceof yy ||
                  (this.texture
                    ? this.texture.update(this.image)
                    : ((this.texture = new gy(t, this.image, i.RGBA)),
                      this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)),
                  (this._dirty = !1)),
                  e1 && this._prepareData(t);
              }
              loadTile(e1, t) {
                this.tileID && this.tileID.equals(e1.tileID.canonical)
                  ? ((this.tiles[String(e1.tileID.wrap)] = e1),
                    (e1.buckets = {}),
                    t(null))
                  : ((e1.state = "errored"), t(null));
              }
              serialize() {
                return {
                  type: "image",
                  url: this.options.url,
                  coordinates: this.coordinates,
                };
              }
              hasTransition() {
                return !1;
              }
            }
            class Zb extends _a {
              constructor(e1) {
                super(e1, {}),
                  (this.implementation = e1),
                  e1.slot && (this.slot = e1.slot);
              }
              is3D() {
                return "3d" === this.implementation.renderingMode;
              }
              hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
              }
              isLayerDraped(e1) {
                return void 0 !== this.implementation.renderToTile;
              }
              shouldRedrape() {
                return (
                  !!this.implementation.shouldRerenderTiles &&
                  this.implementation.shouldRerenderTiles()
                );
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {
                return !1;
              }
              serialize() {}
              onAdd(e1) {
                this.implementation.onAdd &&
                  this.implementation.onAdd(e1, e1.painter.context.gl);
              }
              onRemove(e1) {
                this.implementation.onRemove &&
                  this.implementation.onRemove(e1, e1.painter.context.gl);
              }
            }
            const $b = new da({
              visibility: new ca(Ct.layout_sky.visibility),
            });
            var Hb = {
              paint: new da({
                "sky-type": new ca(Ct.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new ca(
                  Ct.paint_sky["sky-atmosphere-sun"],
                ),
                "sky-atmosphere-sun-intensity": new ca(
                  Ct.paint_sky["sky-atmosphere-sun-intensity"],
                ),
                "sky-gradient-center": new ca(
                  Ct.paint_sky["sky-gradient-center"],
                ),
                "sky-gradient-radius": new ca(
                  Ct.paint_sky["sky-gradient-radius"],
                ),
                "sky-gradient": new ua(Ct.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new ca(
                  Ct.paint_sky["sky-atmosphere-halo-color"],
                ),
                "sky-atmosphere-color": new ca(
                  Ct.paint_sky["sky-atmosphere-color"],
                ),
                "sky-opacity": new ca(Ct.paint_sky["sky-opacity"]),
              }),
              layout: $b,
            };
            function Wb(e1, t, i) {
              const r = [0, 0, 1],
                n = bu.identity([]);
              return (
                bu.rotateY(n, n, i ? -w(e1) + Math.PI : w(e1)),
                bu.rotateX(n, n, -w(t)),
                Mu.transformQuat(r, r, n),
                Mu.normalize(r, r)
              );
            }
            var Xb = {
              paint: new da({}),
            };
            const Yb = {
              circle: class extends _a {
                constructor(e1, t) {
                  super(e1, Pp, t);
                }
                createBucket(e1) {
                  return new dp(e1);
                }
                queryRadius(e1) {
                  const t = e1;
                  return (
                    Sp("circle-radius", this, t) +
                    Sp("circle-stroke-width", this, t) +
                    Ip(this.paint.get("circle-translate"))
                  );
                }
                queryIntersectsFeature(e1, t, i, r, n, o, s, a) {
                  const l = zp(
                      this.paint.get("circle-translate"),
                      this.paint.get("circle-translate-anchor"),
                      o.angle,
                      e1.pixelToTileUnitsFactor,
                    ),
                    c =
                      this.paint.get("circle-radius").evaluate(t, i) +
                      this.paint.get("circle-stroke-width").evaluate(t, i);
                  return Op(
                    e1,
                    r,
                    o,
                    s,
                    a,
                    "map" === this.paint.get("circle-pitch-alignment"),
                    "map" === this.paint.get("circle-pitch-scale"),
                    l,
                    c,
                  );
                }
                getProgramIds() {
                  return ["circle"];
                }
                getDefaultProgramParams(e1, t) {
                  const i = kp(this);
                  return {
                    config: new $l(this, t),
                    defines: i,
                    overrideFog: !1,
                  };
                }
              },
              heatmap: class extends _a {
                createBucket(e1) {
                  return new Vp(e1);
                }
                constructor(e1, t) {
                  super(e1, Xp, t), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(e1) {
                  "heatmap-color" === e1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                  (this.colorRamp = Yp({
                    expression:
                      this._transitionablePaint._values["heatmap-color"].value
                        .expression,
                    evaluationKey: "heatmapDensity",
                    image: this.colorRamp,
                  })),
                    (this.colorRampTexture = null);
                }
                resize() {
                  this.heatmapFbo &&
                    (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
                }
                queryRadius(e1) {
                  return Sp("heatmap-radius", this, e1);
                }
                queryIntersectsFeature(e1, t, i, r, n, o, s, a) {
                  const l = this.paint.get("heatmap-radius").evaluate(t, i);
                  return Op(e1, r, o, s, a, !0, !0, new y(0, 0), l);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("heatmap-opacity") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["heatmap", "heatmapTexture"];
                }
                getDefaultProgramParams(e1, t) {
                  return "heatmap" === e1
                    ? {
                        config: new $l(this, t),
                        overrideFog: !1,
                      }
                    : {};
                }
              },
              hillshade: class extends _a {
                constructor(e1, t) {
                  super(e1, Jp, t);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("hillshade-exaggeration") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["hillshade", "hillshadePrepare"];
                }
                getDefaultProgramParams(e1, t) {
                  return {
                    overrideFog: !1,
                  };
                }
              },
              fill: class extends _a {
                constructor(e1, t) {
                  super(e1, Of, t);
                }
                getProgramIds() {
                  const e1 = this.paint.get("fill-pattern"),
                    t = e1 && e1.constantOr(1),
                    i = [t ? "fillPattern" : "fill"];
                  return (
                    this.paint.get("fill-antialias") &&
                      i.push(
                        t && !this.getPaintProperty("fill-outline-color")
                          ? "fillOutlinePattern"
                          : "fillOutline",
                      ),
                    i
                  );
                }
                getDefaultProgramParams(e1, t) {
                  return {
                    config: new $l(this, t),
                    overrideFog: !1,
                  };
                }
                recalculate(e1, t) {
                  super.recalculate(e1, t);
                  const i = this.paint._values["fill-outline-color"];
                  "constant" === i.value.kind &&
                    void 0 === i.value.value &&
                    (this.paint._values["fill-outline-color"] =
                      this.paint._values["fill-color"]);
                }
                createBucket(e1) {
                  return new Lf(e1);
                }
                queryRadius() {
                  return Ip(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(e1, t, i, r, n, o) {
                  return (
                    !e1.queryGeometry.isAboveHorizon &&
                    mp(
                      Cp(
                        e1.tilespaceGeometry,
                        this.paint.get("fill-translate"),
                        this.paint.get("fill-translate-anchor"),
                        o.angle,
                        e1.pixelToTileUnitsFactor,
                      ),
                      r,
                    )
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              "fill-extrusion": class extends _a {
                constructor(e1, t) {
                  super(e1, Eb, t);
                }
                createBucket(e1) {
                  return new db(e1);
                }
                queryRadius() {
                  return Ip(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                  return !0;
                }
                hasShadowPass() {
                  return !0;
                }
                cutoffRange() {
                  return this.paint.get("fill-extrusion-cutoff-fade-range");
                }
                canCastShadows() {
                  return !0;
                }
                getProgramIds() {
                  return [
                    this.paint.get("fill-extrusion-pattern").constantOr(1)
                      ? "fillExtrusionPattern"
                      : "fillExtrusion",
                  ];
                }
                queryIntersectsFeature(e1, t, i, r, n, o, s, a, l) {
                  const c = zp(
                      this.paint.get("fill-extrusion-translate"),
                      this.paint.get("fill-extrusion-translate-anchor"),
                      o.angle,
                      e1.pixelToTileUnitsFactor,
                    ),
                    h = this.paint.get("fill-extrusion-height").evaluate(t, i),
                    u = this.paint.get("fill-extrusion-base").evaluate(t, i),
                    d = [0, 0],
                    p = a && o.elevation,
                    f = o.elevation ? o.elevation.exaggeration() : 1,
                    m = e1.tile.getBucket(this);
                  if (p && m instanceof db) {
                    const e1 = m.centroidVertexArray,
                      t = l + 1;
                    t < e1.length &&
                      ((d[0] = e1.geta_centroid_pos0(t)),
                      (d[1] = e1.geta_centroid_pos1(t)));
                  }
                  if (0 === d[0] && 1 === d[1]) return !1;
                  "globe" === o.projection.name &&
                    (r = bb(
                      [r],
                      [new y(0, 0), new y(sr, sr)],
                      e1.tileID.canonical,
                    )
                      .map((e1) => e1.polygon)
                      .flat());
                  const _ = p ? a : null,
                    [g, x] = (function (e1, t, i, r, n, o, s, a, l, c, h) {
                      return "globe" === e1.projection.name
                        ? (function (e1, t, i, r, n, o, s, a, l, c, h) {
                            const u = [],
                              d = [],
                              p = e1.projection.upVectorScale(
                                h,
                                e1.center.lat,
                                e1.worldSize,
                              ).metersToTile,
                              f = [0, 0, 0, 1],
                              m = [0, 0, 0, 1],
                              _ = (e1, t, i, r) => {
                                (e1[0] = t),
                                  (e1[1] = i),
                                  (e1[2] = r),
                                  (e1[3] = 1);
                              },
                              g = vb();
                            i > 0 && (i += g), (r += g);
                            for (const g of t) {
                              const t = [],
                                y = [];
                              for (const u of g) {
                                const d = u.x + n.x,
                                  g = u.y + n.y,
                                  x = e1.projection.projectTilePoint(d, g, h),
                                  v = e1.projection.upVector(h, u.x, u.y);
                                let b = i,
                                  w = r;
                                if (s) {
                                  const e1 = Ib(d, g, i, r, s, a, l, c);
                                  (b += e1.base), (w += e1.top);
                                }
                                0 !== i
                                  ? _(
                                      f,
                                      x.x + v[0] * p * b,
                                      x.y + v[1] * p * b,
                                      x.z + v[2] * p * b,
                                    )
                                  : _(f, x.x, x.y, x.z),
                                  _(
                                    m,
                                    x.x + v[0] * p * w,
                                    x.y + v[1] * p * w,
                                    x.z + v[2] * p * w,
                                  ),
                                  Mu.transformMat4(f, f, o),
                                  Mu.transformMat4(m, m, o),
                                  t.push(new Mb(f[0], f[1], f[2])),
                                  y.push(new Mb(m[0], m[1], m[2]));
                              }
                              u.push(t), d.push(y);
                            }
                            return [u, d];
                          })(e1, t, i, r, n, o, s, a, l, c, h)
                        : s
                        ? (function (e1, t, i, r, n, o, s, a, l) {
                            const c = [],
                              h = [],
                              u = [0, 0, 0, 1];
                            for (const d of e1) {
                              const e1 = [],
                                p = [];
                              for (const c of d) {
                                const h = c.x + r.x,
                                  d = c.y + r.y,
                                  f = Ib(h, d, t, i, o, s, a, l);
                                (u[0] = h),
                                  (u[1] = d),
                                  (u[2] = f.base),
                                  (u[3] = 1),
                                  uu.transformMat4(u, u, n),
                                  (u[3] = Math.max(u[3], 1e-5));
                                const m = new Mb(
                                  u[0] / u[3],
                                  u[1] / u[3],
                                  u[2] / u[3],
                                );
                                (u[0] = h),
                                  (u[1] = d),
                                  (u[2] = f.top),
                                  (u[3] = 1),
                                  uu.transformMat4(u, u, n),
                                  (u[3] = Math.max(u[3], 1e-5));
                                const _ = new Mb(
                                  u[0] / u[3],
                                  u[1] / u[3],
                                  u[2] / u[3],
                                );
                                e1.push(m), p.push(_);
                              }
                              c.push(e1), h.push(p);
                            }
                            return [c, h];
                          })(t, i, r, n, o, s, a, l, c)
                        : (function (e1, t, i, r, n) {
                            const o = [],
                              s = [],
                              a = n[8] * t,
                              l = n[9] * t,
                              c = n[10] * t,
                              h = n[11] * t,
                              u = n[8] * i,
                              d = n[9] * i,
                              p = n[10] * i,
                              f = n[11] * i;
                            for (const t of e1) {
                              const e1 = [],
                                i = [];
                              for (const o of t) {
                                const t = o.x + r.x,
                                  s = o.y + r.y,
                                  m = n[0] * t + n[4] * s + n[12],
                                  _ = n[1] * t + n[5] * s + n[13],
                                  g = n[2] * t + n[6] * s + n[14],
                                  y = n[3] * t + n[7] * s + n[15],
                                  x = m + a,
                                  v = _ + l,
                                  b = g + c,
                                  w = Math.max(y + h, 1e-5),
                                  T = m + u,
                                  E = _ + d,
                                  M = g + p,
                                  A = Math.max(y + f, 1e-5);
                                e1.push(new Mb(x / w, v / w, b / w)),
                                  i.push(new Mb(T / A, E / A, M / A));
                              }
                              o.push(e1), s.push(i);
                            }
                            return [o, s];
                          })(t, i, r, n, o);
                    })(
                      o,
                      r,
                      u,
                      h,
                      c,
                      s,
                      _,
                      d,
                      f,
                      o.center.lat,
                      e1.tileID.canonical,
                    ),
                    v = e1.queryGeometry;
                  return (function (e1, t, i) {
                    let r = 1 / 0;
                    mp(i, t) && (r = Sb(i, t[0]));
                    for (let n = 0; n < t.length; n++) {
                      const o = t[n],
                        s = e1[n];
                      for (let e1 = 0; e1 < o.length - 1; e1++) {
                        const t = o[e1],
                          n = [t, o[e1 + 1], s[e1 + 1], s[e1], t];
                        pp(i, n) && (r = Math.min(r, Sb(i, n)));
                      }
                    }
                    return r !== 1 / 0 && r;
                  })(
                    g,
                    x,
                    v.isPointQuery() ? v.screenBounds : v.screenGeometry,
                  );
                }
              },
              line: class extends _a {
                constructor(e1, t) {
                  super(e1, zb, t), (this.gradientVersion = 0);
                }
                _handleSpecialPaintPropertyUpdate(e1) {
                  if ("line-gradient" === e1) {
                    const e1 =
                      this._transitionablePaint._values["line-gradient"].value
                        .expression;
                    (this.stepInterpolant =
                      e1._styleExpression &&
                      e1._styleExpression.expression instanceof Hr),
                      (this.gradientVersion =
                        (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
                  }
                }
                gradientExpression() {
                  return this._transitionablePaint._values["line-gradient"]
                    .value.expression;
                }
                widthExpression() {
                  return this._transitionablePaint._values["line-width"].value
                    .expression;
                }
                recalculate(e1, t) {
                  super.recalculate(e1, t),
                    (this.paint._values["line-floorwidth"] =
                      Bb.possiblyEvaluate(
                        this._transitioningPaint._values["line-width"].value,
                        e1,
                      ));
                }
                createBucket(e1) {
                  return new _y(e1);
                }
                getProgramIds() {
                  return [
                    this.paint.get("line-pattern").constantOr(1)
                      ? "linePattern"
                      : "line",
                  ];
                }
                getDefaultProgramParams(e1, t) {
                  const i = kb(this);
                  return {
                    config: new $l(this, t),
                    defines: i,
                    overrideFog: !1,
                  };
                }
                queryRadius(e1) {
                  const t = e1,
                    i = Fb(
                      Sp("line-width", this, t),
                      Sp("line-gap-width", this, t),
                    ),
                    r = Sp("line-offset", this, t);
                  return (
                    i / 2 + Math.abs(r) + Ip(this.paint.get("line-translate"))
                  );
                }
                queryIntersectsFeature(e1, t, i, r, n, o) {
                  if (e1.queryGeometry.isAboveHorizon) return !1;
                  const s = Cp(
                      e1.tilespaceGeometry,
                      this.paint.get("line-translate"),
                      this.paint.get("line-translate-anchor"),
                      o.angle,
                      e1.pixelToTileUnitsFactor,
                    ),
                    a =
                      (e1.pixelToTileUnitsFactor / 2) *
                      Fb(
                        this.paint.get("line-width").evaluate(t, i),
                        this.paint.get("line-gap-width").evaluate(t, i),
                      ),
                    l = this.paint.get("line-offset").evaluate(t, i);
                  return (
                    l &&
                      (r = (function (e1, t) {
                        const i = [],
                          r = new y(0, 0);
                        for (let n = 0; n < e1.length; n++) {
                          const o = e1[n],
                            s = [];
                          for (let e1 = 0; e1 < o.length; e1++) {
                            const i = o[e1],
                              n = o[e1 + 1],
                              a =
                                0 === e1
                                  ? r
                                  : i
                                      .sub(o[e1 - 1])
                                      ._unit()
                                      ._perp(),
                              l =
                                e1 === o.length - 1
                                  ? r
                                  : n.sub(i)._unit()._perp(),
                              c = a._add(l)._unit();
                            c._mult(1 / (c.x * l.x + c.y * l.y)),
                              s.push(c._mult(t)._add(i));
                          }
                          i.push(s);
                        }
                        return i;
                      })(r, l * e1.pixelToTileUnitsFactor)),
                    (function (e1, t, i) {
                      for (let r = 0; r < t.length; r++) {
                        const n = t[r];
                        if (e1.length >= 3) {
                          for (let t = 0; t < n.length; t++)
                            if (wp(e1, n[t])) return !0;
                        }
                        if (_p(e1, n, i)) return !0;
                      }
                      return !1;
                    })(s, r, a)
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              symbol: Kg,
              background: class extends _a {
                constructor(e1, t) {
                  super(e1, Ub, t);
                }
                getProgramIds() {
                  return [
                    this.paint.get("background-pattern")
                      ? "backgroundPattern"
                      : "background",
                  ];
                }
                getDefaultProgramParams(e1, t) {
                  return {
                    overrideFog: !1,
                  };
                }
              },
              raster: class extends _a {
                constructor(e1, t) {
                  super(e1, jb, t), this._updateColorRamp();
                }
                getProgramIds() {
                  return ["raster"];
                }
                hasColorMap() {
                  return !!this._transitionablePaint._values["raster-color"]
                    .value.value;
                }
                isLayerDraped(e1) {
                  return !(
                    e1 &&
                    e1._source instanceof qb &&
                    (e1._source.onNorthPole || e1._source.onSouthPole)
                  );
                }
                _handleSpecialPaintPropertyUpdate(e1) {
                  ("raster-color" !== e1 && "raster-color-range" !== e1) ||
                    this._updateColorRamp();
                }
                _updateColorRamp() {
                  if (!this.hasColorMap()) return;
                  const e1 =
                      this._transitionablePaint._values["raster-color"].value
                        .expression,
                    [t, i] = this._transitionablePaint._values[
                      "raster-color-range"
                    ].value.expression.evaluate({
                      zoom: 0,
                    });
                  (this.colorRamp = Yp({
                    expression: e1,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [
                      {
                        start: t,
                        end: i,
                      },
                    ],
                    resolution: 256,
                  })),
                    (this.colorRampTexture = null);
                }
              },
              sky: class extends _a {
                constructor(e1, t) {
                  super(e1, Hb, t), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(e1) {
                  "sky-gradient" === e1
                    ? this._updateColorRamp()
                    : ("sky-atmosphere-sun" !== e1 &&
                        "sky-atmosphere-halo-color" !== e1 &&
                        "sky-atmosphere-color" !== e1 &&
                        "sky-atmosphere-sun-intensity" !== e1) ||
                      (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                  (this.colorRamp = Yp({
                    expression:
                      this._transitionablePaint._values["sky-gradient"].value
                        .expression,
                    evaluationKey: "skyRadialProgress",
                  })),
                    this.colorRampTexture &&
                      (this.colorRampTexture.destroy(),
                      (this.colorRampTexture = null));
                }
                needsSkyboxCapture(e1) {
                  if (
                    this._skyboxInvalidated ||
                    !this.skyboxTexture ||
                    !this.skyboxGeometry
                  )
                    return !0;
                  if (!this.paint.get("sky-atmosphere-sun")) {
                    const t = e1.style.light.properties.get("position");
                    return (
                      this._lightPosition.azimuthal !== t.azimuthal ||
                      this._lightPosition.polar !== t.polar
                    );
                  }
                  return !1;
                }
                getCenter(e1, t) {
                  if ("atmosphere" === this.paint.get("sky-type")) {
                    const i = this.paint.get("sky-atmosphere-sun"),
                      r = !i,
                      n = e1.style.light,
                      o = n.properties.get("position");
                    return (
                      r &&
                        "viewport" === n.properties.get("anchor") &&
                        W(
                          "The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.",
                        ),
                      r
                        ? Wb(o.azimuthal, 90 - o.polar, t)
                        : Wb(i[0], 90 - i[1], t)
                    );
                  }
                  const i = this.paint.get("sky-gradient-center");
                  return Wb(i[0], 90 - i[1], t);
                }
                isSky() {
                  return !0;
                }
                markSkyboxValid(e1) {
                  (this._skyboxInvalidated = !1),
                    (this._lightPosition =
                      e1.style.light.properties.get("position"));
                }
                hasOffscreenPass() {
                  return !0;
                }
                getProgramIds() {
                  const e1 = this.paint.get("sky-type");
                  return "atmosphere" === e1
                    ? ["skyboxCapture", "skybox"]
                    : "gradient" === e1
                    ? ["skyboxGradient"]
                    : null;
                }
              },
              slot: class extends _a {
                constructor(e1, t) {
                  super(e1, Xb);
                }
              },
              model: class extends _a {
                constructor(e1, t) {
                  super(e1, Dv, t);
                }
                createBucket(e1) {
                  return new Cv(e1);
                }
                getProgramIds() {
                  return ["model"];
                }
                is3D() {
                  return !0;
                }
                hasShadowPass() {
                  return !0;
                }
                canCastShadows() {
                  return !0;
                }
                hasLightBeamPass() {
                  return !0;
                }
                cutoffRange() {
                  return this.paint.get("model-cutoff-fade-range");
                }
                queryRadius() {
                  return 0;
                }
                queryIntersectsFeature() {
                  return !1;
                }
                _handleOverridablePaintPropertyUpdate(e1, t, i) {
                  return !(
                    !this.layout ||
                    t.isDataDriven() ||
                    i.isDataDriven() ||
                    ("model-color" !== e1 &&
                      "model-color-mix-intensity" !== e1 &&
                      "model-rotation" !== e1 &&
                      "model-scale" !== e1 &&
                      "model-translation" !== e1 &&
                      "model-emissive-strength" !== e1)
                  );
                }
                _isPropertyZoomDependent(e1) {
                  const t = this._transitionablePaint._values[e1];
                  return (
                    null != t &&
                    null != t.value &&
                    null != t.value.expression &&
                    t.value.expression instanceof bo
                  );
                }
                isZoomDependent() {
                  return (
                    this._isPropertyZoomDependent("model-scale") ||
                    this._isPropertyZoomDependent("model-rotation") ||
                    this._isPropertyZoomDependent("model-translation")
                  );
                }
              },
            };
            function Kb(e1, t) {
              return "custom" === e1.type ? new Zb(e1) : new Yb[e1.type](e1, t);
            }
            function Jb(e1) {
              const { userImage: t } = e1;
              return (
                !!(t && t.render && t.render()) &&
                (e1.data.replace(new Uint8Array(t.data.buffer)), !0)
              );
            }
            class Qb extends It {
              constructor() {
                super(),
                  (this.images = {}),
                  (this.updatedImages = {}),
                  (this.callbackDispatchedThisFrame = {}),
                  (this.loaded = {}),
                  (this.requestors = []),
                  (this.patterns = {}),
                  (this.atlasImage = {}),
                  (this.atlasTexture = {}),
                  (this.dirty = !0);
              }
              createScope(e1) {
                (this.images[e1] = {}),
                  (this.loaded[e1] = !1),
                  (this.updatedImages[e1] = {}),
                  (this.patterns[e1] = {}),
                  (this.callbackDispatchedThisFrame[e1] = {}),
                  (this.atlasImage[e1] = new $p({
                    width: 1,
                    height: 1,
                  }));
              }
              isLoaded() {
                for (const e1 in this.loaded) if (!this.loaded[e1]) return !1;
                return !0;
              }
              setLoaded(e1, t) {
                if (this.loaded[t] !== e1 && ((this.loaded[t] = e1), e1)) {
                  for (const { ids: e1, callback: i } of this.requestors)
                    this._notify(e1, t, i);
                  this.requestors = [];
                }
              }
              hasImage(e1, t) {
                return !!this.getImage(e1, t);
              }
              getImage(e1, t) {
                return this.images[t][e1];
              }
              addImage(e1, t, i) {
                this._validate(e1, i) && (this.images[t][e1] = i);
              }
              _validate(e1, t) {
                let i = !0;
                return (
                  this._validateStretch(t.stretchX, t.data && t.data.width) ||
                    (this.fire(
                      new St(
                        new Error(`Image "${e1}" has invalid "stretchX" value`),
                      ),
                    ),
                    (i = !1)),
                  this._validateStretch(t.stretchY, t.data && t.data.height) ||
                    (this.fire(
                      new St(
                        new Error(`Image "${e1}" has invalid "stretchY" value`),
                      ),
                    ),
                    (i = !1)),
                  this._validateContent(t.content, t) ||
                    (this.fire(
                      new St(
                        new Error(`Image "${e1}" has invalid "content" value`),
                      ),
                    ),
                    (i = !1)),
                  i
                );
              }
              _validateStretch(e1, t) {
                if (!e1) return !0;
                let i = 0;
                for (const r of e1) {
                  if (r[0] < i || r[1] < r[0] || t < r[1]) return !1;
                  i = r[1];
                }
                return !0;
              }
              _validateContent(e1, t) {
                return !(
                  e1 &&
                  (4 !== e1.length ||
                    e1[0] < 0 ||
                    t.data.width < e1[0] ||
                    e1[1] < 0 ||
                    t.data.height < e1[1] ||
                    e1[2] < 0 ||
                    t.data.width < e1[2] ||
                    e1[3] < 0 ||
                    t.data.height < e1[3] ||
                    e1[2] < e1[0] ||
                    e1[3] < e1[1])
                );
              }
              updateImage(e1, t, i) {
                (i.version = this.images[t][e1].version + 1),
                  (this.images[t][e1] = i),
                  (this.updatedImages[t][e1] = !0);
              }
              removeImage(e1, t) {
                const i = this.images[t][e1];
                delete this.images[t][e1],
                  delete this.patterns[t][e1],
                  i.userImage && i.userImage.onRemove && i.userImage.onRemove();
              }
              listImages(e1) {
                return Object.keys(this.images[e1]);
              }
              getImages(e1, t, i) {
                let r = !0;
                const n = !!this.loaded[t];
                if (!n) for (const i of e1) this.images[t][i] || (r = !1);
                n || r
                  ? this._notify(e1, t, i)
                  : this.requestors.push({
                      ids: e1,
                      scope: t,
                      callback: i,
                    });
              }
              getUpdatedImages(e1) {
                return this.updatedImages[e1];
              }
              _notify(e1, t, i) {
                const r = {};
                for (const i of e1) {
                  this.images[t][i] ||
                    this.fire(
                      new At("styleimagemissing", {
                        id: i,
                      }),
                    );
                  const e1 = this.images[t][i];
                  e1
                    ? (r[i] = {
                        data: e1.data.clone(),
                        pixelRatio: e1.pixelRatio,
                        sdf: e1.sdf,
                        version: e1.version,
                        stretchX: e1.stretchX,
                        stretchY: e1.stretchY,
                        content: e1.content,
                        hasRenderCallback: Boolean(
                          e1.userImage && e1.userImage.render,
                        ),
                      })
                    : W(
                        `Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`,
                      );
                }
                i(null, r);
              }
              getPixelSize(e1) {
                const { width: t, height: i } = this.atlasImage[e1];
                return {
                  width: t,
                  height: i,
                };
              }
              getPattern(e1, t) {
                const i = this.patterns[t][e1],
                  r = this.getImage(e1, t);
                if (!r) return null;
                if (i && i.position.version === r.version) return i.position;
                if (i) i.position.version = r.version;
                else {
                  const i = {
                      w: r.data.width + 2,
                      h: r.data.height + 2,
                      x: 0,
                      y: 0,
                    },
                    n = new v_(i, r);
                  this.patterns[t][e1] = {
                    bin: i,
                    position: n,
                  };
                }
                return (
                  this._updatePatternAtlas(t), this.patterns[t][e1].position
                );
              }
              bind(e1, t) {
                const i = e1.gl;
                let r = this.atlasTexture[t];
                r
                  ? this.dirty &&
                    (r.update(this.atlasImage[t]), (this.dirty = !1))
                  : ((r = new gy(e1, this.atlasImage[t], i.RGBA)),
                    (this.atlasTexture[t] = r)),
                  r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
              }
              _updatePatternAtlas(e1) {
                const t = [];
                for (const i in this.patterns[e1])
                  t.push(this.patterns[e1][i].bin);
                const { w: i, h: r } = y_(t),
                  n = this.atlasImage[e1];
                n.resize({
                  width: i || 1,
                  height: r || 1,
                });
                for (const t in this.patterns[e1]) {
                  const { bin: i } = this.patterns[e1][t],
                    r = i.x + 1,
                    o = i.y + 1,
                    s = this.images[e1][t].data,
                    a = s.width,
                    l = s.height;
                  $p.copy(
                    s,
                    n,
                    {
                      x: 0,
                      y: 0,
                    },
                    {
                      x: r,
                      y: o,
                    },
                    {
                      width: a,
                      height: l,
                    },
                  ),
                    $p.copy(
                      s,
                      n,
                      {
                        x: 0,
                        y: l - 1,
                      },
                      {
                        x: r,
                        y: o - 1,
                      },
                      {
                        width: a,
                        height: 1,
                      },
                    ),
                    $p.copy(
                      s,
                      n,
                      {
                        x: 0,
                        y: 0,
                      },
                      {
                        x: r,
                        y: o + l,
                      },
                      {
                        width: a,
                        height: 1,
                      },
                    ),
                    $p.copy(
                      s,
                      n,
                      {
                        x: a - 1,
                        y: 0,
                      },
                      {
                        x: r - 1,
                        y: o,
                      },
                      {
                        width: 1,
                        height: l,
                      },
                    ),
                    $p.copy(
                      s,
                      n,
                      {
                        x: 0,
                        y: 0,
                      },
                      {
                        x: r + a,
                        y: o,
                      },
                      {
                        width: 1,
                        height: l,
                      },
                    );
                }
                this.dirty = !0;
              }
              beginFrame() {
                for (const e1 in this.images)
                  this.callbackDispatchedThisFrame[e1] = {};
              }
              dispatchRenderCallbacks(e1, t) {
                for (const i of e1) {
                  if (this.callbackDispatchedThisFrame[t][i]) continue;
                  this.callbackDispatchedThisFrame[t][i] = !0;
                  const e1 = this.images[t][i];
                  Jb(e1) && this.updateImage(i, t, e1);
                }
              }
            }
            const ew = new da({
              anchor: new ca(Ct.light.anchor),
              position: new (class {
                constructor(e1) {
                  this.specification = e1;
                }
                possiblyEvaluate(e1, t) {
                  return K(e1.expression.evaluate(t));
                }
                interpolate(e1, t, i) {
                  return {
                    x: Wr(e1.x, t.x, i),
                    y: Wr(e1.y, t.y, i),
                    z: Wr(e1.z, t.z, i),
                    azimuthal: Wr(e1.azimuthal, t.azimuthal, i),
                    polar: Wr(e1.polar, t.polar, i),
                  };
                }
              })(Ct.light.position),
              color: new ca(Ct.light.color),
              intensity: new ca(Ct.light.intensity),
            });
            class tw extends It {
              constructor(e1, t = "flat") {
                super(),
                  (this._transitionable = new ra(ew)),
                  this.setLight(e1, t),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              getLight() {
                return this._transitionable.serialize();
              }
              setLight(e1, t, i = {}) {
                this._validate(ds, e1, i) ||
                  (this._transitionable.setTransitionOrValue(e1),
                  (this.id = t));
              }
              updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(
                  e1,
                  this._transitioning,
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
              }
              _validate(e1, t, i) {
                return (
                  (!i || !1 !== i.validate) &&
                  ws(
                    this,
                    e1.call(
                      hs,
                      k({
                        value: t,
                        style: {
                          glyphs: !0,
                          sprite: !0,
                        },
                        styleSpec: Ct,
                      }),
                    ),
                  )
                );
              }
            }
            const iw = new da({
              source: new ca(Ct.terrain.source),
              exaggeration: new ca(Ct.terrain.exaggeration),
            });
            let rw = class extends It {
              constructor(e1, t) {
                super(),
                  (this._transitionable = new ra(iw)),
                  this.set(e1),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this.drapeRenderMode = t);
              }
              setScope(e1) {
                this.scope = e1;
              }
              get() {
                return this._transitionable.serialize();
              }
              set(e1) {
                this._transitionable.setTransitionOrValue(e1);
              }
              updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(
                  e1,
                  this._transitioning,
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
              }
              getExaggeration(e1) {
                return this._transitioning
                  .possiblyEvaluate(new ea(e1))
                  .get("exaggeration");
              }
              isZoomDependent() {
                const e1 = this._transitionable._values.exaggeration;
                return (
                  null != e1 &&
                  null != e1.value &&
                  null != e1.value.expression &&
                  e1.value.expression instanceof bo
                );
              }
            };
            const nw = 45,
              ow = 65,
              sw = 0.05;
            function aw(e1, t, i, r) {
              const n = D(nw, ow, i),
                [o, s] = lw(e1, r);
              let a = 1 - Math.min(1, Math.exp(((t - o) / (s - o)) * -6));
              return (
                (a *= a * a), (a = Math.min(1, 1.00747 * a)), a * n * e1.alpha
              );
            }
            function lw(e1, t) {
              const i = 0.5 / Math.tan(0.5 * t);
              return [e1.range[0] + i, e1.range[1] + i];
            }
            function cw(e1, t, i, r, n) {
              const o = Mu.transformMat4([], [t, i, r], n.mercatorFogMatrix);
              return aw(e1, Mu.length(o), n.pitch, n._fov);
            }
            function hw(e1, t, i, r, n, o, s) {
              const a = [
                [i, r, 0],
                [n, r, 0],
                [n, o, 0],
                [i, o, 0],
              ];
              let l = Number.MAX_VALUE,
                c = -Number.MAX_VALUE;
              for (const e1 of a) {
                const i = Mu.transformMat4([], e1, t),
                  r = Mu.length(i);
                (l = Math.min(l, r)), (c = Math.max(c, r));
              }
              return [aw(e1, l, s.pitch, s._fov), aw(e1, c, s.pitch, s._fov)];
            }
            const uw = new da({
              range: new ca(Ct.fog.range),
              color: new ca(Ct.fog.color),
              "high-color": new ca(Ct.fog["high-color"]),
              "space-color": new ca(Ct.fog["space-color"]),
              "horizon-blend": new ca(Ct.fog["horizon-blend"]),
              "star-intensity": new ca(Ct.fog["star-intensity"]),
              "vertical-range": new ca(Ct.fog["vertical-range"]),
            });
            class dw extends It {
              constructor(e1, t) {
                super(),
                  (this._transitionable = new ra(uw)),
                  this.set(e1),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this._transform = t);
              }
              get state() {
                const e1 = this._transform,
                  t = "globe" === e1.projection.name,
                  i = Ed(e1.zoom),
                  r = this.properties.get("range"),
                  n = [0.5, 3];
                return {
                  range: t ? [Wr(n[0], r[0], i), Wr(n[1], r[1], i)] : r,
                  horizonBlend: this.properties.get("horizon-blend"),
                  alpha: this.properties.get("color").a,
                };
              }
              get() {
                return this._transitionable.serialize();
              }
              set(e1, t = {}) {
                if (this._validate(ms, e1, t)) return;
                const i = k({}, e1);
                for (const e1 of Object.keys(Ct.fog))
                  void 0 === i[e1] && (i[e1] = Ct.fog[e1].default);
                this._transitionable.setTransitionOrValue(i);
              }
              getOpacity(e1) {
                if (!this._transform.projection.supportsFog) return 0;
                const t =
                  (this.properties && this.properties.get("color")) || 1;
                return (
                  ("globe" === this._transform.projection.name
                    ? 1
                    : D(nw, ow, e1)) * t.a
                );
              }
              getOpacityAtLatLng(e1, t) {
                return this._transform.projection.supportsFog
                  ? (function (e1, t, i) {
                      const r = ep.fromLngLat(t),
                        n = i.elevation ? i.elevation.getAtPointOrZero(r) : 0;
                      return cw(e1, r.x, r.y, n, i);
                    })(this.state, e1, t)
                  : 0;
              }
              getOpacityForTile(e1) {
                if (!this._transform.projection.supportsFog) return [1, 1];
                const t = this._transform.calculateFogTileMatrix(
                  e1.toUnwrapped(),
                );
                return hw(this.state, t, 0, 0, sr, sr, this._transform);
              }
              getOpacityForBounds(e1, t, i, r, n) {
                return this._transform.projection.supportsFog
                  ? hw(this.state, e1, t, i, r, n, this._transform)
                  : [1, 1];
              }
              getFovAdjustedRange(e1) {
                return this._transform.projection.supportsFog
                  ? lw(this.state, e1)
                  : [0, 1];
              }
              isVisibleOnFrustum(e1) {
                if (!this._transform.projection.supportsFog) return !1;
                const t = [4, 5, 6, 7];
                for (const i of t) {
                  const t = e1.points[i];
                  let r;
                  if (t[2] >= 0) r = t;
                  else {
                    const n = e1.points[i - 4];
                    r = Xr(n, t, n[2] / (n[2] - t[2]));
                  }
                  if (cw(this.state, r[0], r[1], 0, this._transform) >= sw)
                    return !0;
                }
                return !1;
              }
              updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(
                  e1,
                  this._transitioning,
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
              }
              _validate(e1, t, i) {
                return (
                  (!i || !1 !== i.validate) &&
                  ws(
                    this,
                    e1.call(
                      hs,
                      k({
                        value: t,
                        style: {
                          glyphs: !0,
                          sprite: !0,
                        },
                        styleSpec: Ct,
                      }),
                    ),
                  )
                );
              }
            }
            class pw {
              constructor(e1) {
                (this._callback = e1),
                  (this._triggered = !1),
                  "undefined" != typeof MessageChannel &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      (this._triggered = !1), this._callback();
                    }));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        (this._triggered = !1), this._callback();
                      }, 0));
              }
              remove() {
                (this._channel = void 0), (this._callback = () => {});
              }
            }
            class fw {
              constructor() {
                (this.tasks = {}),
                  (this.taskQueue = []),
                  j(["process"], this),
                  (this.invoker = new pw(this.process)),
                  (this.nextId = 0);
              }
              add(e1, t) {
                const i = this.nextId++,
                  r = (function ({ type: e1, isSymbolTile: t, zoom: i }) {
                    return (
                      (i = i || 0),
                      "message" === e1
                        ? 0
                        : "maybePrepare" !== e1 || t
                        ? "parseTile" !== e1 || t
                          ? "parseTile" === e1 && t
                            ? 300 - i
                            : "maybePrepare" === e1 && t
                            ? 400 - i
                            : 500
                          : 200 - i
                        : 100 - i
                    );
                  })(t);
                if (0 === r) {
                  Q();
                  e1();
                  return {
                    cancel: () => {},
                  };
                }
                return (
                  (this.tasks[i] = {
                    fn: e1,
                    metadata: t,
                    priority: r,
                    id: i,
                  }),
                  this.taskQueue.push(i),
                  this.invoker.trigger(),
                  {
                    cancel: () => {
                      delete this.tasks[i];
                    },
                  }
                );
              }
              process() {
                Q();
                {
                  if (
                    ((this.taskQueue = this.taskQueue.filter(
                      (e1) => !!this.tasks[e1],
                    )),
                    !this.taskQueue.length)
                  )
                    return;
                  const e1 = this.pick();
                  if (null === e1) return;
                  const t = this.tasks[e1];
                  if (
                    (delete this.tasks[e1],
                    this.taskQueue.length && this.invoker.trigger(),
                    !t)
                  )
                    return;
                  t.fn();
                }
              }
              pick() {
                let e1 = null,
                  t = 1 / 0;
                for (let i = 0; i < this.taskQueue.length; i++) {
                  const r = this.tasks[this.taskQueue[i]];
                  r.priority < t && ((t = r.priority), (e1 = i));
                }
                if (null === e1) return null;
                const i = this.taskQueue[e1];
                return this.taskQueue.splice(e1, 1), i;
              }
              remove() {
                this.invoker.remove();
              }
            }
            class mw {
              constructor(e1, t, i) {
                (this.target = e1),
                  (this.parent = t),
                  (this.mapId = i),
                  (this.callbacks = {}),
                  (this.cancelCallbacks = {}),
                  j(["receive"], this),
                  this.target.addEventListener("message", this.receive, !1),
                  (this.scheduler = new fw());
              }
              send(e1, t, i, r, n = !1, o) {
                const s = Math.round(1e18 * Math.random())
                  .toString(36)
                  .substring(0, 10);
                i && ((i.metadata = o), (this.callbacks[s] = i));
                const a = new Set();
                return (
                  this.target.postMessage(
                    {
                      id: s,
                      type: e1,
                      hasCallback: !!i,
                      targetMapId: r,
                      mustQueue: n,
                      sourceMapId: this.mapId,
                      data: Ds(t, a),
                    },
                    a,
                  ),
                  {
                    cancel: () => {
                      i && delete this.callbacks[s],
                        this.target.postMessage({
                          id: s,
                          type: "<cancel>",
                          targetMapId: r,
                          sourceMapId: this.mapId,
                        });
                    },
                  }
                );
              }
              receive(e1) {
                const t = e1.data,
                  i = t.id;
                if (i && (!t.targetMapId || this.mapId === t.targetMapId)) {
                  if ("<cancel>" === t.type) {
                    const e1 = this.cancelCallbacks[i];
                    delete this.cancelCallbacks[i], e1 && e1.cancel();
                  } else if (t.mustQueue || Q()) {
                    const e1 = this.callbacks[i];
                    this.cancelCallbacks[i] = this.scheduler.add(
                      () => this.processTask(i, t),
                      (e1 && e1.metadata) || {
                        type: "message",
                      },
                    );
                  } else this.processTask(i, t);
                }
              }
              processTask(e1, t) {
                if ("<response>" === t.type) {
                  const i = this.callbacks[e1];
                  delete this.callbacks[e1],
                    i && (t.error ? i(Ps(t.error)) : i(null, Ps(t.data)));
                } else {
                  const i = new Set(),
                    r = t.hasCallback
                      ? (t, r) => {
                          delete this.cancelCallbacks[e1],
                            this.target.postMessage(
                              {
                                id: e1,
                                type: "<response>",
                                sourceMapId: this.mapId,
                                error: t ? Ds(t) : null,
                                data: Ds(r, i),
                              },
                              i,
                            );
                        }
                      : (e1) => {},
                    n = Ps(t.data);
                  if (this.parent[t.type])
                    this.parent[t.type](t.sourceMapId, n, r);
                  else if (this.parent.getWorkerSource) {
                    const e1 = t.type.split(".");
                    this.parent
                      .getWorkerSource(t.sourceMapId, e1[0], n.source, n.scope)
                      [e1[1]](n, r);
                  } else r(new Error(`Could not find function ${t.type}`));
                }
              }
              remove() {
                this.scheduler.remove(),
                  this.target.removeEventListener("message", this.receive, !1);
              }
            }
            class _w {
              constructor(e1, t) {
                (this.workerPool = e1),
                  (this.actors = []),
                  (this.currentActor = 0),
                  (this.id = F());
                const i = this.workerPool.acquire(this.id);
                for (let e1 = 0; e1 < i.length; e1++) {
                  const r = new _w.Actor(i[e1], t, this.id);
                  (r.name = `Worker ${e1}`), this.actors.push(r);
                }
                (this.ready = !1),
                  this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                  });
              }
              broadcast(e1, t, i) {
                R(
                  this.actors,
                  (i, r) => {
                    i.send(e1, t, r);
                  },
                  (i = i || function () {}),
                );
              }
              getActor() {
                return (
                  (this.currentActor =
                    (this.currentActor + 1) % this.actors.length),
                  this.actors[this.currentActor]
                );
              }
              remove() {
                this.actors.forEach((e1) => {
                  e1.remove();
                }),
                  (this.actors = []),
                  this.workerPool.release(this.id);
              }
            }
            _w.Actor = mw;
            class gw extends It {
              constructor(e1, t, i, r) {
                super(),
                  (this.scope = i),
                  (this._options = e1),
                  (this.properties = new la(t)),
                  (this._transitionable = new ra(t, new Map(r))),
                  this._transitionable.setTransitionOrValue(e1.properties),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              updateConfig(e1) {
                this._transitionable.setTransitionOrValue(
                  this._options.properties,
                  new Map(e1),
                );
              }
              updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(
                  e1,
                  this._transitioning,
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
              }
              get() {
                return (
                  (this._options.properties = this._transitionable.serialize()),
                  this._options
                );
              }
              set(e1, t) {
                (this._options = e1),
                  this._transitionable.setTransitionOrValue(e1.properties, t);
              }
              shadowsEnabled() {
                return (
                  !!this.properties &&
                  !0 === this.properties.get("cast-shadows")
                );
              }
            }
            const yw = new da({
                color: new ca(Ct.properties_light_ambient.color),
                intensity: new ca(Ct.properties_light_ambient.intensity),
              }),
              xw = new da({
                direction: new (class {
                  constructor(e1) {
                    this.specification = e1;
                  }
                  possiblyEvaluate(e1, t) {
                    return (function ([e1, t]) {
                      const i = K([1, e1, t]);
                      return {
                        x: i.x,
                        y: i.y,
                        z: i.z,
                      };
                    })(e1.expression.evaluate(t));
                  }
                  interpolate(e1, t, i) {
                    return {
                      x: Wr(e1.x, t.x, i),
                      y: Wr(e1.y, t.y, i),
                      z: Wr(e1.z, t.z, i),
                    };
                  }
                })(Ct.properties_light_directional.direction),
                color: new ca(Ct.properties_light_directional.color),
                intensity: new ca(Ct.properties_light_directional.intensity),
                "cast-shadows": new ca(
                  Ct.properties_light_directional["cast-shadows"],
                ),
                "shadow-intensity": new ca(
                  Ct.properties_light_directional["shadow-intensity"],
                ),
              });
            class vw {
              constructor(e1, t, i, r) {
                (this.screenBounds = e1),
                  (this.cameraPoint = t),
                  (this._screenRaycastCache = {}),
                  (this._cameraRaycastCache = {}),
                  (this.isAboveHorizon = i),
                  (this.screenGeometry = this.bufferedScreenGeometry(0)),
                  (this.screenGeometryMercator = this._bufferedScreenMercator(
                    0,
                    r,
                  ));
              }
              static createFromScreenPoints(e1, t) {
                let i, r;
                if (e1 instanceof y || "number" == typeof e1[0]) {
                  const n = y.convert(e1);
                  (i = [n]), (r = t.isPointAboveHorizon(n));
                } else {
                  const n = y.convert(e1[0]),
                    o = y.convert(e1[1]);
                  (i = [n, o]),
                    (r = S(n, o).every((e1) => t.isPointAboveHorizon(e1)));
                }
                return new vw(i, t.getCameraPoint(), r, t);
              }
              isPointQuery() {
                return 1 === this.screenBounds.length;
              }
              bufferedScreenGeometry(e1) {
                return S(
                  this.screenBounds[0],
                  1 === this.screenBounds.length
                    ? this.screenBounds[0]
                    : this.screenBounds[1],
                  e1,
                );
              }
              bufferedCameraGeometry(e1) {
                const t = this.screenBounds[0],
                  i =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new y(1, 1))
                      : this.screenBounds[1],
                  r = S(t, i, 0, !1);
                return (
                  this.cameraPoint.y > i.y &&
                    (this.cameraPoint.x > t.x && this.cameraPoint.x < i.x
                      ? r.splice(3, 0, this.cameraPoint)
                      : this.cameraPoint.x >= i.x
                      ? (r[2] = this.cameraPoint)
                      : this.cameraPoint.x <= t.x && (r[3] = this.cameraPoint)),
                  (function (e1, t) {
                    const i = [];
                    for (let r = 0; r < e1.length; r++) {
                      const n = P(r - 1, -1, e1.length - 1),
                        o = P(r + 1, -1, e1.length - 1),
                        s = e1[r],
                        a = e1[o],
                        l = e1[n].sub(s).unit(),
                        c = a.sub(s).unit(),
                        h = c.angleWithSep(l.x, l.y),
                        u = l
                          .add(c)
                          .unit()
                          .mult((-1 * t) / Math.sin(h / 2));
                      i.push(s.add(u));
                    }
                    return i;
                  })(r, e1)
                );
              }
              bufferedCameraGeometryGlobe(e1) {
                const t = this.screenBounds[0],
                  i =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new y(1, 1))
                      : this.screenBounds[1],
                  r = S(t, i, e1),
                  n = this.cameraPoint.clone();
                switch (
                  3 * ((n.y > t.y) + (n.y > i.y)) +
                  ((n.x > t.x) + (n.x > i.x))
                ) {
                  case 0:
                    (r[0] = n), (r[4] = n.clone());
                    break;
                  case 1:
                    r.splice(1, 0, n);
                    break;
                  case 2:
                    r[1] = n;
                    break;
                  case 3:
                    r.splice(4, 0, n);
                    break;
                  case 5:
                    r.splice(2, 0, n);
                    break;
                  case 6:
                    r[3] = n;
                    break;
                  case 7:
                    r.splice(3, 0, n);
                    break;
                  case 8:
                    r[2] = n;
                }
                return r;
              }
              containsTile(e1, t, i, r = 0) {
                const n = e1.queryPadding / t._pixelsPerMercatorPixel + 1,
                  o = i
                    ? this._bufferedCameraMercator(n, t)
                    : this._bufferedScreenMercator(n, t);
                let s = e1.tileID.wrap + (o.unwrapped ? r : 0);
                const a = o.polygon.map((t) => Mg(e1.tileTransform, t, s));
                if (!Tp(a, 0, 0, sr, sr)) return;
                s =
                  e1.tileID.wrap +
                  (this.screenGeometryMercator.unwrapped ? r : 0);
                const l = this.screenGeometryMercator.polygon.map((t) =>
                    Ag(e1.tileTransform, t, s),
                  ),
                  c = l.map((e1) => new y(e1[0], e1[1])),
                  h = t.getFreeCameraOptions().position || new ep(0, 0, 0),
                  u = Ag(e1.tileTransform, h, s),
                  d = l.map((e1) => {
                    const t = Mu.sub(e1, e1, u);
                    return Mu.normalize(t, t), new Uu(u, t);
                  }),
                  p = Xx(e1, 1, t.zoom) * t._pixelsPerMercatorPixel;
                var f;
                return {
                  queryGeometry: this,
                  tilespaceGeometry: c,
                  tilespaceRays: d,
                  bufferedTilespaceGeometry: a,
                  bufferedTilespaceBounds:
                    ((f = A(a)),
                    (f.min.x = z(f.min.x, 0, sr)),
                    (f.min.y = z(f.min.y, 0, sr)),
                    (f.max.x = z(f.max.x, 0, sr)),
                    (f.max.y = z(f.max.y, 0, sr)),
                    f),
                  tile: e1,
                  tileID: e1.tileID,
                  pixelToTileUnitsFactor: p,
                };
              }
              _bufferedScreenMercator(e1, t) {
                const i = Tw(e1);
                if (this._screenRaycastCache[i])
                  return this._screenRaycastCache[i];
                {
                  let r;
                  return (
                    (r =
                      "globe" === t.projection.name
                        ? this._projectAndResample(
                            this.bufferedScreenGeometry(e1),
                            t,
                          )
                        : {
                            polygon: this.bufferedScreenGeometry(e1).map((e1) =>
                              t.pointCoordinate3D(e1),
                            ),
                            unwrapped: !0,
                          }),
                    (this._screenRaycastCache[i] = r),
                    r
                  );
                }
              }
              _bufferedCameraMercator(e1, t) {
                const i = Tw(e1);
                if (this._cameraRaycastCache[i])
                  return this._cameraRaycastCache[i];
                {
                  let r;
                  return (
                    (r =
                      "globe" === t.projection.name
                        ? this._projectAndResample(
                            this.bufferedCameraGeometryGlobe(e1),
                            t,
                          )
                        : {
                            polygon: this.bufferedCameraGeometry(e1).map((e1) =>
                              t.pointCoordinate3D(e1),
                            ),
                            unwrapped: !0,
                          }),
                    (this._cameraRaycastCache[i] = r),
                    r
                  );
                }
              }
              _projectAndResample(e1, t) {
                const i = (function (e1, t) {
                  const i = xu.multiply([], t.pixelMatrix, t.globeMatrix),
                    r = [0, -Yu, 0, 1],
                    n = [0, Yu, 0, 1],
                    o = [0, 0, 0, 1];
                  uu.transformMat4(r, r, i),
                    uu.transformMat4(n, n, i),
                    uu.transformMat4(o, o, i);
                  const s = new y(r[0] / r[3], r[1] / r[3]),
                    a = new y(n[0] / n[3], n[1] / n[3]),
                    l = wp(e1, s) && r[3] < o[3],
                    c = wp(e1, a) && n[3] < o[3];
                  if (!l && !c) return null;
                  const h = (function (e1, t, i) {
                    for (let r = 1; r < e1.length; r++) {
                      const n = ww(t.pointCoordinate3D(e1[r - 1]).x),
                        o = ww(t.pointCoordinate3D(e1[r]).x);
                      if (i < 0) {
                        if (n < o)
                          return {
                            idx: r,
                            t: -n / (o - 1 - n),
                          };
                      } else if (o < n)
                        return {
                          idx: r,
                          t: (1 - n) / (o + 1 - n),
                        };
                    }
                    return null;
                  })(e1, t, l ? -1 : 1);
                  if (!h) return null;
                  const { idx: u, t: d } = h;
                  let p = u > 1 ? bw(e1.slice(0, u), t) : [],
                    f = u < e1.length ? bw(e1.slice(u), t) : [];
                  (p = p.map((e1) => new y(ww(e1.x), e1.y))),
                    (f = f.map((e1) => new y(ww(e1.x), e1.y)));
                  const m = [...p];
                  0 === m.length && m.push(f[f.length - 1]);
                  const _ = Wr(
                    m[m.length - 1].y,
                    (0 === f.length ? p[0] : f[0]).y,
                    d,
                  );
                  let g;
                  return (
                    (g = l
                      ? [new y(0, _), new y(0, 0), new y(1, 0), new y(1, _)]
                      : [new y(1, _), new y(1, 1), new y(0, 1), new y(0, _)]),
                    m.push(...g),
                    0 === f.length ? m.push(p[0]) : m.push(...f),
                    {
                      polygon: m.map((e1) => new ep(e1.x, e1.y)),
                      unwrapped: !1,
                    }
                  );
                })(e1, t);
                if (i) return i;
                const r = (function (e1, t) {
                  let i = !1,
                    r = -1 / 0,
                    n = 0;
                  for (let t = 0; t < e1.length - 1; t++)
                    e1[t].x > r && ((r = e1[t].x), (n = t));
                  for (let t = 0; t < e1.length - 1; t++) {
                    const r = (n + t) % (e1.length - 1),
                      o = e1[r],
                      s = e1[r + 1];
                    Math.abs(o.x - s.x) > 0.5 &&
                      (o.x < s.x
                        ? ((o.x += 1), 0 === r && (e1[e1.length - 1].x += 1))
                        : ((s.x += 1),
                          r + 1 === e1.length - 1 && (e1[0].x += 1)),
                      (i = !0));
                  }
                  const o = Gd(t.center.lng);
                  return (
                    i &&
                      o < Math.abs(o - 1) &&
                      e1.forEach((e1) => {
                        e1.x -= 1;
                      }),
                    {
                      polygon: e1,
                      unwrapped: i,
                    }
                  );
                })(
                  bw(e1, t).map((e1) => new y(ww(e1.x), e1.y)),
                  t,
                );
                return {
                  polygon: r.polygon.map((e1) => new ep(e1.x, e1.y)),
                  unwrapped: r.unwrapped,
                };
              }
            }
            function bw(e1, t) {
              return ip(
                e1,
                (e1) => {
                  const i = t.pointCoordinate3D(e1);
                  (e1.x = i.x), (e1.y = i.y);
                },
                1 / 256,
              );
            }
            function ww(e1) {
              return e1 < 0 ? 1 + (e1 % 1) : e1 % 1;
            }
            function Tw(e1) {
              return (100 * e1) | 0;
            }
            function Ew(e1, t, i, r, n) {
              const o = function (i, r) {
                if (i) return n(i);
                if (r) {
                  e1.url && r.tiles && e1.tiles && delete e1.tiles;
                  const i = O(k(r, e1), [
                    "tiles",
                    "minzoom",
                    "maxzoom",
                    "attribution",
                    "mapbox_logo",
                    "bounds",
                    "scheme",
                    "tileSize",
                    "encoding",
                  ]);
                  r.vector_layers &&
                    ((i.vectorLayers = r.vector_layers),
                    (i.vectorLayerIds = i.vectorLayers.map((e1) => e1.id))),
                    (i.tiles = t.canonicalizeTileset(i, e1.url)),
                    n(null, i);
                }
              };
              return e1.url
                ? we(
                    t.transformRequest(
                      t.normalizeSourceURL(e1.url, null, i, r),
                      ye.Source,
                    ),
                    o,
                  )
                : ht.frame(() => o(null, e1));
            }
            class Mw {
              constructor(e1, t, i) {
                (this.bounds = Ql.convert(this.validateBounds(e1))),
                  (this.minzoom = t || 0),
                  (this.maxzoom = i || 24);
              }
              validateBounds(e1) {
                return Array.isArray(e1) && 4 === e1.length
                  ? [
                      Math.max(-180, e1[0]),
                      Math.max(-90, e1[1]),
                      Math.min(180, e1[2]),
                      Math.min(90, e1[3]),
                    ]
                  : [-180, -90, 180, 90];
              }
              contains(e1) {
                const t = Math.pow(2, e1.z),
                  i = Math.floor(Gd(this.bounds.getWest()) * t),
                  r = Math.floor(qd(this.bounds.getNorth()) * t),
                  n = Math.ceil(Gd(this.bounds.getEast()) * t),
                  o = Math.ceil(qd(this.bounds.getSouth()) * t);
                return e1.x >= i && e1.x < n && e1.y >= r && e1.y < o;
              }
            }
            class Aw {
              constructor(e1, t) {
                (this.width = e1),
                  (this.height = t),
                  (this.nextRow = 0),
                  (this.image = new Zp({
                    width: e1,
                    height: t,
                  })),
                  (this.positions = {}),
                  (this.uploaded = !1);
              }
              getDash(e1, t) {
                const i = this.getKey(e1, t);
                return this.positions[i];
              }
              trim() {
                const e1 = this.width,
                  t = (this.height = U(this.nextRow));
                this.image.resize({
                  width: e1,
                  height: t,
                });
              }
              getKey(e1, t) {
                return e1.join(",") + t;
              }
              getDashRanges(e1, t, i) {
                const r = [];
                let n = e1.length % 2 == 1 ? -e1[e1.length - 1] * i : 0,
                  o = e1[0] * i,
                  s = !0;
                r.push({
                  left: n,
                  right: o,
                  isDash: s,
                  zeroLength: 0 === e1[0],
                });
                let a = e1[0];
                for (let t = 1; t < e1.length; t++) {
                  s = !s;
                  const l = e1[t];
                  (n = a * i),
                    (a += l),
                    (o = a * i),
                    r.push({
                      left: n,
                      right: o,
                      isDash: s,
                      zeroLength: 0 === l,
                    });
                }
                return r;
              }
              addRoundDash(e1, t, i) {
                const r = t / 2;
                for (let t = -i; t <= i; t++) {
                  const n = this.width * (this.nextRow + i + t);
                  let o = 0,
                    s = e1[o];
                  for (let a = 0; a < this.width; a++) {
                    a / s.right > 1 && (s = e1[++o]);
                    const l = Math.abs(a - s.left),
                      c = Math.abs(a - s.right),
                      h = Math.min(l, c);
                    let u;
                    const d = (t / i) * (r + 1);
                    if (s.isDash) {
                      const e1 = r - Math.abs(d);
                      u = Math.sqrt(h * h + e1 * e1);
                    } else u = r - Math.sqrt(h * h + d * d);
                    this.image.data[n + a] = Math.max(
                      0,
                      Math.min(255, u + 128),
                    );
                  }
                }
              }
              addRegularDash(e1, t) {
                for (let t = e1.length - 1; t >= 0; --t) {
                  const i = e1[t],
                    r = e1[t + 1];
                  i.zeroLength
                    ? e1.splice(t, 1)
                    : r &&
                      r.isDash === i.isDash &&
                      ((r.left = i.left), e1.splice(t, 1));
                }
                const i = e1[0],
                  r = e1[e1.length - 1];
                i.isDash === r.isDash &&
                  ((i.left = r.left - this.width),
                  (r.right = i.right + this.width));
                const n = this.width * this.nextRow;
                let o = 0,
                  s = e1[o];
                for (let i = 0; i < this.width; i++) {
                  i / s.right > 1 && (s = e1[++o]);
                  const r = Math.abs(i - s.left),
                    a = Math.abs(i - s.right),
                    l = Math.min(r, a);
                  this.image.data[n + i] = Math.max(
                    0,
                    Math.min(255, (s.isDash ? l : -l) + t + 128),
                  );
                }
              }
              addDash(e1, t) {
                const i = this.getKey(e1, t);
                if (this.positions[i]) return this.positions[i];
                const r = "round" === t,
                  n = r ? 7 : 0,
                  o = 2 * n + 1;
                if (this.nextRow + o > this.height)
                  return W("LineAtlas out of space"), null;
                0 === e1.length && e1.push(1);
                let s = 0;
                for (let t = 0; t < e1.length; t++)
                  e1[t] < 0 &&
                    (W(
                      "Negative value is found in line dasharray, replacing values with 0",
                    ),
                    (e1[t] = 0)),
                    (s += e1[t]);
                if (0 !== s) {
                  const i = this.width / s,
                    o = this.getDashRanges(e1, this.width, i);
                  r
                    ? this.addRoundDash(o, i, n)
                    : this.addRegularDash(o, "square" === t ? 0.5 * i : 0);
                }
                const a = this.nextRow + n;
                this.nextRow += o;
                const l = {
                  tl: [a, n],
                  br: [s, 0],
                };
                return (this.positions[i] = l), l;
              }
            }
            Is(Aw, "LineAtlas");
            const Sw = 1 * Y_;
            class Iw {
              constructor(e1) {
                const t = {},
                  i = [];
                for (const r in e1) {
                  const n = e1[r],
                    o = (t[r] = {});
                  for (const e1 in n.glyphs) {
                    const t = n.glyphs[+e1];
                    if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height)
                      continue;
                    const r = t.metrics.localGlyph ? Sw : 1,
                      s = {
                        x: 0,
                        y: 0,
                        w: t.bitmap.width + 2 * r,
                        h: t.bitmap.height + 2 * r,
                      };
                    i.push(s), (o[e1] = s);
                  }
                }
                const { w: r, h: n } = y_(i),
                  o = new Zp({
                    width: r || 1,
                    height: n || 1,
                  });
                for (const i in e1) {
                  const r = e1[i];
                  for (const e1 in r.glyphs) {
                    const n = r.glyphs[+e1];
                    if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height)
                      continue;
                    const s = t[i][e1],
                      a = n.metrics.localGlyph ? Sw : 1;
                    Zp.copy(
                      n.bitmap,
                      o,
                      {
                        x: 0,
                        y: 0,
                      },
                      {
                        x: s.x + a,
                        y: s.y + a,
                      },
                      n.bitmap,
                    );
                  }
                }
                (this.image = o), (this.positions = t);
              }
            }
            Is(Iw, "GlyphAtlas");
            class Cw {
              constructor(e1) {
                (this.tileID = new Bu(
                  e1.tileID.overscaledZ,
                  e1.tileID.wrap,
                  e1.tileID.canonical.z,
                  e1.tileID.canonical.x,
                  e1.tileID.canonical.y,
                )),
                  (this.tileZoom = e1.tileZoom),
                  (this.uid = e1.uid),
                  (this.zoom = e1.zoom),
                  (this.canonical = e1.tileID.canonical),
                  (this.pixelRatio = e1.pixelRatio),
                  (this.tileSize = e1.tileSize),
                  (this.source = e1.source),
                  (this.scope = e1.scope),
                  (this.overscaling = this.tileID.overscaleFactor()),
                  (this.showCollisionBoxes = e1.showCollisionBoxes),
                  (this.collectResourceTiming = !!e1.collectResourceTiming),
                  (this.promoteId = e1.promoteId),
                  (this.isSymbolTile = e1.isSymbolTile),
                  (this.tileTransform = Tg(e1.tileID.canonical, e1.projection)),
                  (this.projection = e1.projection),
                  (this.brightness = e1.brightness),
                  (this.extraShadowCaster = !!e1.extraShadowCaster);
              }
              parse(e1, t, i, r, n) {
                (this.status = "parsing"),
                  (this.data = e1),
                  (this.collisionBoxArray = new el());
                const o = new nm(Object.keys(e1.layers).sort()),
                  s = new Zm(this.tileID, this.promoteId);
                s.bucketLayerIDs = [];
                const a = {},
                  l = new Aw(256, 256),
                  c = {
                    featureIndex: s,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: l,
                    availableImages: i,
                    brightness: this.brightness,
                  },
                  h = t.familiesBySource[this.source];
                for (const t in h) {
                  const r = e1.layers[t];
                  if (!r) continue;
                  let n = !1,
                    l = !1,
                    u = !1;
                  for (const e1 of h[t])
                    "symbol" === e1[0].type ? (n = !0) : (l = !0),
                      e1[0].is3D() && "model" !== e1[0].type && (u = !0);
                  if (this.extraShadowCaster && !u) continue;
                  if (!0 === this.isSymbolTile && !n) continue;
                  if (!1 === this.isSymbolTile && !l) continue;
                  1 === r.version &&
                    W(
                      `Vector tile source "${this.source}" layer "${t}" does not use vector tile spec v2 and therefore may have some rendering errors.`,
                    );
                  const d = o.encode(t),
                    p = [];
                  for (let e1 = 0; e1 < r.length; e1++) {
                    const i = r.feature(e1),
                      n = s.getId(i, t);
                    p.push({
                      feature: i,
                      id: n,
                      index: e1,
                      sourceLayerIndex: d,
                    });
                  }
                  for (const e1 of h[t]) {
                    const t = e1[0];
                    (!this.extraShadowCaster ||
                      (t.is3D() && "model" !== t.type)) &&
                      ((void 0 !== this.isSymbolTile &&
                        ("symbol" === t.type) !== this.isSymbolTile) ||
                        (t.minzoom && this.zoom < Math.floor(t.minzoom)) ||
                        (t.maxzoom && this.zoom >= t.maxzoom) ||
                        ("none" !== t.visibility &&
                          (zw(e1, this.zoom, c.brightness, i),
                          (a[t.id] = t.createBucket({
                            index: s.bucketLayerIDs.length,
                            layers: e1,
                            zoom: this.zoom,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: d,
                            sourceID: this.source,
                            projection: this.projection.spec,
                          })).populate(
                            p,
                            c,
                            this.tileID.canonical,
                            this.tileTransform,
                          ),
                          s.bucketLayerIDs.push(e1.map((e1) => e1.id)))));
                  }
                }
                let u, d, p, f;
                l.trim();
                const m = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom,
                  },
                  _ = () => {
                    if (u) return n(u);
                    if (this.extraShadowCaster)
                      (this.status = "done"),
                        n(null, {
                          buckets: L(a).filter((e1) => !e1.isEmpty()),
                          featureIndex: s,
                          collisionBoxArray: null,
                          glyphAtlasImage: null,
                          lineAtlas: null,
                          imageAtlas: null,
                          brightness: c.brightness,
                          glyphMap: null,
                          iconMap: null,
                          glyphPositions: null,
                        });
                    else if (d && p && f) {
                      const e1 = new Iw(d),
                        t = new b_(p, f);
                      for (const r in a) {
                        const n = a[r];
                        n instanceof cy
                          ? (zw(n.layers, this.zoom, c.brightness, i),
                            dg(
                              n,
                              d,
                              e1.positions,
                              p,
                              t.iconPositions,
                              this.showCollisionBoxes,
                              i,
                              this.tileID.canonical,
                              this.tileZoom,
                              this.projection,
                              this.brightness,
                            ))
                          : n.hasPattern &&
                            (n instanceof _y ||
                              n instanceof Lf ||
                              n instanceof db) &&
                            (zw(n.layers, this.zoom, c.brightness, i),
                            n.addFeatures(
                              c,
                              this.tileID.canonical,
                              t.patternPositions,
                              i,
                              this.tileTransform,
                              this.brightness,
                            ));
                      }
                      (this.status = "done"),
                        n(null, {
                          buckets: L(a).filter((e1) => !e1.isEmpty()),
                          featureIndex: s,
                          collisionBoxArray: this.collisionBoxArray,
                          glyphAtlasImage: e1.image,
                          lineAtlas: l,
                          imageAtlas: t,
                          brightness: c.brightness,
                        });
                    }
                  };
                if (!this.extraShadowCaster) {
                  const e1 = q(c.glyphDependencies, (e1) =>
                    Object.keys(e1).map(Number),
                  );
                  Object.keys(e1).length
                    ? r.send(
                        "getGlyphs",
                        {
                          uid: this.uid,
                          stacks: e1,
                          scope: this.scope,
                        },
                        (e1, t) => {
                          u || ((u = e1), (d = t), _());
                        },
                        void 0,
                        !1,
                        m,
                      )
                    : (d = {});
                  const t = Object.keys(c.iconDependencies);
                  t.length
                    ? r.send(
                        "getImages",
                        {
                          icons: t,
                          source: this.source,
                          scope: this.scope,
                          tileID: this.tileID,
                          type: "icons",
                        },
                        (e1, t) => {
                          u || ((u = e1), (p = t), _());
                        },
                        void 0,
                        !1,
                        m,
                      )
                    : (p = {});
                  const i = Object.keys(c.patternDependencies);
                  i.length
                    ? r.send(
                        "getImages",
                        {
                          icons: i,
                          source: this.source,
                          scope: this.scope,
                          tileID: this.tileID,
                          type: "patterns",
                        },
                        (e1, t) => {
                          u || ((u = e1), (f = t), _());
                        },
                        void 0,
                        !1,
                        m,
                      )
                    : (f = {});
                }
                _();
              }
            }
            function zw(e1, t, i, r) {
              const n = new ea(t, {
                brightness: i,
              });
              for (const t of e1) t.recalculate(n, r);
            }
            class Dw {
              constructor(e1) {
                (this.entries = {}), (this.scheduler = e1);
              }
              request(e1, t, i, r) {
                const n = (this.entries[e1] = this.entries[e1] || {
                  callbacks: [],
                });
                if (n.result) {
                  const [e1, i] = n.result;
                  return (
                    this.scheduler
                      ? this.scheduler.add(() => {
                          r(e1, i);
                        }, t)
                      : r(e1, i),
                    () => {}
                  );
                }
                return (
                  n.callbacks.push(r),
                  n.cancel ||
                    (n.cancel = i((i, r) => {
                      n.result = [i, r];
                      for (const e1 of n.callbacks)
                        this.scheduler
                          ? this.scheduler.add(() => {
                              e1(i, r);
                            }, t)
                          : e1(i, r);
                      setTimeout(() => delete this.entries[e1], 3e3);
                    })),
                  () => {
                    n.result ||
                      ((n.callbacks = n.callbacks.filter((e1) => e1 !== r)),
                      n.callbacks.length ||
                        (n.cancel(), delete this.entries[e1]));
                  }
                );
              }
            }
            function Pw(e1, t, i) {
              const r = JSON.stringify(e1.request);
              return (
                e1.data &&
                  (this.deduped.entries[r] = {
                    result: [null, e1.data],
                  }),
                this.deduped.request(
                  r,
                  {
                    type: "parseTile",
                    isSymbolTile: e1.isSymbolTile,
                    zoom: e1.tileZoom,
                  },
                  (t) => {
                    const r = Te(e1.request, (e1, r, n, o) => {
                      e1
                        ? t(e1)
                        : r &&
                          t(null, {
                            vectorTile: i ? void 0 : new tm(new Sm(r)),
                            rawData: r,
                            cacheControl: n,
                            expires: o,
                          });
                    });
                    return () => {
                      r.cancel(), t();
                    };
                  },
                  t,
                )
              );
            }
            class Rw extends It {
              constructor(e1, t, i, r) {
                if (
                  (super(),
                  (this.id = e1),
                  (this.dispatcher = i),
                  (this.type = "vector"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this.reparseOverscaled = !0),
                  (this.isTileClipped = !0),
                  (this._loaded = !1),
                  k(this, O(t, ["url", "scheme", "tileSize", "promoteId"])),
                  (this._options = k(
                    {
                      type: "vector",
                    },
                    t,
                  )),
                  (this._collectResourceTiming = !!t.collectResourceTiming),
                  512 !== this.tileSize)
                )
                  throw new Error(
                    "vector tile sources must have a tileSize of 512",
                  );
                this.setEventedParent(r),
                  (this._tileWorkers = {}),
                  (this._deduped = new Dw());
              }
              load(e1) {
                (this._loaded = !1),
                  this.fire(
                    new At("dataloading", {
                      dataType: "source",
                    }),
                  );
                const t = Array.isArray(this.map._language)
                    ? this.map._language.join()
                    : this.map._language,
                  i = this.map._worldview;
                this._tileJSONRequest = Ew(
                  this._options,
                  this.map._requestManager,
                  t,
                  i,
                  (r, n) => {
                    (this._tileJSONRequest = null),
                      (this._loaded = !0),
                      r
                        ? (t &&
                            console.warn(
                              `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`,
                            ),
                          i &&
                            2 !== i.length &&
                            console.warn(
                              `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i}`,
                            ),
                          this.fire(new St(r)))
                        : n &&
                          (k(this, n),
                          n.bounds &&
                            (this.tileBounds = new Mw(
                              n.bounds,
                              this.minzoom,
                              this.maxzoom,
                            )),
                          Ge(
                            n.tiles,
                            this.map._requestManager._customAccessToken,
                          ),
                          this.fire(
                            new At("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            }),
                          ),
                          this.fire(
                            new At("data", {
                              dataType: "source",
                              sourceDataType: "content",
                            }),
                          )),
                      e1 && e1(r);
                  },
                );
              }
              loaded() {
                return this._loaded;
              }
              hasTile(e1) {
                return (
                  !this.tileBounds || this.tileBounds.contains(e1.canonical)
                );
              }
              onAdd(e1) {
                (this.map = e1), this.load();
              }
              reload() {
                this.cancelTileJSONRequest();
                const e1 = pa(this.id, this.scope);
                this.load(() => this.map.style.clearSource(e1));
              }
              setTiles(e1) {
                return (this._options.tiles = e1), this.reload(), this;
              }
              setUrl(e1) {
                return (
                  (this.url = e1), (this._options.url = e1), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return k({}, this._options);
              }
              loadTile(e1, t) {
                const i = this.map._requestManager.normalizeTileURL(
                    e1.tileID.canonical.url(this.tiles, this.scheme),
                  ),
                  r = {
                    request: this.map._requestManager.transformRequest(
                      i,
                      ye.Tile,
                    ),
                    data: void 0,
                    uid: e1.uid,
                    tileID: e1.tileID,
                    tileZoom: e1.tileZoom,
                    zoom: e1.tileID.overscaledZ,
                    tileSize: this.tileSize * e1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    pixelRatio: ht.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: e1.isSymbolTile,
                    brightness:
                      (this.map.style && this.map.style.getBrightness()) || 0,
                    extraShadowCaster: e1.isExtraShadowCaster,
                  };
                if (
                  ((r.request.collectResourceTiming =
                    this._collectResourceTiming),
                  e1.actor && "expired" !== e1.state)
                )
                  "loading" === e1.state
                    ? (e1.reloadCallback = t)
                    : (e1.request = e1.actor.send(
                        "reloadTile",
                        r,
                        n.bind(this),
                      ));
                else if (
                  ((e1.actor = this._tileWorkers[i] =
                    this._tileWorkers[i] || this.dispatcher.getActor()),
                  this.dispatcher.ready)
                )
                  e1.request = e1.actor.send(
                    "loadTile",
                    r,
                    n.bind(this),
                    void 0,
                    !0,
                  );
                else {
                  const t = Pw.call(
                    {
                      deduped: this._deduped,
                    },
                    r,
                    (t, i) => {
                      t || !i
                        ? n.call(this, t)
                        : ((r.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0),
                          }),
                          e1.actor &&
                            e1.actor.send(
                              "loadTile",
                              r,
                              n.bind(this),
                              void 0,
                              !0,
                            ));
                    },
                    !0,
                  );
                  e1.request = {
                    cancel: t,
                  };
                }
                function n(i, r) {
                  return (
                    delete e1.request,
                    e1.aborted
                      ? t(null)
                      : i && 404 !== i.status
                      ? t(i)
                      : (r &&
                          r.resourceTiming &&
                          (e1.resourceTiming = r.resourceTiming),
                        this.map._refreshExpiredTiles &&
                          r &&
                          e1.setExpiryData(r),
                        e1.loadVectorData(r, this.map.painter),
                        ge(this.dispatcher),
                        t(null),
                        void (
                          e1.reloadCallback &&
                          (this.loadTile(e1, e1.reloadCallback),
                          (e1.reloadCallback = null))
                        ))
                  );
                }
              }
              abortTile(e1) {
                e1.request && (e1.request.cancel(), delete e1.request),
                  e1.actor &&
                    e1.actor.send("abortTile", {
                      uid: e1.uid,
                      type: this.type,
                      source: this.id,
                      scope: this.scope,
                    });
              }
              unloadTile(e1) {
                e1.unloadVectorData(),
                  e1.actor &&
                    e1.actor.send("removeTile", {
                      uid: e1.uid,
                      type: this.type,
                      source: this.id,
                      scope: this.scope,
                    });
              }
              hasTransition() {
                return !1;
              }
              afterUpdate() {
                this._tileWorkers = {};
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            class Lw extends It {
              constructor(e1, t, i, r) {
                super(),
                  (this.id = e1),
                  (this.dispatcher = i),
                  this.setEventedParent(r),
                  (this.type = "raster"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.roundZoom = !0),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this._loaded = !1),
                  (this._options = k(
                    {
                      type: "raster",
                    },
                    t,
                  )),
                  k(this, O(t, ["url", "scheme", "tileSize"]));
              }
              load(e1) {
                (this._loaded = !1),
                  this.fire(
                    new At("dataloading", {
                      dataType: "source",
                    }),
                  ),
                  (this._tileJSONRequest = Ew(
                    this._options,
                    this.map._requestManager,
                    null,
                    null,
                    (t, i) => {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        t
                          ? this.fire(new St(t))
                          : i &&
                            (k(this, i),
                            i.bounds &&
                              (this.tileBounds = new Mw(
                                i.bounds,
                                this.minzoom,
                                this.maxzoom,
                              )),
                            Ge(i.tiles),
                            this.fire(
                              new At("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              }),
                            ),
                            this.fire(
                              new At("data", {
                                dataType: "source",
                                sourceDataType: "content",
                              }),
                            )),
                        e1 && e1(t);
                    },
                  ));
              }
              loaded() {
                return this._loaded;
              }
              onAdd(e1) {
                (this.map = e1), this.load();
              }
              reload() {
                this.cancelTileJSONRequest();
                const e1 = pa(this.id, this.scope);
                this.load(() => this.map.style.clearSource(e1));
              }
              setTiles(e1) {
                return (this._options.tiles = e1), this.reload(), this;
              }
              setUrl(e1) {
                return (
                  (this.url = e1), (this._options.url = e1), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return k({}, this._options);
              }
              hasTile(e1) {
                return (
                  !this.tileBounds || this.tileBounds.contains(e1.canonical)
                );
              }
              loadTile(e1, t) {
                const i = ht.devicePixelRatio >= 2,
                  r = this.map._requestManager.normalizeTileURL(
                    e1.tileID.canonical.url(this.tiles, this.scheme),
                    i,
                    this.tileSize,
                  );
                e1.request = Ie(
                  this.map._requestManager.transformRequest(r, ye.Tile),
                  (i, r, n, o) => (
                    delete e1.request,
                    e1.aborted
                      ? ((e1.state = "unloaded"), t(null))
                      : i
                      ? ((e1.state = "errored"), t(i))
                      : r
                      ? (this.map._refreshExpiredTiles &&
                          e1.setExpiryData({
                            cacheControl: n,
                            expires: o,
                          }),
                        e1.setTexture(r, this.map.painter),
                        (e1.state = "loaded"),
                        ge(this.dispatcher),
                        void t(null))
                      : t(null)
                  ),
                );
              }
              static loadTileData(e1, t, i) {
                e1.setTexture(t, i);
              }
              static unloadTileData(e1, t) {
                e1.texture && t.saveTileTexture(e1.texture);
              }
              abortTile(e1, t) {
                e1.request && (e1.request.cancel(), delete e1.request), t();
              }
              unloadTile(e1, t) {
                e1.texture && this.map.painter.saveTileTexture(e1.texture), t();
              }
              hasTransition() {
                return !1;
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            let kw;
            function Ow() {
              return null != cI.workerClass
                ? new cI.workerClass()
                : new t.Worker(cI.workerUrl);
            }
            const Bw = "mapboxgl_preloaded_worker_pool";
            class Fw {
              constructor() {
                this.active = {};
              }
              acquire(e1) {
                if (!this.workers)
                  for (
                    this.workers = [];
                    this.workers.length < Fw.workerCount;

                  )
                    this.workers.push(new Ow());
                return (this.active[e1] = !0), this.workers.slice();
              }
              release(e1) {
                delete this.active[e1],
                  this.workers &&
                    0 === this.numActive() &&
                    (this.workers.forEach((e1) => {
                      e1.terminate();
                    }),
                    (this.workers = null));
              }
              isPreloaded() {
                return !!this.active[Bw];
              }
              numActive() {
                return Object.keys(this.active).length;
              }
            }
            let Nw;
            function Uw() {
              return Nw || (Nw = new Fw()), Nw;
            }
            Fw.workerCount = 2;
            let Vw,
              jw,
              Gw,
              qw = null;
            function Zw() {
              return Q() && self.worker && self.worker.dracoUrl
                ? self.worker.dracoUrl
                : jw || n.DRACO_URL;
            }
            const $w = 5123,
              Hw = 5126,
              Ww = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                [$w]: Uint16Array,
                5125: Uint32Array,
                [Hw]: Float32Array,
              },
              Xw = {
                5120: "DT_INT8",
                5121: "DT_UINT8",
                5122: "DT_INT16",
                [$w]: "DT_UINT16",
                5125: "DT_UINT32",
                [Hw]: "DT_FLOAT32",
              },
              Yw = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16,
              };
            function Kw(e1, t, i) {
              const r = i.json.bufferViews.length,
                n = i.buffers.length;
              (t.bufferView = r),
                (i.json.bufferViews[r] = {
                  buffer: n,
                  byteLength: e1.byteLength,
                }),
                (i.buffers[n] = e1);
            }
            const Jw = "KHR_draco_mesh_compression";
            function Qw(e1, t) {
              const i = e1.extensions && e1.extensions[Jw];
              if (!i) return;
              const r = new Gw.Decoder(),
                n = nT(t, i.bufferView),
                o = new Gw.Mesh();
              if (!r.DecodeArrayToMesh(n, n.byteLength, o))
                throw new Error("Failed to decode Draco mesh");
              const s = t.json.accessors[e1.indices],
                a = Ww[s.componentType],
                l = s.count * a.BYTES_PER_ELEMENT,
                c = Gw._malloc(l);
              a === Uint16Array
                ? r.GetTrianglesUInt16Array(o, l, c)
                : r.GetTrianglesUInt32Array(o, l, c),
                Kw(Gw.memory.buffer.slice(c, c + l), s, t),
                Gw._free(c);
              for (const n of Object.keys(i.attributes)) {
                const s = r.GetAttributeByUniqueId(o, i.attributes[n]),
                  a = t.json.accessors[e1.attributes[n]],
                  l = Xw[a.componentType],
                  c =
                    a.count *
                    Yw[a.type] *
                    Ww[a.componentType].BYTES_PER_ELEMENT,
                  h = Gw._malloc(c);
                r.GetAttributeDataArrayForAllPoints(o, s, Gw[l], c, h),
                  Kw(Gw.memory.buffer.slice(h, h + c), a, t),
                  Gw._free(h);
              }
              r.destroy(), o.destroy(), delete e1.extensions[Jw];
            }
            const eT = 1179937895,
              tT = new TextDecoder("utf8");
            function iT(e1, t) {
              return new URL(e1, t).href;
            }
            function rT(e1, t, i, r) {
              return fetch(iT(e1.uri, r))
                .then((e1) => e1.arrayBuffer())
                .then((e1) => {
                  t.buffers[i] = e1;
                });
            }
            function nT(e1, t) {
              const i = e1.json.bufferViews[t];
              return new Uint8Array(
                e1.buffers[i.buffer],
                i.byteOffset || 0,
                i.byteLength,
              );
            }
            function oT(e1, i, r, n) {
              if (e1.uri) {
                const o = iT(e1.uri, n);
                return fetch(o)
                  .then((e1) => e1.blob())
                  .then((e1) => t.createImageBitmap(e1))
                  .then((e1) => {
                    i.images[r] = e1;
                  });
              }
              if (void 0 !== e1.bufferView) {
                const n = nT(i, e1.bufferView),
                  o = new t.Blob([n], {
                    type: e1.mimeType,
                  });
                return t.createImageBitmap(o).then((e1) => {
                  i.images[r] = e1;
                });
              }
            }
            function sT(e1, t = 0, i) {
              const r = {
                json: null,
                images: [],
                buffers: [],
              };
              if (new Uint32Array(e1, t, 1)[0] === eT) {
                const i = new Uint32Array(e1, t);
                let n = 2;
                const o = (i[n++] >> 2) - 3,
                  s = i[n++] >> 2;
                if (
                  (n++,
                  (r.json = JSON.parse(tT.decode(i.subarray(n, n + s)))),
                  (n += s),
                  n < o)
                ) {
                  const o = i[n++];
                  n++;
                  const s = t + (n << 2);
                  r.buffers[0] = e1.slice(s, s + o);
                }
              } else r.json = JSON.parse(tT.decode(new Uint8Array(e1, t)));
              const {
                buffers: n,
                images: o,
                meshes: s,
                extensionsUsed: a,
              } = r.json;
              let l = Promise.resolve();
              if (n) {
                const e1 = [];
                for (let t = 0; t < n.length; t++) {
                  const o = n[t];
                  o.uri
                    ? e1.push(rT(o, r, t, i))
                    : r.buffers[t] || (r.buffers[t] = null);
                }
                l = Promise.all(e1);
              }
              return l.then(() => {
                const e1 = [],
                  t = a && a.includes(Jw);
                if (
                  (t &&
                    e1.push(
                      (function () {
                        if (!Gw)
                          return (
                            Vw ||
                            ((Vw = (function (e1) {
                              let t,
                                i = null;
                              function r() {
                                t = new Uint8Array(i.buffer);
                              }
                              function n() {
                                throw new Error("Unexpected Draco error.");
                              }
                              const o = {
                                a: {
                                  a: n,
                                  d: function (e1, i, r) {
                                    return t.copyWithin(e1, i, i + r);
                                  },
                                  c: function (e1) {
                                    const n = t.length,
                                      o = Math.max(
                                        e1 >>> 0,
                                        Math.ceil(1.2 * n),
                                      ),
                                      s = Math.ceil((o - n) / 65536);
                                    try {
                                      return i.grow(s), r(), !0;
                                    } catch (e1) {
                                      return !1;
                                    }
                                  },
                                  b: n,
                                },
                              };
                              return (
                                WebAssembly.instantiateStreaming
                                  ? WebAssembly.instantiateStreaming(e1, o)
                                  : e1
                                      .then((e1) => e1.arrayBuffer())
                                      .then((e1) =>
                                        WebAssembly.instantiate(e1, o),
                                      )
                              ).then((e1) => {
                                const {
                                  Rb: n,
                                  Qb: o,
                                  P: s,
                                  T: a,
                                  X: l,
                                  Ja: c,
                                  La: h,
                                  Qa: u,
                                  Va: d,
                                  Wa: p,
                                  eb: f,
                                  jb: m,
                                  f: _,
                                  e: g,
                                  yb: y,
                                  zb: x,
                                  Ab: v,
                                  Bb: b,
                                  Db: w,
                                  Gb: T,
                                } = e1.instance.exports;
                                i = g;
                                const E = (() => {
                                  let e1 = 0,
                                    i = 0,
                                    r = 0,
                                    s = 0;
                                  return (a) => {
                                    r && (n(s), n(e1), (i += r), (r = e1 = 0)),
                                      e1 || ((i += 128), (e1 = o(i)));
                                    const l = (a.length + 7) & -8;
                                    let c = e1;
                                    l >= i && ((r = l), (c = s = o(l)));
                                    for (let e1 = 0; e1 < a.length; e1++)
                                      t[c + e1] = a[e1];
                                    return c;
                                  };
                                })();
                                return (
                                  r(),
                                  _(),
                                  {
                                    memory: g,
                                    _free: n,
                                    _malloc: o,
                                    Mesh: class {
                                      constructor() {
                                        this.ptr = s();
                                      }
                                      destroy() {
                                        a(this.ptr);
                                      }
                                    },
                                    Decoder: class {
                                      constructor() {
                                        this.ptr = c();
                                      }
                                      destroy() {
                                        m(this.ptr);
                                      }
                                      DecodeArrayToMesh(e1, t, i) {
                                        const r = E(e1),
                                          n = h(this.ptr, r, t, i.ptr);
                                        return !!l(n);
                                      }
                                      GetAttributeByUniqueId(e1, t) {
                                        return {
                                          ptr: u(this.ptr, e1.ptr, t),
                                        };
                                      }
                                      GetTrianglesUInt16Array(e1, t, i) {
                                        d(this.ptr, e1.ptr, t, i);
                                      }
                                      GetTrianglesUInt32Array(e1, t, i) {
                                        p(this.ptr, e1.ptr, t, i);
                                      }
                                      GetAttributeDataArrayForAllPoints(
                                        e1,
                                        t,
                                        i,
                                        r,
                                        n,
                                      ) {
                                        f(this.ptr, e1.ptr, t.ptr, i, r, n);
                                      }
                                    },
                                    DT_INT8: y(),
                                    DT_UINT8: x(),
                                    DT_INT16: v(),
                                    DT_UINT16: b(),
                                    DT_UINT32: w(),
                                    DT_FLOAT32: T(),
                                  }
                                );
                              });
                            })(fetch(Zw()))),
                            Vw.then((e1) => {
                              (Gw = e1), (Vw = void 0);
                            }))
                          );
                      })(),
                    ),
                  o)
                )
                  for (let t = 0; t < o.length; t++) e1.push(oT(o[t], r, t, i));
                return (e1.length ? Promise.all(e1) : Promise.resolve()).then(
                  () => {
                    if (t && s)
                      for (const { primitives: e1 } of s)
                        for (const t of e1) Qw(t, r);
                    return r;
                  },
                );
              });
            }
            function aT(e1) {
              return fetch(e1)
                .then((e1) => e1.arrayBuffer())
                .then((t) => sT(t, 0, e1));
            }
            class lT {
              constructor(e1, t, i) {
                if (
                  ((this.triangleCount = t.length / 3),
                  (this.min = new y(0, 0)),
                  (this.max = new y(0, 0)),
                  (this.xScale = 0),
                  (this.yScale = 0),
                  (this.cellsX = 0),
                  (this.cellsY = 0),
                  (this.cells = []),
                  (this.payload = []),
                  0 === this.triangleCount || 0 === e1.length || 0 === i)
                )
                  return;
                const r = e1.map((e1) => e1.x),
                  n = e1.map((e1) => e1.y);
                (this.min = new y(Math.min(...r), Math.min(...n))),
                  (this.max = new y(Math.max(...r), Math.max(...n)));
                const o = this.max.sub(this.min);
                (o.x = Math.max(o.x, 1)), (o.y = Math.max(o.y, 1));
                const s = Math.max(o.x, o.y) / i;
                (this.cellsX = Math.max(1, Math.ceil(o.x / s))),
                  (this.cellsY = Math.max(1, Math.ceil(o.y / s))),
                  (this.xScale = 1 / s),
                  (this.yScale = 1 / s);
                const a = [];
                for (let i = 0; i < this.triangleCount; i++) {
                  const r = e1[t[3 * i + 0]].sub(this.min),
                    n = e1[t[3 * i + 1]].sub(this.min),
                    o = e1[t[3 * i + 2]].sub(this.min),
                    l = cT(
                      Math.floor(Math.min(r.x, n.x, o.x)),
                      this.xScale,
                      this.cellsX,
                    ),
                    c = cT(
                      Math.floor(Math.max(r.x, n.x, o.x)),
                      this.xScale,
                      this.cellsX,
                    ),
                    h = cT(
                      Math.floor(Math.min(r.y, n.y, o.y)),
                      this.yScale,
                      this.cellsY,
                    ),
                    u = cT(
                      Math.floor(Math.max(r.y, n.y, o.y)),
                      this.yScale,
                      this.cellsY,
                    ),
                    d = new y(0, 0),
                    p = new y(0, 0),
                    f = new y(0, 0),
                    m = new y(0, 0);
                  for (let e1 = h; e1 <= u; ++e1) {
                    (d.y = p.y = e1 * s), (f.y = m.y = (e1 + 1) * s);
                    for (let t = l; t <= c; ++t)
                      (d.x = f.x = t * s),
                        (p.x = m.x = (t + 1) * s),
                        (Ap(r, n, o, d, p, m) || Ap(r, n, o, d, m, f)) &&
                          a.push({
                            cellIdx: e1 * this.cellsX + t,
                            triIdx: i,
                          });
                  }
                }
                if (0 === a.length) return;
                a.sort(
                  (e1, t) => e1.cellIdx - t.cellIdx || e1.triIdx - t.triIdx,
                );
                let l = 0;
                for (; l < a.length; ) {
                  const e1 = a[l].cellIdx,
                    t = {
                      start: this.payload.length,
                      len: 0,
                    };
                  for (; l < a.length && a[l].cellIdx === e1; )
                    ++t.len, this.payload.push(a[l++].triIdx);
                  this.cells[e1] = t;
                }
              }
              query(e1, t, i) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (e1.x > this.max.x || this.min.x > t.x) return;
                if (e1.y > this.max.y || this.min.y > t.y) return;
                this.lookup ||
                  (this.lookup = new Uint8Array(
                    Math.ceil(this.triangleCount / 8),
                  ));
                for (let e1 = 0; e1 < this.lookup.length; e1++)
                  this.lookup[e1] = 0;
                const r = cT(e1.x - this.min.x, this.xScale, this.cellsX),
                  n = cT(t.x - this.min.x, this.xScale, this.cellsX),
                  o = cT(e1.y - this.min.y, this.yScale, this.cellsY),
                  s = cT(t.y - this.min.y, this.yScale, this.cellsY);
                for (let e1 = o; e1 <= s; e1++)
                  for (let t = r; t <= n; t++) {
                    const r = this.cells[e1 * this.cellsX + t];
                    if (r)
                      for (let e1 = 0; e1 < r.len; e1++) {
                        const t = this.payload[r.start + e1],
                          n = Math.floor(t / 8),
                          o = 1 << t % 8;
                        if (
                          !(this.lookup[n] & o) &&
                          ((this.lookup[n] |= o),
                          i.push(t),
                          i.length === this.triangleCount)
                        )
                          return;
                      }
                  }
              }
            }
            function cT(e1, t, i) {
              return Math.max(0, Math.min(i - 1, Math.floor(e1 * t)));
            }
            function hT(e1, t) {
              const i = e1.json.bufferViews[t.bufferView];
              return new Ww[t.componentType](
                e1.buffers[i.buffer],
                (t.byteOffset || 0) + (i.byteOffset || 0),
                t.count * Yw[t.type],
              );
            }
            function uT(e1, t, i) {
              const r = e1.indices,
                n = e1.attributes,
                o = {};
              o.indexArray = new Va();
              const s = t.json.accessors[r],
                a = s.count / 3;
              o.indexArray.reserve(a);
              const l = hT(t, s);
              for (let e1 = 0; e1 < a; e1++)
                o.indexArray.emplaceBack(
                  l[3 * e1],
                  l[3 * e1 + 1],
                  l[3 * e1 + 2],
                );
              o.indexArray._trim(), (o.vertexArray = new Ua());
              const c = t.json.accessors[n.POSITION];
              o.vertexArray.reserve(c.count);
              const h = hT(t, c);
              for (let e1 = 0; e1 < c.count; e1++)
                o.vertexArray.emplaceBack(
                  h[3 * e1],
                  h[3 * e1 + 1],
                  h[3 * e1 + 2],
                );
              if (
                (o.vertexArray._trim(),
                (o.aabb = new Hu(c.min, c.max)),
                (o.centroid = (function (e1, t) {
                  const i = [0, 0, 0],
                    r = e1.length;
                  if (r > 0) {
                    for (let n = 0; n < r; n++) {
                      const r = 3 * e1[n];
                      (i[0] += t[r]), (i[1] += t[r + 1]), (i[2] += t[r + 2]);
                    }
                    (i[0] /= r), (i[1] /= r), (i[2] /= r);
                  }
                  return i;
                })(l, h)),
                void 0 !== n.COLOR_0)
              ) {
                const e1 = t.json.accessors[n.COLOR_0],
                  i = Yw[e1.type];
                if (e1.componentType === Hw) {
                  (o.colorArray = 3 === i ? new Ua() : new Ia()),
                    o.colorArray.reserve(e1.count);
                  const r = hT(t, e1);
                  if (3 === i)
                    for (let t = 0; t < e1.count; t++)
                      o.colorArray.emplaceBack(
                        r[3 * t],
                        r[3 * t + 1],
                        r[3 * t + 2],
                      );
                  else
                    for (let t = 0; t < e1.count; t++)
                      o.colorArray.emplaceBack(
                        r[4 * t],
                        r[4 * t + 1],
                        r[4 * t + 2],
                        r[4 * t + 3],
                      );
                  o.colorArray._trim();
                } else if (e1.componentType === $w && 4 === i) {
                  (o.colorArray = new Ia()), o.colorArray.resize(e1.count);
                  const i = hT(t, e1),
                    r = 1 / 65535,
                    n = o.colorArray.float32;
                  for (let e1 = 0; e1 < 4 * i.length; ++e1) n[e1] = i[e1] * r;
                } else
                  W(
                    `glTF color buffer parsing for accessor ${JSON.stringify(
                      e1,
                    )} is not supported`,
                  );
              }
              if (void 0 !== n.NORMAL) {
                o.normalArray = new Ua();
                const e1 = t.json.accessors[n.NORMAL];
                o.normalArray.reserve(e1.count);
                const i = hT(t, e1);
                for (let t = 0; t < e1.count; t++)
                  o.normalArray.emplaceBack(
                    i[3 * t],
                    i[3 * t + 1],
                    i[3 * t + 2],
                  );
                o.normalArray._trim();
              }
              if (void 0 !== n.TEXCOORD_0 && i.length > 0) {
                o.texcoordArray = new Xa();
                const e1 = t.json.accessors[n.TEXCOORD_0];
                o.texcoordArray.reserve(e1.count);
                const i = hT(t, e1);
                for (let t = 0; t < e1.count; t++)
                  o.texcoordArray.emplaceBack(i[2 * t], i[2 * t + 1]);
                o.texcoordArray._trim();
              }
              const u = e1.material;
              return (
                (o.material = (function (e1, t) {
                  const {
                      emissiveFactor: i = [0, 0, 0],
                      alphaMode: r = "OPAQUE",
                      alphaCutoff: n = 0.5,
                      normalTexture: o,
                      occlusionTexture: s,
                      emissiveTexture: a,
                      doubleSided: l,
                    } = e1,
                    {
                      baseColorFactor: c = [1, 1, 1, 1],
                      metallicFactor: h = 1,
                      roughnessFactor: u = 1,
                      baseColorTexture: d,
                      metallicRoughnessTexture: p,
                    } = e1.pbrMetallicRoughness || {};
                  return {
                    pbrMetallicRoughness: {
                      baseColorFactor: new li(...c),
                      metallicFactor: h,
                      roughnessFactor: u,
                      baseColorTexture: d ? t[d.index] : void 0,
                      metallicRoughnessTexture: p ? t[p.index] : void 0,
                    },
                    doubleSided: l,
                    emissiveFactor: i,
                    alphaMode: r,
                    alphaCutoff: n,
                    normalTexture: o ? t[o.index] : void 0,
                    occlusionTexture: s ? t[s.index] : void 0,
                    emissionTexture: a ? t[a.index] : void 0,
                    defined: void 0 === e1.defined,
                  };
                })(
                  void 0 !== u
                    ? t.json.materials[u]
                    : {
                        defined: !1,
                      },
                  i,
                )),
                void 0 !== n._FEATURE_RGBA4444 &&
                  (o.featureData = new Uint32Array(
                    hT(t, t.json.accessors[n._FEATURE_RGBA4444]).buffer,
                  )),
                o
              );
            }
            function dT(e1, t, i) {
              const {
                  matrix: r,
                  rotation: n,
                  translation: o,
                  scale: s,
                  mesh: a,
                  extras: l,
                  children: c,
                } = e1,
                h = {};
              if (
                ((h.matrix =
                  r ||
                  xu.fromRotationTranslationScale(
                    [],
                    n || [0, 0, 0, 1],
                    o || [0, 0, 0],
                    s || [1, 1, 1],
                  )),
                void 0 !== a)
              ) {
                h.meshes = i[a];
                const e1 = (h.anchor = [0, 0]);
                for (const t of h.meshes) {
                  const { min: i, max: r } = t.aabb;
                  (e1[0] += i[0] + r[0]), (e1[1] += i[1] + r[1]);
                }
                (e1[0] = Math.floor(e1[0] / h.meshes.length / 2)),
                  (e1[1] = Math.floor(e1[1] / h.meshes.length / 2));
              }
              if (
                (l &&
                  (l.id && (h.id = l.id),
                  l.lights &&
                    (h.lights = (function (e1) {
                      if (!e1.length) return [];
                      const t = (function (e1) {
                          const t = atob(e1),
                            i = new Uint8Array(t.length);
                          for (let e1 = 0; e1 < t.length; e1++)
                            i[e1] = t.codePointAt(e1);
                          return i;
                        })(e1),
                        i = [],
                        r = t.length / 24,
                        n = new Uint16Array(t.buffer),
                        o = new Float32Array(t.buffer);
                      for (let e1 = 0; e1 < r; e1++) {
                        const t = n[2 * e1 * 6] / 30,
                          r = n[2 * e1 * 6 + 1] / 30,
                          s = n[2 * e1 * 6 + 10] / 100,
                          a = o[6 * e1 + 1],
                          l = o[6 * e1 + 2],
                          c = o[6 * e1 + 3],
                          h = o[6 * e1 + 4],
                          u = c - a,
                          d = h - l,
                          p = Math.hypot(u, d);
                        i.push({
                          pos: [a + 0.5 * u, l + 0.5 * d, r],
                          normal: [d / p, -u / p, 0],
                          width: p,
                          height: t,
                          depth: s,
                          points: [a, l, c, h],
                        });
                      }
                      return i;
                    })(l.lights))),
                c)
              ) {
                const e1 = [];
                for (const r of c) e1.push(dT(t.json.nodes[r], t, i));
                h.children = e1;
              }
              return h;
            }
            function pT(e1) {
              if (0 === e1.vertices.length || 0 === e1.indices.length)
                return null;
              const [t, i] = [e1.vertices[0].clone(), e1.vertices[0].clone()];
              for (let r = 1; r < e1.vertices.length; ++r) {
                const n = e1.vertices[r];
                (t.x = Math.min(t.x, n.x)),
                  (t.y = Math.min(t.y, n.y)),
                  (i.x = Math.max(i.x, n.x)),
                  (i.y = Math.max(i.y, n.y));
              }
              const r = Math.ceil(Math.max(i.x - t.x, i.y - t.y) / 256),
                n = Math.max(8, r),
                o = new lT(e1.vertices, e1.indices, n);
              return {
                vertices: e1.vertices,
                indices: e1.indices,
                grid: o,
                min: t,
                max: i,
              };
            }
            function fT(e1) {
              if (!e1.extras || !e1.extras.ground) return null;
              const t = e1.extras.ground;
              if (!t || !Array.isArray(t) || 0 === t.length) return null;
              const i = t[0];
              if (!i || !Array.isArray(i) || 0 === i.length) return null;
              const r = [];
              for (const e1 of i) {
                if (!Array.isArray(e1) || 2 !== e1.length) continue;
                const t = e1[0],
                  i = e1[1];
                "number" == typeof t &&
                  "number" == typeof i &&
                  r.push(new y(t, i));
              }
              if (r.length < 3) return null;
              r.length > 1 && r[r.length - 1].equals(r[0]) && r.pop();
              let n = 0;
              for (let e1 = 0; e1 < r.length; e1++) {
                const t = r[e1],
                  i = r[(e1 + 1) % r.length],
                  o = r[(e1 + 2) % r.length];
                n += (t.x - i.x) * (o.y - i.y) - (o.x - i.x) * (t.y - i.y);
              }
              n > 0 && r.reverse();
              const o = Cf(
                r.flatMap((e1) => [e1.x, e1.y]),
                [],
              );
              return 0 === o.length
                ? null
                : {
                    vertices: r,
                    indices: o,
                  };
            }
            function mT(e1) {
              const t = [],
                i = [];
              let r = 0;
              for (const n of e1) {
                r = t.length;
                const e1 = n.vertexArray.float32,
                  o = n.indexArray.uint16;
                for (let i = 0; i < n.vertexArray.length; i++)
                  t.push(new y(e1[3 * i + 0], e1[3 * i + 1]));
                for (let e1 = 0; e1 < 3 * n.indexArray.length; e1++)
                  i.push(o[e1] + r);
              }
              if (i.length % 3 != 0) return null;
              for (let e1 = 0; e1 < i.length; e1 += 3) {
                const r = t[i[e1 + 0]],
                  n = t[i[e1 + 1]],
                  o = t[i[e1 + 2]];
                (r.x - n.x) * (o.y - n.y) - (o.x - n.x) * (r.y - n.y) > 0 &&
                  ([i[e1 + 1], i[e1 + 2]] = [i[e1 + 2], i[e1 + 1]]);
              }
              return {
                vertices: t,
                indices: i,
              };
            }
            function _T(e1) {
              const i = (function (e1, i) {
                  const r = [],
                    n = t.WebGL2RenderingContext;
                  if (e1.json.textures)
                    for (const t of e1.json.textures) {
                      const o = {
                        magFilter: n.LINEAR,
                        minFilter: n.NEAREST,
                        wrapS: n.REPEAT,
                        wrapT: n.REPEAT,
                      };
                      void 0 !== t.sampler &&
                        Object.assign(o, e1.json.samplers[t.sampler]),
                        r.push({
                          image: i[t.source],
                          sampler: o,
                          uploaded: !1,
                        });
                    }
                  return r;
                })(e1, e1.images),
                r = (function (e1, t) {
                  const i = [];
                  for (const r of e1.json.meshes) {
                    const n = [];
                    for (const i of r.primitives) n.push(uT(i, e1, t));
                    i.push(n);
                  }
                  return i;
                })(e1, i),
                { scenes: n, scene: o, nodes: s } = e1.json,
                a = n ? n[o || 0].nodes : s,
                l = [];
              for (const t of a) l.push(dT(s[t], e1, r));
              return (
                (function (e1, t, i) {
                  const r = {},
                    n = new Set();
                  for (let o = 0; o < e1.length; o++) {
                    const e1 = i[t[o]];
                    if (!e1.extras) continue;
                    const s = e1.extras["mapbox:footprint:version"],
                      a = e1.extras["mapbox:footprint:id"];
                    (s || a) && n.add(o), "1.0.0" === s && a && (r[a] = o);
                  }
                  for (let o = 0; o < e1.length; o++) {
                    if (n.has(o)) continue;
                    const s = e1[o],
                      a = i[t[o]];
                    if (!a.extras) continue;
                    let l = null;
                    s.id in r && (l = mT(e1[r[s.id]].meshes)),
                      l || (l = fT(a)),
                      l && (s.footprint = pT(l));
                  }
                  if (n.size > 0) {
                    const t = Array.from(n.values()).sort((e1, t) => e1 - t);
                    for (let i = t.length - 1; i >= 0; i--) e1.splice(t[i], 1);
                  }
                })(l, a, e1.json.nodes),
                l
              );
            }
            function gT(e1) {
              (e1.heightmap = new Float32Array(4096)), e1.heightmap.fill(-1);
              const t = e1.vertexArray.float32,
                i = e1.aabb.min[0] - 1,
                r = e1.aabb.min[1] - 1,
                n = xv / (e1.aabb.max[0] - i + 2),
                o = xv / (e1.aabb.max[1] - r + 2);
              for (let s = 0; s < t.length; s += 3) {
                const a = t[s + 2],
                  l = ((t[s + 0] - i) * n) | 0,
                  c = ((t[s + 1] - r) * o) | 0;
                a > e1.heightmap[c * xv + l] && (e1.heightmap[c * xv + l] = a);
              }
            }
            function yT(e1, t) {
              const i = {};
              (i.indexArray = new Va()),
                i.indexArray.reserve(4 * e1.length),
                (i.vertexArray = new Ua()),
                i.vertexArray.reserve(10 * e1.length),
                (i.colorArray = new Ia()),
                i.vertexArray.reserve(10 * e1.length);
              let r = 0;
              for (const n of e1) {
                const e1 = Math.min(10, Math.max(4, 1.3 * n.height)) * t,
                  o = [-n.normal[1], n.normal[0], 0],
                  s = Math.min(0.29, (0.1 * n.width) / n.depth),
                  a = n.width - 2 * n.depth * t * (s + 0.01),
                  l = Mu.scaleAndAdd([], n.pos, o, a / 2),
                  c = Mu.scaleAndAdd([], n.pos, o, -a / 2),
                  h = [l[0], l[1], l[2] + n.height],
                  u = [c[0], c[1], c[2] + n.height],
                  d = Mu.scaleAndAdd([], n.normal, o, s);
                Mu.scale(d, d, e1);
                const p = Mu.scaleAndAdd([], n.normal, o, -s);
                Mu.scale(p, p, e1),
                  Mu.add(d, l, d),
                  Mu.add(p, c, p),
                  (l[2] += 0.1),
                  (c[2] += 0.1),
                  i.vertexArray.emplaceBack(d[0], d[1], d[2]),
                  i.vertexArray.emplaceBack(p[0], p[1], p[2]),
                  i.vertexArray.emplaceBack(l[0], l[1], l[2]),
                  i.vertexArray.emplaceBack(c[0], c[1], c[2]),
                  i.vertexArray.emplaceBack(h[0], h[1], h[2]),
                  i.vertexArray.emplaceBack(u[0], u[1], u[2]),
                  i.vertexArray.emplaceBack(l[0], l[1], l[2]),
                  i.vertexArray.emplaceBack(c[0], c[1], c[2]),
                  i.vertexArray.emplaceBack(d[0], d[1], d[2]),
                  i.vertexArray.emplaceBack(p[0], p[1], p[2]);
                const f = a / e1 / 2;
                i.colorArray.emplaceBack(-f - s, -1, f, 0.8),
                  i.colorArray.emplaceBack(f + s, -1, f, 0.8),
                  i.colorArray.emplaceBack(-f, 0, f, 1.3),
                  i.colorArray.emplaceBack(f, 0, f, 1.3),
                  i.colorArray.emplaceBack(f + s, -0.8, f, 0.7),
                  i.colorArray.emplaceBack(f + s, -0.8, f, 0.7),
                  i.colorArray.emplaceBack(0, 0, f, 1.3),
                  i.colorArray.emplaceBack(0, 0, f, 1.3),
                  i.colorArray.emplaceBack(f + s, -1.2, f, 0.8),
                  i.colorArray.emplaceBack(f + s, -1.2, f, 0.8),
                  i.indexArray.emplaceBack(6 + r, 4 + r, 8 + r),
                  i.indexArray.emplaceBack(7 + r, 9 + r, 5 + r),
                  i.indexArray.emplaceBack(0 + r, 1 + r, 2 + r),
                  i.indexArray.emplaceBack(1 + r, 3 + r, 2 + r),
                  (r += 10);
              }
              const n = {
                  defined: !0,
                  emissiveFactor: [0, 0, 0],
                },
                o = {};
              return (
                (o.baseColorFactor = li.white),
                (n.pbrMetallicRoughness = o),
                (i.material = n),
                (i.aabb = new Hu(
                  [1 / 0, 1 / 0, 1 / 0],
                  [-1 / 0, -1 / 0, -1 / 0],
                )),
                i
              );
            }
            Is(lT, "TriangleGridIndex");
            const xT = {
                vector: Rw,
                raster: Lw,
                "raster-dem": class extends Lw {
                  constructor(e1, t, i, r) {
                    super(e1, t, i, r),
                      (this.type = "raster-dem"),
                      (this.maxzoom = 22),
                      (this._options = k(
                        {
                          type: "raster-dem",
                        },
                        t,
                      )),
                      (this.encoding = t.encoding || "mapbox");
                  }
                  loadTile(e1, i) {
                    const r = this.map._requestManager.normalizeTileURL(
                      e1.tileID.canonical.url(this.tiles, this.scheme),
                      !1,
                      this.tileSize,
                    );
                    e1.request = Ie(
                      this.map._requestManager.transformRequest(r, ye.Tile),
                      function (r, s, a, l) {
                        if ((delete e1.request, e1.aborted))
                          (e1.state = "unloaded"), i(null);
                        else if (r) (e1.state = "errored"), i(r);
                        else if (s) {
                          this.map._refreshExpiredTiles &&
                            e1.setExpiryData({
                              cacheControl: a,
                              expires: l,
                            });
                          const i =
                              t.ImageBitmap &&
                              s instanceof t.ImageBitmap &&
                              (null == kw &&
                                (kw =
                                  t.OffscreenCanvas &&
                                  new t.OffscreenCanvas(1, 1).getContext(
                                    "2d",
                                  ) &&
                                  "function" == typeof t.createImageBitmap),
                              kw),
                            r =
                              1 -
                              (s.width -
                                ((c = s.width) <= 1
                                  ? 1
                                  : Math.pow(
                                      2,
                                      Math.floor(Math.log(c) / Math.LN2),
                                    ))) /
                                2;
                          r < 1 ||
                            e1.neighboringTiles ||
                            (e1.neighboringTiles = this._getNeighboringTiles(
                              e1.tileID,
                            ));
                          const h = i ? s : ht.getImageData(s, r),
                            u = {
                              uid: e1.uid,
                              coord: e1.tileID,
                              source: this.id,
                              scope: this.scope,
                              rawImageData: h,
                              encoding: this.encoding,
                              padding: r,
                              convertToFloat: n,
                            };
                          (e1.actor && "expired" !== e1.state) ||
                            ((e1.actor = this.dispatcher.getActor()),
                            e1.actor.send(
                              "loadDEMTile",
                              u,
                              o.bind(this),
                              void 0,
                              !0,
                            ));
                        }
                        var c;
                      }.bind(this),
                    );
                    const n = this.map?.painter?.terrainUseFloatDEM();
                    function o(t, r) {
                      t && ((e1.state = "errored"), i(t)),
                        r &&
                          ((e1.dem = r),
                          e1.dem.onDeserialize(),
                          (e1.needsHillshadePrepare = !0),
                          (e1.needsDEMTextureUpload = !0),
                          (e1.state = "loaded"),
                          i(null));
                    }
                  }
                  _getNeighboringTiles(e1) {
                    const t = e1.canonical,
                      i = Math.pow(2, t.z),
                      r = (t.x - 1 + i) % i,
                      n = 0 === t.x ? e1.wrap - 1 : e1.wrap,
                      o = (t.x + 1 + i) % i,
                      s = t.x + 1 === i ? e1.wrap + 1 : e1.wrap,
                      a = {};
                    return (
                      (a[new Bu(e1.overscaledZ, n, t.z, r, t.y).key] = {
                        backfilled: !1,
                      }),
                      (a[new Bu(e1.overscaledZ, s, t.z, o, t.y).key] = {
                        backfilled: !1,
                      }),
                      t.y > 0 &&
                        ((a[new Bu(e1.overscaledZ, n, t.z, r, t.y - 1).key] = {
                          backfilled: !1,
                        }),
                        (a[
                          new Bu(e1.overscaledZ, e1.wrap, t.z, t.x, t.y - 1).key
                        ] = {
                          backfilled: !1,
                        }),
                        (a[new Bu(e1.overscaledZ, s, t.z, o, t.y - 1).key] = {
                          backfilled: !1,
                        })),
                      t.y + 1 < i &&
                        ((a[new Bu(e1.overscaledZ, n, t.z, r, t.y + 1).key] = {
                          backfilled: !1,
                        }),
                        (a[
                          new Bu(e1.overscaledZ, e1.wrap, t.z, t.x, t.y + 1).key
                        ] = {
                          backfilled: !1,
                        }),
                        (a[new Bu(e1.overscaledZ, s, t.z, o, t.y + 1).key] = {
                          backfilled: !1,
                        })),
                      a
                    );
                  }
                  unloadTile(e1) {
                    e1.demTexture &&
                      this.map.painter.saveTileTexture(e1.demTexture),
                      e1.hillshadeFBO &&
                        (e1.hillshadeFBO.destroy(), delete e1.hillshadeFBO),
                      e1.dem && delete e1.dem,
                      delete e1.neighboringTiles,
                      (e1.state = "unloaded");
                  }
                },
                geojson: class extends It {
                  constructor(e1, t, i, r) {
                    super(),
                      (this.id = e1),
                      (this.type = "geojson"),
                      (this.minzoom = 0),
                      (this.maxzoom = 18),
                      (this.tileSize = 512),
                      (this.isTileClipped = !0),
                      (this.reparseOverscaled = !0),
                      (this._loaded = !1),
                      (this.actor = i.getActor()),
                      this.setEventedParent(r),
                      (this._data = t.data),
                      (this._options = k({}, t)),
                      (this._collectResourceTiming = t.collectResourceTiming),
                      void 0 !== t.maxzoom && (this.maxzoom = t.maxzoom),
                      t.type && (this.type = t.type),
                      t.attribution && (this.attribution = t.attribution),
                      (this.promoteId = t.promoteId);
                    const n = sr / this.tileSize;
                    this.workerOptions = k(
                      {
                        source: this.id,
                        scope: this.scope,
                        cluster: t.cluster || !1,
                        geojsonVtOptions: {
                          buffer: (void 0 !== t.buffer ? t.buffer : 128) * n,
                          tolerance:
                            (void 0 !== t.tolerance ? t.tolerance : 0.375) * n,
                          extent: sr,
                          maxZoom: this.maxzoom,
                          lineMetrics: t.lineMetrics || !1,
                          generateId: t.generateId || !1,
                        },
                        superclusterOptions: {
                          maxZoom:
                            void 0 !== t.clusterMaxZoom
                              ? t.clusterMaxZoom
                              : this.maxzoom - 1,
                          minPoints: Math.max(2, t.clusterMinPoints || 2),
                          extent: sr,
                          radius:
                            (void 0 !== t.clusterRadius
                              ? t.clusterRadius
                              : 50) * n,
                          log: !1,
                          generateId: t.generateId || !1,
                        },
                        clusterProperties: t.clusterProperties,
                        filter: t.filter,
                      },
                      t.workerOptions,
                    );
                  }
                  onAdd(e1) {
                    (this.map = e1), this.setData(this._data);
                  }
                  setData(e1) {
                    return (this._data = e1), this._updateWorkerData(), this;
                  }
                  getClusterExpansionZoom(e1, t) {
                    return (
                      this.actor.send(
                        "geojson.getClusterExpansionZoom",
                        {
                          clusterId: e1,
                          source: this.id,
                          scope: this.scope,
                        },
                        t,
                      ),
                      this
                    );
                  }
                  getClusterChildren(e1, t) {
                    return (
                      this.actor.send(
                        "geojson.getClusterChildren",
                        {
                          clusterId: e1,
                          source: this.id,
                          scope: this.scope,
                        },
                        t,
                      ),
                      this
                    );
                  }
                  getClusterLeaves(e1, t, i, r) {
                    return (
                      this.actor.send(
                        "geojson.getClusterLeaves",
                        {
                          source: this.id,
                          scope: this.scope,
                          clusterId: e1,
                          limit: t,
                          offset: i,
                        },
                        r,
                      ),
                      this
                    );
                  }
                  _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(
                      new At("dataloading", {
                        dataType: "source",
                      }),
                    ),
                      (this._loaded = !1);
                    const e1 = k({}, this.workerOptions);
                    e1.scope = this.scope;
                    const t = this._data;
                    "string" == typeof t
                      ? ((e1.request =
                          this.map._requestManager.transformRequest(
                            ht.resolveURL(t),
                            ye.Source,
                          )),
                        (e1.request.collectResourceTiming =
                          this._collectResourceTiming))
                      : (e1.data = JSON.stringify(t)),
                      (this._pendingLoad = this.actor.send(
                        `${this.type}.loadData`,
                        e1,
                        (e1, t) => {
                          if (
                            ((this._loaded = !0),
                            (this._pendingLoad = null),
                            e1)
                          )
                            this.fire(new St(e1));
                          else {
                            const e1 = {
                              dataType: "source",
                              sourceDataType: this._metadataFired
                                ? "content"
                                : "metadata",
                            };
                            this._collectResourceTiming &&
                              t &&
                              t.resourceTiming &&
                              t.resourceTiming[this.id] &&
                              (e1.resourceTiming = t.resourceTiming[this.id]),
                              this.fire(new At("data", e1)),
                              (this._metadataFired = !0);
                          }
                          this._coalesce &&
                            (this._updateWorkerData(), (this._coalesce = !1));
                        },
                      ));
                  }
                  loaded() {
                    return this._loaded;
                  }
                  loadTile(e1, t) {
                    const i = e1.actor ? "reloadTile" : "loadTile";
                    e1.actor = this.actor;
                    const r = {
                      type: this.type,
                      uid: e1.uid,
                      tileID: e1.tileID,
                      tileZoom: e1.tileZoom,
                      zoom: e1.tileID.overscaledZ,
                      maxZoom: this.maxzoom,
                      tileSize: this.tileSize,
                      source: this.id,
                      scope: this.scope,
                      pixelRatio: ht.devicePixelRatio,
                      showCollisionBoxes: this.map.showCollisionBoxes,
                      promoteId: this.promoteId,
                      brightness:
                        (this.map.style && this.map.style.getBrightness()) || 0,
                    };
                    e1.request = this.actor.send(
                      i,
                      r,
                      (r, n) => (
                        delete e1.request,
                        e1.unloadVectorData(),
                        e1.aborted
                          ? t(null)
                          : r
                          ? t(r)
                          : (e1.loadVectorData(
                              n,
                              this.map.painter,
                              "reloadTile" === i,
                            ),
                            t(null))
                      ),
                      void 0,
                      "loadTile" === i,
                    );
                  }
                  abortTile(e1) {
                    e1.request && (e1.request.cancel(), delete e1.request),
                      (e1.aborted = !0);
                  }
                  unloadTile(e1) {
                    e1.unloadVectorData(),
                      this.actor.send("removeTile", {
                        uid: e1.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                      });
                  }
                  onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                  }
                  serialize() {
                    return k({}, this._options, {
                      type: this.type,
                      data: this._data,
                    });
                  }
                  hasTransition() {
                    return !1;
                  }
                },
                video: class extends qb {
                  constructor(e1, t, i, r) {
                    super(e1, t, i, r),
                      (this.roundZoom = !0),
                      (this.type = "video"),
                      (this.options = t);
                  }
                  load() {
                    this._loaded = !1;
                    const e1 = this.options;
                    this.urls = [];
                    for (const t of e1.urls)
                      this.urls.push(
                        this.map._requestManager.transformRequest(t, ye.Source)
                          .url,
                      );
                    !(function (e1, i) {
                      const r = t.document.createElement("video");
                      (r.muted = !0),
                        (r.onloadstart = function () {
                          i(null, r);
                        });
                      for (let i = 0; i < e1.length; i++) {
                        const n = t.document.createElement("source");
                        Ee(e1[i]) || (r.crossOrigin = "Anonymous"),
                          (n.src = e1[i]),
                          r.appendChild(n);
                      }
                    })(this.urls, (e1, t) => {
                      (this._loaded = !0),
                        e1
                          ? this.fire(new St(e1))
                          : t &&
                            ((this.video = t),
                            (this.video.loop = !0),
                            this.video.setAttribute("playsinline", ""),
                            this.video.addEventListener("playing", () => {
                              this.map.triggerRepaint();
                            }),
                            this.map && this.video.play(),
                            this._finishLoading());
                    });
                  }
                  pause() {
                    this.video && this.video.pause();
                  }
                  play() {
                    this.video && this.video.play();
                  }
                  seek(e1) {
                    if (this.video) {
                      const t = this.video.seekable;
                      e1 < t.start(0) || e1 > t.end(0)
                        ? this.fire(
                            new St(
                              new zt(
                                `sources.${this.id}`,
                                null,
                                `Playback for this video can be set only between the ${t.start(
                                  0,
                                )} and ${t.end(0)}-second mark.`,
                              ),
                            ),
                          )
                        : (this.video.currentTime = e1);
                    }
                  }
                  getVideo() {
                    return this.video;
                  }
                  onAdd(e1) {
                    this.map ||
                      ((this.map = e1),
                      this.load(),
                      this.video &&
                        (this.video.play(),
                        this.setCoordinates(this.coordinates)));
                  }
                  prepare() {
                    if (
                      0 === Object.keys(this.tiles).length ||
                      this.video.readyState < 2
                    )
                      return;
                    const e1 = this.map.painter.context,
                      t = e1.gl;
                    this.texture
                      ? this.video.paused ||
                        (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                        t.texSubImage2D(
                          t.TEXTURE_2D,
                          0,
                          0,
                          0,
                          t.RGBA,
                          t.UNSIGNED_BYTE,
                          this.video,
                        ))
                      : ((this.texture = new gy(e1, this.video, t.RGBA)),
                        this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                        (this.width = this.video.videoWidth),
                        (this.height = this.video.videoHeight)),
                      this._prepareData(e1);
                  }
                  serialize() {
                    return {
                      type: "video",
                      urls: this.urls,
                      coordinates: this.coordinates,
                    };
                  }
                  hasTransition() {
                    return this.video && !this.video.paused;
                  }
                },
                image: qb,
                model: class extends It {
                  constructor(e1, t, i, r) {
                    super(),
                      (this.id = e1),
                      (this.type = "model"),
                      (this.models = []),
                      (this._loaded = !1),
                      (this._options = t);
                  }
                  load() {
                    const e1 = [];
                    for (const t in this._options.models) {
                      const i = this._options.models[t],
                        r = aT(
                          this.map._requestManager.transformRequest(
                            i.uri,
                            ye.Model,
                          ).url,
                        )
                          .then((e1) => {
                            if (!e1) return;
                            const r = _T(e1),
                              n = new bv(t, i.position, i.orientation, r);
                            n.computeBoundsAndApplyParent(),
                              this.models.push(n);
                          })
                          .catch((e1) => {
                            this.fire(
                              new St(
                                new Error(
                                  `Could not load model ${t} from ${i.uri}: ${e1.message}`,
                                ),
                              ),
                            );
                          });
                      e1.push(r);
                    }
                    return Promise.allSettled(e1)
                      .then(() => {
                        (this._loaded = !0),
                          this.fire(
                            new At("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            }),
                          );
                      })
                      .catch((e1) => {
                        this.fire(
                          new St(
                            new Error(`Could not load models: ${e1.message}`),
                          ),
                        );
                      });
                  }
                  onAdd(e1) {
                    (this.map = e1), this.load();
                  }
                  hasTransition() {
                    return !1;
                  }
                  loaded() {
                    return this._loaded;
                  }
                  getModels() {
                    return this.models;
                  }
                  loadTile(e1, t) {}
                  serialize() {
                    return {
                      type: "model",
                    };
                  }
                },
                "batched-model": class extends It {
                  constructor(e1, t, i, r) {
                    super(),
                      (this.type = "batched-model"),
                      (this.id = e1),
                      (this.tileSize = 512),
                      (this._options = t),
                      (this.tiles = this._options.tiles),
                      (this.maxzoom = t.maxzoom || 19),
                      (this.minzoom = t.minzoom || 0),
                      (this.roundZoom = !0),
                      (this.usedInConflation = !0),
                      (this.dispatcher = i),
                      (this.reparseOverscaled = !1),
                      (this.scheme = "xyz"),
                      (this._loaded = !1),
                      this.setEventedParent(r);
                  }
                  onAdd(e1) {
                    (this.map = e1), this.load();
                  }
                  load(e1) {
                    (this._loaded = !1),
                      this.fire(
                        new At("dataloading", {
                          dataType: "source",
                        }),
                      );
                    const t = Array.isArray(this.map._language)
                        ? this.map._language.join()
                        : this.map._language,
                      i = this.map._worldview;
                    this._tileJSONRequest = Ew(
                      this._options,
                      this.map._requestManager,
                      t,
                      i,
                      (r, n) => {
                        (this._tileJSONRequest = null),
                          (this._loaded = !0),
                          r
                            ? (t &&
                                console.warn(
                                  `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`,
                                ),
                              i &&
                                2 !== i.length &&
                                console.warn(
                                  `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i}`,
                                ),
                              this.fire(new St(r)))
                            : n &&
                              (k(this, n),
                              n.bounds &&
                                (this.tileBounds = new Mw(
                                  n.bounds,
                                  this.minzoom,
                                  this.maxzoom,
                                )),
                              Ge(
                                n.tiles,
                                this.map._requestManager._customAccessToken,
                              ),
                              this.fire(
                                new At("data", {
                                  dataType: "source",
                                  sourceDataType: "metadata",
                                }),
                              ),
                              this.fire(
                                new At("data", {
                                  dataType: "source",
                                  sourceDataType: "content",
                                }),
                              )),
                          e1 && e1(r);
                      },
                    );
                  }
                  hasTransition() {
                    return !1;
                  }
                  hasTile(e1) {
                    return (
                      !this.tileBounds || this.tileBounds.contains(e1.canonical)
                    );
                  }
                  loaded() {
                    return this._loaded;
                  }
                  loadTile(e1, t) {
                    const i = this.map._requestManager.normalizeTileURL(
                        e1.tileID.canonical.url(this.tiles, this.scheme),
                      ),
                      r = {
                        request: this.map._requestManager.transformRequest(
                          i,
                          ye.Tile,
                        ),
                        data: void 0,
                        uid: e1.uid,
                        tileID: e1.tileID,
                        tileZoom: e1.tileZoom,
                        zoom: e1.tileID.overscaledZ,
                        tileSize: this.tileSize * e1.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        isSymbolTile: e1.isSymbolTile,
                        brightness:
                          (this.map.style && this.map.style.getBrightness()) ||
                          0,
                      };
                    if (e1.actor && "expired" !== e1.state) {
                      if ("loading" === e1.state) e1.reloadCallback = t;
                      else {
                        if (e1.buckets) {
                          const t = Object.values(e1.buckets);
                          for (const e1 of t) e1.dirty = !0;
                          return void (e1.state = "loaded");
                        }
                        e1.request = e1.actor.send(
                          "reloadTile",
                          r,
                          n.bind(this),
                        );
                      }
                    } else
                      (e1.actor = this.dispatcher.getActor()),
                        (e1.request = e1.actor.send(
                          "loadTile",
                          r,
                          n.bind(this),
                          void 0,
                          !0,
                        ));
                    function n(i, r) {
                      return e1.aborted
                        ? t(null)
                        : i && 404 !== i.status
                        ? t(i)
                        : (r &&
                            (r.resourceTiming &&
                              (e1.resourceTiming = r.resourceTiming),
                            this.map._refreshExpiredTiles &&
                              e1.setExpiryData(r),
                            (e1.buckets = {
                              ...e1.buckets,
                              ...r.buckets,
                            })),
                          (e1.state = "loaded"),
                          void t(null));
                    }
                  }
                  serialize() {
                    return k({}, this._options);
                  }
                },
                canvas: class extends qb {
                  constructor(e1, i, r, n) {
                    super(e1, i, r, n),
                      i.coordinates
                        ? (Array.isArray(i.coordinates) &&
                            4 === i.coordinates.length &&
                            !i.coordinates.some(
                              (e1) =>
                                !Array.isArray(e1) ||
                                2 !== e1.length ||
                                e1.some((e1) => "number" != typeof e1),
                            )) ||
                          this.fire(
                            new St(
                              new zt(
                                `sources.${e1}`,
                                null,
                                '"coordinates" property must be an array of 4 longitude/latitude array pairs',
                              ),
                            ),
                          )
                        : this.fire(
                            new St(
                              new zt(
                                `sources.${e1}`,
                                null,
                                'missing required property "coordinates"',
                              ),
                            ),
                          ),
                      i.animate &&
                        "boolean" != typeof i.animate &&
                        this.fire(
                          new St(
                            new zt(
                              `sources.${e1}`,
                              null,
                              'optional "animate" property must be a boolean value',
                            ),
                          ),
                        ),
                      i.canvas
                        ? "string" == typeof i.canvas ||
                          i.canvas instanceof t.HTMLCanvasElement ||
                          this.fire(
                            new St(
                              new zt(
                                `sources.${e1}`,
                                null,
                                '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance',
                              ),
                            ),
                          )
                        : this.fire(
                            new St(
                              new zt(
                                `sources.${e1}`,
                                null,
                                'missing required property "canvas"',
                              ),
                            ),
                          ),
                      (this.options = i),
                      (this.animate = void 0 === i.animate || i.animate);
                  }
                  load() {
                    (this._loaded = !0),
                      this.canvas ||
                        (this.canvas =
                          this.options.canvas instanceof t.HTMLCanvasElement
                            ? this.options.canvas
                            : t.document.getElementById(this.options.canvas)),
                      (this.width = this.canvas.width),
                      (this.height = this.canvas.height),
                      this._hasInvalidDimensions()
                        ? this.fire(
                            new St(
                              new Error(
                                "Canvas dimensions cannot be less than or equal to zero.",
                              ),
                            ),
                          )
                        : ((this.play = function () {
                            (this._playing = !0), this.map.triggerRepaint();
                          }),
                          (this.pause = function () {
                            this._playing &&
                              (this.prepare(), (this._playing = !1));
                          }),
                          this._finishLoading());
                  }
                  getCanvas() {
                    return this.canvas;
                  }
                  onAdd(e1) {
                    (this.map = e1),
                      this.load(),
                      this.canvas && this.animate && this.play();
                  }
                  onRemove() {
                    this.pause();
                  }
                  prepare() {
                    let e1 = !1;
                    if (
                      (this.canvas.width !== this.width &&
                        ((this.width = this.canvas.width), (e1 = !0)),
                      this.canvas.height !== this.height &&
                        ((this.height = this.canvas.height), (e1 = !0)),
                      this._hasInvalidDimensions())
                    )
                      return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const t = this.map.painter.context;
                    this.texture
                      ? (!e1 && !this._playing) ||
                        this.texture instanceof yy ||
                        this.texture.update(this.canvas, {
                          premultiply: !0,
                        })
                      : (this.texture = new gy(t, this.canvas, t.gl.RGBA, {
                          premultiply: !0,
                        })),
                      this._prepareData(t);
                  }
                  serialize() {
                    return {
                      type: "canvas",
                      coordinates: this.coordinates,
                    };
                  }
                  hasTransition() {
                    return this._playing;
                  }
                  _hasInvalidDimensions() {
                    for (const e1 of [this.canvas.width, this.canvas.height])
                      if (isNaN(e1) || e1 <= 0) return !0;
                    return !1;
                  }
                },
                custom: class extends It {
                  constructor(e1, t, i, r) {
                    super(),
                      (this.id = e1),
                      (this.type = "custom"),
                      (this._dataType = "raster"),
                      (this._dispatcher = i),
                      (this._implementation = t),
                      this.setEventedParent(r),
                      (this.scheme = "xyz"),
                      (this.minzoom = 0),
                      (this.maxzoom = 22),
                      (this.tileSize = 512),
                      (this._loaded = !1),
                      (this.roundZoom = !0),
                      this._implementation ||
                        this.fire(
                          new St(
                            new Error(
                              `Missing implementation for ${this.id} custom source`,
                            ),
                          ),
                        ),
                      this._implementation.loadTile ||
                        this.fire(
                          new St(
                            new Error(
                              `Missing loadTile implementation for ${this.id} custom source`,
                            ),
                          ),
                        ),
                      this._implementation.bounds &&
                        (this.tileBounds = new Mw(
                          this._implementation.bounds,
                          this.minzoom,
                          this.maxzoom,
                        )),
                      (t.update = this._update.bind(this)),
                      (t.clearTiles = this._clearTiles.bind(this)),
                      (t.coveringTiles = this._coveringTiles.bind(this)),
                      k(
                        this,
                        O(t, [
                          "dataType",
                          "scheme",
                          "minzoom",
                          "maxzoom",
                          "tileSize",
                          "attribution",
                          "minTileCacheSize",
                          "maxTileCacheSize",
                        ]),
                      );
                  }
                  serialize() {
                    return O(this, [
                      "type",
                      "scheme",
                      "minzoom",
                      "maxzoom",
                      "tileSize",
                      "attribution",
                    ]);
                  }
                  load() {
                    (this._loaded = !0),
                      this.fire(
                        new At("data", {
                          dataType: "source",
                          sourceDataType: "metadata",
                        }),
                      ),
                      this.fire(
                        new At("data", {
                          dataType: "source",
                          sourceDataType: "content",
                        }),
                      );
                  }
                  loaded() {
                    return this._loaded;
                  }
                  onAdd(e1) {
                    (this._map = e1),
                      (this._loaded = !1),
                      this.fire(
                        new At("dataloading", {
                          dataType: "source",
                        }),
                      ),
                      this._implementation.onAdd &&
                        this._implementation.onAdd(e1),
                      this.load();
                  }
                  onRemove(e1) {
                    this._implementation.onRemove &&
                      this._implementation.onRemove(e1);
                  }
                  hasTile(e1) {
                    if (this._implementation.hasTile) {
                      const { x: t, y: i, z: r } = e1.canonical;
                      return this._implementation.hasTile({
                        x: t,
                        y: i,
                        z: r,
                      });
                    }
                    return (
                      !this.tileBounds || this.tileBounds.contains(e1.canonical)
                    );
                  }
                  loadTile(e1, i) {
                    const { x: r, y: n, z: o } = e1.tileID.canonical,
                      s = new t.AbortController();
                    (e1.request = Promise.resolve(
                      this._implementation.loadTile(
                        {
                          x: r,
                          y: n,
                          z: o,
                        },
                        {
                          signal: s.signal,
                        },
                      ),
                    )
                      .then(
                        function (r) {
                          return (
                            delete e1.request,
                            e1.aborted
                              ? ((e1.state = "unloaded"), i(null))
                              : void 0 === r
                              ? ((e1.state = "errored"), i(null))
                              : null === r
                              ? (this.loadTileData(e1, {
                                  width: this.tileSize,
                                  height: this.tileSize,
                                  data: null,
                                }),
                                (e1.state = "loaded"),
                                i(null))
                              : (function (e1) {
                                  return (
                                    e1 instanceof t.ImageData ||
                                    e1 instanceof t.HTMLCanvasElement ||
                                    e1 instanceof t.ImageBitmap ||
                                    e1 instanceof t.HTMLImageElement
                                  );
                                })(r)
                              ? (this.loadTileData(e1, r),
                                (e1.state = "loaded"),
                                void i(null))
                              : ((e1.state = "errored"),
                                i(
                                  new Error(
                                    `Can't infer data type for ${this.id}, only raster data supported at the moment`,
                                  ),
                                ))
                          );
                        }.bind(this),
                      )
                      .catch((t) => {
                        20 !== t.code && ((e1.state = "errored"), i(t));
                      })),
                      (e1.request.cancel = () => s.abort());
                  }
                  loadTileData(e1, t) {
                    Lw.loadTileData(e1, t, this._map.painter);
                  }
                  unloadTileData(e1) {
                    Lw.unloadTileData(e1, this._map.painter);
                  }
                  unloadTile(e1, t) {
                    if (
                      (this.unloadTileData(e1), this._implementation.unloadTile)
                    ) {
                      const { x: t, y: i, z: r } = e1.tileID.canonical;
                      this._implementation.unloadTile({
                        x: t,
                        y: i,
                        z: r,
                      });
                    }
                    t();
                  }
                  abortTile(e1, t) {
                    e1.request &&
                      e1.request.cancel &&
                      (e1.request.cancel(), delete e1.request),
                      t();
                  }
                  hasTransition() {
                    return !1;
                  }
                  _coveringTiles() {
                    return this._map.transform
                      .coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom,
                      })
                      .map((e1) => ({
                        x: e1.canonical.x,
                        y: e1.canonical.y,
                        z: e1.canonical.z,
                      }));
                  }
                  _clearTiles() {
                    const e1 = pa(this.id, this.scope);
                    this._map.style.clearSource(e1);
                  }
                  _update() {
                    this.fire(
                      new At("data", {
                        dataType: "source",
                        sourceDataType: "content",
                      }),
                    );
                  }
                },
              },
              vT = function (e1, t, i, r) {
                const n = new xT[t.type](e1, t, i, r);
                if (n.id !== e1)
                  throw new Error(
                    `Expected Source id to be ${e1} instead of ${n.id}`,
                  );
                return (
                  j(["load", "abort", "unload", "serialize", "prepare"], n), n
                );
              };
            function bT(e1, t) {
              const i = xu.identity([]);
              return (
                xu.scale(i, i, [0.5 * e1.width, 0.5 * -e1.height, 1]),
                xu.translate(i, i, [1, -1, 0]),
                xu.multiply(i, i, e1.calculateProjMatrix(t.toUnwrapped())),
                Float32Array.from(i)
              );
            }
            function wT(e1, t, i, r, n, o, s, a = !1) {
              const l = e1.tilesIn(r, s, a);
              l.sort(ET);
              const c = [];
              for (const r of l)
                c.push({
                  wrappedTileID: r.tile.tileID.wrapped().key,
                  queryResults: r.tile.queryRenderedFeatures(
                    t,
                    i,
                    e1._state,
                    r,
                    n,
                    o,
                    bT(e1.transform, r.tile.tileID),
                    a,
                  ),
                });
              const h = (function (e1) {
                const t = {},
                  i = {};
                for (const r of e1) {
                  const e1 = r.queryResults,
                    n = r.wrappedTileID,
                    o = (i[n] = i[n] || {});
                  for (const i in e1) {
                    const r = e1[i],
                      n = (o[i] = o[i] || {}),
                      s = (t[i] = t[i] || []);
                    for (const e1 of r)
                      n[e1.featureIndex] ||
                        ((n[e1.featureIndex] = !0), s.push(e1));
                  }
                }
                return t;
              })(c);
              for (const t in h)
                h[t].forEach((t) => {
                  const i = t.feature,
                    r = i.layer;
                  r &&
                    "background" !== r.type &&
                    "sky" !== r.type &&
                    "slot" !== r.type &&
                    ((i.source = r.source),
                    r["source-layer"] && (i.sourceLayer = r["source-layer"]),
                    (i.state =
                      void 0 !== i.id
                        ? e1.getFeatureState(r["source-layer"], i.id)
                        : {}));
                });
              return h;
            }
            function TT(e1, t) {
              const i = e1.getRenderableIds().map((t) => e1.getTileByID(t)),
                r = [],
                n = {};
              for (let e1 = 0; e1 < i.length; e1++) {
                const o = i[e1],
                  s = o.tileID.canonical.key;
                n[s] || ((n[s] = !0), o.querySourceFeatures(r, t));
              }
              return r;
            }
            function ET(e1, t) {
              const i = e1.tileID,
                r = t.tileID;
              return (
                i.overscaledZ - r.overscaledZ ||
                i.canonical.y - r.canonical.y ||
                i.wrap - r.wrap ||
                i.canonical.x - r.canonical.x
              );
            }
            class MT {
              constructor(e1) {
                this.style = e1;
              }
              processLayersChanged() {
                this.layers = [];
                for (const e1 in this.style._mergedLayers) {
                  const t = this.style._mergedLayers[e1];
                  if ("fill-extrusion" === t.type) this.layers.push(t);
                  else if ("model" === t.type) {
                    const e1 = this.style.getLayerSource(t);
                    e1 && "batched-model" === e1.type && this.layers.push(t);
                  }
                }
              }
              updateZOffset(e1, t) {
                this.currentBuildingBuckets = [];
                for (let e1 = 0; e1 < this.layers.length; ++e1) {
                  const i = this.layers[e1],
                    r = this.style.getLayerSourceCache(i);
                  let n = 1;
                  "fill-extrusion" === i.type &&
                    (n =
                      i.paint.get("fill-extrusion-opacity") > 0
                        ? i.paint.get("fill-extrusion-vertical-scale")
                        : 0);
                  let o = r ? r.getTile(t) : null;
                  if (!o && r && t.canonical.z > r.getSource().minzoom) {
                    let e1 = t.scaledTo(
                      Math.min(r.getSource().maxzoom, t.overscaledZ - 1),
                    );
                    for (
                      ;
                      e1.overscaledZ >= r.getSource().minzoom &&
                      ((o = r.getTile(e1)), !o && 0 !== e1.overscaledZ);

                    )
                      e1 = e1.scaledTo(e1.overscaledZ - 1);
                  }
                  this.currentBuildingBuckets.push({
                    bucket: o ? o.getBucket(i) : null,
                    tileID: o ? o.tileID : t,
                    verticalScale: n,
                  });
                }
                e1.hasAnyZOffset = !1;
                let i = !1;
                for (let r = 0; r < e1.symbolInstances.length; r++) {
                  const n = e1.symbolInstances.get(r),
                    o = n.zOffset,
                    s = this._getHeightAtTileOffset(
                      t,
                      n.tileAnchorX,
                      n.tileAnchorY,
                    );
                  (n.zOffset = -1 !== s ? s : o),
                    i || o === n.zOffset || (i = !0),
                    e1.hasAnyZOffset ||
                      0 === n.zOffset ||
                      (e1.hasAnyZOffset = !0);
                }
                i &&
                  ((e1.zOffsetBuffersNeedUpload = !0),
                  (e1.zOffsetSortDirty = !0));
              }
              _mapCoordToOverlappingTile(e1, t, i, r) {
                let n = t,
                  o = i;
                if (e1.canonical.z !== r.canonical.z) {
                  const s = r.canonical,
                    a = 1 / (1 << (e1.canonical.z - s.z));
                  (n = ((t + e1.canonical.x * sr) * a - s.x * sr) | 0),
                    (o = ((i + e1.canonical.y * sr) * a - s.y * sr) | 0);
                }
                return {
                  tileX: n,
                  tileY: o,
                };
              }
              _getHeightAtTileOffset(e1, t, i) {
                let r;
                for (let n = 0; n < this.layers.length; ++n) {
                  if ("fill-extrusion" !== this.layers[n].type) continue;
                  const {
                    bucket: o,
                    tileID: s,
                    verticalScale: a,
                  } = this.currentBuildingBuckets[n];
                  if (!o) continue;
                  const { tileX: l, tileY: c } =
                      this._mapCoordToOverlappingTile(e1, t, i, s),
                    h = o.getHeightAtTileCoord(l, c);
                  if (h && void 0 !== h.height) {
                    if (!h.hidden) return h.height * a;
                    r = h.height;
                  }
                }
                for (let n = 0; n < this.layers.length; ++n) {
                  if ("model" !== this.layers[n].type) continue;
                  const { bucket: o, tileID: s } =
                    this.currentBuildingBuckets[n];
                  if (!o) continue;
                  const { tileX: a, tileY: l } =
                      this._mapCoordToOverlappingTile(e1, t, i, s),
                    c = o.getHeightAtTileCoord(a, l);
                  if (c && !c.hidden)
                    return void 0 === c.height && void 0 !== r
                      ? Math.min(c.maxHeight, r) * c.verticalScale
                      : (c.height || 0) * c.verticalScale;
                }
                return -1;
              }
            }
            var AT = [
              "type",
              "source",
              "source-layer",
              "minzoom",
              "maxzoom",
              "filter",
              "layout",
            ];
            function ST(e1, t) {
              const i = {};
              for (const t in e1) "ref" !== t && (i[t] = e1[t]);
              return (
                AT.forEach((e1) => {
                  e1 in t && (i[e1] = t[e1]);
                }),
                i
              );
            }
            function IT(e1) {
              e1 = e1.slice();
              const t = Object.create(null);
              for (let i = 0; i < e1.length; i++) t[e1[i].id] = e1[i];
              for (let i = 0; i < e1.length; i++)
                "ref" in e1[i] && (e1[i] = ST(e1[i], t[e1[i].ref]));
              return e1;
            }
            const CT = {
              setStyle: "setStyle",
              addLayer: "addLayer",
              removeLayer: "removeLayer",
              setPaintProperty: "setPaintProperty",
              setLayoutProperty: "setLayoutProperty",
              setSlot: "setSlot",
              setFilter: "setFilter",
              addSource: "addSource",
              removeSource: "removeSource",
              setGeoJSONSourceData: "setGeoJSONSourceData",
              setLayerZoomRange: "setLayerZoomRange",
              setLayerProperty: "setLayerProperty",
              setCenter: "setCenter",
              setZoom: "setZoom",
              setBearing: "setBearing",
              setPitch: "setPitch",
              setSprite: "setSprite",
              setGlyphs: "setGlyphs",
              setTransition: "setTransition",
              setLight: "setLight",
              setTerrain: "setTerrain",
              setFog: "setFog",
              setCamera: "setCamera",
              setLights: "setLights",
              setProjection: "setProjection",
              addImport: "addImport",
              removeImport: "removeImport",
              setImportUrl: "setImportUrl",
              setImportData: "setImportData",
              setImportConfig: "setImportConfig",
            };
            function zT(e1, t, i) {
              i.push({
                command: CT.addSource,
                args: [e1, t[e1]],
              });
            }
            function DT(e1, t, i) {
              t.push({
                command: CT.removeSource,
                args: [e1],
              }),
                (i[e1] = !0);
            }
            function PT(e1, t, i, r) {
              DT(e1, i, r), zT(e1, t, i);
            }
            function RT(e1, t, i) {
              let r;
              for (r in e1[i])
                if (
                  e1[i].hasOwnProperty(r) &&
                  "data" !== r &&
                  !x(e1[i][r], t[i][r])
                )
                  return !1;
              for (r in t[i])
                if (
                  t[i].hasOwnProperty(r) &&
                  "data" !== r &&
                  !x(e1[i][r], t[i][r])
                )
                  return !1;
              return !0;
            }
            function LT(e1, t, i, r, n, o) {
              let s;
              for (s in ((t = t || {}), (e1 = e1 || {})))
                e1.hasOwnProperty(s) &&
                  (x(e1[s], t[s]) ||
                    i.push({
                      command: o,
                      args: [r, s, t[s], n],
                    }));
              for (s in t)
                t.hasOwnProperty(s) &&
                  !e1.hasOwnProperty(s) &&
                  (x(e1[s], t[s]) ||
                    i.push({
                      command: o,
                      args: [r, s, t[s], n],
                    }));
            }
            function kT(e1) {
              return e1.id;
            }
            function OT(e1, t) {
              return (e1[t.id] = t), e1;
            }
            class BT {
              constructor(e1, t) {
                this.reset(e1, t);
              }
              reset(e1, t) {
                (this.points = e1 || []), (this._distances = [0]);
                for (let e1 = 1; e1 < this.points.length; e1++)
                  this._distances[e1] =
                    this._distances[e1 - 1] +
                    this.points[e1].dist(this.points[e1 - 1]);
                (this.length = this._distances[this._distances.length - 1]),
                  (this.padding = Math.min(t || 0, 0.5 * this.length)),
                  (this.paddedLength = this.length - 2 * this.padding);
              }
              lerp(e1) {
                if (1 === this.points.length) return this.points[0];
                e1 = z(e1, 0, 1);
                let t = 1,
                  i = this._distances[t];
                const r = e1 * this.paddedLength + this.padding;
                for (; i < r && t < this._distances.length; )
                  i = this._distances[++t];
                const n = t - 1,
                  o = this._distances[n],
                  s = i - o,
                  a = s > 0 ? (r - o) / s : 0;
                return this.points[n].mult(1 - a).add(this.points[t].mult(a));
              }
            }
            class FT {
              constructor(e1, t, i) {
                const r = (this.boxCells = []),
                  n = (this.circleCells = []);
                (this.xCellCount = Math.ceil(e1 / i)),
                  (this.yCellCount = Math.ceil(t / i));
                for (let e1 = 0; e1 < this.xCellCount * this.yCellCount; e1++)
                  r.push([]), n.push([]);
                (this.circleKeys = []),
                  (this.boxKeys = []),
                  (this.bboxes = []),
                  (this.circles = []),
                  (this.width = e1),
                  (this.height = t),
                  (this.xScale = this.xCellCount / e1),
                  (this.yScale = this.yCellCount / t),
                  (this.boxUid = 0),
                  (this.circleUid = 0);
              }
              keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
              }
              insert(e1, t, i, r, n) {
                this._forEachCell(
                  t,
                  i,
                  r,
                  n,
                  this._insertBoxCell,
                  this.boxUid++,
                ),
                  this.boxKeys.push(e1),
                  this.bboxes.push(t),
                  this.bboxes.push(i),
                  this.bboxes.push(r),
                  this.bboxes.push(n);
              }
              insertCircle(e1, t, i, r) {
                this._forEachCell(
                  t - r,
                  i - r,
                  t + r,
                  i + r,
                  this._insertCircleCell,
                  this.circleUid++,
                ),
                  this.circleKeys.push(e1),
                  this.circles.push(t),
                  this.circles.push(i),
                  this.circles.push(r);
              }
              _insertBoxCell(e1, t, i, r, n, o) {
                this.boxCells[n].push(o);
              }
              _insertCircleCell(e1, t, i, r, n, o) {
                this.circleCells[n].push(o);
              }
              _query(e1, t, i, r, n, o) {
                if (i < 0 || e1 > this.width || r < 0 || t > this.height)
                  return !n && [];
                const s = [];
                if (e1 <= 0 && t <= 0 && this.width <= i && this.height <= r) {
                  if (n) return !0;
                  for (let e1 = 0; e1 < this.boxKeys.length; e1++)
                    s.push({
                      key: this.boxKeys[e1],
                      x1: this.bboxes[4 * e1],
                      y1: this.bboxes[4 * e1 + 1],
                      x2: this.bboxes[4 * e1 + 2],
                      y2: this.bboxes[4 * e1 + 3],
                    });
                  for (let e1 = 0; e1 < this.circleKeys.length; e1++) {
                    const t = this.circles[3 * e1],
                      i = this.circles[3 * e1 + 1],
                      r = this.circles[3 * e1 + 2];
                    s.push({
                      key: this.circleKeys[e1],
                      x1: t - r,
                      y1: i - r,
                      x2: t + r,
                      y2: i + r,
                    });
                  }
                  return o ? s.filter(o) : s;
                }
                return (
                  this._forEachCell(
                    e1,
                    t,
                    i,
                    r,
                    this._queryCell,
                    s,
                    {
                      hitTest: n,
                      seenUids: {
                        box: {},
                        circle: {},
                      },
                    },
                    o,
                  ),
                  n ? s.length > 0 : s
                );
              }
              _queryCircle(e1, t, i, r, n) {
                const o = e1 - i,
                  s = e1 + i,
                  a = t - i,
                  l = t + i;
                if (s < 0 || o > this.width || l < 0 || a > this.height)
                  return !r && [];
                const c = [];
                return (
                  this._forEachCell(
                    o,
                    a,
                    s,
                    l,
                    this._queryCellCircle,
                    c,
                    {
                      hitTest: r,
                      circle: {
                        x: e1,
                        y: t,
                        radius: i,
                      },
                      seenUids: {
                        box: {},
                        circle: {},
                      },
                    },
                    n,
                  ),
                  r ? c.length > 0 : c
                );
              }
              query(e1, t, i, r, n) {
                return this._query(e1, t, i, r, !1, n);
              }
              hitTest(e1, t, i, r, n) {
                return this._query(e1, t, i, r, !0, n);
              }
              hitTestCircle(e1, t, i, r) {
                return this._queryCircle(e1, t, i, !0, r);
              }
              _queryCell(e1, t, i, r, n, o, s, a) {
                const l = s.seenUids,
                  c = this.boxCells[n];
                if (null !== c) {
                  const n = this.bboxes;
                  for (const h of c)
                    if (!l.box[h]) {
                      l.box[h] = !0;
                      const c = 4 * h;
                      if (
                        e1 <= n[c + 2] &&
                        t <= n[c + 3] &&
                        i >= n[c + 0] &&
                        r >= n[c + 1] &&
                        (!a || a(this.boxKeys[h]))
                      ) {
                        if (s.hitTest) return o.push(!0), !0;
                        o.push({
                          key: this.boxKeys[h],
                          x1: n[c],
                          y1: n[c + 1],
                          x2: n[c + 2],
                          y2: n[c + 3],
                        });
                      }
                    }
                }
                const h = this.circleCells[n];
                if (null !== h) {
                  const n = this.circles;
                  for (const c of h)
                    if (!l.circle[c]) {
                      l.circle[c] = !0;
                      const h = 3 * c;
                      if (
                        this._circleAndRectCollide(
                          n[h],
                          n[h + 1],
                          n[h + 2],
                          e1,
                          t,
                          i,
                          r,
                        ) &&
                        (!a || a(this.circleKeys[c]))
                      ) {
                        if (s.hitTest) return o.push(!0), !0;
                        {
                          const e1 = n[h],
                            t = n[h + 1],
                            i = n[h + 2];
                          o.push({
                            key: this.circleKeys[c],
                            x1: e1 - i,
                            y1: t - i,
                            x2: e1 + i,
                            y2: t + i,
                          });
                        }
                      }
                    }
                }
              }
              _queryCellCircle(e1, t, i, r, n, o, s, a) {
                const l = s.circle,
                  c = s.seenUids,
                  h = this.boxCells[n];
                if (null !== h) {
                  const e1 = this.bboxes;
                  for (const t of h)
                    if (!c.box[t]) {
                      c.box[t] = !0;
                      const i = 4 * t;
                      if (
                        this._circleAndRectCollide(
                          l.x,
                          l.y,
                          l.radius,
                          e1[i + 0],
                          e1[i + 1],
                          e1[i + 2],
                          e1[i + 3],
                        ) &&
                        (!a || a(this.boxKeys[t]))
                      )
                        return o.push(!0), !0;
                    }
                }
                const u = this.circleCells[n];
                if (null !== u) {
                  const e1 = this.circles;
                  for (const t of u)
                    if (!c.circle[t]) {
                      c.circle[t] = !0;
                      const i = 3 * t;
                      if (
                        this._circlesCollide(
                          e1[i],
                          e1[i + 1],
                          e1[i + 2],
                          l.x,
                          l.y,
                          l.radius,
                        ) &&
                        (!a || a(this.circleKeys[t]))
                      )
                        return o.push(!0), !0;
                    }
                }
              }
              _forEachCell(e1, t, i, r, n, o, s, a) {
                const l = this._convertToXCellCoord(e1),
                  c = this._convertToYCellCoord(t),
                  h = this._convertToXCellCoord(i),
                  u = this._convertToYCellCoord(r);
                for (let d = l; d <= h; d++)
                  for (let l = c; l <= u; l++)
                    if (
                      n.call(
                        this,
                        e1,
                        t,
                        i,
                        r,
                        this.xCellCount * l + d,
                        o,
                        s,
                        a,
                      )
                    )
                      return;
              }
              _convertToXCellCoord(e1) {
                return Math.max(
                  0,
                  Math.min(this.xCellCount - 1, Math.floor(e1 * this.xScale)),
                );
              }
              _convertToYCellCoord(e1) {
                return Math.max(
                  0,
                  Math.min(this.yCellCount - 1, Math.floor(e1 * this.yScale)),
                );
              }
              _circlesCollide(e1, t, i, r, n, o) {
                const s = r - e1,
                  a = n - t,
                  l = i + o;
                return l * l > s * s + a * a;
              }
              _circleAndRectCollide(e1, t, i, r, n, o, s) {
                const a = (o - r) / 2,
                  l = Math.abs(e1 - (r + a));
                if (l > a + i) return !1;
                const c = (s - n) / 2,
                  h = Math.abs(t - (n + c));
                if (h > c + i) return !1;
                if (l <= a || h <= c) return !0;
                const u = l - a,
                  d = h - c;
                return u * u + d * d <= i * i;
              }
            }
            const NT = 100;
            class UT {
              constructor(
                e1,
                t,
                i = new FT(e1.width + 200, e1.height + 200, 25),
                r = new FT(e1.width + 200, e1.height + 200, 25),
              ) {
                (this.transform = e1),
                  (this.grid = i),
                  (this.ignoredGrid = r),
                  (this.pitchfactor =
                    Math.cos(e1._pitch) * e1.cameraToCenterDistance),
                  (this.screenRightBoundary = e1.width + NT),
                  (this.screenBottomBoundary = e1.height + NT),
                  (this.gridRightBoundary = e1.width + 200),
                  (this.gridBottomBoundary = e1.height + 200),
                  (this.fogState = t);
              }
              placeCollisionBox(e1, t, i, r, n, o, s, a) {
                let l = i.projectedAnchorX,
                  c = i.projectedAnchorY,
                  h = i.projectedAnchorZ;
                const u = i.elevation,
                  d = i.tileID,
                  p = e1.getProjection();
                if (u && d) {
                  const [e1, t, r] = p.upVector(
                      d.canonical,
                      i.tileAnchorX,
                      i.tileAnchorY,
                    ),
                    n = p.upVectorScale(
                      d.canonical,
                      this.transform.center.lat,
                      this.transform.worldSize,
                    ).metersToTile;
                  (l += e1 * u * n), (c += t * u * n), (h += r * u * n);
                }
                const f = this.projectAndGetPerspectiveRatio(
                    s,
                    l,
                    c,
                    h,
                    i.tileID,
                    "globe" === p.name || !!u || this.transform.pitch > 0,
                    p,
                  ),
                  m = o * f.perspectiveRatio,
                  _ = (i.x1 * t + r.x - i.padding) * m + f.point.x,
                  g = (i.y1 * t + r.y - i.padding) * m + f.point.y,
                  y = (i.x2 * t + r.x + i.padding) * m + f.point.x,
                  x = (i.y2 * t + r.y + i.padding) * m + f.point.y,
                  v = f.perspectiveRatio <= 0.55 || f.occluded;
                return !this.isInsideGrid(_, g, y, x) ||
                  (!n && this.grid.hitTest(_, g, y, x, a)) ||
                  v
                  ? {
                      box: [],
                      offscreen: !1,
                      occluded: f.occluded,
                    }
                  : {
                      box: [_, g, y, x],
                      offscreen: this.isOffscreen(_, g, y, x),
                      occluded: !1,
                    };
              }
              placeCollisionCircles(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
              ) {
                const m = [],
                  _ = this.transform.elevation,
                  g = e1.getProjection(),
                  x = _
                    ? _.getAtTileOffsetFunc(
                        f,
                        this.transform.center.lat,
                        this.transform.worldSize,
                        g,
                      )
                    : null,
                  v = new y(i.tileAnchorX, i.tileAnchorY);
                let {
                  x: b,
                  y: w,
                  z: T,
                } = g.projectTilePoint(v.x, v.y, f.canonical);
                if (x) {
                  const [e1, t, i] = x(v);
                  (b += e1), (w += t), (T += i);
                }
                const E = "globe" === g.name,
                  M = this.projectAndGetPerspectiveRatio(
                    s,
                    b,
                    w,
                    T,
                    f,
                    E || !!_ || this.transform.pitch > 0,
                    g,
                  ),
                  { perspectiveRatio: A } = M,
                  S = (h ? o / A : o * A) / r_,
                  I = tv(b, w, T, a),
                  C =
                    M.signedDistanceFromCamera > 0
                      ? ov(
                          S,
                          n,
                          i.lineOffsetX * S,
                          i.lineOffsetY * S,
                          !1,
                          I,
                          v,
                          i,
                          r,
                          a,
                          {},
                          _ && !h ? x : null,
                          h && !!_,
                          g,
                          f,
                          h,
                        )
                      : null;
                let z = !1,
                  D = !1,
                  P = !0;
                if (C && !M.occluded) {
                  const e1 = 0.5 * d * A + p,
                    i = new y(-100, -100),
                    r = new y(
                      this.screenRightBoundary,
                      this.screenBottomBoundary,
                    ),
                    n = new BT(),
                    { first: o, last: s } = C,
                    a = o.path.length;
                  let h = [];
                  for (let e1 = a - 1; e1 >= 1; e1--) h.push(o.path[e1]);
                  for (let e1 = 1; e1 < s.path.length; e1++) h.push(s.path[e1]);
                  const f = 2.5 * e1;
                  l &&
                    ((h = h.map(
                      ([e1, t, i], r) => (
                        x &&
                          !E &&
                          (i = x(
                            r < a - 1
                              ? o.tilePath[a - 1 - r]
                              : s.tilePath[r - a + 2],
                          )[2]),
                        tv(e1, t, i, l)
                      ),
                    )),
                    h.some((e1) => e1[3] <= 0) && (h = []));
                  let _ = [];
                  if (h.length > 0) {
                    let e1 = 1 / 0,
                      t = -1 / 0,
                      n = 1 / 0,
                      o = -1 / 0;
                    for (const i of h)
                      (e1 = Math.min(e1, i[0])),
                        (n = Math.min(n, i[1])),
                        (t = Math.max(t, i[0])),
                        (o = Math.max(o, i[1]));
                    t >= i.x &&
                      e1 <= r.x &&
                      o >= i.y &&
                      n <= r.y &&
                      ((_ = [h.map((e1) => new y(e1[0], e1[1]))]),
                      (e1 < i.x || t > r.x || n < i.y || o > r.y) &&
                        (_ = $_(_, i.x, i.y, r.x, r.y)));
                  }
                  for (const i of _) {
                    n.reset(i, 0.25 * e1);
                    let r = 0;
                    r =
                      n.length <= 0.5 * e1
                        ? 1
                        : Math.ceil(n.paddedLength / f) + 1;
                    for (let i = 0; i < r; i++) {
                      const o = i / Math.max(r - 1, 1),
                        s = n.lerp(o),
                        a = s.x + NT,
                        l = s.y + NT;
                      m.push(a, l, e1, 0);
                      const h = a - e1,
                        d = l - e1,
                        p = a + e1,
                        f = l + e1;
                      if (
                        ((P = P && this.isOffscreen(h, d, p, f)),
                        (D = D || this.isInsideGrid(h, d, p, f)),
                        !t &&
                          this.grid.hitTestCircle(a, l, e1, u) &&
                          ((z = !0), !c))
                      )
                        return {
                          circles: [],
                          offscreen: !1,
                          collisionDetected: z,
                          occluded: !1,
                        };
                    }
                  }
                }
                return {
                  circles: (!c && z) || !D ? [] : m,
                  offscreen: P,
                  collisionDetected: z,
                  occluded: M.occluded,
                };
              }
              queryRenderedSymbols(e1) {
                if (
                  0 === e1.length ||
                  (0 === this.grid.keysLength() &&
                    0 === this.ignoredGrid.keysLength())
                )
                  return {};
                const t = [];
                let i = 1 / 0,
                  r = 1 / 0,
                  n = -1 / 0,
                  o = -1 / 0;
                for (const s of e1) {
                  const e1 = new y(s.x + NT, s.y + NT);
                  (i = Math.min(i, e1.x)),
                    (r = Math.min(r, e1.y)),
                    (n = Math.max(n, e1.x)),
                    (o = Math.max(o, e1.y)),
                    t.push(e1);
                }
                const s = this.grid
                    .query(i, r, n, o)
                    .concat(this.ignoredGrid.query(i, r, n, o)),
                  a = {},
                  l = {};
                for (const e1 of s) {
                  const i = e1.key;
                  void 0 === a[i.bucketInstanceId] &&
                    (a[i.bucketInstanceId] = {}),
                    a[i.bucketInstanceId][i.featureIndex] ||
                      (pp(t, [
                        new y(e1.x1, e1.y1),
                        new y(e1.x2, e1.y1),
                        new y(e1.x2, e1.y2),
                        new y(e1.x1, e1.y2),
                      ]) &&
                        ((a[i.bucketInstanceId][i.featureIndex] = !0),
                        void 0 === l[i.bucketInstanceId] &&
                          (l[i.bucketInstanceId] = []),
                        l[i.bucketInstanceId].push(i.featureIndex)));
                }
                return l;
              }
              insertCollisionBox(e1, t, i, r, n) {
                (t ? this.ignoredGrid : this.grid).insert(
                  {
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: n,
                  },
                  e1[0],
                  e1[1],
                  e1[2],
                  e1[3],
                );
              }
              insertCollisionCircles(e1, t, i, r, n) {
                const o = t ? this.ignoredGrid : this.grid,
                  s = {
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: n,
                  };
                for (let t = 0; t < e1.length; t += 4)
                  o.insertCircle(s, e1[t], e1[t + 1], e1[t + 2]);
              }
              projectAndGetPerspectiveRatio(e1, t, i, r, n, o, s) {
                const a = [t, i, r, 1];
                let l = !1;
                if (r || this.transform.pitch > 0) {
                  if (
                    (uu.transformMat4(a, a, e1),
                    this.fogState && n && "globe" !== s.name)
                  ) {
                    const e1 = (function (e1, t, i, r, n, o) {
                      const s = o.calculateFogTileMatrix(n),
                        a = [t, i, r];
                      return (
                        Mu.transformMat4(a, a, s),
                        aw(e1, Mu.length(a), o.pitch, o._fov)
                      );
                    })(this.fogState, t, i, r, n.toUnwrapped(), this.transform);
                    l = e1 > 0.9;
                  }
                } else dv(a, a, e1);
                const c = a[3];
                return {
                  point: new y(
                    ((a[0] / c + 1) / 2) * this.transform.width + NT,
                    ((-a[1] / c + 1) / 2) * this.transform.height + NT,
                  ),
                  perspectiveRatio: Math.min(
                    0.5 +
                      (this.transform.getCameraToCenterDistance(s) / c) * 0.5,
                    1.5,
                  ),
                  signedDistanceFromCamera: c,
                  occluded: (o && a[2] > c) || l,
                };
              }
              isOffscreen(e1, t, i, r) {
                return (
                  i < NT ||
                  e1 >= this.screenRightBoundary ||
                  r < NT ||
                  t > this.screenBottomBoundary
                );
              }
              isInsideGrid(e1, t, i, r) {
                return (
                  i >= 0 &&
                  e1 < this.gridRightBoundary &&
                  r >= 0 &&
                  t < this.gridBottomBoundary
                );
              }
              getViewportMatrix() {
                const e1 = xu.identity([]);
                return xu.translate(e1, e1, [-100, -100, 0]), e1;
              }
            }
            function VT(e1, t, i) {
              const r = t.createTileMatrix(e1, e1.worldSize, i.toUnwrapped());
              return xu.multiply(new Float32Array(16), e1.projMatrix, r);
            }
            function jT(e1, t, i) {
              if (t.projection.name === i.projection.name) return e1.projMatrix;
              const r = i.clone();
              return (
                r.setProjection(t.projection), VT(r, t.getProjection(), e1)
              );
            }
            function GT(e1, t, i) {
              return t.name === i.projection.name
                ? e1.projMatrix
                : VT(i, t, e1);
            }
            class qT {
              constructor(e1, t, i, r) {
                (this.opacity = e1
                  ? Math.max(0, Math.min(1, e1.opacity + (e1.placed ? t : -t)))
                  : r && i
                  ? 1
                  : 0),
                  (this.placed = i);
              }
              isHidden() {
                return 0 === this.opacity && !this.placed;
              }
            }
            class ZT {
              constructor(e1, t, i, r, n, o = !1) {
                (this.text = new qT(e1 ? e1.text : null, t, i, n)),
                  (this.icon = new qT(e1 ? e1.icon : null, t, r, n)),
                  (this.clipped = o);
              }
              isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
              }
            }
            class $T {
              constructor(e1, t, i, r = !1) {
                (this.text = e1),
                  (this.icon = t),
                  (this.skipFade = i),
                  (this.clipped = r);
              }
            }
            class HT {
              constructor() {
                (this.invProjMatrix = xu.create()),
                  (this.viewportMatrix = xu.create()),
                  (this.circles = []);
              }
            }
            class WT {
              constructor(e1, t, i, r, n) {
                (this.bucketInstanceId = e1),
                  (this.featureIndex = t),
                  (this.sourceLayerIndex = i),
                  (this.bucketIndex = r),
                  (this.tileID = n);
              }
            }
            class XT {
              constructor(e1) {
                (this.crossSourceCollisions = e1),
                  (this.maxGroupID = 0),
                  (this.collisionGroups = {});
              }
              get(e1) {
                if (this.crossSourceCollisions)
                  return {
                    ID: 0,
                    predicate: null,
                  };
                if (!this.collisionGroups[e1]) {
                  const t = ++this.maxGroupID;
                  this.collisionGroups[e1] = {
                    ID: t,
                    predicate: (e1) => e1.collisionGroupID === t,
                  };
                }
                return this.collisionGroups[e1];
              }
            }
            function YT(e1, t, i, r, n) {
              const { horizontalAlign: o, verticalAlign: s } = L_(e1),
                a = -(o - 0.5) * t,
                l = -(s - 0.5) * i,
                c = ug(e1, r);
              return new y(a + c[0] * n, l + c[1] * n);
            }
            function KT(e1, t, i, r, n) {
              const o = new y(e1, t);
              return i && o._rotate(r ? n : -n), o;
            }
            class JT {
              constructor(e1, t, i, r, n, o) {
                (this.transform = e1.clone()),
                  (this.projection = e1.projection.name),
                  (this.collisionIndex = new UT(this.transform, n)),
                  (this.buildingIndex = o),
                  (this.placements = {}),
                  (this.opacities = {}),
                  (this.variableOffsets = {}),
                  (this.stale = !1),
                  (this.commitTime = 0),
                  (this.fadeDuration = t),
                  (this.retainedQueryData = {}),
                  (this.collisionGroups = new XT(i)),
                  (this.collisionCircleArrays = {}),
                  (this.prevPlacement = r),
                  r && (r.prevPlacement = void 0),
                  (this.placedOrientations = {});
              }
              getBucketParts(e1, t, i, r) {
                const n = i.getBucket(t),
                  o = i.latestFeatureIndex;
                if (!n || !o || t.fqid !== n.layerIds[0]) return;
                const s = n.layers[0].layout,
                  a = i.collisionBoxArray,
                  l = Math.pow(2, this.transform.zoom - i.tileID.overscaledZ),
                  c = i.tileSize / sr,
                  h = i.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const u =
                  ((d = i.tileID),
                  (p = n.getProjection()),
                  (f = this.transform),
                  p.name === this.projection
                    ? f.calculateProjMatrix(d.toUnwrapped())
                    : VT(f, p, d));
                var d, p, f;
                const m = "map" === s.get("text-pitch-alignment"),
                  _ = "map" === s.get("text-rotation-alignment");
                t.compileFilter();
                const g = t.dynamicFilter(),
                  y = t.dynamicFilterNeedsFeature(),
                  x = this.transform.calculatePixelsToTileUnitsMatrix(i),
                  v = Qx(
                    u,
                    i.tileID.canonical,
                    m,
                    _,
                    this.transform,
                    n.getProjection(),
                    x,
                  );
                let b = null;
                if (m) {
                  const e1 = ev(
                    u,
                    i.tileID.canonical,
                    m,
                    _,
                    this.transform,
                    n.getProjection(),
                    x,
                  );
                  b = xu.multiply([], this.transform.labelPlaneMatrix, e1);
                }
                let w = null;
                g &&
                  i.latestFeatureIndex &&
                  (w = {
                    unwrappedTileID: h,
                    dynamicFilter: g,
                    dynamicFilterNeedsFeature: y,
                    featureIndex: i.latestFeatureIndex,
                  }),
                  (this.retainedQueryData[n.bucketInstanceId] = new WT(
                    n.bucketInstanceId,
                    o,
                    n.sourceLayerIndex,
                    n.index,
                    i.tileID,
                  ));
                const T = {
                  bucket: n,
                  layout: s,
                  posMatrix: u,
                  textLabelPlaneMatrix: v,
                  labelToScreenMatrix: b,
                  clippingData: w,
                  scale: l,
                  textPixelRatio: c,
                  holdingForFade: i.holdingForFade(),
                  collisionBoxArray: a,
                  partiallyEvaluatedTextSize: a_(
                    n.textSizeData,
                    this.transform.zoom,
                  ),
                  partiallyEvaluatedIconSize: a_(
                    n.iconSizeData,
                    this.transform.zoom,
                  ),
                  collisionGroup: this.collisionGroups.get(n.sourceID),
                };
                if (r)
                  for (const t of n.sortKeyRanges) {
                    const {
                      sortKey: i,
                      symbolInstanceStart: r,
                      symbolInstanceEnd: n,
                    } = t;
                    e1.push({
                      sortKey: i,
                      symbolInstanceStart: r,
                      symbolInstanceEnd: n,
                      parameters: T,
                    });
                  }
                else
                  e1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n.symbolInstances.length,
                    parameters: T,
                  });
              }
              attemptAnchorPlacement(
                e1,
                t,
                i,
                r,
                n,
                o,
                s,
                a,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
              ) {
                const { textOffset0: y, textOffset1: x, crossTileID: v } = u,
                  b = [y, x],
                  w = YT(e1, i, r, b, n),
                  T = this.collisionIndex.placeCollisionBox(
                    p,
                    n,
                    t,
                    KT(w.x, w.y, o, s, this.transform.angle),
                    h,
                    a,
                    l,
                    c.predicate,
                  );
                if (m) {
                  const e1 = p.getSymbolInstanceIconSize(
                    g,
                    this.transform.zoom,
                    u.placedIconSymbolIndex,
                  );
                  if (
                    0 ===
                    this.collisionIndex.placeCollisionBox(
                      p,
                      e1,
                      m,
                      KT(w.x, w.y, o, s, this.transform.angle),
                      h,
                      a,
                      l,
                      c.predicate,
                    ).box.length
                  )
                    return;
                }
                if (T.box.length > 0) {
                  let t;
                  return (
                    this.prevPlacement &&
                      this.prevPlacement.variableOffsets[v] &&
                      this.prevPlacement.placements[v] &&
                      this.prevPlacement.placements[v].text &&
                      (t = this.prevPlacement.variableOffsets[v].anchor),
                    (this.variableOffsets[v] = {
                      textOffset: b,
                      width: i,
                      height: r,
                      anchor: e1,
                      textScale: n,
                      prevAnchor: t,
                    }),
                    this.markUsedJustification(p, e1, u, f),
                    p.allowVerticalPlacement &&
                      (this.markUsedOrientation(p, f, u),
                      (this.placedOrientations[v] = f)),
                    {
                      shift: w,
                      placedGlyphBoxes: T,
                    }
                  );
                }
              }
              placeLayerBucketPart(e1, t, i, r) {
                const {
                    bucket: n,
                    layout: o,
                    posMatrix: s,
                    textLabelPlaneMatrix: a,
                    labelToScreenMatrix: l,
                    clippingData: c,
                    textPixelRatio: h,
                    holdingForFade: u,
                    collisionBoxArray: d,
                    partiallyEvaluatedTextSize: p,
                    partiallyEvaluatedIconSize: f,
                    collisionGroup: m,
                  } = e1.parameters,
                  _ = o.get("text-optional"),
                  g = o.get("icon-optional"),
                  x = o.get("text-allow-overlap"),
                  v = o.get("icon-allow-overlap"),
                  b = "map" === o.get("text-rotation-alignment"),
                  w = "map" === o.get("text-pitch-alignment"),
                  T = "viewport-y" === o.get("symbol-z-order"),
                  E = o.get("symbol-z-elevate");
                this.transform.setProjection(n.projection);
                let M = x && (v || !n.hasIconData() || g),
                  A = v && (x || !n.hasTextData() || _);
                !n.collisionArrays && d && n.deserializeCollisionBoxes(d),
                  i &&
                    r &&
                    n.updateCollisionDebugBuffers(this.transform.zoom, d);
                const S = (e1, r, d) => {
                  const { crossTileID: T, numVerticalGlyphVertices: E } = e1;
                  if (c) {
                    const i = {
                      zoom: this.transform.zoom,
                      pitch: this.transform.pitch,
                    };
                    let r = null;
                    if (c.dynamicFilterNeedsFeature) {
                      const t = this.retainedQueryData[n.bucketInstanceId];
                      r = c.featureIndex.loadFeature({
                        featureIndex: e1.featureIndex,
                        bucketIndex: t.bucketIndex,
                        sourceLayerIndex: t.sourceLayerIndex,
                        layoutVertexArrayOffset: 0,
                      });
                    }
                    if (
                      !(0, c.dynamicFilter)(
                        i,
                        r,
                        this.retainedQueryData[n.bucketInstanceId].tileID
                          .canonical,
                        new y(e1.tileAnchorX, e1.tileAnchorY),
                        this.transform.calculateDistanceTileData(
                          c.unwrappedTileID,
                        ),
                      )
                    )
                      return (
                        (this.placements[T] = new $T(!1, !1, !1, !0)),
                        void t.add(T)
                      );
                  }
                  if (t.has(T)) return;
                  if (u) return void (this.placements[T] = new $T(!1, !1, !1));
                  let S = !1,
                    I = !1,
                    C = !0,
                    z = !1,
                    D = !1,
                    P = null,
                    R = {
                      box: null,
                      offscreen: null,
                      occluded: null,
                    },
                    L = {
                      box: null,
                      offscreen: null,
                      occluded: null,
                    },
                    k = null,
                    O = null,
                    B = null,
                    F = 0,
                    N = 0,
                    U = 0;
                  d.textFeatureIndex
                    ? (F = d.textFeatureIndex)
                    : e1.useRuntimeCollisionCircles && (F = e1.featureIndex),
                    d.verticalTextFeatureIndex &&
                      (N = d.verticalTextFeatureIndex);
                  const V = (t) => {
                      t.tileID =
                        this.retainedQueryData[n.bucketInstanceId].tileID;
                      const i = this.transform.elevation;
                      t.elevation =
                        e1.zOffset +
                        (i
                          ? i.getAtTileOffset(
                              t.tileID,
                              t.tileAnchorX,
                              t.tileAnchorY,
                            )
                          : 0);
                    },
                    j = d.textBox;
                  if (j) {
                    V(j);
                    const t = (t) => {
                        let i = w_.horizontal;
                        if (
                          n.allowVerticalPlacement &&
                          !t &&
                          this.prevPlacement
                        ) {
                          const t = this.prevPlacement.placedOrientations[T];
                          t &&
                            ((this.placedOrientations[T] = t),
                            (i = t),
                            this.markUsedOrientation(n, i, e1));
                        }
                        return i;
                      },
                      i = (e1, t) => {
                        if (
                          n.allowVerticalPlacement &&
                          E > 0 &&
                          d.verticalTextBox
                        ) {
                          for (const i of n.writingModes)
                            if (
                              (i === w_.vertical
                                ? ((R = t()), (L = R))
                                : (R = e1()),
                              R && R.box && R.box.length)
                            )
                              break;
                        } else R = e1();
                      };
                    if (o.get("text-variable-anchor")) {
                      let a = o.get("text-variable-anchor");
                      if (
                        this.prevPlacement &&
                        this.prevPlacement.variableOffsets[T]
                      ) {
                        const e1 = this.prevPlacement.variableOffsets[T];
                        a.indexOf(e1.anchor) > 0 &&
                          ((a = a.filter((t) => t !== e1.anchor)),
                          a.unshift(e1.anchor));
                      }
                      const l = (t, i, o) => {
                        const l = n.getSymbolInstanceTextSize(
                            p,
                            e1,
                            this.transform.zoom,
                            r,
                          ),
                          c = (t.x2 - t.x1) * l + 2 * t.padding,
                          u = (t.y2 - t.y1) * l + 2 * t.padding,
                          d = e1.hasIconTextFit && !v ? i : null;
                        d && V(d);
                        let _ = {
                          box: [],
                          offscreen: !1,
                          occluded: !1,
                        };
                        const g = x ? 2 * a.length : a.length;
                        for (let i = 0; i < g; ++i) {
                          const g = this.attemptAnchorPlacement(
                            a[i % a.length],
                            t,
                            c,
                            u,
                            l,
                            b,
                            w,
                            h,
                            s,
                            m,
                            i >= a.length,
                            e1,
                            r,
                            n,
                            o,
                            d,
                            p,
                            f,
                          );
                          if (
                            g &&
                            ((_ = g.placedGlyphBoxes),
                            _ && _.box && _.box.length)
                          ) {
                            (S = !0), (P = g.shift);
                            break;
                          }
                        }
                        return _;
                      };
                      i(
                        () => l(j, d.iconBox, w_.horizontal),
                        () => {
                          const e1 = d.verticalTextBox;
                          return (
                            e1 && V(e1),
                            n.allowVerticalPlacement &&
                            !(R && R.box && R.box.length) &&
                            E > 0 &&
                            e1
                              ? l(e1, d.verticalIconBox, w_.vertical)
                              : {
                                  box: null,
                                  offscreen: null,
                                  occluded: null,
                                }
                          );
                        },
                      ),
                        R && ((S = R.box), (C = R.offscreen), (z = R.occluded));
                      const c = t(!(!R || !R.box));
                      if (!S && this.prevPlacement) {
                        const t = this.prevPlacement.variableOffsets[T];
                        t &&
                          ((this.variableOffsets[T] = t),
                          this.markUsedJustification(n, t.anchor, e1, c));
                      }
                    } else {
                      const o = (t, i) => {
                        const o = n.getSymbolInstanceTextSize(
                            p,
                            e1,
                            this.transform.zoom,
                            r,
                          ),
                          a = this.collisionIndex.placeCollisionBox(
                            n,
                            o,
                            t,
                            new y(0, 0),
                            x,
                            h,
                            s,
                            m.predicate,
                          );
                        return (
                          a &&
                            a.box &&
                            a.box.length &&
                            (this.markUsedOrientation(n, i, e1),
                            (this.placedOrientations[T] = i)),
                          a
                        );
                      };
                      i(
                        () => o(j, w_.horizontal),
                        () => {
                          const e1 = d.verticalTextBox;
                          return n.allowVerticalPlacement && E > 0 && e1
                            ? (V(e1), o(e1, w_.vertical))
                            : {
                                box: null,
                                offscreen: null,
                                occluded: null,
                              };
                        },
                      ),
                        t(!!(R && R.box && R.box.length));
                    }
                  }
                  if (
                    ((k = R),
                    (S = k && k.box && k.box.length > 0),
                    (C = k && k.offscreen),
                    (z = k && k.occluded),
                    e1.useRuntimeCollisionCircles)
                  ) {
                    const t = n.text.placedSymbolArray.get(
                        e1.centerJustifiedTextSymbolIndex >= 0
                          ? e1.centerJustifiedTextSymbolIndex
                          : e1.verticalPlacedTextSymbolIndex,
                      ),
                      r = s_(n.textSizeData, p, t),
                      c = o.get("text-padding");
                    (O = this.collisionIndex.placeCollisionCircles(
                      n,
                      x,
                      t,
                      n.lineVertexArray,
                      n.glyphOffsetArray,
                      r,
                      s,
                      a,
                      l,
                      i,
                      w,
                      m.predicate,
                      (e1.collisionCircleDiameter * r) / r_,
                      c,
                      this.retainedQueryData[n.bucketInstanceId].tileID,
                    )),
                      (S = x || (O.circles.length > 0 && !O.collisionDetected)),
                      (C = C && O.offscreen),
                      (z = O.occluded);
                  }
                  if (
                    (d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox)
                  ) {
                    const t = (t) => {
                      V(t);
                      const i =
                          e1.hasIconTextFit && P
                            ? KT(P.x, P.y, b, w, this.transform.angle)
                            : new y(0, 0),
                        r = n.getSymbolInstanceIconSize(
                          f,
                          this.transform.zoom,
                          e1.placedIconSymbolIndex,
                        );
                      return this.collisionIndex.placeCollisionBox(
                        n,
                        r,
                        t,
                        i,
                        v,
                        h,
                        s,
                        m.predicate,
                      );
                    };
                    L && L.box && L.box.length && d.verticalIconBox
                      ? ((B = t(d.verticalIconBox)), (I = B.box.length > 0))
                      : ((B = t(d.iconBox)), (I = B.box.length > 0)),
                      (C = C && B.offscreen),
                      (D = B.occluded);
                  }
                  const G =
                      _ || (0 === e1.numHorizontalGlyphVertices && 0 === E),
                    q = g || 0 === e1.numIconVertices;
                  if (
                    (G || q
                      ? q
                        ? G || (I = I && S)
                        : (S = I && S)
                      : (I = S = I && S),
                    S &&
                      k &&
                      k.box &&
                      this.collisionIndex.insertCollisionBox(
                        k.box,
                        o.get("text-ignore-placement"),
                        n.bucketInstanceId,
                        L && L.box && N ? N : F,
                        m.ID,
                      ),
                    I &&
                      B &&
                      this.collisionIndex.insertCollisionBox(
                        B.box,
                        o.get("icon-ignore-placement"),
                        n.bucketInstanceId,
                        U,
                        m.ID,
                      ),
                    O &&
                      (S &&
                        this.collisionIndex.insertCollisionCircles(
                          O.circles,
                          o.get("text-ignore-placement"),
                          n.bucketInstanceId,
                          F,
                          m.ID,
                        ),
                      i))
                  ) {
                    const e1 = n.bucketInstanceId;
                    let t = this.collisionCircleArrays[e1];
                    void 0 === t &&
                      (t = this.collisionCircleArrays[e1] = new HT());
                    for (let e1 = 0; e1 < O.circles.length; e1 += 4)
                      t.circles.push(O.circles[e1 + 0]),
                        t.circles.push(O.circles[e1 + 1]),
                        t.circles.push(O.circles[e1 + 2]),
                        t.circles.push(O.collisionDetected ? 1 : 0);
                  }
                  const Z = "globe" !== n.projection.name;
                  (M = M && (Z || !z)),
                    (A = A && (Z || !D)),
                    (this.placements[T] = new $T(
                      S || M,
                      I || A,
                      C || n.justReloaded,
                    )),
                    t.add(T);
                };
                if (
                  (E &&
                    this.buildingIndex &&
                    (this.buildingIndex.updateZOffset(
                      n,
                      this.retainedQueryData[n.bucketInstanceId].tileID,
                    ),
                    n.updateZOffset()),
                  T)
                ) {
                  const e1 = n.getSortedSymbolIndexes(this.transform.angle);
                  for (let t = e1.length - 1; t >= 0; --t) {
                    const i = e1[t];
                    S(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                  }
                  n.hasAnyZOffset &&
                    W(
                      `${n.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`,
                    );
                } else if (n.hasAnyZOffset) {
                  const e1 = n.getSortedIndexesByZOffset();
                  for (let t = 0; t < e1.length; ++t) {
                    const i = e1[t];
                    S(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                  }
                } else
                  for (
                    let t = e1.symbolInstanceStart;
                    t < e1.symbolInstanceEnd;
                    t++
                  )
                    S(n.symbolInstances.get(t), t, n.collisionArrays[t]);
                if (i && n.bucketInstanceId in this.collisionCircleArrays) {
                  const e1 = this.collisionCircleArrays[n.bucketInstanceId];
                  xu.invert(e1.invProjMatrix, s),
                    (e1.viewportMatrix =
                      this.collisionIndex.getViewportMatrix());
                }
                n.justReloaded = !1;
              }
              markUsedJustification(e1, t, i, r) {
                const {
                    leftJustifiedTextSymbolIndex: n,
                    centerJustifiedTextSymbolIndex: o,
                    rightJustifiedTextSymbolIndex: s,
                    verticalPlacedTextSymbolIndex: a,
                    crossTileID: l,
                  } = i,
                  c = pg(t),
                  h =
                    r === w_.vertical
                      ? a
                      : "left" === c
                      ? n
                      : "center" === c
                      ? o
                      : "right" === c
                      ? s
                      : -1;
                n >= 0 &&
                  (e1.text.placedSymbolArray.get(n).crossTileID =
                    h >= 0 && n !== h ? 0 : l),
                  o >= 0 &&
                    (e1.text.placedSymbolArray.get(o).crossTileID =
                      h >= 0 && o !== h ? 0 : l),
                  s >= 0 &&
                    (e1.text.placedSymbolArray.get(s).crossTileID =
                      h >= 0 && s !== h ? 0 : l),
                  a >= 0 &&
                    (e1.text.placedSymbolArray.get(a).crossTileID =
                      h >= 0 && a !== h ? 0 : l);
              }
              markUsedOrientation(e1, t, i) {
                const r =
                    t === w_.horizontal || t === w_.horizontalOnly ? t : 0,
                  n = t === w_.vertical ? t : 0,
                  {
                    leftJustifiedTextSymbolIndex: o,
                    centerJustifiedTextSymbolIndex: s,
                    rightJustifiedTextSymbolIndex: a,
                    verticalPlacedTextSymbolIndex: l,
                  } = i,
                  c = e1.text.placedSymbolArray;
                o >= 0 && (c.get(o).placedOrientation = r),
                  s >= 0 && (c.get(s).placedOrientation = r),
                  a >= 0 && (c.get(a).placedOrientation = r),
                  l >= 0 && (c.get(l).placedOrientation = n);
              }
              commit(e1) {
                (this.commitTime = e1),
                  (this.zoomAtLastRecencyCheck = this.transform.zoom);
                const t = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t
                  ? t.zoomAdjustment(this.transform.zoom)
                  : 0;
                const r = t ? t.symbolFadeChange(e1) : 1,
                  n = t ? t.opacities : {},
                  o = t ? t.variableOffsets : {},
                  s = t ? t.placedOrientations : {};
                for (const e1 in this.placements) {
                  const t = this.placements[e1],
                    o = n[e1];
                  o
                    ? ((this.opacities[e1] = new ZT(
                        o,
                        r,
                        t.text,
                        t.icon,
                        null,
                        t.clipped,
                      )),
                      (i =
                        i ||
                        t.text !== o.text.placed ||
                        t.icon !== o.icon.placed))
                    : ((this.opacities[e1] = new ZT(
                        null,
                        r,
                        t.text,
                        t.icon,
                        t.skipFade,
                        t.clipped,
                      )),
                      (i = i || t.text || t.icon));
                }
                for (const e1 in n) {
                  const t = n[e1];
                  if (!this.opacities[e1]) {
                    const n = new ZT(t, r, !1, !1);
                    n.isHidden() ||
                      ((this.opacities[e1] = n),
                      (i = i || t.text.placed || t.icon.placed));
                  }
                }
                for (const e1 in o)
                  this.variableOffsets[e1] ||
                    !this.opacities[e1] ||
                    this.opacities[e1].isHidden() ||
                    (this.variableOffsets[e1] = o[e1]);
                for (const e1 in s)
                  this.placedOrientations[e1] ||
                    !this.opacities[e1] ||
                    this.opacities[e1].isHidden() ||
                    (this.placedOrientations[e1] = s[e1]);
                i
                  ? (this.lastPlacementChangeTime = e1)
                  : "number" != typeof this.lastPlacementChangeTime &&
                    (this.lastPlacementChangeTime = t
                      ? t.lastPlacementChangeTime
                      : e1);
              }
              updateLayerOpacities(e1, t) {
                const i = new Set();
                for (const r of t) {
                  const t = r.getBucket(e1);
                  t &&
                    r.latestFeatureIndex &&
                    e1.fqid === t.layerIds[0] &&
                    (this.updateBucketOpacities(t, i, r.collisionBoxArray),
                    t.layers[0].layout.get("symbol-z-elevate") &&
                      this.buildingIndex &&
                      (this.buildingIndex.updateZOffset(t, r.tileID),
                      t.updateZOffset()));
                }
              }
              updateBucketOpacities(e1, t, i) {
                e1.hasTextData() && e1.text.opacityVertexArray.clear(),
                  e1.hasIconData() && e1.icon.opacityVertexArray.clear(),
                  e1.hasIconCollisionBoxData() &&
                    e1.iconCollisionBox.collisionVertexArray.clear(),
                  e1.hasTextCollisionBoxData() &&
                    e1.textCollisionBox.collisionVertexArray.clear();
                const r = e1.layers[0].layout,
                  n = !!e1.layers[0].dynamicFilter(),
                  o = new ZT(null, 0, !1, !1, !0),
                  s = r.get("text-allow-overlap"),
                  a = r.get("icon-allow-overlap"),
                  l = r.get("text-variable-anchor"),
                  c = "map" === r.get("text-rotation-alignment"),
                  h = "map" === r.get("text-pitch-alignment"),
                  u = new ZT(
                    null,
                    0,
                    s && (a || !e1.hasIconData() || r.get("icon-optional")),
                    a && (s || !e1.hasTextData() || r.get("text-optional")),
                    !0,
                  );
                !e1.collisionArrays &&
                  i &&
                  (e1.hasIconCollisionBoxData() ||
                    e1.hasTextCollisionBoxData()) &&
                  e1.deserializeCollisionBoxes(i);
                const d = (e1, t, i) => {
                  for (let r = 0; r < t / 4; r++)
                    e1.opacityVertexArray.emplaceBack(i);
                };
                let p = 0;
                for (let i = 0; i < e1.symbolInstances.length; i++) {
                  const r = e1.symbolInstances.get(i),
                    {
                      numHorizontalGlyphVertices: s,
                      numVerticalGlyphVertices: a,
                      crossTileID: f,
                      numIconVertices: m,
                    } = r,
                    _ = t.has(f);
                  let g = this.opacities[f];
                  _ ? (g = o) : g || ((g = u), (this.opacities[f] = g)),
                    t.add(f);
                  const x = s > 0 || a > 0,
                    v = m > 0,
                    b = this.placedOrientations[f],
                    w = b === w_.vertical,
                    T = b === w_.horizontal || b === w_.horizontalOnly;
                  if (((!x && !v) || g.isHidden() || p++, x)) {
                    const t = aE(g.text);
                    d(e1.text, s, w ? lE : t), d(e1.text, a, T ? lE : t);
                    const i = g.text.isHidden(),
                      {
                        leftJustifiedTextSymbolIndex: n,
                        centerJustifiedTextSymbolIndex: o,
                        rightJustifiedTextSymbolIndex: l,
                        verticalPlacedTextSymbolIndex: c,
                      } = r,
                      h = e1.text.placedSymbolArray,
                      u = i || w ? 1 : 0;
                    n >= 0 && (h.get(n).hidden = u),
                      o >= 0 && (h.get(o).hidden = u),
                      l >= 0 && (h.get(l).hidden = u),
                      c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);
                    const p = this.variableOffsets[f];
                    p && this.markUsedJustification(e1, p.anchor, r, b);
                    const m = this.placedOrientations[f];
                    m &&
                      (this.markUsedJustification(e1, "left", r, m),
                      this.markUsedOrientation(e1, m, r));
                  }
                  if (v) {
                    const t = aE(g.icon),
                      {
                        placedIconSymbolIndex: i,
                        verticalPlacedIconSymbolIndex: n,
                      } = r,
                      o = e1.icon.placedSymbolArray,
                      s = g.icon.isHidden() ? 1 : 0;
                    i >= 0 &&
                      (d(e1.icon, m, w ? lE : t), (o.get(i).hidden = s)),
                      n >= 0 &&
                        (d(e1.icon, r.numVerticalIconVertices, T ? lE : t),
                        (o.get(n).hidden = s));
                  }
                  if (
                    e1.hasIconCollisionBoxData() ||
                    e1.hasTextCollisionBoxData()
                  ) {
                    const t = e1.collisionArrays[i];
                    if (t) {
                      let i = new y(0, 0),
                        o = !0;
                      if (t.textBox || t.verticalTextBox) {
                        if (l) {
                          const e1 = this.variableOffsets[f];
                          e1
                            ? ((i = YT(
                                e1.anchor,
                                e1.width,
                                e1.height,
                                e1.textOffset,
                                e1.textScale,
                              )),
                              c &&
                                i._rotate(
                                  h
                                    ? this.transform.angle
                                    : -this.transform.angle,
                                ))
                            : (o = !1);
                        }
                        n && (o = !g.clipped),
                          t.textBox &&
                            QT(
                              e1.textCollisionBox.collisionVertexArray,
                              g.text.placed,
                              !o || w,
                              i.x,
                              i.y,
                            ),
                          t.verticalTextBox &&
                            QT(
                              e1.textCollisionBox.collisionVertexArray,
                              g.text.placed,
                              !o || T,
                              i.x,
                              i.y,
                            );
                      }
                      const s = o && Boolean(!T && t.verticalIconBox);
                      t.iconBox &&
                        QT(
                          e1.iconCollisionBox.collisionVertexArray,
                          g.icon.placed,
                          s,
                          r.hasIconTextFit ? i.x : 0,
                          r.hasIconTextFit ? i.y : 0,
                        ),
                        t.verticalIconBox &&
                          QT(
                            e1.iconCollisionBox.collisionVertexArray,
                            g.icon.placed,
                            !s,
                            r.hasIconTextFit ? i.x : 0,
                            r.hasIconTextFit ? i.y : 0,
                          );
                    }
                  }
                }
                if (
                  ((e1.fullyClipped = 0 === p),
                  e1.sortFeatures(this.transform.angle),
                  this.retainedQueryData[e1.bucketInstanceId] &&
                    (this.retainedQueryData[
                      e1.bucketInstanceId
                    ].featureSortOrder = e1.featureSortOrder),
                  e1.hasTextData() &&
                    e1.text.opacityVertexBuffer &&
                    e1.text.opacityVertexBuffer.updateData(
                      e1.text.opacityVertexArray,
                    ),
                  e1.hasIconData() &&
                    e1.icon.opacityVertexBuffer &&
                    e1.icon.opacityVertexBuffer.updateData(
                      e1.icon.opacityVertexArray,
                    ),
                  e1.hasIconCollisionBoxData() &&
                    e1.iconCollisionBox.collisionVertexBuffer &&
                    e1.iconCollisionBox.collisionVertexBuffer.updateData(
                      e1.iconCollisionBox.collisionVertexArray,
                    ),
                  e1.hasTextCollisionBoxData() &&
                    e1.textCollisionBox.collisionVertexBuffer &&
                    e1.textCollisionBox.collisionVertexBuffer.updateData(
                      e1.textCollisionBox.collisionVertexArray,
                    ),
                  e1.bucketInstanceId in this.collisionCircleArrays)
                ) {
                  const t = this.collisionCircleArrays[e1.bucketInstanceId];
                  (e1.placementInvProjMatrix = t.invProjMatrix),
                    (e1.placementViewportMatrix = t.viewportMatrix),
                    (e1.collisionCircleArray = t.circles),
                    delete this.collisionCircleArrays[e1.bucketInstanceId];
                }
              }
              symbolFadeChange(e1) {
                return 0 === this.fadeDuration
                  ? 1
                  : (e1 - this.commitTime) / this.fadeDuration +
                      this.prevZoomAdjustment;
              }
              zoomAdjustment(e1) {
                return Math.max(0, (this.transform.zoom - e1) / 1.5);
              }
              hasTransitions(e1) {
                return (
                  this.stale ||
                  e1 - this.lastPlacementChangeTime < this.fadeDuration
                );
              }
              stillRecent(e1, t) {
                const i =
                  this.zoomAtLastRecencyCheck === t
                    ? 1 - this.zoomAdjustment(t)
                    : 1;
                return (
                  (this.zoomAtLastRecencyCheck = t),
                  this.commitTime + this.fadeDuration * i > e1
                );
              }
              setStale() {
                this.stale = !0;
              }
            }
            function QT(e1, t, i, r, n) {
              e1.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
                e1.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
                e1.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
                e1.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0);
            }
            const eE = Math.pow(2, 25),
              tE = Math.pow(2, 24),
              iE = Math.pow(2, 17),
              rE = Math.pow(2, 16),
              nE = Math.pow(2, 9),
              oE = Math.pow(2, 8),
              sE = Math.pow(2, 1);
            function aE(e1) {
              if (0 === e1.opacity && !e1.placed) return 0;
              if (1 === e1.opacity && e1.placed) return 4294967295;
              const t = e1.placed ? 1 : 0,
                i = Math.floor(127 * e1.opacity);
              return (
                i * eE + t * tE + i * iE + t * rE + i * nE + t * oE + i * sE + t
              );
            }
            const lE = 0;
            class cE {
              constructor(e1) {
                (this._sortAcrossTiles =
                  "viewport-y" !== e1.layout.get("symbol-z-order") &&
                  void 0 !== e1.layout.get("symbol-sort-key").constantOr(1)),
                  (this._currentTileIndex = 0),
                  (this._currentPartIndex = 0),
                  (this._seenCrossTileIDs = new Set()),
                  (this._bucketParts = []);
              }
              continuePlacement(e1, t, i, r, n) {
                const o = this._bucketParts;
                for (; this._currentTileIndex < e1.length; )
                  if (
                    (t.getBucketParts(
                      o,
                      r,
                      e1[this._currentTileIndex],
                      this._sortAcrossTiles,
                    ),
                    this._currentTileIndex++,
                    n())
                  )
                    return !0;
                for (
                  this._sortAcrossTiles &&
                  ((this._sortAcrossTiles = !1),
                  o.sort((e1, t) => e1.sortKey - t.sortKey));
                  this._currentPartIndex < o.length;

                ) {
                  const e1 = o[this._currentPartIndex];
                  if (
                    (t.placeLayerBucketPart(
                      e1,
                      this._seenCrossTileIDs,
                      i,
                      0 === e1.symbolInstanceStart,
                    ),
                    this._currentPartIndex++,
                    n())
                  )
                    return !0;
                }
                return !1;
              }
            }
            class hE {
              constructor(e1, t, i, r, n, o, s, a, l) {
                (this.placement = new JT(e1, n, o, s, a, l)),
                  (this._currentPlacementIndex = t.length - 1),
                  (this._forceFullPlacement = i),
                  (this._showCollisionBoxes = r),
                  (this._done = !1);
              }
              isDone() {
                return this._done;
              }
              continuePlacement(e1, t, i, r) {
                const n = ht.now(),
                  o = () => {
                    const e1 = ht.now() - n;
                    return !this._forceFullPlacement && e1 > 2;
                  };
                for (; this._currentPlacementIndex >= 0; ) {
                  const n = t[e1[this._currentPlacementIndex]],
                    s = this.placement.collisionIndex.transform.zoom;
                  if (
                    "symbol" === n.type &&
                    (!n.minzoom || n.minzoom <= s) &&
                    (!n.maxzoom || n.maxzoom > s)
                  ) {
                    const e1 = n,
                      t = e1.layout.get("symbol-z-elevate"),
                      s = (this._inProgressLayer =
                        this._inProgressLayer || new cE(e1)),
                      a = pa(n.source, n.scope);
                    if (
                      s.continuePlacement(
                        t ? r[a] : i[a],
                        this.placement,
                        this._showCollisionBoxes,
                        n,
                        o,
                      )
                    )
                      return;
                    delete this._inProgressLayer;
                  }
                  this._currentPlacementIndex--;
                }
                this._done = !0;
              }
              commit(e1) {
                return this.placement.commit(e1), this.placement;
              }
            }
            const uE = [
              Int8Array,
              Uint8Array,
              Uint8ClampedArray,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ];
            class dE {
              static from(e1) {
                if (!(e1 instanceof ArrayBuffer))
                  throw new Error("Data must be an instance of ArrayBuffer.");
                const [t, i] = new Uint8Array(e1, 0, 2);
                if (219 !== t)
                  throw new Error(
                    "Data does not appear to be in a KDBush format.",
                  );
                const r = i >> 4;
                if (1 !== r)
                  throw new Error(`Got v${r} data when expected v1.`);
                const n = uE[15 & i];
                if (!n) throw new Error("Unrecognized array type.");
                const [o] = new Uint16Array(e1, 2, 1),
                  [s] = new Uint32Array(e1, 4, 1);
                return new dE(s, o, n, e1);
              }
              constructor(e1, t = 64, i = Float64Array, r) {
                if (isNaN(e1) || e1 < 0)
                  throw new Error(`Unpexpected numItems value: ${e1}.`);
                (this.numItems = +e1),
                  (this.nodeSize = Math.min(Math.max(+t, 2), 65535)),
                  (this.ArrayType = i),
                  (this.IndexArrayType =
                    e1 < 65536 ? Uint16Array : Uint32Array);
                const n = uE.indexOf(this.ArrayType),
                  o = 2 * e1 * this.ArrayType.BYTES_PER_ELEMENT,
                  s = e1 * this.IndexArrayType.BYTES_PER_ELEMENT,
                  a = (8 - (s % 8)) % 8;
                if (n < 0)
                  throw new Error(`Unexpected typed array class: ${i}.`);
                r && r instanceof ArrayBuffer
                  ? ((this.data = r),
                    (this.ids = new this.IndexArrayType(this.data, 8, e1)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + s + a,
                      2 * e1,
                    )),
                    (this._pos = 2 * e1),
                    (this._finished = !0))
                  : ((this.data = new ArrayBuffer(8 + o + s + a)),
                    (this.ids = new this.IndexArrayType(this.data, 8, e1)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + s + a,
                      2 * e1,
                    )),
                    (this._pos = 0),
                    (this._finished = !1),
                    new Uint8Array(this.data, 0, 2).set([219, 16 + n]),
                    (new Uint16Array(this.data, 2, 1)[0] = t),
                    (new Uint32Array(this.data, 4, 1)[0] = e1));
              }
              add(e1, t) {
                const i = this._pos >> 1;
                return (
                  (this.ids[i] = i),
                  (this.coords[this._pos++] = e1),
                  (this.coords[this._pos++] = t),
                  i
                );
              }
              finish() {
                const e1 = this._pos >> 1;
                if (e1 !== this.numItems)
                  throw new Error(
                    `Added ${e1} items when expected ${this.numItems}.`,
                  );
                return (
                  pE(
                    this.ids,
                    this.coords,
                    this.nodeSize,
                    0,
                    this.numItems - 1,
                    0,
                  ),
                  (this._finished = !0),
                  this
                );
              }
              range(e1, t, i, r) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish().",
                  );
                const { ids: n, coords: o, nodeSize: s } = this,
                  a = [0, n.length - 1, 0],
                  l = [];
                for (; a.length; ) {
                  const c = a.pop() || 0,
                    h = a.pop() || 0,
                    u = a.pop() || 0;
                  if (h - u <= s) {
                    for (let s = u; s <= h; s++) {
                      const a = o[2 * s],
                        c = o[2 * s + 1];
                      a >= e1 && a <= i && c >= t && c <= r && l.push(n[s]);
                    }
                    continue;
                  }
                  const d = (u + h) >> 1,
                    p = o[2 * d],
                    f = o[2 * d + 1];
                  p >= e1 && p <= i && f >= t && f <= r && l.push(n[d]),
                    (0 === c ? e1 <= p : t <= f) &&
                      (a.push(u), a.push(d - 1), a.push(1 - c)),
                    (0 === c ? i >= p : r >= f) &&
                      (a.push(d + 1), a.push(h), a.push(1 - c));
                }
                return l;
              }
              within(e1, t, i) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish().",
                  );
                const { ids: r, coords: n, nodeSize: o } = this,
                  s = [0, r.length - 1, 0],
                  a = [],
                  l = i * i;
                for (; s.length; ) {
                  const c = s.pop() || 0,
                    h = s.pop() || 0,
                    u = s.pop() || 0;
                  if (h - u <= o) {
                    for (let i = u; i <= h; i++)
                      gE(n[2 * i], n[2 * i + 1], e1, t) <= l && a.push(r[i]);
                    continue;
                  }
                  const d = (u + h) >> 1,
                    p = n[2 * d],
                    f = n[2 * d + 1];
                  gE(p, f, e1, t) <= l && a.push(r[d]),
                    (0 === c ? e1 - i <= p : t - i <= f) &&
                      (s.push(u), s.push(d - 1), s.push(1 - c)),
                    (0 === c ? e1 + i >= p : t + i >= f) &&
                      (s.push(d + 1), s.push(h), s.push(1 - c));
                }
                return a;
              }
            }
            function pE(e1, t, i, r, n, o) {
              if (n - r <= i) return;
              const s = (r + n) >> 1;
              fE(e1, t, s, r, n, o),
                pE(e1, t, i, r, s - 1, 1 - o),
                pE(e1, t, i, s + 1, n, 1 - o);
            }
            function fE(e1, t, i, r, n, o) {
              for (; n > r; ) {
                if (n - r > 600) {
                  const s = n - r + 1,
                    a = i - r + 1,
                    l = Math.log(s),
                    c = 0.5 * Math.exp((2 * l) / 3),
                    h =
                      0.5 *
                      Math.sqrt((l * c * (s - c)) / s) *
                      (a - s / 2 < 0 ? -1 : 1);
                  fE(
                    e1,
                    t,
                    i,
                    Math.max(r, Math.floor(i - (a * c) / s + h)),
                    Math.min(n, Math.floor(i + ((s - a) * c) / s + h)),
                    o,
                  );
                }
                const s = t[2 * i + o];
                let a = r,
                  l = n;
                for (
                  mE(e1, t, r, i), t[2 * n + o] > s && mE(e1, t, r, n);
                  a < l;

                ) {
                  for (mE(e1, t, a, l), a++, l--; t[2 * a + o] < s; ) a++;
                  for (; t[2 * l + o] > s; ) l--;
                }
                t[2 * r + o] === s ? mE(e1, t, r, l) : (l++, mE(e1, t, l, n)),
                  l <= i && (r = l + 1),
                  i <= l && (n = l - 1);
              }
            }
            function mE(e1, t, i, r) {
              _E(e1, i, r), _E(t, 2 * i, 2 * r), _E(t, 2 * i + 1, 2 * r + 1);
            }
            function _E(e1, t, i) {
              const r = e1[t];
              (e1[t] = e1[i]), (e1[i] = r);
            }
            function gE(e1, t, i, r) {
              const n = e1 - i,
                o = t - r;
              return n * n + o * o;
            }
            const yE = 512 / sr / 2;
            class xE {
              constructor(e1, t, i) {
                (this.tileID = e1),
                  (this.bucketInstanceId = i),
                  (this.index = new dE(t.length, 16, Int32Array)),
                  (this.keys = []),
                  (this.crossTileIDs = []);
                const r = e1.canonical.x * sr,
                  n = e1.canonical.y * sr;
                for (let e1 = 0; e1 < t.length; e1++) {
                  const {
                      key: i,
                      crossTileID: o,
                      tileAnchorX: s,
                      tileAnchorY: a,
                    } = t.get(e1),
                    l = Math.floor((r + s) * yE),
                    c = Math.floor((n + a) * yE);
                  this.index.add(l, c),
                    this.keys.push(i),
                    this.crossTileIDs.push(o);
                }
                this.index.finish();
              }
              findMatches(e1, t, i) {
                const r =
                    this.tileID.canonical.z < t.canonical.z
                      ? 1
                      : Math.pow(2, this.tileID.canonical.z - t.canonical.z),
                  n = yE / Math.pow(2, t.canonical.z - this.tileID.canonical.z),
                  o = t.canonical.x * sr,
                  s = t.canonical.y * sr;
                for (let t = 0; t < e1.length; t++) {
                  const a = e1.get(t);
                  if (a.crossTileID) continue;
                  const { key: l, tileAnchorX: c, tileAnchorY: h } = a,
                    u = Math.floor((o + c) * n),
                    d = Math.floor((s + h) * n),
                    p = this.index.range(u - r, d - r, u + r, d + r);
                  for (const e1 of p) {
                    const t = this.crossTileIDs[e1];
                    if (this.keys[e1] === l && !i.has(t)) {
                      i.add(t), (a.crossTileID = t);
                      break;
                    }
                  }
                }
              }
            }
            class vE {
              constructor() {
                this.maxCrossTileID = 0;
              }
              generate() {
                return ++this.maxCrossTileID;
              }
            }
            class bE {
              constructor() {
                (this.indexes = {}),
                  (this.usedCrossTileIDs = {}),
                  (this.lng = 0);
              }
              handleWrapJump(e1) {
                const t = Math.round((e1 - this.lng) / 360);
                if (0 !== t)
                  for (const e1 in this.indexes) {
                    const i = this.indexes[e1],
                      r = {};
                    for (const e1 in i) {
                      const n = i[e1];
                      (n.tileID = n.tileID.unwrapTo(n.tileID.wrap + t)),
                        (r[n.tileID.key] = n);
                    }
                    this.indexes[e1] = r;
                  }
                this.lng = e1;
              }
              addBucket(e1, t, i) {
                if (
                  this.indexes[e1.overscaledZ] &&
                  this.indexes[e1.overscaledZ][e1.key]
                ) {
                  if (
                    this.indexes[e1.overscaledZ][e1.key].bucketInstanceId ===
                    t.bucketInstanceId
                  )
                    return !1;
                  this.removeBucketCrossTileIDs(
                    e1.overscaledZ,
                    this.indexes[e1.overscaledZ][e1.key],
                  );
                }
                for (let e1 = 0; e1 < t.symbolInstances.length; e1++)
                  t.symbolInstances.get(e1).crossTileID = 0;
                this.usedCrossTileIDs[e1.overscaledZ] ||
                  (this.usedCrossTileIDs[e1.overscaledZ] = new Set());
                const r = this.usedCrossTileIDs[e1.overscaledZ];
                for (const i in this.indexes) {
                  const n = this.indexes[i];
                  if (Number(i) > e1.overscaledZ)
                    for (const i in n) {
                      const o = n[i];
                      o.tileID.isChildOf(e1) &&
                        o.findMatches(t.symbolInstances, e1, r);
                    }
                  else {
                    const o = n[e1.scaledTo(Number(i)).key];
                    o && o.findMatches(t.symbolInstances, e1, r);
                  }
                }
                for (let e1 = 0; e1 < t.symbolInstances.length; e1++) {
                  const n = t.symbolInstances.get(e1);
                  n.crossTileID ||
                    ((n.crossTileID = i.generate()), r.add(n.crossTileID));
                }
                return (
                  void 0 === this.indexes[e1.overscaledZ] &&
                    (this.indexes[e1.overscaledZ] = {}),
                  (this.indexes[e1.overscaledZ][e1.key] = new xE(
                    e1,
                    t.symbolInstances,
                    t.bucketInstanceId,
                  )),
                  !0
                );
              }
              removeBucketCrossTileIDs(e1, t) {
                for (const i of t.crossTileIDs)
                  this.usedCrossTileIDs[e1].delete(i);
              }
              removeStaleBuckets(e1) {
                let t = !1;
                for (const i in this.indexes) {
                  const r = this.indexes[i];
                  for (const n in r)
                    e1[r[n].bucketInstanceId] ||
                      (this.removeBucketCrossTileIDs(i, r[n]),
                      delete r[n],
                      (t = !0));
                }
                return t;
              }
            }
            class wE {
              constructor() {
                (this.layerIndexes = {}),
                  (this.crossTileIDs = new vE()),
                  (this.maxBucketInstanceId = 0),
                  (this.bucketsInCurrentPlacement = {});
              }
              addLayer(e1, t, i, r) {
                let n = this.layerIndexes[e1.fqid];
                void 0 === n && (n = this.layerIndexes[e1.fqid] = new bE());
                let o = !1;
                const s = {};
                "globe" !== r.name && n.handleWrapJump(i);
                for (const i of t) {
                  const t = i.getBucket(e1);
                  t &&
                    e1.fqid === t.layerIds[0] &&
                    (t.bucketInstanceId ||
                      (t.bucketInstanceId = ++this.maxBucketInstanceId),
                    n.addBucket(i.tileID, t, this.crossTileIDs) && (o = !0),
                    (s[t.bucketInstanceId] = !0));
                }
                return n.removeStaleBuckets(s) && (o = !0), o;
              }
              pruneUnusedLayers(e1) {
                const t = {};
                e1.forEach((e1) => {
                  t[e1] = !0;
                });
                for (const e1 in this.layerIndexes)
                  t[e1] || delete this.layerIndexes[e1];
              }
            }
            var TE =
                "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nvec3 linearTosRGB(vec3 color)\n{return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn)\n{return pow(srgbIn,vec3(2.2));}vec3 linearProduct(vec3 srgbIn,vec3 k)\n{return srgbIn*pow(k,vec3(1./2.2));}\n#if __VERSION__ >=300\n#define _HANDLE_WIREFRAME_DEPTH gl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define _HANDLE_WIREFRAME_DEPTH\n#endif\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\ngl_FragColor=vec4(0.7,0.0,0.0,0.7); \\\n_HANDLE_WIREFRAME_DEPTH;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w-0.0001;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif",
              EE =
                "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
              ME =
                "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));float tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
              AE =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
              SE =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif",
              IE =
                "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS",
              CE =
                "#ifdef RENDER_SHADOWS\n#if defined(NATIVE) && __VERSION__ >=300\n#define TEXTURE_GATHER\n#endif\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture2D(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture2D(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture2D(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture2D(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef TEXTURE_GATHER\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
            const zE = [];
            OE(TE, zE);
            const DE = {
                "_prelude_fog.vertex.glsl": AE,
                "_prelude_terrain.vertex.glsl": ME,
                "_prelude_shadow.vertex.glsl": IE,
                "_prelude_fog.fragment.glsl": SE,
                "_prelude_shadow.fragment.glsl": CE,
                "_prelude_lighting.glsl":
                  "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE",
              },
              PE = {};
            BE("", ME), BE(SE, AE), BE(CE, IE);
            const RE = BE(
                "\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;varying float v_cutoff_opacity;\n#endif",
                "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;varying float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.",
              ),
              LE = TE;
            var kE = {
              background: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nattribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;varying vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              backgroundPattern: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              circle: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}',
              ),
              clippingMask: BE(
                "void main() {gl_FragColor=vec4(1.0);}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}",
              ),
              heatmap: BE(
                '#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}',
              ),
              heatmapTexture: BE(
                "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}",
                "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}",
              ),
              collisionBox: BE(
                "varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",
                '#include "_prelude_terrain.vertex.glsl"\nattribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}',
              ),
              collisionCircle: BE(
                "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}",
                "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}",
              ),
              debug: BE(
                "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}",
                '#include "_prelude_terrain.vertex.glsl"\nattribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}',
              ),
              fill: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nattribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              fillOutline: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nvarying vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nattribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              fillOutlinePattern: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              fillPattern: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              fillExtrusion: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvarying highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nvarying float v_flood_radius;varying float v_has_floodlight;\n#endif\nvarying float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef RENDER_CUTOFF\ncolor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#if __VERSION__ >=300\n#ifdef RENDER_CUTOFF\ninvariant gl_Position;\n#endif\n#endif\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nvarying float v_flood_radius;varying float v_has_floodlight;\n#endif\nvarying float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}',
              ),
              fillExtrusionDepth: BE(
                "varying highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\ngl_FragColor=pack_depth(v_depth);\n#endif\n}",
                '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nvarying highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}',
              ),
              fillExtrusionPattern: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying vec3 v_normal;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}',
              ),
              groundShadow: BE(
                '#include "_prelude_shadow.fragment.glsl"\n#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec3 u_ground_shadow_factor;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,v_depth));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\ngl_FragColor=vec4(shadow,1.0);}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;attribute vec2 a_pos;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);v_depth=gl_Position.w;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}',
              ),
              fillExtrusionGroundEffect: BE(
                "uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nvarying highp vec2 v_pos;varying highp vec4 v_line_segment;varying highp float v_flood_light_radius_tile;varying highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nvarying highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture2D(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\ngl_FragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\ngl_FragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\ngl_FragColor=color;HANDLE_WIREFRAME_DEBUG;\n#endif\n#endif\n}",
                '#include "_prelude_fog.vertex.glsl"\nattribute highp vec4 a_pos_end;attribute highp float a_angular_offset_factor;attribute highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nvarying highp vec2 v_pos;varying highp vec4 v_line_segment;varying highp float v_flood_light_radius_tile;varying highp vec2 v_ao;\n#ifdef FOG\nvarying highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;\n#ifdef FORCE_ABS_FL_GROUND_RADIUS\nfl_ground_radius=abs(flood_light_ground_radius);\n#endif\nfloat flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}',
              ),
              hillshadePrepare: BE(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture(u_image,coord).r/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}",
                "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}",
              ),
              hillshade: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting_with_emission_ground(gl_FragColor,u_emissive_strength);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}',
              ),
              line: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}',
              ),
              linePattern: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}',
              ),
              raster: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec2 u_colorization_scale;uniform highp vec4 u_colorization_mix;highp vec4 colormap (highp float value) {highp float scaled_value=value*u_colorization_scale.y+u_colorization_scale.x;highp vec2 coords=vec2(scaled_value,0.5);return texture2D(u_color_ramp,coords);}\n#endif\nvoid main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);vec4 color;\n#ifdef RASTER_COLOR\nhighp vec4 fadedColor=mix(color0,color1,u_fade_t);color=colormap(dot(vec4(fadedColor.rgb,1),u_colorization_mix));color.a*=fadedColor.a;if (color.a > 0.0) {color.rgb/=color.a;}\n#else\nif (color0.a > 0.0) {color0.rgb/=color0.a;}if (color1.a > 0.0) {color1.rgb/=color1.a;}color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_ground(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;attribute vec2 a_texture_pos;\n#endif\nvarying vec2 v_pos0;varying vec2 v_pos1;void main() {vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*u_globe_matrix*vec4(a_globe_pos,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\nuv=a_texture_pos/8192.0;\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}',
              ),
              symbolIcon: BE(
                '#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nvarying float v_fade_opacity;varying vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nvarying vec2 v_tex_b;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture2D(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture2D(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;\n#else\nout_color=texture2D(u_texture,v_tex_a)*alpha;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_terrain.vertex.glsl"\nattribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef Z_OFFSET\nattribute float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nattribute vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nvarying vec2 v_tex_b;\n#endif\nvarying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}',
              ),
              symbolSDF: BE(
                '#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;\n#if __VERSION__ >=300\nflat varying float v_draw_halo;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo;\n#if __VERSION__ >=300\ndraw_halo=v_draw_halo > 0.0;\n#else\ndraw_halo=u_is_halo;\n#endif\nif (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_terrain.vertex.glsl"\nattribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef Z_OFFSET\nattribute float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\n#if __VERSION__ >=300\nflat varying float v_draw_halo;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;\n#if __VERSION__ >=300\nv_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;\n#endif\nv_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}',
              ),
              symbolTextAndIcon: BE(
                '#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;\n#if __VERSION__ >=300\nflat varying float v_draw_halo;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo;\n#if __VERSION__ >=300\ndraw_halo=v_draw_halo > 0.0;\n#else\ndraw_halo=u_is_halo;\n#endif\nif (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_terrain.vertex.glsl"\nattribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef Z_OFFSET\nattribute float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\n#if __VERSION__ >=300\nflat varying float v_draw_halo;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;\n#if __VERSION__ >=300\nv_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}',
              ),
              terrainRaster: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture2D(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,v_depth,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}',
              ),
              terrainDepth: BE(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}",
                '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}',
              ),
              skybox: BE(
                '#include "_prelude_fog.fragment.glsl"\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
                EE,
              ),
              skyboxGradient: BE(
                '#include "_prelude_fog.fragment.glsl"\nvarying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
                EE,
              ),
              skyboxCapture: BE(
                "\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}",
                "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}",
              ),
              globeRaster: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture2D(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}',
              ),
              globeAtmosphere: BE(
                '#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\ngl_FragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\ngl_FragColor=vec4(1,1,1,1);\n#else\ngl_FragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);gl_FragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\ngl_FragColor=vec4(c*t,t);\n#endif\n}',
                "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}",
              ),
              model: BE(
                '#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;varying highp vec4 v_position_height;varying lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth_shadows;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nvarying lowp vec4 v_roughness_metallic_emissive_alpha;varying mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nvarying highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture2D(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\nconst float M_PI=3.141592653589793;\n#define saturate(_x) clamp(_x,0.,1.)\nfloat calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture2D(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\ntexColor.rgb=sRGBToLinear(texColor.rgb);if(u_baseTextureIsAlpha) {if (texColor.w < 0.5) {discard;}albedo*=mix(vec4(texColor.rgb,texColor.a),vec4(texColor.a),float(u_baseTextureIsAlpha));} else {albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture2D( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture2D(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(M_PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/M_PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/M_PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 diffuse=getDiffuseShadedColor(getBaseColor().rgb,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture2D(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(diffuse,1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nfloat ao=(texture2D(u_occlusionTexture,uv_2f).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture2D(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\ncolor=mix(color,mat.baseColor.rgb,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\ngl_FragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}',
                '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nattribute vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nattribute vec4 a_normal_matrix0;attribute vec4 a_normal_matrix1;attribute vec4 a_normal_matrix2;attribute vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth_shadows;\n#endif\nvarying vec4 v_position_height;varying lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nvarying highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nvarying lowp vec4 v_roughness_metallic_emissive_alpha;varying mediump vec4 v_height_based_emission_params;\n#endif\nvoid main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=local_pos;\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;\n#endif\n}',
              ),
              modelDepth: BE(
                "varying highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\ngl_FragColor=pack_depth(v_depth);\n#endif\n}",
                "attribute vec3 a_pos_3f;uniform mat4 u_matrix;varying highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nattribute vec4 a_normal_matrix0;attribute vec4 a_normal_matrix1;attribute vec4 a_normal_matrix2;attribute vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}",
              ),
              stars: BE(
                "varying highp vec2 v_uv;varying mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;gl_FragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}",
                "\nattribute vec3 a_pos_3f;attribute vec2 a_uv;attribute float a_size_scale;attribute float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;varying highp vec2 v_uv;varying mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}",
              ),
            };
            function OE(e1, t) {
              const i = e1.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
              for (let e1 of i)
                if (
                  ((e1 = e1.trim()),
                  "#" === e1[0] && e1.includes("if") && !e1.includes("endif"))
                ) {
                  e1 = e1
                    .replace("#", "")
                    .replace(/ifdef|ifndef|elif|if/g, "")
                    .replace(/!|defined|\(|\)|\|\||&&/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                  const i = e1.split(" ");
                  for (const e1 of i) t.includes(e1) || t.push(e1);
                }
            }
            function BE(e1, t) {
              const i = /#include\s+"([^"]+)"/g,
                r = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
              let n = t.match(
                /attribute(\S*) (highp |mediump |lowp )?([\w]+) ([\w]+)/g,
              );
              n && (n = n.filter((e1, t) => n.indexOf(e1) === t));
              const o = {},
                s = [],
                a = [];
              (e1 = e1.replace(i, (e1, t) => (a.push(t), ""))),
                (t = t.replace(i, (e1, t) => (s.push(t), "")));
              let l = [...zE];
              OE(e1, l), OE(t, l);
              for (const e1 of [...s, ...a])
                DE[e1] || console.error(`Undefined include: ${e1}`),
                  PE[e1] || ((PE[e1] = []), OE(DE[e1], PE[e1])),
                  (l = [...l, ...PE[e1]]);
              return {
                fragmentSource: (e1 = e1.replace(
                  r,
                  (e1, t, i, r, n) => (
                    (o[n] = !0),
                    "define" === t
                      ? `\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                      : "initialize" === t
                      ? `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                      : "define-attribute" === t
                      ? `\n#ifdef HAS_ATTRIBUTE_a_${n}\n    varying ${i} ${r} ${n};\n#endif\n`
                      : "initialize-attribute" === t
                      ? ""
                      : void 0
                  ),
                )),
                vertexSource: (t = t.replace(r, (e1, t, i, r, n) => {
                  const s = "float" === r ? "vec2" : r,
                    a = n.match(/color/) ? "color" : s;
                  return "define-attribute-vertex-shader-only" === t
                    ? `\n#ifdef HAS_ATTRIBUTE_a_${n}\nattribute ${i} ${r} a_${n};\n#endif\n`
                    : o[n]
                    ? "define" === t
                      ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                      : "initialize" === t
                      ? "vec4" === a
                        ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                        : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                      : "define-attribute" === t
                      ? `\n#ifdef HAS_ATTRIBUTE_a_${n}\n    attribute ${i} ${r} a_${n};\n    varying ${i} ${r} ${n};\n#endif\n`
                      : "initialize-attribute" === t
                      ? `\n#ifdef HAS_ATTRIBUTE_a_${n}\n    ${n} = a_${n};\n#endif\n`
                      : void 0
                    : "define" === t
                    ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                    : "define-instanced" === t
                    ? "mat4" === a
                      ? `\n#ifdef INSTANCED_ARRAYS\nattribute vec4 a_${n}0;\nattribute vec4 a_${n}1;\nattribute vec4 a_${n}2;\nattribute vec4 a_${n}3;\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                      : `\n#ifdef INSTANCED_ARRAYS\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                    : "initialize-attribute-custom" === t
                    ? `\n#ifdef HAS_ATTRIBUTE_a_${n}\n    ${i} ${r} ${n} = a_${n};\n#endif\n`
                    : "vec4" === a
                    ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                    : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`;
                })),
                staticAttributes: n,
                usedDefines: l,
                vertexIncludes: s,
                fragmentIncludes: a,
              };
            }
            class FE {
              constructor() {
                (this.boundProgram = null),
                  (this.boundLayoutVertexBuffer = null),
                  (this.boundPaintVertexBuffers = []),
                  (this.boundIndexBuffer = null),
                  (this.boundVertexOffset = null),
                  (this.boundDynamicVertexBuffers = []),
                  (this.vao = null);
              }
              bind(e1, t, i, r, n, o, s, a) {
                this.context = e1;
                let l = this.boundPaintVertexBuffers.length !== r.length;
                for (let e1 = 0; !l && e1 < r.length; e1++)
                  this.boundPaintVertexBuffers[e1] !== r[e1] && (l = !0);
                let c = this.boundDynamicVertexBuffers.length !== s.length;
                for (let e1 = 0; !c && e1 < s.length; e1++)
                  this.boundDynamicVertexBuffers[e1] !== s[e1] && (c = !0);
                if (
                  !this.vao ||
                  this.boundProgram !== t ||
                  this.boundLayoutVertexBuffer !== i ||
                  l ||
                  c ||
                  this.boundIndexBuffer !== n ||
                  this.boundVertexOffset !== o
                )
                  this.freshBind(t, i, r, n, o, s, a);
                else {
                  e1.bindVertexArrayOES.set(this.vao);
                  for (const i of s)
                    i &&
                      (i.bind(),
                      a &&
                        i.instanceCount &&
                        i.setVertexAttribDivisor(e1.gl, t, a));
                  n && n.dynamicDraw && n.bind();
                }
              }
              freshBind(e1, t, i, r, n, o, s) {
                const a = e1.numAttributes,
                  l = this.context,
                  c = l.gl;
                this.vao && this.destroy(),
                  (this.vao = l.gl.createVertexArray()),
                  l.bindVertexArrayOES.set(this.vao),
                  (this.boundProgram = e1),
                  (this.boundLayoutVertexBuffer = t),
                  (this.boundPaintVertexBuffers = i),
                  (this.boundIndexBuffer = r),
                  (this.boundVertexOffset = n),
                  (this.boundDynamicVertexBuffers = o),
                  t.enableAttributes(c, e1),
                  t.bind(),
                  t.setVertexAttribPointers(c, e1, n);
                for (const t of i)
                  t.enableAttributes(c, e1),
                    t.bind(),
                    t.setVertexAttribPointers(c, e1, n);
                for (const t of o)
                  t &&
                    (t.enableAttributes(c, e1),
                    t.bind(),
                    t.setVertexAttribPointers(c, e1, n),
                    s && t.instanceCount && t.setVertexAttribDivisor(c, e1, s));
                r && r.bind(), (l.currentNumAttributes = a);
              }
              destroy() {
                this.vao &&
                  (this.context.gl.deleteVertexArray(this.vao),
                  (this.vao = null));
              }
            }
            function NE(e1, t) {
              const i = Math.pow(2, t.canonical.z),
                r = t.canonical.y;
              return [
                new ep(0, r / i).toLngLat().lat,
                new ep(0, (r + 1) / i).toLngLat().lat,
              ];
            }
            function UE(e1, t, i, r, n, o, s) {
              const a = e1.context,
                l = a.gl,
                c = i.hillshadeFBO;
              if (!c) return;
              e1.prepareDrawTile();
              const h = e1.isTileAffectedByFog(t),
                u = e1.getOrCreateProgram("hillshade", {
                  overrideFog: h,
                });
              a.activeTexture.set(l.TEXTURE0),
                l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());
              const d = ((e1, t, i, r) => {
                const n = i.paint.get("hillshade-shadow-color"),
                  o = i.paint.get("hillshade-highlight-color"),
                  s = i.paint.get("hillshade-accent-color"),
                  a = i.paint.get("hillshade-emissive-strength");
                let l = w(i.paint.get("hillshade-illumination-direction"));
                if ("viewport" === i.paint.get("hillshade-illumination-anchor"))
                  l -= e1.transform.angle;
                else if (
                  e1.style &&
                  e1.style.enable3dLights() &&
                  e1.style.directionalLight
                ) {
                  const t =
                    e1.style.directionalLight.properties.get("direction");
                  l = w(J(t.x, t.y, t.z)[1]);
                }
                const c = !e1.options.moving;
                return {
                  u_matrix:
                    r ||
                    e1.transform.calculateProjMatrix(t.tileID.toUnwrapped(), c),
                  u_image: 0,
                  u_latrange: NE(0, t.tileID),
                  u_light: [i.paint.get("hillshade-exaggeration"), l],
                  u_shadow: n,
                  u_highlight: o,
                  u_emissive_strength: a,
                  u_accent: s,
                };
              })(e1, i, r, e1.terrain ? t.projMatrix : null);
              e1.uploadCommonUniforms(a, u, t.toUnwrapped());
              const {
                tileBoundsBuffer: p,
                tileBoundsIndexBuffer: f,
                tileBoundsSegments: m,
              } = e1.getTileBoundsBuffers(i);
              u.draw(e1, l.TRIANGLES, n, o, s, Ex.disabled, d, r.id, p, f, m);
            }
            function VE(e1, t, i) {
              if (!t.needsDEMTextureUpload) return;
              const r = e1.context,
                n = r.gl;
              r.pixelStoreUnpackPremultiplyAlpha.set(!1),
                (t.demTexture = t.demTexture || e1.getTileTexture(i.stride));
              const o = i.getPixels();
              t.demTexture
                ? t.demTexture.update(o, {
                    premultiply: !1,
                  })
                : (t.demTexture = new gy(
                    r,
                    o,
                    e1.terrainUseFloatDEM() ? n.R32F : n.RGBA,
                    {
                      premultiply: !1,
                    },
                  )),
                (t.needsDEMTextureUpload = !1);
            }
            function jE(e1, t, i) {
              const r = e1.context,
                n = r.gl;
              if (!t.dem) return;
              const o = t.dem;
              if (
                (r.activeTexture.set(n.TEXTURE1), VE(e1, t, o), !t.demTexture)
              )
                return;
              t.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE);
              const s = o.dim;
              r.activeTexture.set(n.TEXTURE0);
              let a = t.hillshadeFBO;
              if (!a) {
                const e1 = new gy(
                  r,
                  {
                    width: s,
                    height: s,
                    data: null,
                  },
                  n.RGBA,
                );
                e1.bind(n.LINEAR, n.CLAMP_TO_EDGE),
                  (a = t.hillshadeFBO =
                    r.createFramebuffer(s, s, !0, "renderbuffer")),
                  a.colorAttachment.set(e1.texture);
              }
              r.bindFramebuffer.set(a.framebuffer),
                r.viewport.set([0, 0, s, s]);
              const {
                  tileBoundsBuffer: l,
                  tileBoundsIndexBuffer: c,
                  tileBoundsSegments: h,
                } = e1.getMercatorTileBoundsBuffers(),
                u = [];
              e1.terrainUseFloatDEM() && u.push("TERRAIN_DEM_FLOAT_FORMAT"),
                e1
                  .getOrCreateProgram("hillshadePrepare", {
                    defines: u,
                  })
                  .draw(
                    e1,
                    n.TRIANGLES,
                    gx.disabled,
                    xx.disabled,
                    bx.unblended,
                    Ex.disabled,
                    ((e1, t) => {
                      const i = t.stride,
                        r = xu.create();
                      return (
                        xu.ortho(r, 0, sr, -sr, 0, 0, 1),
                        xu.translate(r, r, [0, -sr, 0]),
                        {
                          u_matrix: r,
                          u_image: 1,
                          u_dimension: [i, i],
                          u_zoom: e1.overscaledZ,
                          u_unpack: t.unpackVector,
                        }
                      );
                    })(t.tileID, o),
                    i.id,
                    l,
                    c,
                    h,
                  ),
                (t.needsHillshadePrepare = !1);
            }
            const GE = (e1) => ({
                u_matrix: new kl(e1),
                u_image0: new Il(e1),
                u_skirt_height: new Cl(e1),
                u_ground_shadow_factor: new Dl(e1),
              }),
              qE = (e1, t, i) => ({
                u_matrix: e1,
                u_image0: 0,
                u_skirt_height: t,
                u_ground_shadow_factor: i,
              }),
              ZE = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f) => ({
                u_proj_matrix: Float32Array.from(e1),
                u_globe_matrix: t,
                u_normalize_matrix: Float32Array.from(r),
                u_merc_matrix: i,
                u_zoom_transition: n,
                u_merc_center: o,
                u_image0: 0,
                u_frustum_tl: s,
                u_frustum_tr: a,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: u,
                u_viewport: d,
                u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),
                u_skirt_height: p,
              }),
              $E = (e1, t) => {
                if (
                  (t > 0 &&
                    e1.terrain &&
                    W("Cutoff is currently disabled on terrain"),
                  t <= 0 || e1.terrain)
                )
                  return {
                    shouldRenderCutoff: !1,
                    uniformValues: {
                      u_cutoff_params: [0, 0, 0, 0],
                    },
                  };
                const i = e1.transform,
                  r = Math.max(Math.abs(i._zoom - (e1.minCutoffZoom - 1)), 1),
                  n = i.isLODDisabled(!1)
                    ? D(60, 45, i.pitch)
                    : D(30, 15, i.pitch),
                  o = i._farZ - i._nearZ,
                  s = t * i.height,
                  a =
                    ((1 - (l = n)) * (0.75 * i.cameraToCenterDistance) +
                      l * (i._farZ + s)) *
                    r;
                var l;
                return {
                  shouldRenderCutoff: n < 1,
                  uniformValues: {
                    u_cutoff_params: [
                      i._nearZ,
                      i._farZ,
                      (a - i._nearZ) / o,
                      (a - s - i._nearZ) / o,
                    ],
                  },
                };
              };
            function HE(e1, t) {
              return (
                null != e1 &&
                null != t &&
                !(!e1.hasData() || !t.hasData()) &&
                null != e1.demTexture &&
                null != t.demTexture &&
                e1.tileID.key !== t.tileID.key
              );
            }
            const WE = new (class {
                constructor() {
                  this.operations = {};
                }
                newMorphing(e1, t, i, r, n) {
                  if (e1 in this.operations) {
                    const t = this.operations[e1];
                    t.to.tileID.key !== i.tileID.key && (t.queued = i);
                  } else
                    this.operations[e1] = {
                      startTime: r,
                      phase: 0,
                      duration: n,
                      from: t,
                      to: i,
                      queued: null,
                    };
                }
                getMorphValuesForProxy(e1) {
                  if (!(e1 in this.operations)) return null;
                  const t = this.operations[e1];
                  return {
                    from: t.from,
                    to: t.to,
                    phase: t.phase,
                  };
                }
                update(e1) {
                  for (const t in this.operations) {
                    const i = this.operations[t];
                    for (
                      i.phase = (e1 - i.startTime) / i.duration;
                      i.phase >= 1 || !this._validOp(i);

                    )
                      if (!this._nextOp(i, e1)) {
                        delete this.operations[t];
                        break;
                      }
                  }
                }
                _nextOp(e1, t) {
                  return (
                    !!e1.queued &&
                    ((e1.from = e1.to),
                    (e1.to = e1.queued),
                    (e1.queued = null),
                    (e1.phase = 0),
                    (e1.startTime = t),
                    !0)
                  );
                }
                _validOp(e1) {
                  return e1.from.hasData() && e1.to.hasData();
                }
              })(),
              XE = {
                0: null,
                1: "TERRAIN_VERTEX_MORPHING",
              };
            function YE(e1, t, i) {
              if (0 === t) return 0;
              const r = t < 1 && 514 === i ? 0.25 / t : 1;
              return 6 * Math.pow(1.5, 22 - e1) * Math.max(t, 1) * r;
            }
            function KE(e1, t) {
              const i = 1 << e1.z;
              return (
                (!t && (0 === e1.x || e1.x === i - 1)) ||
                0 === e1.y ||
                e1.y === i - 1
              );
            }
            const JE = (e1) => ({
              u_matrix: e1,
            });
            function QE(e1, t, i, r, n) {
              if (n > 0) {
                const o = ht.now(),
                  s = (o - e1.timeAdded) / n,
                  a = t ? (o - t.timeAdded) / n : -1,
                  l = i.getSource(),
                  c = r.coveringZoomLevel({
                    tileSize: l.tileSize,
                    roundZoom: l.roundZoom,
                  }),
                  h =
                    !t ||
                    Math.abs(t.tileID.overscaledZ - c) >
                      Math.abs(e1.tileID.overscaledZ - c),
                  u =
                    h && e1.refreshedUponExpiration
                      ? 1
                      : z(h ? s : 1 - a, 0, 1);
                return (
                  e1.refreshedUponExpiration &&
                    s >= 1 &&
                    (e1.refreshedUponExpiration = !1),
                  t
                    ? {
                        opacity: 1,
                        mix: 1 - u,
                      }
                    : {
                        opacity: u,
                        mix: 0,
                      }
                );
              }
              return {
                opacity: 1,
                mix: 0,
              };
            }
            class eM extends Ax {
              constructor(e1) {
                const t = {
                    type: "raster-dem",
                    maxzoom: e1.transform.maxZoom,
                  },
                  i = new _w(Uw(), null),
                  r = vT("mock-dem", t, i, e1.style);
                super("mock-dem", r, !1),
                  r.setEventedParent(this),
                  (this._sourceLoaded = !0);
              }
              _loadTile(e1, t) {
                (e1.state = "loaded"), t(null);
              }
            }
            class tM extends Ax {
              constructor(e1) {
                const t = vT(
                  "proxy",
                  {
                    type: "geojson",
                    maxzoom: e1.transform.maxZoom,
                  },
                  new _w(Uw(), null),
                  e1.style,
                );
                super("proxy", t, !1),
                  t.setEventedParent(this),
                  (this.map = this.getSource().map = e1),
                  (this.used = this._sourceLoaded = !0),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
              update(e1, t, i) {
                if (e1.freezeTileCoverage) return;
                this.transform = e1;
                const r = e1
                  .coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                  })
                  .reduce((t, i) => {
                    if (((t[i.key] = ""), !this._tiles[i.key])) {
                      const t = new Iy(
                        i,
                        this._source.tileSize * i.overscaleFactor(),
                        e1.tileZoom,
                      );
                      (t.state = "loaded"), (this._tiles[i.key] = t);
                    }
                    return t;
                  }, {});
                for (const e1 in this._tiles)
                  e1 in r ||
                    (this.freeFBO(e1),
                    this._tiles[e1].unloadVectorData(),
                    delete this._tiles[e1]);
              }
              freeFBO(e1) {
                const t = this.proxyCachedFBO[e1];
                if (void 0 !== t) {
                  const i = Object.values(t);
                  this.renderCachePool.push(...i),
                    delete this.proxyCachedFBO[e1];
                }
              }
              deallocRenderCache() {
                this.renderCache.forEach((e1) => e1.fb.destroy()),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
            }
            class iM extends Bu {
              constructor(e1, t, i) {
                super(
                  e1.overscaledZ,
                  e1.wrap,
                  e1.canonical.z,
                  e1.canonical.x,
                  e1.canonical.y,
                ),
                  (this.proxyTileKey = t),
                  (this.projMatrix = i);
              }
            }
            class rM extends Gm {
              constructor(e1, t) {
                super(),
                  (this.painter = e1),
                  (this.terrainTileForTile = {}),
                  (this.prevTerrainTileForTile = {});
                const [i, r, n] = (function (e1) {
                    const t = new Ta(),
                      i = new Va(),
                      r = 131;
                    t.reserve(17161), i.reserve(33800);
                    const n = sr / 128,
                      o = sr + n / 2,
                      s = o + n;
                    for (let e1 = -n; e1 < s; e1 += n)
                      for (let i = -n; i < s; i += n) {
                        const r =
                            i < 0 || i > o || e1 < 0 || e1 > o ? 24575 : 0,
                          n = z(Math.round(i), 0, sr),
                          s = z(Math.round(e1), 0, sr);
                        t.emplaceBack(n + r, s);
                      }
                    const a = (e1, t) => {
                      const n = t * r + e1;
                      i.emplaceBack(n + 1, n, n + r),
                        i.emplaceBack(n + r, n + r + 1, n + 1);
                    };
                    for (let e1 = 1; e1 < 129; e1++)
                      for (let t = 1; t < 129; t++) a(t, e1);
                    return (
                      [0, 129].forEach((e1) => {
                        for (let t = 0; t < 130; t++) a(t, e1), a(e1, t);
                      }),
                      [t, i, 32768]
                    );
                  })(),
                  o = e1.context;
                (this.gridBuffer = o.createVertexBuffer(i, Pu.members)),
                  (this.gridIndexBuffer = o.createIndexBuffer(r)),
                  (this.gridSegments = dl.simpleSegment(
                    0,
                    0,
                    i.length,
                    r.length,
                  )),
                  (this.gridNoSkirtSegments = dl.simpleSegment(
                    0,
                    0,
                    i.length,
                    n,
                  )),
                  (this.proxyCoords = []),
                  (this.proxiedCoords = {}),
                  (this._visibleDemTiles = []),
                  (this._drapedRenderBatches = []),
                  (this._sourceTilesOverlap = {}),
                  (this.proxySourceCache = new tM(t.map)),
                  (this.orthoMatrix = xu.create()),
                  xu.ortho(
                    this.orthoMatrix,
                    "globe" === this.painter.transform.projection.name
                      ? 0.015
                      : 0,
                    sr,
                    0,
                    sr,
                    0,
                    1,
                  );
                const s = o.gl;
                (this._overlapStencilMode = new xx(
                  {
                    func: s.GEQUAL,
                    mask: 255,
                  },
                  0,
                  255,
                  s.KEEP,
                  s.KEEP,
                  s.REPLACE,
                )),
                  (this._previousZoom = e1.transform.zoom),
                  (this.pool = []),
                  (this._findCoveringTileCache = {}),
                  (this._tilesDirty = {}),
                  (this.style = t),
                  (this._useVertexMorphing = !0),
                  (this._exaggeration = 1),
                  (this._mockSourceCache = new eM(t.map)),
                  (this._pendingGroundEffectLayers = []);
              }
              set style(e1) {
                e1.on("data", this._onStyleDataEvent.bind(this)),
                  (this._style = e1),
                  this._style.map.on("moveend", () => {
                    this._clearLineLayersFromRenderCache();
                  });
              }
              update(e1, t, i) {
                if (e1 && e1.terrain) {
                  this._style !== e1 &&
                    ((this.style = e1), (this._evaluationZoom = void 0));
                  const r = e1.terrain.properties,
                    n = 0 === e1.terrain.drapeRenderMode,
                    o = e1.terrain.isZoomDependent();
                  (this._previousUpdateTimestamp = this.enabled
                    ? this._updateTimestamp
                    : void 0),
                    (this._updateTimestamp = ht.now());
                  const s = e1.terrain && e1.terrain.scope,
                    a = r.get("source"),
                    l = n ? this._mockSourceCache : e1.getSourceCache(a, s);
                  if (!l) return void W(`Couldn't find terrain source "${a}".`);
                  if (
                    ((this.sourceCache = l),
                    (this._exaggeration = o
                      ? this.calculateExaggeration(t)
                      : r.get("exaggeration")),
                    !t.projection.requiresDraping &&
                      o &&
                      0 === this._exaggeration)
                  )
                    return void this._disable();
                  this.enabled = !0;
                  const c = () => {
                    this.sourceCache.used &&
                      W(
                        `Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`,
                      );
                    const e1 = this.getScaledDemTileSize();
                    this.sourceCache.update(t, e1, !0),
                      this.resetTileLookupCache(this.sourceCache.id);
                  };
                  this.sourceCache.usedForTerrain ||
                    (this.resetTileLookupCache(this.sourceCache.id),
                    (this.sourceCache.usedForTerrain = !0),
                    c(),
                    (this._initializing = !0)),
                    c(),
                    t.updateElevation(!0, i),
                    this.resetTileLookupCache(this.proxySourceCache.id),
                    this.proxySourceCache.update(t),
                    (this._emptyDEMTextureDirty = !0),
                    (this._previousZoom = t.zoom);
                } else this._disable();
              }
              calculateExaggeration(e1) {
                const t = this._previousCameraAltitude,
                  i =
                    (e1.getFreeCameraOptions().position.z / e1.pixelsPerMeter) *
                    e1.worldSize;
                this._previousCameraAltitude = i;
                const r = null != t ? i - t : Number.MAX_VALUE;
                if (Math.abs(r) < 2) return this._exaggeration;
                const n = e1.zoom,
                  o = this._style.terrain;
                if (!this._previousUpdateTimestamp) return o.getExaggeration(n);
                let s = n - this._previousZoom;
                const a = this._previousUpdateTimestamp;
                let l = n;
                null != this._evaluationZoom &&
                  ((l = this._evaluationZoom),
                  Math.abs(n - l) > 0.5 && (s = 0.5 * (n - l + s)),
                  s * r < 0 && (l += s)),
                  (this._evaluationZoom = l);
                const c = o.getExaggeration(l),
                  h = c === o.getExaggeration(Math.max(0, l - 0.1));
                if (h && Math.abs(c - this._exaggeration) < 0.01) return c;
                let u = Math.min(0.1, 0.00375 * (this._updateTimestamp - a));
                return (
                  (h || c < 0.1 || Math.abs(s) < 1e-4) &&
                    (u = Math.min(0.2, 4 * u)),
                  Wr(this._exaggeration, c, u)
                );
              }
              resetTileLookupCache(e1) {
                this._findCoveringTileCache[e1] = {};
              }
              getScaledDemTileSize() {
                return (
                  (this.sourceCache.getSource().tileSize / 128) *
                  this.proxySourceCache.getSource().tileSize
                );
              }
              _onStyleDataEvent(e1) {
                e1.coord && "source" === e1.dataType
                  ? this._clearRenderCacheForTile(e1.sourceCacheId, e1.coord)
                  : "style" === e1.dataType &&
                    ((this.invalidateRenderCache = !0),
                    (this._evaluationZoom = void 0),
                    (this._previousUpdateTimestamp = void 0),
                    (this._previousCameraAltitude = void 0));
              }
              _disable() {
                if (
                  this.enabled &&
                  ((this.enabled = !1),
                  (this._sharedDepthStencil = void 0),
                  (this._evaluationZoom = void 0),
                  (this._previousUpdateTimestamp = void 0),
                  this.proxySourceCache.deallocRenderCache(),
                  this._style)
                )
                  for (const e1 in this._style._mergedSourceCaches)
                    this._style._mergedSourceCaches[e1].usedForTerrain = !1;
              }
              destroy() {
                this._disable(),
                  this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                  this._emptyDepthBufferTexture &&
                    this._emptyDepthBufferTexture.destroy(),
                  this.pool.forEach((e1) => e1.fb.destroy()),
                  (this.pool = []),
                  this._depthFBO &&
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0)),
                  this.framebufferCopyTexture &&
                    this.framebufferCopyTexture.destroy();
              }
              _source() {
                return this.enabled ? this.sourceCache : null;
              }
              isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
              }
              exaggeration() {
                return this._exaggeration;
              }
              get visibleDemTiles() {
                return this._visibleDemTiles;
              }
              get drapeBufferSize() {
                const e1 = 2 * this.proxySourceCache.getSource().tileSize;
                return [e1, e1];
              }
              set useVertexMorphing(e1) {
                this._useVertexMorphing = e1;
              }
              updateTileBinding(e1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const t = this.proxySourceCache,
                  i = this.painter.transform;
                this._initializing &&
                  ((this._initializing =
                    0 === i._centerAltitude &&
                    -1 === this.getAtPointOrZero(ep.fromLngLat(i.center), -1)),
                  (this._emptyDEMTextureDirty = !this._initializing));
                const r = (this.proxyCoords = t.getIds().map((e1) => {
                  const r = t.getTileByID(e1).tileID;
                  return (
                    (r.projMatrix = i.calculateProjMatrix(r.toUnwrapped())), r
                  );
                }));
                !(function (e1, t) {
                  const i = t.transform.pointCoordinate(
                      t.transform.getCameraPoint(),
                    ),
                    r = new y(i.x, i.y);
                  e1.sort((e1, t) => {
                    if (t.overscaledZ - e1.overscaledZ)
                      return t.overscaledZ - e1.overscaledZ;
                    const i = new y(
                        e1.canonical.x + (1 << e1.canonical.z) * e1.wrap,
                        e1.canonical.y,
                      ),
                      n = new y(
                        t.canonical.x + (1 << t.canonical.z) * t.wrap,
                        t.canonical.y,
                      ),
                      o = r.mult(1 << e1.canonical.z);
                    return (
                      (o.x -= 0.5), (o.y -= 0.5), o.distSqr(i) - o.distSqr(n)
                    );
                  });
                })(r, this.painter);
                const n = this.proxyToSource || {};
                (this.proxyToSource = {}),
                  r.forEach((e1) => {
                    this.proxyToSource[e1.key] = {};
                  }),
                  (this.terrainTileForTile = {});
                const o = this._style._mergedSourceCaches;
                for (const t in o) {
                  const i = o[t];
                  if (!i.used) continue;
                  if (
                    (i !== this.sourceCache && this.resetTileLookupCache(i.id),
                    this._setupProxiedCoordsForOrtho(i, e1[t], n),
                    i.usedForTerrain)
                  )
                    continue;
                  const r = e1[t];
                  i.getSource().reparseOverscaled &&
                    this._assignTerrainTiles(r);
                }
                (this.proxiedCoords[t.id] = r.map(
                  (e1) => new iM(e1, e1.key, this.orthoMatrix),
                )),
                  this._assignTerrainTiles(r),
                  this._prepareDEMTextures(),
                  this._setupDrapedRenderBatches(),
                  this._initFBOPool(),
                  this._setupRenderCache(n),
                  (this.renderingToTexture = !1);
                const s = {};
                this._visibleDemTiles = [];
                for (const e1 of this.proxyCoords) {
                  const t = this.terrainTileForTile[e1.key];
                  if (!t) continue;
                  const i = t.tileID.key;
                  i in s || (this._visibleDemTiles.push(t), (s[i] = i));
                }
              }
              _assignTerrainTiles(e1) {
                this._initializing ||
                  e1.forEach((e1) => {
                    if (this.terrainTileForTile[e1.key]) return;
                    const t = this._findTileCoveringTileID(
                      e1,
                      this.sourceCache,
                    );
                    t && (this.terrainTileForTile[e1.key] = t);
                  });
              }
              _prepareDEMTextures() {
                const e1 = this.painter.context,
                  t = e1.gl;
                for (const i in this.terrainTileForTile) {
                  const r = this.terrainTileForTile[i],
                    n = r.dem;
                  !n ||
                    (r.demTexture && !r.needsDEMTextureUpload) ||
                    (e1.activeTexture.set(t.TEXTURE1), VE(this.painter, r, n));
                }
              }
              _prepareDemTileUniforms(e1, t, i, r) {
                if (!t || null == t.demTexture) return !1;
                const n = e1.tileID.canonical,
                  o = Math.pow(2, t.tileID.canonical.z - n.z),
                  s = r || "";
                return (
                  (i[`u_dem_tl${s}`] = [(n.x * o) % 1, (n.y * o) % 1]),
                  (i[`u_dem_scale${s}`] = o),
                  !0
                );
              }
              get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture
                  ? this._emptyDEMTexture
                  : this._updateEmptyDEMTexture();
              }
              get emptyDepthBufferTexture() {
                const e1 = this.painter.context,
                  t = e1.gl;
                if (!this._emptyDepthBufferTexture) {
                  const i = new $p(
                    {
                      width: 1,
                      height: 1,
                    },
                    Uint8Array.of(255, 255, 255, 255),
                  );
                  this._emptyDepthBufferTexture = new gy(e1, i, t.RGBA, {
                    premultiply: !1,
                  });
                }
                return this._emptyDepthBufferTexture;
              }
              _getLoadedAreaMinimum() {
                let e1 = 0;
                const t = this._visibleDemTiles.reduce((t, i) => {
                  if (!i.dem) return t;
                  const r = i.dem.tree.minimums[0];
                  return r > 0 && e1++, t + r;
                }, 0);
                return e1 ? t / e1 : 0;
              }
              _updateEmptyDEMTexture() {
                const e1 = this.painter.context,
                  t = e1.gl;
                e1.activeTexture.set(t.TEXTURE2);
                const i = this._getLoadedAreaMinimum(),
                  [r, n] = (() => {
                    if (this.painter.terrainUseFloatDEM()) {
                      const e1 = new Hp(
                        {
                          width: 1,
                          height: 1,
                        },
                        new Float32Array([i]),
                      );
                      return [t.R32F, e1];
                    }
                    {
                      const e1 = new $p(
                        {
                          width: 1,
                          height: 1,
                        },
                        new Uint8Array(
                          jm.pack(i, this.sourceCache.getSource().encoding),
                        ),
                      );
                      return [t.RGBA, e1];
                    }
                  })();
                this._emptyDEMTextureDirty = !1;
                let o = this._emptyDEMTexture;
                return (
                  o
                    ? o.update(n, {
                        premultiply: !1,
                      })
                    : (o = this._emptyDEMTexture =
                        new gy(e1, n, r, {
                          premultiply: !1,
                        })),
                  o
                );
              }
              setupElevationDraw(e1, t, i) {
                const r = this.painter.context,
                  n = r.gl,
                  o =
                    ((s = this.sourceCache.getSource().encoding),
                    {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_unpack: jm.getUnpackVector(s),
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_exaggeration: 0,
                    });
                var s;
                o.u_exaggeration = this.exaggeration();
                let a = null,
                  l = null,
                  c = 1;
                if (i && i.morphing && this._useVertexMorphing) {
                  const t = i.morphing.srcDemTile,
                    r = i.morphing.dstDemTile;
                  (c = i.morphing.phase),
                    t &&
                      r &&
                      (this._prepareDemTileUniforms(e1, t, o, "_prev") &&
                        (l = t),
                      this._prepareDemTileUniforms(e1, r, o) && (a = r));
                }
                const h = (e1) =>
                    e1 && e1.demTexture && this.painter.terrainUseFloatDEM()
                      ? n.LINEAR
                      : n.NEAREST,
                  u = (e1) => {
                    o.u_dem_size = 1 === e1.size[0] ? 1 : e1.size[0] - 2;
                  };
                if (l && a)
                  r.activeTexture.set(n.TEXTURE2),
                    a.demTexture.bind(h(a), n.CLAMP_TO_EDGE),
                    r.activeTexture.set(n.TEXTURE4),
                    l.demTexture.bind(h(l), n.CLAMP_TO_EDGE),
                    a.demTexture && u(a.demTexture),
                    (o.u_dem_lerp = c);
                else {
                  (a = this.terrainTileForTile[e1.tileID.key]),
                    r.activeTexture.set(n.TEXTURE2);
                  const t = this._prepareDemTileUniforms(e1, a, o)
                    ? a.demTexture
                    : this.emptyDEMTexture;
                  t.bind(h(a), n.CLAMP_TO_EDGE), u(t);
                }
                if (
                  (r.activeTexture.set(n.TEXTURE3),
                  i && i.useDepthForOcclusion
                    ? (this._depthTexture &&
                        this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE),
                      this._depthFBO &&
                        (o.u_depth_size_inv = [
                          1 / this._depthFBO.width,
                          1 / this._depthFBO.height,
                        ]))
                    : (this.emptyDepthBufferTexture.bind(
                        n.NEAREST,
                        n.CLAMP_TO_EDGE,
                      ),
                      (o.u_depth_size_inv = [1, 1])),
                  i && i.useMeterToDem && a)
                ) {
                  const e1 =
                    (1 << a.tileID.canonical.z) *
                    Zd(1, this.painter.transform.center.lat) *
                    this.sourceCache.getSource().tileSize;
                  o.u_meter_to_dem = e1;
                }
                if (
                  (i &&
                    i.labelPlaneMatrixInv &&
                    (o.u_label_plane_matrix_inv = i.labelPlaneMatrixInv),
                  t.setTerrainUniformValues(r, o),
                  "globe" === this.painter.transform.projection.name)
                ) {
                  const n = this.globeUniformValues(
                    this.painter.transform,
                    e1.tileID.canonical,
                    i && i.useDenormalizedUpVectorScale,
                  );
                  t.setGlobeUniformValues(r, n);
                }
              }
              globeUniformValues(e1, t, i) {
                const r = e1.projection;
                return {
                  u_tile_tl_up: r.upVector(t, 0, 0),
                  u_tile_tr_up: r.upVector(t, sr, 0),
                  u_tile_br_up: r.upVector(t, sr, sr),
                  u_tile_bl_up: r.upVector(t, 0, sr),
                  u_tile_up_scale: i
                    ? rd(1)
                    : r.upVectorScale(t, e1.center.lat, e1.worldSize)
                        .metersToTile,
                };
              }
              renderToBackBuffer(e1) {
                const t = this.painter,
                  i = this.painter.context;
                0 !== e1.length &&
                  (i.bindFramebuffer.set(null),
                  i.viewport.set([0, 0, t.width, t.height]),
                  t.gpuTimingDeferredRenderStart(),
                  (this.renderingToTexture = !1),
                  (function (e1, t, i, r, n) {
                    if ("globe" === e1.transform.projection.name)
                      !(function (e1, t, i, r, n) {
                        const o = e1.context,
                          s = o.gl;
                        let a, l;
                        const c = e1.transform,
                          h = Ad(e1, o, c),
                          u = (t, i) => {
                            if (l === i) return;
                            const r = [XE[i], "PROJECTION_GLOBE_VIEW"];
                            h && r.push("CUSTOM_ANTIALIASING");
                            const n = e1.isTileAffectedByFog(t);
                            (a = e1.getOrCreateProgram("globeRaster", {
                              defines: r,
                              overrideFog: n,
                            })),
                              (l = i);
                          },
                          d = e1.colorModeForRenderPass(),
                          p = new gx(
                            s.LEQUAL,
                            gx.ReadWrite,
                            e1.depthRangeFor3D,
                          );
                        WE.update(n);
                        const f = (function (e1) {
                            const t = e1.pixelsPerMeter,
                              i = t / Zd(1, e1.center.lat),
                              r = xu.identity(new Float64Array(16));
                            return (
                              xu.translate(r, r, [e1.point.x, e1.point.y, 0]),
                              xu.scale(r, r, [i, i, t]),
                              Float32Array.from(r)
                            );
                          })(c),
                          m = [Gd(c.center.lng), qd(c.center.lat)],
                          _ = e1.globeSharedBuffers,
                          g = [
                            c.width * ht.devicePixelRatio,
                            c.height * ht.devicePixelRatio,
                          ],
                          y = Float32Array.from(c.globeMatrix),
                          x = {
                            useDenormalizedUpVectorScale: !0,
                          };
                        {
                          const c = e1.transform,
                            h = YE(
                              c.zoom,
                              t.exaggeration(),
                              t.sourceCache._source.tileSize,
                            );
                          l = -1;
                          const v = s.TRIANGLES;
                          for (const l of r) {
                            const r = i.getTile(l),
                              b = xx.disabled,
                              w = t.prevTerrainTileForTile[l.key],
                              T = t.terrainTileForTile[l.key];
                            HE(w, T) && WE.newMorphing(l.key, w, T, n, 250),
                              o.activeTexture.set(s.TEXTURE0),
                              r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                            const E = WE.getMorphValuesForProxy(l.key),
                              A = E ? 1 : 0;
                            E &&
                              Pt(x, {
                                morphing: {
                                  srcDemTile: E.from,
                                  dstDemTile: E.to,
                                  phase: M(E.phase),
                                },
                              });
                            const S = dd(l.canonical),
                              I = Id(S.getCenter().lat),
                              C = Sd(
                                l.canonical,
                                S,
                                I,
                                c.worldSize / c._pixelsPerMercatorPixel,
                              ),
                              z = xd(ad(l.canonical)),
                              D = ZE(
                                c.projMatrix,
                                y,
                                f,
                                z,
                                Ed(c.zoom),
                                m,
                                c.frustumCorners.TL,
                                c.frustumCorners.TR,
                                c.frustumCorners.BR,
                                c.frustumCorners.BL,
                                c.globeCenterInViewSpace,
                                c.globeRadius,
                                g,
                                h,
                                C,
                              );
                            if (
                              (u(l, A),
                              a &&
                                (t.setupElevationDraw(r, a, x),
                                e1.uploadCommonUniforms(o, a, l.toUnwrapped()),
                                _))
                            ) {
                              const [t, i, r] = _.getGridBuffers(I, 0 !== h);
                              a.draw(
                                e1,
                                v,
                                p,
                                b,
                                d,
                                Ex.backCCW,
                                D,
                                "globe_raster",
                                t,
                                i,
                                r,
                              );
                            }
                          }
                        }
                        if (
                          _ &&
                          (e1.renderDefaultNorthPole ||
                            e1.renderDefaultSouthPole)
                        ) {
                          const n = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                          h && n.push("CUSTOM_ANTIALIASING"),
                            (a = e1.getOrCreateProgram("globeRaster", {
                              defines: n,
                            }));
                          for (const n of r) {
                            const { x: r, y: l, z: h } = n.canonical,
                              u = 0 === l,
                              f = l === (1 << h) - 1,
                              [y, v, b, w] = _.getPoleBuffers(h, !1);
                            if (w && (u || f)) {
                              const l = i.getTile(n);
                              o.activeTexture.set(s.TEXTURE0),
                                l.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                              let _ = Md(h, r, c);
                              const T = xd(ad(n.canonical)),
                                E = (t, i) =>
                                  t.draw(
                                    e1,
                                    s.TRIANGLES,
                                    p,
                                    xx.disabled,
                                    d,
                                    Ex.disabled,
                                    ZE(
                                      c.projMatrix,
                                      _,
                                      _,
                                      T,
                                      0,
                                      m,
                                      c.frustumCorners.TL,
                                      c.frustumCorners.TR,
                                      c.frustumCorners.BR,
                                      c.frustumCorners.BL,
                                      c.globeCenterInViewSpace,
                                      c.globeRadius,
                                      g,
                                      0,
                                    ),
                                    "globe_pole_raster",
                                    i,
                                    b,
                                    w,
                                  );
                              t.setupElevationDraw(l, a, x),
                                e1.uploadCommonUniforms(o, a, n.toUnwrapped()),
                                u && e1.renderDefaultNorthPole && E(a, y),
                                f &&
                                  e1.renderDefaultSouthPole &&
                                  ((_ = xu.scale(xu.create(), _, [1, -1, 1])),
                                  E(a, v));
                            }
                          }
                        }
                      })(e1, t, i, r, n);
                    else {
                      const o = e1.context,
                        s = o.gl;
                      let a, l;
                      const c = e1.shadowRenderer,
                        h = $E(e1, e1.longestCutoffRange),
                        u = (t) => {
                          if (l === t) return;
                          const i = [];
                          i.push(XE[t]),
                            h.shouldRenderCutoff && i.push("RENDER_CUTOFF"),
                            (a = e1.getOrCreateProgram("terrainRaster", {
                              defines: i,
                            })),
                            (l = t);
                        },
                        d = e1.colorModeForRenderPass(),
                        p = new gx(s.LEQUAL, gx.ReadWrite, e1.depthRangeFor3D);
                      WE.update(n);
                      const f = e1.transform,
                        m = YE(
                          f.zoom,
                          t.exaggeration(),
                          t.sourceCache._source.tileSize,
                        );
                      let _ = [0, 0, 0];
                      if (c) {
                        const t = e1.style.directionalLight,
                          i = e1.style.ambientLight;
                        t && i && (_ = BA(t, i));
                      }
                      {
                        l = -1;
                        const g = s.TRIANGLES,
                          [y, x] = [t.gridIndexBuffer, t.gridSegments];
                        for (const l of r) {
                          const r = i.getTile(l),
                            v = xx.disabled,
                            b = t.prevTerrainTileForTile[l.key],
                            w = t.terrainTileForTile[l.key];
                          HE(b, w) && WE.newMorphing(l.key, b, w, n, 250),
                            o.activeTexture.set(s.TEXTURE0),
                            r.texture.bind(
                              s.LINEAR,
                              s.CLAMP_TO_EDGE,
                              s.LINEAR_MIPMAP_NEAREST,
                            );
                          const T = WE.getMorphValuesForProxy(l.key),
                            E = T ? 1 : 0;
                          let A;
                          T &&
                            (A = {
                              morphing: {
                                srcDemTile: T.from,
                                dstDemTile: T.to,
                                phase: M(T.phase),
                              },
                            });
                          const S = qE(
                            l.projMatrix,
                            KE(l.canonical, f.renderWorldCopies) ? m / 10 : m,
                            _,
                          );
                          if ((u(E), !a)) continue;
                          t.setupElevationDraw(r, a, A);
                          const I = l.toUnwrapped();
                          c && c.setupShadows(I, a),
                            e1.uploadCommonUniforms(o, a, I, null, h),
                            a.draw(
                              e1,
                              g,
                              p,
                              v,
                              d,
                              Ex.backCCW,
                              S,
                              "terrain_raster",
                              t.gridBuffer,
                              y,
                              x,
                            );
                        }
                      }
                    }
                  })(t, this, this.proxySourceCache, e1, this._updateTimestamp),
                  (this.renderingToTexture = !0),
                  t.gpuTimingDeferredRenderEnd(),
                  e1.splice(0, e1.length));
              }
              renderBatch(e1) {
                if (0 === this._drapedRenderBatches.length) return e1 + 1;
                this.renderingToTexture = !0;
                const t = this.painter,
                  i = this.painter.context,
                  r = this.proxySourceCache,
                  n = this.proxiedCoords[r.id],
                  o = this._drapedRenderBatches.shift(),
                  s = t.style.order,
                  a = [];
                let l = 0;
                for (const c of n) {
                  const n = r.getTileByID(c.proxyTileKey),
                    h = r.proxyCachedFBO[c.key]
                      ? r.proxyCachedFBO[c.key][e1]
                      : void 0,
                    u = void 0 !== h ? r.renderCache[h] : this.pool[l++],
                    d = void 0 !== h;
                  if (((n.texture = u.tex), d && !u.dirty)) {
                    a.push(n.tileID);
                    continue;
                  }
                  let p;
                  i.bindFramebuffer.set(u.fb.framebuffer),
                    (this.renderedToTile = !1),
                    u.dirty &&
                      (i.clear({
                        color: li.transparent,
                        stencil: 0,
                      }),
                      (u.dirty = !1));
                  for (let e1 = o.start; e1 <= o.end; ++e1) {
                    const r = t.style._mergedLayers[s[e1]];
                    if (r.isHidden(t.transform.zoom)) continue;
                    const n = t.style.getLayerSourceCache(r),
                      o = n ? this.proxyToSource[c.key][n.id] : [c];
                    if (!o) continue;
                    const a = o;
                    i.viewport.set([0, 0, u.fb.width, u.fb.height]),
                      p !== (n ? n.id : null) &&
                        (this._setupStencil(u, o, r, n), (p = n ? n.id : null)),
                      t.renderLayer(t, n, r, a);
                  }
                  if (0 === this._drapedRenderBatches.length)
                    for (const e1 of this._pendingGroundEffectLayers) {
                      const r = t.style._mergedLayers[s[e1]];
                      if (r.isHidden(t.transform.zoom)) continue;
                      const n = t.style.getLayerSourceCache(r),
                        o = n ? this.proxyToSource[c.key][n.id] : [c];
                      if (!o) continue;
                      const a = o;
                      i.viewport.set([0, 0, u.fb.width, u.fb.height]),
                        p !== (n ? n.id : null) &&
                          (this._setupStencil(u, o, r, n),
                          (p = n ? n.id : null)),
                        t.renderLayer(t, n, r, a);
                    }
                  this.renderedToTile
                    ? ((u.dirty = !0), a.push(n.tileID))
                    : d || --l,
                    5 === l && ((l = 0), this.renderToBackBuffer(a));
                }
                return (
                  this.renderToBackBuffer(a),
                  (this.renderingToTexture = !1),
                  i.bindFramebuffer.set(null),
                  i.viewport.set([0, 0, t.width, t.height]),
                  o.end + 1
                );
              }
              postRender() {}
              isLayerOrderingCorrect(e1) {
                const t = e1.order.length;
                let i = -1,
                  r = t;
                for (let n = 0; n < t; ++n)
                  this._style.isLayerDraped(e1._mergedLayers[e1.order[n]])
                    ? (i = Math.max(i, n))
                    : (r = Math.min(r, n));
                return r > i;
              }
              getMinElevationBelowMSL() {
                let e1 = 0;
                return (
                  this._visibleDemTiles
                    .filter((e1) => e1.dem)
                    .forEach((t) => {
                      e1 = Math.min(e1, t.dem.tree.minimums[0]);
                    }),
                  0 === e1 ? e1 : (e1 - 30) * this._exaggeration
                );
              }
              raycast(e1, t, i) {
                if (!this._visibleDemTiles) return null;
                const r = this._visibleDemTiles
                  .filter((e1) => e1.dem)
                  .map((r) => {
                    const n = r.tileID,
                      o = 1 << n.overscaledZ,
                      { x: s, y: a } = n.canonical,
                      l = s / o,
                      c = (s + 1) / o,
                      h = a / o,
                      u = (a + 1) / o;
                    return {
                      minx: l,
                      miny: h,
                      maxx: c,
                      maxy: u,
                      t: r.dem.tree.raycastRoot(l, h, c, u, e1, t, i),
                      tile: r,
                    };
                  });
                r.sort(
                  (e1, t) =>
                    (null !== e1.t ? e1.t : Number.MAX_VALUE) -
                    (null !== t.t ? t.t : Number.MAX_VALUE),
                );
                for (const n of r) {
                  if (null == n.t) return null;
                  const r = n.tile.dem.tree.raycast(
                    n.minx,
                    n.miny,
                    n.maxx,
                    n.maxy,
                    e1,
                    t,
                    i,
                  );
                  if (null != r) return r;
                }
                return null;
              }
              _createFBO() {
                const e1 = this.painter.context,
                  t = e1.gl,
                  i = this.drapeBufferSize;
                e1.activeTexture.set(t.TEXTURE0);
                const r = new gy(
                  e1,
                  {
                    width: i[0],
                    height: i[1],
                    data: null,
                  },
                  t.RGBA,
                );
                r.bind(t.LINEAR, t.CLAMP_TO_EDGE);
                const n = e1.createFramebuffer(i[0], i[1], !0, null);
                return (
                  n.colorAttachment.set(r.texture),
                  (n.depthAttachment = new mx(e1, n.framebuffer)),
                  void 0 === this._sharedDepthStencil
                    ? ((this._sharedDepthStencil = e1.createRenderbuffer(
                        e1.gl.DEPTH_STENCIL,
                        i[0],
                        i[1],
                      )),
                      (this._stencilRef = 0),
                      n.depthAttachment.set(this._sharedDepthStencil),
                      e1.clear({
                        stencil: 0,
                      }))
                    : n.depthAttachment.set(this._sharedDepthStencil),
                  e1.extTextureFilterAnisotropic &&
                    !e1.extTextureFilterAnisotropicForceOff &&
                    t.texParameterf(
                      t.TEXTURE_2D,
                      e1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                      e1.extTextureFilterAnisotropicMax,
                    ),
                  {
                    fb: n,
                    tex: r,
                    dirty: !1,
                  }
                );
              }
              _initFBOPool() {
                for (
                  ;
                  this.pool.length < Math.min(5, this.proxyCoords.length);

                )
                  this.pool.push(this._createFBO());
              }
              _shouldDisableRenderCache() {
                if (this._style.hasLightTransitions()) return !0;
                for (const e1 in this._style._mergedSourceCaches)
                  if (this._style._mergedSourceCaches[e1].hasTransition())
                    return !0;
                return this._style.order.some((e1) => {
                  const t = this._style._mergedLayers[e1],
                    i = t.isHidden(this.painter.transform.zoom);
                  return "custom" === t.type
                    ? !i && t.shouldRedrape()
                    : !i && t.hasTransition();
                });
              }
              _clearLineLayersFromRenderCache() {
                let e1 = !1;
                for (const t of this._style.getSources())
                  if (t instanceof Rw) {
                    e1 = !0;
                    break;
                  }
                if (!e1) return;
                const t = {};
                for (let e1 = 0; e1 < this._style.order.length; ++e1) {
                  const i = this._style._mergedLayers[this._style.order[e1]],
                    r = this._style.getLayerSourceCache(i);
                  if (
                    r &&
                    !t[r.id] &&
                    !i.isHidden(this.painter.transform.zoom) &&
                    "line" === i.type &&
                    i.widthExpression() instanceof bo
                  ) {
                    t[r.id] = !0;
                    for (const e1 of this.proxyCoords) {
                      const t = this.proxyToSource[e1.key][r.id];
                      if (t)
                        for (const e1 of t)
                          this._clearRenderCacheForTile(r.id, e1);
                    }
                  }
                }
              }
              _clearRasterLayersFromRenderCache() {
                let e1 = !1;
                for (const t in this._style._mergedSourceCaches)
                  if (
                    this._style._mergedSourceCaches[t]._source instanceof Lw
                  ) {
                    e1 = !0;
                    break;
                  }
                if (!e1) return;
                const t = {};
                for (let e1 = 0; e1 < this._style.order.length; ++e1) {
                  const i = this._style._mergedLayers[this._style.order[e1]],
                    r = this._style.getLayerSourceCache(i);
                  if (!r || t[r.id]) continue;
                  if (
                    i.isHidden(this.painter.transform.zoom) ||
                    "raster" !== i.type
                  )
                    continue;
                  const n = i.paint.get("raster-fade-duration");
                  for (const e1 of this.proxyCoords) {
                    const t = this.proxyToSource[e1.key][r.id];
                    if (t)
                      for (const e1 of t) {
                        const t = QE(
                          r.getTile(e1),
                          r.findLoadedParent(e1, 0),
                          r,
                          this.painter.transform,
                          n,
                        );
                        (1 !== t.opacity || 0 !== t.mix) &&
                          this._clearRenderCacheForTile(r.id, e1);
                      }
                  }
                }
              }
              _setupDrapedRenderBatches() {
                const e1 = this._style.order,
                  t = e1.length;
                if (0 === t) return;
                const i = [];
                this._pendingGroundEffectLayers = [];
                let r,
                  n = 0,
                  o = this._style._mergedLayers[e1[n]];
                for (
                  ;
                  !this._style.isLayerDraped(o) &&
                  o.isHidden(this.painter.transform.zoom) &&
                  ++n < t;

                )
                  o = this._style._mergedLayers[e1[n]];
                for (; n < t; ++n) {
                  const t = this._style._mergedLayers[e1[n]];
                  t.isHidden(this.painter.transform.zoom) ||
                    (this._style.isLayerDraped(t)
                      ? void 0 === r && (r = n)
                      : ("fill-extrusion" === t.type &&
                          this._pendingGroundEffectLayers.push(n),
                        void 0 !== r &&
                          (i.push({
                            start: r,
                            end: n - 1,
                          }),
                          (r = void 0))));
                }
                if (
                  (void 0 !== r &&
                    i.push({
                      start: r,
                      end: n - 1,
                    }),
                  0 !== i.length)
                ) {
                  const e1 = i[i.length - 1],
                    t = this._pendingGroundEffectLayers.every(
                      (t) => t > e1.end,
                    );
                  t ||
                    W(
                      "fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.",
                    );
                }
                this._drapedRenderBatches = i;
              }
              _setupRenderCache(e1) {
                const t = this.proxySourceCache;
                if (
                  this._shouldDisableRenderCache() ||
                  this.invalidateRenderCache
                ) {
                  if (
                    ((this.invalidateRenderCache = !1),
                    t.renderCache.length > t.renderCachePool.length)
                  ) {
                    const e1 = Object.values(t.proxyCachedFBO);
                    t.proxyCachedFBO = {};
                    for (let i = 0; i < e1.length; ++i) {
                      const r = Object.values(e1[i]);
                      t.renderCachePool.push(...r);
                    }
                  }
                  return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords,
                  r = this._tilesDirty;
                for (let n = i.length - 1; n >= 0; n--) {
                  const o = i[n];
                  if (
                    (t.getTileByID(o.key), void 0 !== t.proxyCachedFBO[o.key])
                  ) {
                    const i = e1[o.key],
                      n = this.proxyToSource[o.key];
                    let s = 0;
                    for (const e1 in n) {
                      const t = n[e1],
                        o = i[e1];
                      if (
                        !o ||
                        o.length !== t.length ||
                        t.some(
                          (t, i) =>
                            t !== o[i] ||
                            (r[e1] && r[e1].hasOwnProperty(t.key)),
                        )
                      ) {
                        s = -1;
                        break;
                      }
                      ++s;
                    }
                    for (const e1 in t.proxyCachedFBO[o.key])
                      t.renderCache[t.proxyCachedFBO[o.key][e1]].dirty =
                        s < 0 || s !== Object.values(i).length;
                  }
                }
                const n = [...this._drapedRenderBatches];
                n.sort((e1, t) => t.end - t.start - (e1.end - e1.start));
                for (const e1 of n)
                  for (const r of i) {
                    if (t.proxyCachedFBO[r.key]) continue;
                    let i = t.renderCachePool.pop();
                    void 0 === i &&
                      t.renderCache.length < 50 &&
                      ((i = t.renderCache.length),
                      t.renderCache.push(this._createFBO())),
                      void 0 !== i &&
                        ((t.proxyCachedFBO[r.key] = {}),
                        (t.proxyCachedFBO[r.key][e1.start] = i),
                        (t.renderCache[i].dirty = !0));
                  }
                this._tilesDirty = {};
              }
              _setupStencil(e1, t, i, r) {
                if (!r || !this._sourceTilesOverlap[r.id])
                  return void (
                    this._overlapStencilType && (this._overlapStencilType = !1)
                  );
                const n = this.painter.context,
                  o = n.gl;
                if (t.length <= 1) return void (this._overlapStencilType = !1);
                let s;
                if (i.isTileClipped())
                  (s = t.length),
                    (this._overlapStencilMode.test = {
                      func: o.EQUAL,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Clip");
                else {
                  if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ))
                    return void (this._overlapStencilType = !1);
                  (s = 1),
                    (this._overlapStencilMode.test = {
                      func: o.GREATER,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Mask");
                }
                this._stencilRef + s > 255 &&
                  (n.clear({
                    stencil: 0,
                  }),
                  (this._stencilRef = 0)),
                  (this._stencilRef += s),
                  (this._overlapStencilMode.ref = this._stencilRef),
                  i.isTileClipped() &&
                    this._renderTileClippingMasks(
                      t,
                      this._overlapStencilMode.ref,
                    );
              }
              clipOrMaskOverlapStencilType() {
                return (
                  "Clip" === this._overlapStencilType ||
                  "Mask" === this._overlapStencilType
                );
              }
              stencilModeForRTTOverlap(e1) {
                return this.renderingToTexture && this._overlapStencilType
                  ? ("Clip" === this._overlapStencilType &&
                      (this._overlapStencilMode.ref =
                        this.painter._tileClippingMaskIDs[e1.key]),
                    this._overlapStencilMode)
                  : xx.disabled;
              }
              _renderTileClippingMasks(e1, t) {
                const i = this.painter,
                  r = this.painter.context,
                  n = r.gl;
                (i._tileClippingMaskIDs = {}),
                  r.setColorMode(bx.disabled),
                  r.setDepthMode(gx.disabled);
                const o = i.getOrCreateProgram("clippingMask");
                for (const r of e1) {
                  const e1 = (i._tileClippingMaskIDs[r.key] = --t);
                  o.draw(
                    i,
                    n.TRIANGLES,
                    gx.disabled,
                    new xx(
                      {
                        func: n.ALWAYS,
                        mask: 0,
                      },
                      e1,
                      255,
                      n.KEEP,
                      n.KEEP,
                      n.REPLACE,
                    ),
                    bx.disabled,
                    Ex.disabled,
                    JE(r.projMatrix),
                    "$clipping",
                    i.tileExtentBuffer,
                    i.quadTriangleIndexBuffer,
                    i.tileExtentSegments,
                  );
                }
              }
              pointCoordinate(e1) {
                const t = this.painter.transform;
                if (e1.x < 0 || e1.x > t.width || e1.y < 0 || e1.y > t.height)
                  return null;
                const i = [e1.x, e1.y, 1, 1];
                uu.transformMat4(i, i, t.pixelMatrixInverse),
                  uu.scale(i, i, 1 / i[3]),
                  (i[0] /= t.worldSize),
                  (i[1] /= t.worldSize);
                const r = t._camera.position,
                  n = Zd(1, t.center.lat),
                  o = [r[0], r[1], r[2] / n, 0],
                  s = Mu.subtract([], i.slice(0, 3), o);
                Mu.normalize(s, s);
                const a = this.raycast(o, s, this._exaggeration);
                return null !== a && a
                  ? (Mu.scaleAndAdd(o, o, s, a), (o[3] = o[2]), (o[2] *= n), o)
                  : null;
              }
              drawDepth() {
                const e1 = this.painter,
                  t = e1.context,
                  i = this.proxySourceCache,
                  r = Math.ceil(e1.width),
                  n = Math.ceil(e1.height);
                if (
                  (!this._depthFBO ||
                    (this._depthFBO.width === r &&
                      this._depthFBO.height === n) ||
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0)),
                  !this._depthFBO)
                ) {
                  const e1 = t.gl,
                    i = t.createFramebuffer(r, n, !0, "renderbuffer");
                  t.activeTexture.set(e1.TEXTURE0);
                  const o = new gy(
                    t,
                    {
                      width: r,
                      height: n,
                      data: null,
                    },
                    e1.RGBA,
                  );
                  o.bind(e1.NEAREST, e1.CLAMP_TO_EDGE),
                    i.colorAttachment.set(o.texture);
                  const s = t.createRenderbuffer(t.gl.DEPTH_COMPONENT16, r, n);
                  i.depthAttachment.set(s),
                    (this._depthFBO = i),
                    (this._depthTexture = o);
                }
                t.bindFramebuffer.set(this._depthFBO.framebuffer),
                  t.viewport.set([0, 0, r, n]),
                  (function (e1, t, i, r) {
                    if ("globe" === e1.transform.projection.name) return;
                    const n = e1.context,
                      o = n.gl;
                    n.clear({
                      depth: 1,
                    });
                    const s = e1.getOrCreateProgram("terrainDepth"),
                      a = new gx(o.LESS, gx.ReadWrite, e1.depthRangeFor3D);
                    for (const n of r) {
                      const r = i.getTile(n),
                        l = qE(n.projMatrix, 0, [0, 0, 0]);
                      t.setupElevationDraw(r, s),
                        s.draw(
                          e1,
                          o.TRIANGLES,
                          a,
                          xx.disabled,
                          bx.unblended,
                          Ex.backCCW,
                          l,
                          "terrain_depth",
                          t.gridBuffer,
                          t.gridIndexBuffer,
                          t.gridNoSkirtSegments,
                        );
                    }
                  })(e1, this, i, this.proxyCoords);
              }
              _setupProxiedCoordsForOrtho(e1, t, i) {
                if (e1.getSource() instanceof qb)
                  return this._setupProxiedCoordsForImageSource(e1, t, i);
                this._findCoveringTileCache[e1.id] =
                  this._findCoveringTileCache[e1.id] || {};
                const r = (this.proxiedCoords[e1.id] = []),
                  n = this.proxyCoords;
                for (let t = 0; t < n.length; t++) {
                  const o = n[t],
                    s = this._findTileCoveringTileID(o, e1);
                  if (s) {
                    const t = this._createProxiedId(
                      o,
                      s,
                      i[o.key] && i[o.key][e1.id],
                    );
                    r.push(t), (this.proxyToSource[o.key][e1.id] = [t]);
                  }
                }
                let o = !1;
                for (let n = 0; n < t.length; n++) {
                  const s = e1.getTile(t[n]);
                  if (!s || !s.hasData()) continue;
                  const a = this._findTileCoveringTileID(
                    s.tileID,
                    this.proxySourceCache,
                  );
                  if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                    const t = this.proxyToSource[a.tileID.key][e1.id],
                      n = this._createProxiedId(
                        a.tileID,
                        s,
                        i[a.tileID.key] && i[a.tileID.key][e1.id],
                      );
                    t
                      ? t.splice(t.length - 1, 0, n)
                      : (this.proxyToSource[a.tileID.key][e1.id] = [n]),
                      r.push(n),
                      (o = !0);
                  }
                }
                this._sourceTilesOverlap[e1.id] = o;
              }
              _setupProxiedCoordsForImageSource(e1, t, i) {
                if (!e1.getSource().loaded()) return;
                const r = (this.proxiedCoords[e1.id] = []),
                  n = this.proxyCoords,
                  o = e1.getSource(),
                  s = o.tileID;
                if (!s) return;
                const a = new y(s.x, s.y)._div(1 << s.z),
                  l = o.coordinates
                    .map(ep.fromLngLat)
                    .reduce(
                      (e1, t) => (
                        (e1.min.x = Math.min(e1.min.x, t.x - a.x)),
                        (e1.min.y = Math.min(e1.min.y, t.y - a.y)),
                        (e1.max.x = Math.max(e1.max.x, t.x - a.x)),
                        (e1.max.y = Math.max(e1.max.y, t.y - a.y)),
                        e1
                      ),
                      {
                        min: new y(Number.MAX_VALUE, Number.MAX_VALUE),
                        max: new y(-Number.MAX_VALUE, -Number.MAX_VALUE),
                      },
                    ),
                  c = (e1, t) => {
                    const i = e1.wrap + e1.canonical.x / (1 << e1.canonical.z),
                      r = e1.canonical.y / (1 << e1.canonical.z),
                      n = sr / (1 << e1.canonical.z),
                      o = t.wrap + t.canonical.x / (1 << t.canonical.z),
                      s = t.canonical.y / (1 << t.canonical.z);
                    return (
                      i + n < o + l.min.x ||
                      i > o + l.max.x ||
                      r + n < s + l.min.y ||
                      r > s + l.max.y
                    );
                  };
                for (let o = 0; o < n.length; o++) {
                  const s = n[o];
                  for (let n = 0; n < t.length; n++) {
                    const o = e1.getTile(t[n]);
                    if (!o || !o.hasData()) continue;
                    if (c(s, o.tileID)) continue;
                    const a = this._createProxiedId(
                        s,
                        o,
                        i[s.key] && i[s.key][e1.id],
                      ),
                      l = this.proxyToSource[s.key][e1.id];
                    l ? l.push(a) : (this.proxyToSource[s.key][e1.id] = [a]),
                      r.push(a);
                  }
                }
              }
              _createProxiedId(e1, t, i) {
                let r = this.orthoMatrix;
                if (i) {
                  const e1 = i.find((e1) => e1.key === t.tileID.key);
                  if (e1) return e1;
                }
                if (t.tileID.key !== e1.key) {
                  const i = e1.canonical.z - t.tileID.canonical.z;
                  let n, o, s;
                  r = xu.create();
                  const a = (t.tileID.wrap - e1.wrap) << e1.overscaledZ;
                  i > 0
                    ? ((n = sr >> i),
                      (o =
                        n * ((t.tileID.canonical.x << i) - e1.canonical.x + a)),
                      (s = n * ((t.tileID.canonical.y << i) - e1.canonical.y)))
                    : ((n = sr << -i),
                      (o =
                        sr *
                        (t.tileID.canonical.x - ((e1.canonical.x + a) << -i))),
                      (s =
                        sr * (t.tileID.canonical.y - (e1.canonical.y << -i)))),
                    xu.ortho(r, 0, n, 0, n, 0, 1),
                    xu.translate(r, r, [o, s, 0]);
                }
                return new iM(t.tileID, e1.key, r);
              }
              _findTileCoveringTileID(e1, t) {
                let i = t.getTile(e1);
                if (i && i.hasData()) return i;
                const r = this._findCoveringTileCache[t.id],
                  n = r[e1.key];
                if (
                  ((i = n ? t.getTileByID(n) : null),
                  (i && i.hasData()) || null === n)
                )
                  return i;
                let o = i ? i.tileID : e1,
                  s = o.overscaledZ;
                const a = t.getSource().minzoom,
                  l = [];
                if (!n) {
                  const r = t.getSource().maxzoom;
                  if (e1.canonical.z >= r) {
                    const i = e1.canonical.z - r;
                    t.getSource().reparseOverscaled
                      ? ((s = Math.max(
                          e1.canonical.z + 2,
                          t.transform.tileZoom,
                        )),
                        (o = new Bu(
                          s,
                          e1.wrap,
                          r,
                          e1.canonical.x >> i,
                          e1.canonical.y >> i,
                        )))
                      : 0 !== i &&
                        ((s = r),
                        (o = new Bu(
                          s,
                          e1.wrap,
                          r,
                          e1.canonical.x >> i,
                          e1.canonical.y >> i,
                        )));
                  }
                  o.key !== e1.key && (l.push(o.key), (i = t.getTile(o)));
                }
                const c = (e1) => {
                  l.forEach((t) => {
                    r[t] = e1;
                  }),
                    (l.length = 0);
                };
                for (s -= 1; s >= a && (!i || !i.hasData()); s--) {
                  i && c(i.tileID.key);
                  const e1 = o.calculateScaledKey(s);
                  if (((i = t.getTileByID(e1)), i && i.hasData())) break;
                  const n = r[e1];
                  if (null === n) break;
                  void 0 === n ? l.push(e1) : (i = t.getTileByID(n));
                }
                return c(i ? i.tileID.key : null), i && i.hasData() ? i : null;
              }
              findDEMTileFor(e1) {
                return this.enabled
                  ? this._findTileCoveringTileID(e1, this.sourceCache)
                  : null;
              }
              prepareDrawTile() {
                this.renderedToTile = !0;
              }
              _clearRenderCacheForTile(e1, t) {
                let i = this._tilesDirty[e1];
                i || (i = this._tilesDirty[e1] = {}), (i[t.key] = !0);
              }
            }
            function nM(e1, t, i) {
              const r = (function (e1, t, i) {
                  const r = Mu.dot(t, e1),
                    n = Mu.dot(i, [0.2126, 0.7152, 0.0722]),
                    o = (e1, t, i) => (1 - i) * e1 + i * t,
                    s = o(1 - 0.3 * Math.min(n, 1), 1, Math.min(r + 1, 1));
                  return (
                    o(0.92, 1, Math.asin(z(t[2], -1, 1)) / Math.PI + 0.5) * s
                  );
                })(e1, [0, 0, 1], t),
                n = [0, 0, 0];
              Mu.scale(n, i.slice(0, 3), r);
              const o = [0, 0, 0];
              Mu.scale(o, t.slice(0, 3), e1[2]);
              const s = [0, 0, 0];
              return Mu.add(s, n, o), ae(s);
            }
            const oM = [
                "fill",
                "fillOutline",
                "fillPattern",
                "line",
                "linePattern",
                "background",
                "backgroundPattern",
                "hillshade",
                "raster",
              ],
              sM = [
                "stars",
                "fillExtrusion",
                "fillExtrusionGroundEffect",
                "model",
                "symbolSDF",
                "symbolIcon",
                "symbolTextAndIcon",
              ];
            class aM {
              static cacheKey(e1, t, i, r) {
                let n = `${t}${r ? r.cacheKey : ""}`;
                for (const t of i) e1.usedDefines.includes(t) && (n += `/${t}`);
                return n;
              }
              constructor(e1, t, i, r, n, o) {
                const s = e1.gl;
                (this.program = s.createProgram()),
                  (this.configuration = r),
                  (this.name = t),
                  (this.fixedDefines = [...o]);
                const a = (function (e1) {
                    const t = [];
                    for (let i = 0; i < e1.length; i++) {
                      if (null === e1[i]) continue;
                      const r = e1[i].split(" ");
                      t.push(r.pop());
                    }
                    return t;
                  })(i.staticAttributes),
                  l = r ? r.getBinderAttributes() : [],
                  c = a.concat(l);
                let h = r ? r.defines() : [];
                h = h.concat(o.map((e1) => `#define ${e1}`));
                const u = "#version 300 es\n";
                let d =
                  u +
                  h
                    .concat(
                      "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif",
                      LE,
                      RE.fragmentSource,
                    )
                    .join("\n");
                for (const e1 of i.fragmentIncludes) d += `\n${DE[e1]}`;
                d += `\n${i.fragmentSource}`;
                let p =
                  u +
                  h
                    .concat(
                      "\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif",
                      LE,
                      RE.vertexSource,
                    )
                    .join("\n");
                for (const e1 of i.vertexIncludes) p += `\n${DE[e1]}`;
                p += `\n${i.vertexSource}`;
                const f = s.createShader(s.FRAGMENT_SHADER);
                if (s.isContextLost()) return void (this.failedToCreate = !0);
                s.shaderSource(f, d),
                  s.compileShader(f),
                  s.attachShader(this.program, f);
                const m = s.createShader(s.VERTEX_SHADER);
                if (s.isContextLost()) this.failedToCreate = !0;
                else {
                  s.shaderSource(m, p),
                    s.compileShader(m),
                    s.attachShader(this.program, m),
                    (this.attributes = {}),
                    (this.numAttributes = c.length);
                  for (let e1 = 0; e1 < this.numAttributes; e1++)
                    if (c[e1]) {
                      const t = c[e1].startsWith("a_") ? c[e1] : `a_${c[e1]}`;
                      s.bindAttribLocation(this.program, e1, t),
                        (this.attributes[t] = e1);
                    }
                  s.linkProgram(this.program),
                    s.deleteShader(m),
                    s.deleteShader(f),
                    (this.fixedUniforms = n(e1)),
                    (this.binderUniforms = r ? r.getUniforms(e1) : []),
                    o.includes("TERRAIN") &&
                      (this.terrainUniforms = ((e1) => ({
                        u_dem: new Il(e1),
                        u_dem_prev: new Il(e1),
                        u_dem_unpack: new Pl(e1),
                        u_dem_tl: new zl(e1),
                        u_dem_scale: new Cl(e1),
                        u_dem_tl_prev: new zl(e1),
                        u_dem_scale_prev: new Cl(e1),
                        u_dem_size: new Cl(e1),
                        u_dem_lerp: new Cl(e1),
                        u_exaggeration: new Cl(e1),
                        u_depth: new Il(e1),
                        u_depth_size_inv: new zl(e1),
                        u_meter_to_dem: new Cl(e1),
                        u_label_plane_matrix_inv: new kl(e1),
                      }))(e1)),
                    o.includes("GLOBE") &&
                      (this.globeUniforms = ((e1) => ({
                        u_tile_tl_up: new Dl(e1),
                        u_tile_tr_up: new Dl(e1),
                        u_tile_br_up: new Dl(e1),
                        u_tile_bl_up: new Dl(e1),
                        u_tile_up_scale: new Cl(e1),
                      }))(e1)),
                    o.includes("FOG") &&
                      (this.fogUniforms = ((e1) => ({
                        u_fog_matrix: new kl(e1),
                        u_fog_range: new zl(e1),
                        u_fog_color: new Pl(e1),
                        u_fog_horizon_blend: new Cl(e1),
                        u_fog_vertical_limit: new zl(e1),
                        u_fog_temporal_offset: new Cl(e1),
                        u_frustum_tl: new Dl(e1),
                        u_frustum_tr: new Dl(e1),
                        u_frustum_br: new Dl(e1),
                        u_frustum_bl: new Dl(e1),
                        u_globe_pos: new Dl(e1),
                        u_globe_radius: new Cl(e1),
                        u_globe_transition: new Cl(e1),
                        u_is_globe: new Il(e1),
                        u_viewport: new zl(e1),
                      }))(e1)),
                    o.includes("RENDER_CUTOFF") &&
                      (this.cutoffUniforms = ((e1) => ({
                        u_cutoff_params: new Pl(e1),
                      }))(e1)),
                    o.includes("LIGHTING_3D_MODE") &&
                      (this.lightsUniforms = ((e1) => ({
                        u_lighting_ambient_color: new Dl(e1),
                        u_lighting_directional_dir: new Dl(e1),
                        u_lighting_directional_color: new Dl(e1),
                        u_ground_radiance: new Dl(e1),
                      }))(e1)),
                    o.includes("RENDER_SHADOWS") &&
                      (this.shadowUniforms = ((e1) => ({
                        u_light_matrix_0: new kl(e1),
                        u_light_matrix_1: new kl(e1),
                        u_fade_range: new zl(e1),
                        u_shadow_normal_offset: new Dl(e1),
                        u_shadow_intensity: new Cl(e1),
                        u_shadow_texel_size: new Cl(e1),
                        u_shadow_map_resolution: new Cl(e1),
                        u_shadow_direction: new Dl(e1),
                        u_shadow_bias: new Dl(e1),
                        u_shadowmap_0: new Il(e1),
                        u_shadowmap_1: new Il(e1),
                      }))(e1));
                }
              }
              setTerrainUniformValues(e1, t) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                  e1.program.set(this.program);
                  for (const e1 in t)
                    i[e1] && i[e1].set(this.program, e1, t[e1]);
                }
              }
              setGlobeUniformValues(e1, t) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                  e1.program.set(this.program);
                  for (const e1 in t)
                    i[e1] && i[e1].set(this.program, e1, t[e1]);
                }
              }
              setFogUniformValues(e1, t) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                  e1.program.set(this.program);
                  for (const e1 in t) i[e1].set(this.program, e1, t[e1]);
                }
              }
              setCutoffUniformValues(e1, t) {
                if (!this.cutoffUniforms) return;
                const i = this.cutoffUniforms;
                if (!this.failedToCreate) {
                  e1.program.set(this.program);
                  for (const e1 in t) i[e1].set(this.program, e1, t[e1]);
                }
              }
              setLightsUniformValues(e1, t) {
                if (!this.lightsUniforms) return;
                const i = this.lightsUniforms;
                if (!this.failedToCreate) {
                  e1.program.set(this.program);
                  for (const e1 in t) i[e1].set(this.program, e1, t[e1]);
                }
              }
              setShadowUniformValues(e1, t) {
                if (this.failedToCreate || !this.shadowUniforms) return;
                const i = this.shadowUniforms;
                e1.program.set(this.program);
                for (const e1 in t) i[e1].set(this.program, e1, t[e1]);
              }
              _drawDebugWireframe(e1, t, i, r, n, o, s, a, l, c) {
                const h = e1.options.wireframe;
                if (!1 === h.terrain && !1 === h.layers2D && !1 === h.layers3D)
                  return;
                const u = e1.context;
                if (
                  !(() =>
                    !(
                      !h.terrain ||
                      ("terrainRaster" !== this.name &&
                        "globeRaster" !== this.name)
                    ) ||
                    !(
                      !h.layers2D ||
                      (e1._terrain && e1._terrain.renderingToTexture) ||
                      !oM.includes(this.name)
                    ) ||
                    !(!h.layers3D || !sM.includes(this.name)))()
                )
                  return;
                const d = u.gl,
                  p = e1.wireframeDebugCache.getLinesFromTrianglesBuffer(
                    e1.frameCounter,
                    n,
                    u,
                  );
                if (!p) return;
                const f = [...this.fixedDefines];
                f.push("DEBUG_WIREFRAME");
                const m = e1.getOrCreateProgram(this.name, {
                  config: this.configuration,
                  defines: f,
                });
                u.program.set(m.program);
                const _ = (e1, t, i) => {
                  if (t[e1] && i[e1])
                    for (const r in t[e1])
                      i[e1][r] && i[e1][r].set(i.program, r, t[e1][r].current);
                };
                l &&
                  l.setUniforms(m.program, u, m.binderUniforms, s, {
                    zoom: a,
                  }),
                  _("fixedUniforms", this, m),
                  _("terrainUniforms", this, m),
                  _("globeUniforms", this, m),
                  _("fogUniforms", this, m),
                  _("lightsUniforms", this, m),
                  _("shadowUniforms", this, m),
                  p.bind(),
                  u.setColorMode(
                    new bx(
                      [d.ONE, d.ONE_MINUS_SRC_ALPHA, d.ZERO, d.ONE],
                      li.transparent,
                      [!0, !0, !0, !1],
                    ),
                  ),
                  u.setDepthMode(
                    new gx(
                      t.func === d.LESS ? d.LEQUAL : t.func,
                      gx.ReadOnly,
                      t.range,
                    ),
                  ),
                  u.setStencilMode(xx.disabled);
                const g = 3 * o.primitiveLength * 2,
                  y = 3 * o.primitiveOffset * 4;
                c && c > 1
                  ? d.drawElementsInstanced(d.LINES, g, d.UNSIGNED_SHORT, y, c)
                  : d.drawElements(d.LINES, g, d.UNSIGNED_SHORT, y),
                  n.bind(),
                  u.program.set(this.program),
                  u.setDepthMode(t),
                  u.setStencilMode(i),
                  u.setColorMode(r);
              }
              draw(e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m) {
                const _ = e1.context,
                  g = _.gl;
                if (this.failedToCreate) return;
                _.program.set(this.program),
                  _.setDepthMode(i),
                  _.setStencilMode(r),
                  _.setColorMode(n),
                  _.setCullFace(o);
                for (const e1 of Object.keys(this.fixedUniforms))
                  this.fixedUniforms[e1].set(this.program, e1, s[e1]);
                p &&
                  p.setUniforms(this.program, _, this.binderUniforms, u, {
                    zoom: d,
                  });
                const y = {
                    [g.LINES]: 2,
                    [g.TRIANGLES]: 3,
                    [g.LINE_STRIP]: 1,
                  }[t],
                  x = m && m > 0 ? 1 : void 0;
                for (const o of h.get()) {
                  const s = o.vaos || (o.vaos = {});
                  (s[a] || (s[a] = new FE())).bind(
                    _,
                    this,
                    l,
                    p ? p.getPaintVertexBuffers() : [],
                    c,
                    o.vertexOffset,
                    f || [],
                    x,
                  ),
                    m && m > 1
                      ? g.drawElementsInstanced(
                          t,
                          o.primitiveLength * y,
                          g.UNSIGNED_SHORT,
                          o.primitiveOffset * y * 2,
                          m,
                        )
                      : g.drawElements(
                          t,
                          o.primitiveLength * y,
                          g.UNSIGNED_SHORT,
                          o.primitiveOffset * y * 2,
                        ),
                    t === g.TRIANGLES &&
                      this._drawDebugWireframe(e1, i, r, n, c, o, u, d, p, m);
                }
              }
            }
            function lM(e1, t) {
              const i = Math.pow(2, t.tileID.overscaledZ),
                r = (t.tileSize * Math.pow(2, e1.transform.tileZoom)) / i,
                n = r * (t.tileID.canonical.x + t.tileID.wrap * i),
                o = r * t.tileID.canonical.y;
              return {
                u_image: 0,
                u_texsize: t.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / Xx(t, 1, e1.transform.tileZoom),
                u_pixel_coord_upper: [n >> 16, o >> 16],
                u_pixel_coord_lower: [65535 & n, 65535 & o],
              };
            }
            const cM = xu.create(),
              hM = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f) => {
                const m = t.style.light,
                  _ = m.properties.get("position"),
                  g = [_.x, _.y, _.z],
                  y = gu.create();
                "viewport" === m.properties.get("anchor") &&
                  (gu.fromRotation(y, -t.transform.angle),
                  Mu.transformMat3(g, g, y));
                const x = m.properties.get("color"),
                  v = t.transform,
                  b = {
                    u_matrix: e1,
                    u_lightpos: g,
                    u_lightintensity: m.properties.get("intensity"),
                    u_lightcolor: [x.r, x.g, x.b],
                    u_vertical_gradient: +i,
                    u_opacity: r,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: cM,
                    u_merc_center: [0, 0],
                    u_up_dir: [0, 0, 0],
                    u_height_lift: 0,
                    u_ao: n,
                    u_edge_radius: o,
                    u_flood_light_color: u,
                    u_vertical_scale: d,
                    u_flood_light_intensity: p,
                    u_ground_shadow_factor: f,
                  };
                return (
                  "globe" === v.projection.name &&
                    ((b.u_tile_id = [
                      s.canonical.x,
                      s.canonical.y,
                      1 << s.canonical.z,
                    ]),
                    (b.u_zoom_transition = l),
                    (b.u_inv_rot_matrix = h),
                    (b.u_merc_center = c),
                    (b.u_up_dir = v.projection.upVector(
                      new ku(0, 0, 0),
                      c[0] * sr,
                      c[1] * sr,
                    )),
                    (b.u_height_lift = a)),
                  b
                );
              },
              uM = (e1, t, i) => ({
                u_matrix: e1,
                u_edge_radius: t,
                u_vertical_scale: i,
              }),
              dM = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p) => {
                const f = hM(
                    e1,
                    t,
                    i,
                    r,
                    n,
                    o,
                    s,
                    l,
                    c,
                    h,
                    u,
                    d,
                    p,
                    1,
                    [0, 0, 0],
                  ),
                  m = {
                    u_height_factor:
                      -Math.pow(2, s.overscaledZ) / a.tileSize / 8,
                  };
                return k(f, lM(t, a), m);
              },
              pM = (e1, t) => ({
                u_matrix: e1,
                u_emissive_strength: t,
              }),
              fM = (e1, t, i, r) => k(pM(e1, t), lM(i, r)),
              mM = (e1, t, i) => ({
                u_matrix: e1,
                u_world: i,
                u_emissive_strength: t,
              }),
              _M = (e1, t, i, r, n) =>
                k(fM(e1, t, i, r), {
                  u_world: n,
                }),
              gM = (e1, t, i, r) => {
                const n = sr / i.tileSize;
                return {
                  u_matrix: e1,
                  u_camera_to_center_distance: t.getCameraToCenterDistance(r),
                  u_extrude_scale: [
                    t.pixelsToGLUnits[0] / n,
                    t.pixelsToGLUnits[1] / n,
                  ],
                };
              },
              yM = (e1, t, i = 1) => ({
                u_matrix: e1,
                u_color: t,
                u_overlay: 0,
                u_overlay_scale: i,
              }),
              xM = xu.create(),
              vM = (e1, t, i, r, n, o, s) => {
                const a = e1.transform,
                  l = "globe" === a.projection.name,
                  c = l
                    ? wd(a.zoom, t.canonical) * a._pixelsPerMercatorPixel
                    : Xx(i, 1, o),
                  h = {
                    u_matrix: t.projMatrix,
                    u_extrude_scale: c,
                    u_intensity: s,
                    u_inv_rot_matrix: xM,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0],
                  };
                if (l) {
                  (h.u_inv_rot_matrix = r),
                    (h.u_merc_center = n),
                    (h.u_tile_id = [
                      t.canonical.x,
                      t.canonical.y,
                      1 << t.canonical.z,
                    ]),
                    (h.u_zoom_transition = Ed(a.zoom));
                  const e1 = n[0] * sr,
                    i = n[1] * sr;
                  h.u_up_dir = a.projection.upVector(new ku(0, 0, 0), e1, i);
                }
                return h;
              },
              bM = (e1, t, i, r, n, o, s, a, l, c, h) => {
                var u, d;
                return {
                  u_matrix: e1,
                  u_normalize_matrix: t,
                  u_globe_matrix: i,
                  u_tl_parent: r,
                  u_scale_parent: n,
                  u_fade_t: o.mix,
                  u_opacity: o.opacity * s.paint.get("raster-opacity"),
                  u_image0: 0,
                  u_image1: 1,
                  u_brightness_low: s.paint.get("raster-brightness-min"),
                  u_brightness_high: s.paint.get("raster-brightness-max"),
                  u_saturation_factor:
                    ((d = s.paint.get("raster-saturation")),
                    d > 0 ? 1 - 1 / (1.001 - d) : -d),
                  u_contrast_factor:
                    ((u = s.paint.get("raster-contrast")),
                    u > 0 ? 1 / (1 - u) : 1 + u),
                  u_spin_weights: wM(s.paint.get("raster-hue-rotate")),
                  u_perspective_transform: a,
                  u_colorization_mix: c,
                  u_colorization_scale: TM(h),
                  u_color_ramp: l,
                };
              };
            function wM(e1) {
              e1 *= Math.PI / 180;
              const t = Math.sin(e1),
                i = Math.cos(e1);
              return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t - i + 1) / 3,
                (Math.sqrt(3) * t - i + 1) / 3,
              ];
            }
            function TM([e1, t]) {
              if (e1 === t) return [e1, t];
              const i = (t + e1) / 2,
                r = (((t - e1) / 2) * 256) / 255;
              return [-(e1 = i - r) / ((t = i + r) - e1), 1 / (t - e1)];
            }
            const EM = xu.create(),
              MM = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m, _) => {
                const g = n.transform,
                  y = {
                    u_is_size_zoom_constant: +(
                      "constant" === e1 || "source" === e1
                    ),
                    u_is_size_feature_constant: +(
                      "constant" === e1 || "camera" === e1
                    ),
                    u_size_t: t ? t.uSizeT : 0,
                    u_size: t ? t.uSize : 0,
                    u_camera_to_center_distance: g.getCameraToCenterDistance(m),
                    u_rotate_symbol: +i,
                    u_aspect_ratio: g.width / g.height,
                    u_fade_change: n.options.fadeDuration
                      ? n.symbolFadeChange
                      : 1,
                    u_matrix: o,
                    u_label_plane_matrix: s,
                    u_coord_matrix: a,
                    u_is_text: +l,
                    u_pitch_with_map: +r,
                    u_texsize: c,
                    u_texture: 0,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: EM,
                    u_merc_center: [0, 0],
                    u_camera_forward: [0, 0, 0],
                    u_ecef_origin: [0, 0, 0],
                    u_tile_matrix: EM,
                    u_up_vector: [0, -1, 0],
                    u_icon_transition: _ || 0,
                  };
                return (
                  "globe" === m.name &&
                    ((y.u_tile_id = [
                      h.canonical.x,
                      h.canonical.y,
                      1 << h.canonical.z,
                    ]),
                    (y.u_zoom_transition = u),
                    (y.u_inv_rot_matrix = p),
                    (y.u_merc_center = d),
                    (y.u_camera_forward = g._camera.forward()),
                    (y.u_ecef_origin = (function (e1, t) {
                      const i = [0, 0, 0],
                        r = xd(ad(t.canonical));
                      return (
                        Mu.transformMat4(i, i, r), Mu.transformMat4(i, i, e1), i
                      );
                    })(g.globeMatrix, h.toUnwrapped())),
                    (y.u_tile_matrix = Float32Array.from(g.globeMatrix)),
                    (y.u_up_vector = f)),
                  y
                );
              },
              AM = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m, _) =>
                k(MM(e1, t, i, r, n, o, s, a, l, c, u, d, p, f, m, _), {
                  u_gamma_scale: r
                    ? n.transform.getCameraToCenterDistance(_) *
                      Math.cos(n.terrain ? 0 : n.transform._pitch)
                    : 1,
                  u_device_pixel_ratio: ht.devicePixelRatio,
                  u_is_halo: +h,
                  undefined: void 0,
                }),
              SM = (e1, t, i, r, n, o, s, a, l, c, h, u, d, p, f, m) =>
                k(AM(e1, t, i, r, n, o, s, a, !0, l, !0, h, u, d, p, f, m), {
                  u_texsize_icon: c,
                  u_texture_icon: 1,
                }),
              IM = (e1, t, i, r) => ({
                u_matrix: e1,
                u_emissive_strength: t,
                u_opacity: i,
                u_color: r,
              }),
              CM = (e1, t, i, r, n, o, s) =>
                k(
                  (function (e1, t, i, r) {
                    const n = i.imageManager.getPattern(e1.toString(), t),
                      { width: o, height: s } = i.imageManager.getPixelSize(t),
                      a = Math.pow(2, r.tileID.overscaledZ),
                      l = (r.tileSize * Math.pow(2, i.transform.tileZoom)) / a,
                      c = l * (r.tileID.canonical.x + r.tileID.wrap * a),
                      h = l * r.tileID.canonical.y;
                    return {
                      u_image: 0,
                      u_pattern_tl: n.tl,
                      u_pattern_br: n.br,
                      u_texsize: [o, s],
                      u_pattern_size: n.displaySize,
                      u_tile_units_to_pixels:
                        1 / Xx(r, 1, i.transform.tileZoom),
                      u_pixel_coord_upper: [c >> 16, h >> 16],
                      u_pixel_coord_lower: [65535 & c, 65535 & h],
                    };
                  })(n, o, r, s),
                  {
                    u_matrix: e1,
                    u_emissive_strength: t,
                    u_opacity: i,
                  },
                ),
              zM = {
                BaseColor: 5,
                MetallicRoughness: 6,
                Normal: 7,
                Occlusion: 8,
                Emission: 9,
                ShadowMap0: 10,
              },
              DM = (e1, t, i, r, n, o, s, a, l, c, h, u = [0, 0, 0]) => {
                const d = r.style.light,
                  p = d.properties.get("position"),
                  f = [-p.x, -p.y, p.z],
                  m = gu.create();
                "viewport" === d.properties.get("anchor") &&
                  (gu.fromRotation(m, -r.transform.angle),
                  Mu.transformMat3(f, f, m));
                const _ = "MASK" === c.alphaMode,
                  g = d.properties.get("color"),
                  y = h.paint.get("model-ambient-occlusion-intensity"),
                  x = h.paint.get("model-color").constantOr(li.white),
                  v = h.paint.get("model-color-mix-intensity").constantOr(0);
                return {
                  u_matrix: e1,
                  u_lighting_matrix: t,
                  u_normal_matrix: i,
                  u_lightpos: f,
                  u_lightintensity: d.properties.get("intensity"),
                  u_lightcolor: [g.r, g.g, g.b],
                  u_camera_pos: u,
                  u_opacity: n,
                  u_baseTextureIsAlpha: 0,
                  u_alphaMask: +_,
                  u_alphaCutoff: c.alphaCutoff,
                  u_baseColorFactor: [o.r, o.g, o.b, o.a],
                  u_emissiveFactor: [s[0], s[1], s[2], 1],
                  u_metallicFactor: a,
                  u_roughnessFactor: l,
                  u_baseColorTexture: zM.BaseColor,
                  u_metallicRoughnessTexture: zM.MetallicRoughness,
                  u_normalTexture: zM.Normal,
                  u_occlusionTexture: zM.Occlusion,
                  u_emissionTexture: zM.Emission,
                  u_color_mix: [x.r, x.g, x.b, v],
                  u_aoIntensity: y,
                };
              },
              PM = new Float32Array(16),
              RM = (e1, t = PM, i = PM) => ({
                u_matrix: e1,
                u_instance: t,
                u_node_matrix: i,
              }),
              LM = {
                fillExtrusion: (e1) => ({
                  u_matrix: new kl(e1),
                  u_lightpos: new Dl(e1),
                  u_lightintensity: new Cl(e1),
                  u_lightcolor: new Dl(e1),
                  u_vertical_gradient: new Cl(e1),
                  u_opacity: new Cl(e1),
                  u_edge_radius: new Cl(e1),
                  u_ao: new zl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_up_dir: new Dl(e1),
                  u_height_lift: new Cl(e1),
                  u_flood_light_color: new Dl(e1),
                  u_vertical_scale: new Cl(e1),
                  u_flood_light_intensity: new Cl(e1),
                  u_ground_shadow_factor: new Dl(e1),
                }),
                fillExtrusionDepth: (e1) => ({
                  u_matrix: new kl(e1),
                  u_edge_radius: new Cl(e1),
                  u_vertical_scale: new Cl(e1),
                }),
                fillExtrusionPattern: (e1) => ({
                  u_matrix: new kl(e1),
                  u_lightpos: new Dl(e1),
                  u_lightintensity: new Cl(e1),
                  u_lightcolor: new Dl(e1),
                  u_vertical_gradient: new Cl(e1),
                  u_height_factor: new Cl(e1),
                  u_edge_radius: new Cl(e1),
                  u_ao: new zl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_up_dir: new Dl(e1),
                  u_height_lift: new Cl(e1),
                  u_image: new Il(e1),
                  u_texsize: new zl(e1),
                  u_pixel_coord_upper: new zl(e1),
                  u_pixel_coord_lower: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                  u_opacity: new Cl(e1),
                }),
                fillExtrusionGroundEffect: (e1) => ({
                  u_matrix: new kl(e1),
                  u_opacity: new Cl(e1),
                  u_ao_pass: new Cl(e1),
                  u_meter_to_tile: new Cl(e1),
                  u_ao: new zl(e1),
                  u_flood_light_intensity: new Cl(e1),
                  u_flood_light_color: new Dl(e1),
                  u_attenuation: new Cl(e1),
                  u_edge_radius: new Cl(e1),
                  u_fb: new Il(e1),
                  u_fb_size: new Cl(e1),
                }),
                fill: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                }),
                fillPattern: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_image: new Il(e1),
                  u_texsize: new zl(e1),
                  u_pixel_coord_upper: new zl(e1),
                  u_pixel_coord_lower: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                }),
                fillOutline: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_world: new zl(e1),
                }),
                fillOutlinePattern: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_world: new zl(e1),
                  u_image: new Il(e1),
                  u_texsize: new zl(e1),
                  u_pixel_coord_upper: new zl(e1),
                  u_pixel_coord_lower: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                }),
                circle: (e1) => ({
                  u_camera_to_center_distance: new Cl(e1),
                  u_extrude_scale: new Nl(e1),
                  u_device_pixel_ratio: new Cl(e1),
                  u_matrix: new kl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_up_dir: new Dl(e1),
                  u_emissive_strength: new Cl(e1),
                }),
                collisionBox: (e1) => ({
                  u_matrix: new kl(e1),
                  u_camera_to_center_distance: new Cl(e1),
                  u_extrude_scale: new zl(e1),
                }),
                collisionCircle: (e1) => ({
                  u_matrix: new kl(e1),
                  u_inv_matrix: new kl(e1),
                  u_camera_to_center_distance: new Cl(e1),
                  u_viewport_size: new zl(e1),
                }),
                debug: (e1) => ({
                  u_color: new Rl(e1),
                  u_matrix: new kl(e1),
                  u_overlay: new Il(e1),
                  u_overlay_scale: new Cl(e1),
                }),
                clippingMask: (e1) => ({
                  u_matrix: new kl(e1),
                }),
                heatmap: (e1) => ({
                  u_extrude_scale: new Cl(e1),
                  u_intensity: new Cl(e1),
                  u_matrix: new kl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_up_dir: new Dl(e1),
                }),
                heatmapTexture: (e1) => ({
                  u_image: new Il(e1),
                  u_color_ramp: new Il(e1),
                  u_opacity: new Cl(e1),
                }),
                hillshade: (e1) => ({
                  u_matrix: new kl(e1),
                  u_image: new Il(e1),
                  u_latrange: new zl(e1),
                  u_light: new zl(e1),
                  u_shadow: new Rl(e1),
                  u_highlight: new Rl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_accent: new Rl(e1),
                }),
                hillshadePrepare: (e1) => ({
                  u_matrix: new kl(e1),
                  u_image: new Il(e1),
                  u_dimension: new zl(e1),
                  u_zoom: new Cl(e1),
                  u_unpack: new Pl(e1),
                }),
                line: (e1) => ({
                  u_matrix: new kl(e1),
                  u_pixels_to_tile_units: new Nl(e1),
                  u_device_pixel_ratio: new Cl(e1),
                  u_units_to_pixels: new zl(e1),
                  u_dash_image: new Il(e1),
                  u_gradient_image: new Il(e1),
                  u_image_height: new Cl(e1),
                  u_texsize: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                  u_alpha_discard_threshold: new Cl(e1),
                  u_trim_offset: new zl(e1),
                  u_emissive_strength: new Cl(e1),
                }),
                linePattern: (e1) => ({
                  u_matrix: new kl(e1),
                  u_texsize: new zl(e1),
                  u_pixels_to_tile_units: new Nl(e1),
                  u_device_pixel_ratio: new Cl(e1),
                  u_image: new Il(e1),
                  u_units_to_pixels: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                  u_alpha_discard_threshold: new Cl(e1),
                }),
                raster: (e1) => ({
                  u_matrix: new kl(e1),
                  u_normalize_matrix: new kl(e1),
                  u_globe_matrix: new kl(e1),
                  u_tl_parent: new zl(e1),
                  u_scale_parent: new Cl(e1),
                  u_fade_t: new Cl(e1),
                  u_opacity: new Cl(e1),
                  u_image0: new Il(e1),
                  u_image1: new Il(e1),
                  u_brightness_low: new Cl(e1),
                  u_brightness_high: new Cl(e1),
                  u_saturation_factor: new Cl(e1),
                  u_contrast_factor: new Cl(e1),
                  u_spin_weights: new Dl(e1),
                  u_perspective_transform: new zl(e1),
                  u_colorization_mix: new Pl(e1),
                  u_colorization_scale: new zl(e1),
                  u_color_ramp: new Il(e1),
                }),
                symbolIcon: (e1) => ({
                  u_is_size_zoom_constant: new Il(e1),
                  u_is_size_feature_constant: new Il(e1),
                  u_size_t: new Cl(e1),
                  u_size: new Cl(e1),
                  u_camera_to_center_distance: new Cl(e1),
                  u_rotate_symbol: new Il(e1),
                  u_aspect_ratio: new Cl(e1),
                  u_fade_change: new Cl(e1),
                  u_matrix: new kl(e1),
                  u_label_plane_matrix: new kl(e1),
                  u_coord_matrix: new kl(e1),
                  u_is_text: new Il(e1),
                  u_pitch_with_map: new Il(e1),
                  u_texsize: new zl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_camera_forward: new Dl(e1),
                  u_tile_matrix: new kl(e1),
                  u_up_vector: new Dl(e1),
                  u_ecef_origin: new Dl(e1),
                  u_texture: new Il(e1),
                  u_icon_transition: new Cl(e1),
                }),
                symbolSDF: (e1) => ({
                  u_is_size_zoom_constant: new Il(e1),
                  u_is_size_feature_constant: new Il(e1),
                  u_size_t: new Cl(e1),
                  u_size: new Cl(e1),
                  u_camera_to_center_distance: new Cl(e1),
                  u_rotate_symbol: new Il(e1),
                  u_aspect_ratio: new Cl(e1),
                  u_fade_change: new Cl(e1),
                  u_matrix: new kl(e1),
                  u_label_plane_matrix: new kl(e1),
                  u_coord_matrix: new kl(e1),
                  u_is_text: new Il(e1),
                  u_pitch_with_map: new Il(e1),
                  u_texsize: new zl(e1),
                  u_texture: new Il(e1),
                  u_gamma_scale: new Cl(e1),
                  u_device_pixel_ratio: new Cl(e1),
                  u_tile_id: new Dl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_inv_rot_matrix: new kl(e1),
                  u_merc_center: new zl(e1),
                  u_camera_forward: new Dl(e1),
                  u_tile_matrix: new kl(e1),
                  u_up_vector: new Dl(e1),
                  u_ecef_origin: new Dl(e1),
                  u_is_halo: new Il(e1),
                }),
                symbolTextAndIcon: (e1) => ({
                  u_is_size_zoom_constant: new Il(e1),
                  u_is_size_feature_constant: new Il(e1),
                  u_size_t: new Cl(e1),
                  u_size: new Cl(e1),
                  u_camera_to_center_distance: new Cl(e1),
                  u_rotate_symbol: new Il(e1),
                  u_aspect_ratio: new Cl(e1),
                  u_fade_change: new Cl(e1),
                  u_matrix: new kl(e1),
                  u_label_plane_matrix: new kl(e1),
                  u_coord_matrix: new kl(e1),
                  u_is_text: new Il(e1),
                  u_pitch_with_map: new Il(e1),
                  u_texsize: new zl(e1),
                  u_texsize_icon: new zl(e1),
                  u_texture: new Il(e1),
                  u_texture_icon: new Il(e1),
                  u_gamma_scale: new Cl(e1),
                  u_device_pixel_ratio: new Cl(e1),
                  u_is_halo: new Il(e1),
                }),
                background: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_opacity: new Cl(e1),
                  u_color: new Rl(e1),
                }),
                backgroundPattern: (e1) => ({
                  u_matrix: new kl(e1),
                  u_emissive_strength: new Cl(e1),
                  u_opacity: new Cl(e1),
                  u_image: new Il(e1),
                  u_pattern_tl: new zl(e1),
                  u_pattern_br: new zl(e1),
                  u_texsize: new zl(e1),
                  u_pattern_size: new zl(e1),
                  u_pixel_coord_upper: new zl(e1),
                  u_pixel_coord_lower: new zl(e1),
                  u_tile_units_to_pixels: new Cl(e1),
                }),
                terrainRaster: GE,
                terrainDepth: GE,
                skybox: (e1) => ({
                  u_matrix: new kl(e1),
                  u_sun_direction: new Dl(e1),
                  u_cubemap: new Il(e1),
                  u_opacity: new Cl(e1),
                  u_temporal_offset: new Cl(e1),
                }),
                skyboxGradient: (e1) => ({
                  u_matrix: new kl(e1),
                  u_color_ramp: new Il(e1),
                  u_center_direction: new Dl(e1),
                  u_radius: new Cl(e1),
                  u_opacity: new Cl(e1),
                  u_temporal_offset: new Cl(e1),
                }),
                skyboxCapture: (e1) => ({
                  u_matrix_3f: new Bl(e1),
                  u_sun_direction: new Dl(e1),
                  u_sun_intensity: new Cl(e1),
                  u_color_tint_r: new Pl(e1),
                  u_color_tint_m: new Pl(e1),
                  u_luminance: new Cl(e1),
                }),
                globeRaster: (e1) => ({
                  u_proj_matrix: new kl(e1),
                  u_globe_matrix: new kl(e1),
                  u_normalize_matrix: new kl(e1),
                  u_merc_matrix: new kl(e1),
                  u_zoom_transition: new Cl(e1),
                  u_merc_center: new zl(e1),
                  u_image0: new Il(e1),
                  u_grid_matrix: new Bl(e1),
                  u_skirt_height: new Cl(e1),
                  u_frustum_tl: new Dl(e1),
                  u_frustum_tr: new Dl(e1),
                  u_frustum_br: new Dl(e1),
                  u_frustum_bl: new Dl(e1),
                  u_globe_pos: new Dl(e1),
                  u_globe_radius: new Cl(e1),
                  u_viewport: new zl(e1),
                }),
                globeAtmosphere: (e1) => ({
                  u_frustum_tl: new Dl(e1),
                  u_frustum_tr: new Dl(e1),
                  u_frustum_br: new Dl(e1),
                  u_frustum_bl: new Dl(e1),
                  u_horizon: new Cl(e1),
                  u_transition: new Cl(e1),
                  u_fadeout_range: new Cl(e1),
                  u_color: new Pl(e1),
                  u_high_color: new Pl(e1),
                  u_space_color: new Pl(e1),
                  u_temporal_offset: new Cl(e1),
                  u_horizon_angle: new Cl(e1),
                }),
                model: (e1) => ({
                  u_matrix: new kl(e1),
                  u_lighting_matrix: new kl(e1),
                  u_normal_matrix: new kl(e1),
                  u_lightpos: new Dl(e1),
                  u_lightintensity: new Cl(e1),
                  u_lightcolor: new Dl(e1),
                  u_camera_pos: new Dl(e1),
                  u_opacity: new Cl(e1),
                  u_baseColorFactor: new Pl(e1),
                  u_emissiveFactor: new Pl(e1),
                  u_metallicFactor: new Cl(e1),
                  u_roughnessFactor: new Cl(e1),
                  u_baseTextureIsAlpha: new Il(e1),
                  u_alphaMask: new Il(e1),
                  u_alphaCutoff: new Cl(e1),
                  u_baseColorTexture: new Il(e1),
                  u_metallicRoughnessTexture: new Il(e1),
                  u_normalTexture: new Il(e1),
                  u_occlusionTexture: new Il(e1),
                  u_emissionTexture: new Il(e1),
                  u_color_mix: new Pl(e1),
                  u_aoIntensity: new Cl(e1),
                }),
                modelDepth: (e1) => ({
                  u_matrix: new kl(e1),
                  u_instance: new kl(e1),
                  u_node_matrix: new kl(e1),
                }),
                groundShadow: (e1) => ({
                  u_matrix: new kl(e1),
                  u_ground_shadow_factor: new Dl(e1),
                }),
                stars: (e1) => ({
                  u_matrix: new kl(e1),
                  u_up: new Dl(e1),
                  u_right: new Dl(e1),
                  u_intensity_multiplier: new Cl(e1),
                }),
              };
            let kM;
            function OM(e1, t, i, r, n, o, s) {
              const a = e1.context,
                l = a.gl,
                c = e1.transform,
                h = e1.getOrCreateProgram("collisionBox"),
                u = [];
              let d = 0,
                p = 0;
              for (let a = 0; a < r.length; a++) {
                const f = r[a],
                  m = t.getTile(f),
                  _ = m.getBucket(i);
                if (!_) continue;
                const g = jT(f, _, c);
                let y = g;
                (0 === n[0] && 0 === n[1]) ||
                  (y = e1.translatePosMatrix(g, m, n, o));
                const x = s ? _.textCollisionBox : _.iconCollisionBox,
                  v = _.collisionCircleArray;
                if (v.length > 0) {
                  const e1 = xu.create(),
                    t = y;
                  xu.mul(e1, _.placementInvProjMatrix, c.glCoordMatrix),
                    xu.mul(e1, e1, _.placementViewportMatrix),
                    u.push({
                      circleArray: v,
                      circleOffset: p,
                      transform: t,
                      invTransform: e1,
                      projection: _.getProjection(),
                    }),
                    (d += v.length / 4),
                    (p = d);
                }
                x &&
                  (e1.terrain && e1.terrain.setupElevationDraw(m, h),
                  h.draw(
                    e1,
                    l.LINES,
                    gx.disabled,
                    xx.disabled,
                    e1.colorModeForRenderPass(),
                    Ex.disabled,
                    gM(y, c, m, _.getProjection()),
                    i.id,
                    x.layoutVertexBuffer,
                    x.indexBuffer,
                    x.segments,
                    null,
                    c.zoom,
                    null,
                    [x.collisionVertexBuffer, x.collisionVertexBufferExt],
                  ));
              }
              if (!s || !u.length) return;
              const f = e1.getOrCreateProgram("collisionCircle"),
                m = new Fa();
              m.resize(4 * d), m._trim();
              let _ = 0;
              for (const e1 of u)
                for (let t = 0; t < e1.circleArray.length / 4; t++) {
                  const i = 4 * t,
                    r = e1.circleArray[i + 0],
                    n = e1.circleArray[i + 1],
                    o = e1.circleArray[i + 2],
                    s = e1.circleArray[i + 3];
                  m.emplace(_++, r, n, o, s, 0),
                    m.emplace(_++, r, n, o, s, 1),
                    m.emplace(_++, r, n, o, s, 2),
                    m.emplace(_++, r, n, o, s, 3);
                }
              (!kM || kM.length < 2 * d) &&
                (kM = (function (e1) {
                  const t = 2 * e1,
                    i = new Va();
                  i.resize(t), i._trim();
                  for (let e1 = 0; e1 < t; e1++) {
                    const t = 6 * e1;
                    (i.uint16[t + 0] = 4 * e1 + 0),
                      (i.uint16[t + 1] = 4 * e1 + 1),
                      (i.uint16[t + 2] = 4 * e1 + 2),
                      (i.uint16[t + 3] = 4 * e1 + 2),
                      (i.uint16[t + 4] = 4 * e1 + 3),
                      (i.uint16[t + 5] = 4 * e1 + 0);
                  }
                  return i;
                })(d));
              const g = a.createIndexBuffer(kM, !0),
                y = a.createVertexBuffer(m, i_.members, !0);
              for (const t of u) {
                const r = {
                  u_matrix: t.transform,
                  u_inv_matrix: t.invTransform,
                  u_camera_to_center_distance: (x =
                    c).getCameraToCenterDistance(t.projection),
                  u_viewport_size: [x.width, x.height],
                };
                f.draw(
                  e1,
                  l.TRIANGLES,
                  gx.disabled,
                  xx.disabled,
                  e1.colorModeForRenderPass(),
                  Ex.disabled,
                  r,
                  i.id,
                  y,
                  g,
                  dl.simpleSegment(
                    0,
                    2 * t.circleOffset,
                    t.circleArray.length,
                    t.circleArray.length / 2,
                  ),
                  null,
                  c.zoom,
                );
              }
              var x;
              y.destroy(), g.destroy();
            }
            const BM = xu.create();
            function FM(
              { width: e1, height: t, anchor: i, textOffset: r, textScale: n },
              o,
            ) {
              const { horizontalAlign: s, verticalAlign: a } = L_(i),
                l = -(s - 0.5) * e1,
                c = -(a - 0.5) * t,
                h = ug(i, r);
              return new y((l / n + h[0]) * o, (c / n + h[1]) * o);
            }
            function NM(e1, t, i, r, n, o, s, a, l, c, h) {
              const u = e1.text.placedSymbolArray,
                d = e1.text.dynamicLayoutVertexArray,
                p = e1.icon.dynamicLayoutVertexArray,
                f = {},
                m = e1.getProjection(),
                _ = GT(a, m, o),
                g = o.elevation,
                y = m.upVectorScale(
                  a.canonical,
                  o.center.lat,
                  o.worldSize,
                ).metersToTile;
              d.clear();
              for (let p = 0; p < u.length; p++) {
                const x = u.get(p),
                  { tileAnchorX: v, tileAnchorY: b, numGlyphs: w } = x,
                  T =
                    x.hidden ||
                    !x.crossTileID ||
                    (e1.allowVerticalPlacement && !x.placedOrientation)
                      ? null
                      : r[x.crossTileID];
                if (T) {
                  let r = 0,
                    u = 0,
                    p = 0;
                  if (g) {
                    const e1 = g ? g.getAtTileOffset(a, v, b) : 0,
                      [t, i, n] = m.upVector(a.canonical, v, b);
                    (r = e1 * t * y), (u = e1 * i * y), (p = e1 * n * y);
                  }
                  let [E, M, A, S] = tv(
                    x.projectedAnchorX + r,
                    x.projectedAnchorY + u,
                    x.projectedAnchorZ + p,
                    i ? _ : s,
                  );
                  const I = iv(o.getCameraToCenterDistance(m), S);
                  let C =
                    (n.evaluateSizeForFeature(e1.textSizeData, c, x) * I) / r_;
                  i && (C *= e1.tilePixelRatio / l);
                  const z = FM(T, C);
                  i
                    ? (({
                        x: E,
                        y: M,
                        z: A,
                      } = m.projectTilePoint(v + z.x, b + z.y, a.canonical)),
                      ([E, M, A] = tv(E + r, M + u, A + p, s)))
                    : (t && z._rotate(-o.angle),
                      (E += z.x),
                      (M += z.y),
                      (A = 0));
                  const D =
                    e1.allowVerticalPlacement &&
                    x.placedOrientation === w_.vertical
                      ? Math.PI / 2
                      : 0;
                  for (let e1 = 0; e1 < w; e1++) ny(d, E, M, A, D);
                  h &&
                    x.associatedIconIndex >= 0 &&
                    (f[x.associatedIconIndex] = {
                      x: E,
                      y: M,
                      z: A,
                      angle: D,
                    });
                } else uv(w, d);
              }
              if (h) {
                p.clear();
                const t = e1.icon.placedSymbolArray;
                for (let e1 = 0; e1 < t.length; e1++) {
                  const i = t.get(e1),
                    { numGlyphs: r } = i,
                    n = f[e1];
                  if (i.hidden || !n) uv(r, p);
                  else {
                    const { x: e1, y: t, z: i, angle: o } = n;
                    for (let n = 0; n < r; n++) ny(p, e1, t, i, o);
                  }
                }
                e1.icon.dynamicLayoutVertexBuffer.updateData(p);
              }
              e1.text.dynamicLayoutVertexBuffer.updateData(d);
            }
            function UM(e1, t, i) {
              return i.iconsInText && t
                ? "symbolTextAndIcon"
                : e1
                ? "symbolSDF"
                : "symbolIcon";
            }
            function VM(e1, t, i, r, n, o, s, a, l, c, h, u) {
              const d = e1.context,
                p = d.gl,
                f = e1.transform,
                m = "map" === a,
                _ = "map" === l,
                g = m && "point" !== i.layout.get("symbol-placement"),
                y = m && !_ && !g,
                x = void 0 !== i.layout.get("symbol-sort-key").constantOr(1);
              let v = !1;
              const b = e1.depthModeForSublayer(0, gx.ReadOnly),
                w = [Gd(f.center.lng), qd(f.center.lat)],
                T = i.layout.get("text-variable-anchor"),
                E = "globe" === f.projection.name,
                M = [],
                A = [0, -1, 0];
              let S = A;
              (!E && !f.mercatorFromTransition) ||
                m ||
                (S = (function (e1) {
                  const t = e1._camera.getWorldToCamera(e1.worldSize, 1),
                    i = xu.multiply([], t, e1.globeMatrix);
                  xu.invert(i, i);
                  const r = [0, 0, 0],
                    n = [0, 1, 0, 0];
                  return (
                    uu.transformMat4(n, n, i),
                    (r[0] = n[0]),
                    (r[1] = n[1]),
                    (r[2] = n[2]),
                    Mu.normalize(r, r),
                    r
                  );
                })(f));
              for (const a of r) {
                const r = t.getTile(a),
                  l = r.getBucket(i);
                if (!l) continue;
                if ("mercator" === l.projection.name && E) continue;
                const h = n ? l.text : l.icon;
                if (!h || l.fullyClipped || !h.segments.get().length) continue;
                const u = h.programConfigurations.get(i.id),
                  d = n || l.sdfIcons,
                  b = n ? l.textSizeData : l.iconSizeData,
                  I = _ || 0 !== f.pitch,
                  C = a_(b, f.zoom);
                let z,
                  D,
                  P,
                  R,
                  L = [0, 0],
                  k = null;
                if (n)
                  (D = r.glyphAtlasTexture),
                    (P = p.LINEAR),
                    (z = r.glyphAtlasTexture.size),
                    l.iconsInText &&
                      ((L = r.imageAtlasTexture.size),
                      (k = r.imageAtlasTexture),
                      (R =
                        I ||
                        e1.options.rotating ||
                        e1.options.zooming ||
                        "composite" === b.kind ||
                        "camera" === b.kind
                          ? p.LINEAR
                          : p.NEAREST));
                else {
                  const t =
                    1 !== i.layout.get("icon-size").constantOr(0) ||
                    l.iconsNeedLinear;
                  (D = r.imageAtlasTexture),
                    (P =
                      d || e1.options.rotating || e1.options.zooming || t || I
                        ? p.LINEAR
                        : p.NEAREST),
                    (z = r.imageAtlasTexture.size);
                }
                const O = "globe" === l.projection.name,
                  B = O ? S : A,
                  F = O ? Ed(f.zoom) : 0,
                  N = GT(a, l.getProjection(), f),
                  U = f.calculatePixelsToTileUnitsMatrix(r),
                  V = Jx(N, r.tileID.canonical, _, m, f, l.getProjection(), U),
                  j = e1.terrain && _ && g ? xu.invert(xu.create(), V) : BM,
                  G = ev(N, r.tileID.canonical, _, m, f, l.getProjection(), U),
                  q = T && l.hasTextData(),
                  Z = l.hasIconTextFit() && q && l.hasIconData();
                if (g) {
                  const t = f.elevation,
                    i = t
                      ? t.getAtTileOffsetFunc(
                          a,
                          f.center.lat,
                          f.worldSize,
                          l.getProjection(),
                        )
                      : null,
                    o = Qx(
                      N,
                      r.tileID.canonical,
                      _,
                      m,
                      f,
                      l.getProjection(),
                      U,
                    );
                  nv(l, N, e1, n, o, G, _, c, i, a);
                }
                const $ = g || (n && T) || Z,
                  H = e1.translatePosMatrix(N, r, o, s),
                  W = $ ? BM : V,
                  X = e1.translatePosMatrix(G, r, o, s, !0),
                  Y = l.getProjection().createInversionMatrix(f, a.canonical),
                  K = i.paint.get("icon-image-cross-fade").constantOr(0),
                  J = [];
                e1.terrainRenderModeElevated() &&
                  _ &&
                  J.push("PITCH_WITH_MAP_TERRAIN"),
                  O &&
                    (J.push("PROJECTION_GLOBE_VIEW"),
                    $ && J.push("PROJECTED_POS_ON_VIEWPORT")),
                  K > 0 && J.push("ICON_TRANSITION"),
                  h.zOffsetVertexBuffer && J.push("Z_OFFSET");
                const Q =
                  d &&
                  0 !==
                    i.paint
                      .get(n ? "text-halo-width" : "icon-halo-width")
                      .constantOr(1);
                let ee;
                ee = d
                  ? l.iconsInText
                    ? SM(
                        b.kind,
                        C,
                        y,
                        _,
                        e1,
                        H,
                        W,
                        X,
                        z,
                        L,
                        a,
                        F,
                        w,
                        Y,
                        B,
                        l.getProjection(),
                      )
                    : AM(
                        b.kind,
                        C,
                        y,
                        _,
                        e1,
                        H,
                        W,
                        X,
                        n,
                        z,
                        !0,
                        a,
                        F,
                        w,
                        Y,
                        B,
                        l.getProjection(),
                      )
                  : MM(
                      b.kind,
                      C,
                      y,
                      _,
                      e1,
                      H,
                      W,
                      X,
                      n,
                      z,
                      a,
                      F,
                      w,
                      Y,
                      B,
                      l.getProjection(),
                      K,
                    );
                const te = {
                  program: e1.getOrCreateProgram(UM(d, n, l), {
                    config: u,
                    defines: J,
                  }),
                  buffers: h,
                  uniformValues: ee,
                  atlasTexture: D,
                  atlasTextureIcon: k,
                  atlasInterpolation: P,
                  atlasInterpolationIcon: R,
                  isSDF: d,
                  hasHalo: Q,
                  tile: r,
                  labelPlaneMatrixInv: j,
                };
                if (x && l.canOverlap) {
                  v = !0;
                  const e1 = h.segments.get();
                  for (const t of e1)
                    M.push({
                      segments: new dl([t]),
                      sortKey: t.sortKey,
                      state: te,
                    });
                } else
                  M.push({
                    segments: h.segments,
                    sortKey: 0,
                    state: te,
                  });
              }
              v && M.sort((e1, t) => e1.sortKey - t.sortKey);
              for (const t of M) {
                const r = t.state;
                if (
                  (e1.terrain &&
                    e1.terrain.setupElevationDraw(r.tile, r.program, {
                      useDepthForOcclusion:
                        f.depthOcclusionForSymbolsAndCircles,
                      labelPlaneMatrixInv: r.labelPlaneMatrixInv,
                    }),
                  d.activeTexture.set(p.TEXTURE0),
                  r.atlasTexture.bind(r.atlasInterpolation, p.CLAMP_TO_EDGE),
                  r.atlasTextureIcon &&
                    (d.activeTexture.set(p.TEXTURE1),
                    r.atlasTextureIcon &&
                      r.atlasTextureIcon.bind(
                        r.atlasInterpolationIcon,
                        p.CLAMP_TO_EDGE,
                      )),
                  e1.uploadCommonLightUniforms(e1.context, r.program),
                  r.hasHalo)
                ) {
                  const n = r.uniformValues;
                  (n.u_is_halo = 1),
                    jM(r.buffers, t.segments, i, e1, r.program, b, h, u, n, 2),
                    (n.u_is_halo = 0);
                } else {
                  if (r.isSDF) {
                    const n = r.uniformValues;
                    r.hasHalo &&
                      ((n.u_is_halo = 1),
                      jM(
                        r.buffers,
                        t.segments,
                        i,
                        e1,
                        r.program,
                        b,
                        h,
                        u,
                        n,
                        1,
                      )),
                      (n.u_is_halo = 0);
                  }
                  jM(
                    r.buffers,
                    t.segments,
                    i,
                    e1,
                    r.program,
                    b,
                    h,
                    u,
                    r.uniformValues,
                    1,
                  );
                }
              }
            }
            function jM(e1, t, i, r, n, o, s, a, l, c) {
              const h = [
                e1.dynamicLayoutVertexBuffer,
                e1.opacityVertexBuffer,
                e1.iconTransitioningVertexBuffer,
                e1.globeExtVertexBuffer,
                e1.zOffsetVertexBuffer,
              ];
              n.draw(
                r,
                r.context.gl.TRIANGLES,
                o,
                s,
                a,
                Ex.disabled,
                l,
                i.id,
                e1.layoutVertexBuffer,
                e1.indexBuffer,
                t,
                i.paint,
                r.transform.zoom,
                e1.programConfigurations.get(i.id),
                h,
                c,
              );
            }
            function GM(e1, t, i, r, n, o, s) {
              const a = e1.context.gl,
                l = i.paint.get("fill-pattern"),
                c = l && l.constantOr(1);
              let h, u, d, p, f;
              s
                ? ((u =
                    c && !i.getPaintProperty("fill-outline-color")
                      ? "fillOutlinePattern"
                      : "fillOutline"),
                  (h = a.LINES))
                : ((u = c ? "fillPattern" : "fill"), (h = a.TRIANGLES));
              for (const m of r) {
                const r = t.getTile(m);
                if (c && !r.patternsLoaded()) continue;
                const _ = r.getBucket(i);
                if (!_) continue;
                e1.prepareDrawTile();
                const g = _.programConfigurations.get(i.id),
                  y = e1.isTileAffectedByFog(m),
                  x = e1.getOrCreateProgram(u, {
                    config: g,
                    overrideFog: y,
                  });
                c &&
                  (e1.context.activeTexture.set(a.TEXTURE0),
                  r.imageAtlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                  g.updatePaintBuffers());
                const v = l.constantOr(null);
                if (v && r.imageAtlas) {
                  const e1 = r.imageAtlas.patternPositions[v.toString()];
                  e1 && g.setConstantPatternPositions(e1);
                }
                const b = e1.translatePosMatrix(
                    m.projMatrix,
                    r,
                    i.paint.get("fill-translate"),
                    i.paint.get("fill-translate-anchor"),
                  ),
                  w = i.paint.get("fill-emissive-strength");
                if (s) {
                  (p = _.indexBuffer2), (f = _.segments2);
                  const t =
                    e1.terrain && e1.terrain.renderingToTexture
                      ? e1.terrain.drapeBufferSize
                      : [a.drawingBufferWidth, a.drawingBufferHeight];
                  d =
                    "fillOutlinePattern" === u && c
                      ? _M(b, w, e1, r, t)
                      : mM(b, w, t);
                } else
                  (p = _.indexBuffer),
                    (f = _.segments),
                    (d = c ? fM(b, w, e1, r) : pM(b, w));
                e1.uploadCommonUniforms(e1.context, x, m.toUnwrapped()),
                  x.draw(
                    e1,
                    h,
                    n,
                    e1.stencilModeForClipping(m),
                    o,
                    Ex.disabled,
                    d,
                    i.id,
                    _.layoutVertexBuffer,
                    p,
                    f,
                    i.paint,
                    e1.transform.zoom,
                    g,
                    void 0,
                  );
              }
            }
            function qM(e1, t, i, r, n, o, s, a) {
              const l = e1.context,
                c = l.gl,
                h = e1.transform,
                u = i.paint.get("fill-extrusion-pattern"),
                d = u.constantOr(1),
                p = i.paint.get("fill-extrusion-opacity"),
                f = e1.style.enable3dLights(),
                m = i.paint.get(
                  f && !d
                    ? "fill-extrusion-ambient-occlusion-wall-radius"
                    : "fill-extrusion-ambient-occlusion-radius",
                ),
                _ = [
                  i.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                  m,
                ],
                g = i.layout.get("fill-extrusion-edge-radius"),
                y = g > 0 && !i.paint.get("fill-extrusion-rounded-roof"),
                x = y ? 0 : g,
                v = "globe" === h.projection.name ? vb() : 0,
                b = "globe" === h.projection.name,
                w = b ? Ed(h.zoom) : 0,
                T = [Gd(h.center.lng), qd(h.center.lat)],
                E = i.paint
                  .get("fill-extrusion-flood-light-color")
                  .toArray01()
                  .slice(0, 3),
                M = i.paint.get("fill-extrusion-flood-light-intensity"),
                A = i.paint.get("fill-extrusion-vertical-scale"),
                S = $E(e1, i.paint.get("fill-extrusion-cutoff-fade-range")),
                I = [];
              let C;
              b && I.push("PROJECTION_GLOBE_VIEW"),
                _[0] > 0 && I.push("FAUX_AO"),
                y && I.push("ZERO_ROOF_RADIUS"),
                a && I.push("HAS_CENTROID"),
                M > 0 && I.push("FLOOD_LIGHT"),
                S.shouldRenderCutoff && I.push("RENDER_CUTOFF");
              const z = "shadow" === e1.renderPass,
                D = e1.shadowRenderer,
                P = z && !!D;
              e1.shadowRenderer && (e1.shadowRenderer.useNormalOffset = !0);
              let R = [0, 0, 0];
              if (D) {
                const t = e1.style.directionalLight,
                  i = e1.style.ambientLight;
                t && i && (R = BA(t, i)),
                  (C = I.concat(["SHADOWS_SINGLE_CASCADE"]));
              }
              const L = P
                ? "fillExtrusionDepth"
                : d
                ? "fillExtrusionPattern"
                : "fillExtrusion";
              for (const f of r) {
                const r = t.getTile(f),
                  m = r.getBucket(i);
                if (!m || m.projection.name !== h.projection.name) continue;
                let g = !1;
                D && (g = 0 === D.getMaxCascadeForTile(f.toUnwrapped()));
                const y = e1.isTileAffectedByFog(f),
                  P = m.programConfigurations.get(i.id),
                  k = e1.getOrCreateProgram(L, {
                    config: P,
                    defines: g ? C : I,
                    overrideFog: y,
                  });
                if (e1.terrain) {
                  const t = e1.terrain;
                  e1.style.terrainSetForDrapingOnly(),
                    t.setupElevationDraw(r, k, {
                      useMeterToDem: !0,
                    });
                }
                if (!m.centroidVertexBuffer) {
                  const e1 = k.attributes.a_centroid_pos;
                  void 0 !== e1 && c.vertexAttrib2f(e1, 0, 0);
                }
                !z &&
                  D &&
                  D.setupShadows(
                    r.tileID.toUnwrapped(),
                    k,
                    "vector-tile",
                    r.tileID.overscaledZ,
                  ),
                  d &&
                    (e1.context.activeTexture.set(c.TEXTURE0),
                    r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                    P.updatePaintBuffers());
                const O = u.constantOr(null);
                if (O && r.imageAtlas) {
                  const e1 = r.imageAtlas.patternPositions[O.toString()];
                  e1 && P.setConstantPatternPositions(e1);
                }
                const B = i.paint.get("fill-extrusion-vertical-gradient");
                let F;
                if (z && D) {
                  if (YM(r.tileID, m, e1)) continue;
                  const t = D.calculateShadowPassMatrixFromTile(
                    r.tileID.toUnwrapped(),
                  );
                  F = uM(t, x, A);
                } else {
                  const t = e1.translatePosMatrix(
                      f.projMatrix,
                      r,
                      i.paint.get("fill-extrusion-translate"),
                      i.paint.get("fill-extrusion-translate-anchor"),
                    ),
                    n = h.projection.createInversionMatrix(h, f.canonical);
                  F = d
                    ? dM(t, e1, B, p, _, x, f, r, v, w, T, n, E, A)
                    : hM(t, e1, B, p, _, x, f, v, w, T, n, E, A, M, R);
                }
                e1.uploadCommonUniforms(l, k, f.toUnwrapped(), null, S);
                const N = [];
                (e1.terrain || a) && N.push(m.centroidVertexBuffer),
                  b && N.push(m.layoutVertexExtBuffer),
                  k.draw(
                    e1,
                    l.gl.TRIANGLES,
                    n,
                    o,
                    s,
                    Ex.backCCW,
                    F,
                    i.id,
                    m.layoutVertexBuffer,
                    m.indexBuffer,
                    m.segments,
                    i.paint,
                    e1.transform.zoom,
                    P,
                    N,
                  );
              }
              e1.shadowRenderer && (e1.shadowRenderer.useNormalOffset = !1);
            }
            function ZM(
              e1,
              t,
              i,
              r,
              n,
              o,
              s,
              a,
              l,
              c,
              h,
              u,
              d,
              p,
              f,
              m,
              _,
              g,
              y,
            ) {
              const x = e1.context,
                v = x.gl,
                b = e1.transform,
                w = e1.transform.zoom,
                T = [],
                E = $E(e1, i.paint.get("fill-extrusion-cutoff-fade-range"));
              "clear" === c
                ? (T.push("CLEAR_SUBPASS"),
                  y &&
                    (T.push("CLEAR_FROM_TEXTURE"),
                    x.activeTexture.set(v.TEXTURE0),
                    y.bind(v.LINEAR, v.CLAMP_TO_EDGE)))
                : "sdf" === c && T.push("SDF_SUBPASS"),
                _ && T.push("HAS_CENTROID"),
                E.shouldRenderCutoff && T.push("RENDER_CUTOFF");
              const M = i.layout.get("fill-extrusion-edge-radius"),
                A = (t, r, c, g, v) => {
                  const b = r.programConfigurations.get(i.id),
                    A = e1.isTileAffectedByFog(t),
                    S = e1.getOrCreateProgram("fillExtrusionGroundEffect", {
                      config: b,
                      defines: T,
                      overrideFog: A,
                    }),
                    I = ((e1, t, i, r, n, o, s, a, l, c, h) => ({
                      u_matrix: t,
                      u_opacity: i,
                      u_ao_pass: r ? 1 : 0,
                      u_meter_to_tile: n,
                      u_ao: o,
                      u_flood_light_intensity: s,
                      u_flood_light_color: a,
                      u_attenuation: l,
                      u_edge_radius: c,
                      u_fb: 0,
                      u_fb_size: h,
                    }))(
                      0,
                      g,
                      h,
                      l,
                      v,
                      [u, d * v],
                      p,
                      f,
                      m,
                      w >= 17 ? 0 : M * v,
                      y ? y.size[0] : 0,
                    ),
                    C = [];
                  _ && C.push(r.hiddenByLandmarkVertexBuffer),
                    e1.uploadCommonUniforms(x, S, t.toUnwrapped(), null, E),
                    S.draw(
                      e1,
                      x.gl.TRIANGLES,
                      n,
                      o,
                      s,
                      a,
                      I,
                      i.id,
                      r.vertexBuffer,
                      r.indexBuffer,
                      c,
                      i.paint,
                      w,
                      b,
                      C,
                    );
                };
              for (const n of r) {
                const r = t.getTile(n),
                  o = r.getBucket(i);
                if (
                  !o ||
                  o.projection.name !== b.projection.name ||
                  !o.groundEffect ||
                  (o.groundEffect && !o.groundEffect.hasData())
                )
                  continue;
                const s = o.groundEffect,
                  a = 1 / o.tileToMeter;
                {
                  const t = e1.translatePosMatrix(
                      n.projMatrix,
                      r,
                      i.paint.get("fill-extrusion-translate"),
                      i.paint.get("fill-extrusion-translate-anchor"),
                    ),
                    o = s.getDefaultSegment();
                  A(n, s, o, t, a);
                }
                if (g)
                  for (let o = 0; o < 4; o++) {
                    const s = Nu[o](n),
                      l = t.getTile(s);
                    if (!l) continue;
                    const c = l.getBucket(i);
                    if (
                      !c ||
                      c.projection.name !== b.projection.name ||
                      !c.groundEffect ||
                      (c.groundEffect && !c.groundEffect.hasData())
                    )
                      continue;
                    const h = c.groundEffect;
                    let u, d;
                    0 === o
                      ? ((u = [-sr, 0, 0]), (d = 1))
                      : 1 === o
                      ? ((u = [sr, 0, 0]), (d = 0))
                      : 2 === o
                      ? ((u = [0, -sr, 0]), (d = 3))
                      : ((u = [0, sr, 0]), (d = 2));
                    const p = h.regionSegments[d];
                    if (!p) continue;
                    const f = new Float32Array(16);
                    xu.translate(f, n.projMatrix, u),
                      A(
                        n,
                        h,
                        p,
                        e1.translatePosMatrix(
                          f,
                          r,
                          i.paint.get("fill-extrusion-translate"),
                          i.paint.get("fill-extrusion-translate-anchor"),
                        ),
                        a,
                      );
                  }
              }
            }
            function $M(e1, t, i, r, n, o, s) {
              0 === r.centroidVertexArray.length && r.createCentroidsBuffer();
              const a = o ? o.findDEMTileFor(i) : null;
              if (!((a && a.dem) || s)) return;
              const l = (e1) => {
                  const i = t.getSource().minzoom,
                    r = (e1) => {
                      const i = t.getTileByID(e1);
                      if (i && i.hasData()) return i.getBucket(n);
                    },
                    o = [0, -1, 1];
                  for (const t of o) {
                    if (e1.overscaledZ + t < i) continue;
                    const n = r(e1.calculateScaledKey(e1.overscaledZ + t));
                    if (n) return n;
                  }
                },
                c = [0, 0, 0],
                h = (e1, t) => (
                  (c[0] = Math.min(e1.min.y, t.min.y)),
                  (c[1] = Math.max(e1.max.y, t.max.y)),
                  (c[2] = sr - t.min.x > e1.max.x ? t.min.x - sr : e1.max.x),
                  c
                ),
                u = (e1, t) => (
                  (c[0] = Math.min(e1.min.x, t.min.x)),
                  (c[1] = Math.max(e1.max.x, t.max.x)),
                  (c[2] = sr - t.min.y > e1.max.y ? t.min.y - sr : e1.max.y),
                  c
                ),
                d = [
                  (e1, t) => h(e1, t),
                  (e1, t) => h(t, e1),
                  (e1, t) => u(e1, t),
                  (e1, t) => u(t, e1),
                ],
                p = (e1, t, r, n, s, l, c) => {
                  if (!o) return 0;
                  const h = [
                      [l ? r : e1, l ? e1 : r, 0],
                      [l ? r : t, l ? t : r, 0],
                    ],
                    u = c < 0 ? sr + c : c,
                    d = [l ? u : (e1 + t) / 2, l ? (e1 + t) / 2 : u, 0];
                  return (
                    (0 === r && c < 0) || (0 !== r && c > 0)
                      ? o.getForTilePoints(s, [d], !0, n)
                      : h.push(d),
                    o.getForTilePoints(i, h, !0, a),
                    Math.max(h[0][2], h[1][2], d[2]) / o.exaggeration()
                  );
                };
              for (let e1 = 0; e1 < 4; e1++) {
                const t = r.borderFeatureIndices[e1];
                if (0 === t.length) continue;
                const n = Nu[e1](i),
                  a = l(n);
                if (!(a && a instanceof db)) continue;
                if (r.borderDoneWithNeighborZ[e1] === a.canonical.z) continue;
                0 === a.centroidVertexArray.length && a.createCentroidsBuffer();
                const c = o ? o.findDEMTileFor(n) : null;
                if (!((c && c.dem) || s)) continue;
                const h = (e1 < 2 ? 1 : 5) - e1,
                  u = a.borderDoneWithNeighborZ[h] !== r.canonical.z,
                  g = a.borderFeatureIndices[h];
                let x = 0;
                if (r.canonical.z !== a.canonical.z) {
                  for (const e1 of t) r.showCentroid(r.featuresOnBorder[e1]);
                  if (u)
                    for (const e1 of g) a.showCentroid(a.featuresOnBorder[e1]);
                  (r.borderDoneWithNeighborZ[e1] = a.canonical.z),
                    (a.borderDoneWithNeighborZ[h] = r.canonical.z);
                }
                for (const i of t) {
                  const t = r.featuresOnBorder[i],
                    o = r.centroidData[t.centroidDataIndex],
                    l = t.borders[e1];
                  let u;
                  for (; x < g.length; ) {
                    u = a.featuresOnBorder[g[x]];
                    const e1 = u.borders[h];
                    if (e1[1] > l[0] + 3 || e1[0] > l[0] - 3) break;
                    a.showCentroid(u), x++;
                  }
                  if (u && x < g.length) {
                    const i = x;
                    let v = 0;
                    for (
                      ;
                      !(u.borders[h][0] > l[1] - 3) && (v++, ++x !== g.length);

                    )
                      u = a.featuresOnBorder[g[x]];
                    if (((u = a.featuresOnBorder[g[i]]), v > 1)) {
                      const e1 = u.borders[h];
                      Math.abs(l[0] - e1[0]) < 3 &&
                        Math.abs(l[1] - e1[1]) < 3 &&
                        ((v = 1), (x = i + 1));
                    } else if (0 === v) {
                      r.showCentroid(t);
                      continue;
                    }
                    const b = a.centroidData[u.centroidDataIndex];
                    s &&
                      1 === v &&
                      (((m = o).flags | (_ = b).flags) & tb
                        ? ((m.flags |= tb), (_.flags |= tb))
                        : ((m.flags &= 2147483647), (_.flags &= 2147483647)));
                    let w = new y(0, 0);
                    if (v > 1) x = i;
                    else if (
                      c &&
                      c.dem &&
                      !(t.intersectsCount() > 1 || u.intersectsCount() > 1)
                    ) {
                      const t = d[e1](o, b),
                        i = e1 % 2 ? sr - 1 : 0;
                      (f = p(
                        t[0],
                        Math.min(sr - 1, t[1]),
                        i,
                        c,
                        n,
                        e1 < 2,
                        t[2],
                      )),
                        (w = new y(Math.ceil(7 * (f + 450)), 0));
                    }
                    (o.centroidXY = b.centroidXY = w),
                      r.writeCentroidToBuffer(o),
                      a.writeCentroidToBuffer(b);
                  } else r.showCentroid(t);
                }
                (r.borderDoneWithNeighborZ[e1] = a.canonical.z),
                  (a.borderDoneWithNeighborZ[h] = r.canonical.z);
              }
              var f, m, _;
              (r.needsCentroidUpdate ||
                (!r.centroidVertexBuffer &&
                  0 !== r.centroidVertexArray.length)) &&
                r.uploadCentroid(e1);
            }
            const HM = [1, 0, 0],
              WM = [0, 1, 0],
              XM = [0, 0, 1];
            function YM(e1, t, i) {
              const r = i.transform,
                n = i.shadowRenderer;
              if (!n) return !0;
              const o = e1.toUnwrapped(),
                s = r.tileSize * n._cascades[i.currentShadowCascade].scale;
              let a = t.maxHeight;
              if (r.elevation) {
                const t = r.elevation.getMinMaxForTile(e1);
                t && (a += t.max);
              }
              const l = [...n.shadowDirection];
              l[2] = -l[2];
              const c = n.computeSimplifiedTileShadowVolume(o, a, s, l);
              if (!c) return !1;
              const h = [HM, WM, XM, l, [l[0], 0, l[2]], [0, l[1], l[2]]],
                u = "globe" === r.projection.name,
                d = r.scaleZoom(s),
                p = $u.fromInvProjectionMatrix(
                  r.invProjMatrix,
                  r.worldSize,
                  d,
                  !u,
                ),
                f = n.getCurrentCascadeFrustum();
              return (
                0 === p.intersectsPrecise(c.vertices, c.planes, h) ||
                0 === f.intersectsPrecise(c.vertices, c.planes, h)
              );
            }
            const KM = new li(1, 0, 0, 1),
              JM = new li(0, 1, 0, 1),
              QM = new li(0, 0, 1, 1),
              eA = new li(1, 0, 1, 1),
              tA = new li(0, 1, 1, 1);
            function iA(e1, t, i) {
              const r = e1.context,
                n = e1.transform,
                o = r.gl,
                s = "globe" === n.projection.name,
                a = s ? ["PROJECTION_GLOBE_VIEW"] : [];
              let l = i.projMatrix;
              if (s && Ed(n.zoom) > 0) {
                const e1 = vd(cd(i.canonical, n));
                (l = xu.multiply(new Float32Array(16), n.globeMatrix, e1)),
                  xu.multiply(l, n.projMatrix, l);
              }
              const c = e1.getOrCreateProgram("debug", {
                  defines: a,
                }),
                h = t.getTileByID(i.key);
              e1.terrain && e1.terrain.setupElevationDraw(h, c);
              const u = gx.disabled,
                d = xx.disabled,
                p = e1.colorModeForRenderPass(),
                f = "$debug";
              r.activeTexture.set(o.TEXTURE0),
                e1.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE),
                s
                  ? h._makeGlobeTileDebugBuffers(e1.context, n)
                  : h._makeDebugTileBoundsBuffers(e1.context, n.projection);
              const m = h._tileDebugBuffer || e1.debugBuffer,
                _ = h._tileDebugIndexBuffer || e1.debugIndexBuffer,
                g = h._tileDebugSegments || e1.debugSegments;
              c.draw(
                e1,
                o.LINE_STRIP,
                u,
                d,
                p,
                Ex.disabled,
                yM(l, li.red),
                f,
                m,
                _,
                g,
                null,
                null,
                null,
                [h._globeTileDebugBorderBuffer],
              );
              const y = h.latestRawTileData,
                x = Math.floor(((y && y.byteLength) || 0) / 1024),
                v = t.getTile(i).tileSize,
                b = (512 / Math.min(v, 512)) * (i.overscaledZ / n.zoom) * 0.5;
              let w = i.canonical.toString();
              i.overscaledZ !== i.canonical.z && (w += ` => ${i.overscaledZ}`),
                (w += ` ${x}kb`),
                (function (e1, t) {
                  e1.initDebugOverlayCanvas();
                  const i = e1.debugOverlayCanvas,
                    r = e1.context.gl,
                    n = e1.debugOverlayCanvas.getContext("2d");
                  n.clearRect(0, 0, i.width, i.height),
                    (n.shadowColor = "white"),
                    (n.shadowBlur = 2),
                    (n.lineWidth = 1.5),
                    (n.strokeStyle = "white"),
                    (n.textBaseline = "top"),
                    (n.font = "bold 36px Open Sans, sans-serif"),
                    n.fillText(t, 5, 5),
                    n.strokeText(t, 5, 5),
                    e1.debugOverlayTexture.update(i),
                    e1.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
                })(e1, w);
              const T = h._tileDebugTextBuffer || e1.debugBuffer,
                E = h._tileDebugTextIndexBuffer || e1.quadTriangleIndexBuffer,
                M = h._tileDebugTextSegments || e1.debugSegments;
              c.draw(
                e1,
                o.TRIANGLES,
                u,
                d,
                bx.alphaBlended,
                Ex.disabled,
                yM(l, li.transparent, b),
                f,
                T,
                E,
                M,
                null,
                null,
                null,
                [h._globeTileDebugTextBuffer],
              );
            }
            function rA(e1, t, i, r) {
              oA(e1, 0, t + i / 2, e1.transform.width, i, r);
            }
            function nA(e1, t, i, r) {
              oA(e1, t - i / 2, 0, i, e1.transform.height, r);
            }
            function oA(e1, t, i, r, n, o) {
              const s = e1.context,
                a = s.gl;
              a.enable(a.SCISSOR_TEST),
                a.scissor(
                  t * ht.devicePixelRatio,
                  i * ht.devicePixelRatio,
                  r * ht.devicePixelRatio,
                  n * ht.devicePixelRatio,
                ),
                s.clear({
                  color: o,
                }),
                a.disable(a.SCISSOR_TEST);
            }
            const sA = ba([
                {
                  name: "a_pos_3f",
                  components: 3,
                  type: "Float32",
                },
              ]),
              { members: aA } = sA;
            function lA(e1, t, i, r) {
              e1.emplaceBack(t, i, r);
            }
            class cA {
              constructor(e1) {
                (this.vertexArray = new Ua()),
                  (this.indices = new Va()),
                  lA(this.vertexArray, -1, -1, 1),
                  lA(this.vertexArray, 1, -1, 1),
                  lA(this.vertexArray, -1, 1, 1),
                  lA(this.vertexArray, 1, 1, 1),
                  lA(this.vertexArray, -1, -1, -1),
                  lA(this.vertexArray, 1, -1, -1),
                  lA(this.vertexArray, -1, 1, -1),
                  lA(this.vertexArray, 1, 1, -1),
                  this.indices.emplaceBack(5, 1, 3),
                  this.indices.emplaceBack(3, 7, 5),
                  this.indices.emplaceBack(6, 2, 0),
                  this.indices.emplaceBack(0, 4, 6),
                  this.indices.emplaceBack(2, 6, 7),
                  this.indices.emplaceBack(7, 3, 2),
                  this.indices.emplaceBack(5, 4, 0),
                  this.indices.emplaceBack(0, 1, 5),
                  this.indices.emplaceBack(0, 2, 3),
                  this.indices.emplaceBack(3, 1, 0),
                  this.indices.emplaceBack(7, 6, 4),
                  this.indices.emplaceBack(4, 5, 7),
                  (this.vertexBuffer = e1.createVertexBuffer(
                    this.vertexArray,
                    aA,
                  )),
                  (this.indexBuffer = e1.createIndexBuffer(this.indices)),
                  (this.segment = dl.simpleSegment(0, 0, 36, 12));
              }
            }
            function hA(e1, t, i, r, n, o) {
              const s = e1.context.gl,
                a = t.paint.get("sky-atmosphere-color"),
                l = t.paint.get("sky-atmosphere-halo-color"),
                c = t.paint.get("sky-atmosphere-sun-intensity"),
                h = ((e1, t, i, r, n) => ({
                  u_matrix_3f: e1,
                  u_sun_direction: t,
                  u_sun_intensity: i,
                  u_color_tint_r: [r.r, r.g, r.b, r.a],
                  u_color_tint_m: [n.r, n.g, n.b, n.a],
                  u_luminance: 5e-5,
                }))(gu.fromMat4(gu.create(), r), n, c, a, l);
              s.framebufferTexture2D(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0,
                s.TEXTURE_CUBE_MAP_POSITIVE_X + o,
                t.skyboxTexture,
                0,
              ),
                i.draw(
                  e1,
                  s.TRIANGLES,
                  gx.disabled,
                  xx.disabled,
                  bx.unblended,
                  Ex.frontCW,
                  h,
                  "skyboxCapture",
                  t.skyboxGeometry.vertexBuffer,
                  t.skyboxGeometry.indexBuffer,
                  t.skyboxGeometry.segment,
                );
            }
            const uA = ba([
              {
                type: "Float32",
                name: "a_pos",
                components: 3,
              },
              {
                type: "Float32",
                name: "a_uv",
                components: 2,
              },
            ]);
            class dA {
              constructor(e1) {
                const t = new Za();
                t.emplaceBack(-1, 1, 1, 0, 0),
                  t.emplaceBack(1, 1, 1, 1, 0),
                  t.emplaceBack(1, -1, 1, 1, 1),
                  t.emplaceBack(-1, -1, 1, 0, 1);
                const i = new Va();
                i.emplaceBack(0, 1, 2),
                  i.emplaceBack(2, 3, 0),
                  (this.vertexBuffer = e1.createVertexBuffer(t, uA.members)),
                  (this.indexBuffer = e1.createIndexBuffer(i)),
                  (this.segments = dl.simpleSegment(0, 0, 4, 2));
              }
              destroy() {
                this.vertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy();
              }
            }
            const pA = ba([
              {
                type: "Float32",
                name: "a_pos_3f",
                components: 3,
              },
              {
                type: "Float32",
                name: "a_uv",
                components: 2,
              },
              {
                type: "Float32",
                name: "a_size_scale",
                components: 1,
              },
              {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1,
              },
            ]);
            class fA {
              constructor() {
                (this.colorModeAlphaBlendedWriteRGB = new bx(
                  [1, vx, 1, vx],
                  li.transparent,
                  [!0, !0, !0, !1],
                )),
                  (this.colorModeWriteAlpha = new bx(
                    [1, 0, 1, 0],
                    li.transparent,
                    [!1, !1, !1, !0],
                  ));
              }
              update(e1) {
                const t = e1.context;
                if (!this.atmosphereBuffer) {
                  this.atmosphereBuffer = new dA(t);
                  const e1 = 100,
                    i = 200,
                    r = (function (e1) {
                      const t = $n(30),
                        i = [];
                      for (let e1 = 0; e1 < 16e3; ++e1) {
                        const e1 = 2 * Math.PI * t(),
                          r = Math.acos(1 - 2 * t()) - 0.5 * Math.PI;
                        i.push(
                          Mu.fromValues(
                            Math.cos(r) * Math.cos(e1),
                            Math.cos(r) * Math.sin(e1),
                            Math.sin(r),
                          ),
                        );
                      }
                      return i;
                    })(),
                    n = $n(300),
                    o = new $a(),
                    s = new Va();
                  let a = 0;
                  for (let t = 0; t < r.length; ++t) {
                    const l = Mu.scale([], r[t], 200),
                      c = Math.max(0, 1 + 0.01 * e1 * (1 * n() - 0.5)),
                      h = Math.max(0, 1 + 0.01 * i * (1 * n() - 0.5));
                    o.emplaceBack(l[0], l[1], l[2], -1, -1, c, h),
                      o.emplaceBack(l[0], l[1], l[2], 1, -1, c, h),
                      o.emplaceBack(l[0], l[1], l[2], 1, 1, c, h),
                      o.emplaceBack(l[0], l[1], l[2], -1, 1, c, h),
                      s.emplaceBack(a + 0, a + 1, a + 2),
                      s.emplaceBack(a + 0, a + 2, a + 3),
                      (a += 4);
                  }
                  (this.starsVx = t.createVertexBuffer(o, pA.members)),
                    (this.starsIdx = t.createIndexBuffer(s)),
                    (this.starsSegments = dl.simpleSegment(
                      0,
                      0,
                      o.length,
                      s.length,
                    ));
                }
              }
              destroy() {
                this.atmosphereBuffer && this.atmosphereBuffer.destroy(),
                  this.starsVx && this.starsVx.destroy(),
                  this.starsIdx && this.starsIdx.destroy();
              }
              drawAtmosphereGlow(e1, t) {
                const i = e1.context,
                  r = i.gl,
                  n = e1.transform,
                  o = new gx(r.LEQUAL, gx.ReadOnly, [0, 1]),
                  s = Ed(n.zoom),
                  a = t.properties.get("color").toArray01(),
                  l = t.properties.get("high-color").toArray01(),
                  c = t.properties
                    .get("space-color")
                    .toArray01PremultipliedAlpha(),
                  h = 5e-4,
                  u = z(
                    ((t.properties.get("horizon-blend") - 0) / 1) * 0.2495 + h,
                    5e-4,
                    0.25,
                  ),
                  d =
                    Ad(e1, i, n) && u === h
                      ? n.worldSize / (2 * Math.PI * 1.025) - 1
                      : n.globeRadius,
                  p = (e1.frameCounter / 1e3) % 1,
                  f = Mu.length(n.globeCenterInViewSpace),
                  m = Math.sqrt(Math.pow(f, 2) - Math.pow(d, 2)),
                  _ = Math.acos(m / f),
                  g = (t) => {
                    const h =
                      "globe" === n.projection.name
                        ? ["PROJECTION_GLOBE_VIEW", "FOG"]
                        : ["FOG"];
                    t && h.push("ALPHA_PASS");
                    const d = e1.getOrCreateProgram("globeAtmosphere", {
                        defines: h,
                      }),
                      f = ((e1, t, i, r, n, o, s, a, l, c, h, u) => ({
                        u_frustum_tl: e1,
                        u_frustum_tr: t,
                        u_frustum_br: i,
                        u_frustum_bl: r,
                        u_horizon: n,
                        u_transition: o,
                        u_fadeout_range: s,
                        u_color: a,
                        u_high_color: l,
                        u_space_color: c,
                        u_temporal_offset: h,
                        u_horizon_angle: u,
                      }))(
                        n.frustumCorners.TL,
                        n.frustumCorners.TR,
                        n.frustumCorners.BR,
                        n.frustumCorners.BL,
                        n.frustumCorners.horizon,
                        s,
                        u,
                        a,
                        l,
                        c,
                        p,
                        _,
                      );
                    e1.uploadCommonUniforms(i, d);
                    const m = this.atmosphereBuffer;
                    m &&
                      d.draw(
                        e1,
                        r.TRIANGLES,
                        o,
                        xx.disabled,
                        t
                          ? this.colorModeWriteAlpha
                          : this.colorModeAlphaBlendedWriteRGB,
                        Ex.backCW,
                        f,
                        t ? "atmosphere_glow_alpha" : "atmosphere_glow",
                        m.vertexBuffer,
                        m.indexBuffer,
                        m.segments,
                      );
                  };
                g(!1), g(!0);
              }
              drawStars(e1, t) {
                const i = z(t.properties.get("star-intensity"), 0, 1);
                if (0 === i) return;
                const r = e1.context,
                  n = r.gl,
                  o = e1.transform,
                  s = e1.getOrCreateProgram("stars"),
                  a = bu.identity([]);
                bu.rotateX(a, a, -o._pitch),
                  bu.rotateZ(a, a, -o.angle),
                  bu.rotateX(a, a, w(o._center.lat)),
                  bu.rotateY(a, a, -w(o._center.lng));
                const l = xu.fromQuat(new Float32Array(16), a),
                  c = xu.multiply([], o.starsProjMatrix, l),
                  h = gu.fromMat4([], l),
                  u = gu.invert([], h),
                  d = [0, 1, 0];
                Mu.transformMat3(d, d, u), Mu.scale(d, d, 0.15);
                const p = [1, 0, 0];
                Mu.transformMat3(p, p, u), Mu.scale(p, p, 0.15);
                const f = ((e1, t, i, r) => ({
                  u_matrix: Float32Array.from(e1),
                  u_up: t,
                  u_right: i,
                  u_intensity_multiplier: r,
                }))(c, d, p, i);
                e1.uploadCommonUniforms(r, s),
                  this.starsVx &&
                    this.starsIdx &&
                    s.draw(
                      e1,
                      n.TRIANGLES,
                      gx.disabled,
                      xx.disabled,
                      this.colorModeAlphaBlendedWriteRGB,
                      Ex.disabled,
                      f,
                      "atmosphere_stars",
                      this.starsVx,
                      this.starsIdx,
                      this.starsSegments,
                    );
              }
            }
            function mA(e1, t) {
              const i = [...e1],
                r = t.cameraWorldSizeForFog / t.worldSize,
                n = xu.identity([]);
              return (
                xu.scale(n, n, [r, r, 1]),
                xu.multiply(i, n, i),
                xu.multiply(i, t.worldToFogMatrix, i),
                i
              );
            }
            function _A(e1, t, i, r) {
              const n = i.material,
                o = r.context,
                { baseColorTexture: s, metallicRoughnessTexture: a } =
                  n.pbrMetallicRoughness,
                {
                  normalTexture: l,
                  occlusionTexture: c,
                  emissionTexture: h,
                } = n;
              function u(t, i, r) {
                if (
                  t &&
                  (e1.push(i),
                  o.activeTexture.set(o.gl.TEXTURE0 + r),
                  t.gfxTexture)
                ) {
                  const {
                    minFilter: e1,
                    magFilter: i,
                    wrapS: r,
                    wrapT: n,
                  } = t.sampler;
                  t.gfxTexture.bindExtraParam(e1, i, r, n);
                }
              }
              u(s, "HAS_TEXTURE_u_baseColorTexture", zM.BaseColor),
                u(
                  a,
                  "HAS_TEXTURE_u_metallicRoughnessTexture",
                  zM.MetallicRoughness,
                ),
                u(l, "HAS_TEXTURE_u_normalTexture", zM.Normal),
                u(c, "HAS_TEXTURE_u_occlusionTexture", zM.Occlusion),
                u(h, "HAS_TEXTURE_u_emissionTexture", zM.Emission),
                i.texcoordBuffer &&
                  (e1.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(i.texcoordBuffer)),
                i.colorBuffer &&
                  (e1.push(
                    12 === i.colorBuffer.itemSize
                      ? "HAS_ATTRIBUTE_a_color_3f"
                      : "HAS_ATTRIBUTE_a_color_4f",
                  ),
                  t.push(i.colorBuffer)),
                i.normalBuffer &&
                  (e1.push("HAS_ATTRIBUTE_a_normal_3f"),
                  t.push(i.normalBuffer)),
                i.pbrBuffer &&
                  (e1.push("HAS_ATTRIBUTE_a_pbr"),
                  e1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"),
                  t.push(i.pbrBuffer)),
                ("OPAQUE" !== n.alphaMode && "MASK" !== n.alphaMode) ||
                  e1.push("UNPREMULT_TEXTURE_IN_SHADER"),
                n.defined || e1.push("DIFFUSE_SHADED"),
                e1.push("USE_STANDARD_DERIVATIVES");
            }
            function gA(e1, t, i, r, n, o) {
              const s = i.paint.get("model-opacity"),
                a = t.context,
                l = new gx(
                  t.context.gl.LEQUAL,
                  gx.ReadWrite,
                  t.depthRangeFor3D,
                ),
                c = t.transform,
                h = e1.mesh,
                u = h.material,
                d = u.pbrMetallicRoughness,
                p = t.style.fog;
              let f;
              (f =
                "pixels" === t.transform.projection.zAxisUnit
                  ? [...e1.nodeModelMatrix]
                  : xu.multiply([], r.zScaleMatrix, e1.nodeModelMatrix)),
                xu.multiply(f, r.negCameraPosMatrix, f);
              const m = xu.invert([], f);
              xu.transpose(m, m);
              const _ = DM(
                  new Float32Array(e1.worldViewProjection),
                  new Float32Array(f),
                  new Float32Array(m),
                  t,
                  s,
                  d.baseColorFactor,
                  u.emissiveFactor,
                  d.metallicFactor,
                  d.roughnessFactor,
                  u,
                  i,
                ),
                g = {
                  defines: [],
                },
                y = [];
              _A(g.defines, y, h, t);
              const x = t.shadowRenderer;
              x && (x.useNormalOffset = !1);
              let v = null;
              if (p) {
                const i = mA(e1.nodeModelMatrix, t.transform);
                if (
                  ((v = new Float32Array(i)), "globe" !== c.projection.name)
                ) {
                  const e1 = h.aabb.min,
                    t = h.aabb.max,
                    [r, n] = p.getOpacityForBounds(i, e1[0], e1[1], t[0], t[1]);
                  g.overrideFog = r >= sw || n >= sw;
                }
              }
              const b = $E(t, i.paint.get("model-cutoff-fade-range"));
              b.shouldRenderCutoff && g.defines.push("RENDER_CUTOFF");
              const w = t.getOrCreateProgram("model", g);
              t.uploadCommonUniforms(a, w, null, v, b),
                "shadow" !== t.renderPass &&
                  x &&
                  x.setupShadowsFromMatrix(e1.nodeModelMatrix, w),
                w.draw(
                  t,
                  a.gl.TRIANGLES,
                  l,
                  n,
                  o,
                  h.material.doubleSided ? Ex.disabled : Ex.backCCW,
                  _,
                  i.id,
                  h.vertexBuffer,
                  h.indexBuffer,
                  h.segments,
                  i.paint,
                  t.transform.zoom,
                  void 0,
                  y,
                );
            }
            function yA(e1, t, i, r, n, o, s) {
              let a;
              (a = "globe" === e1.projection.name ? yv(i, e1) : [...i]),
                xu.multiply(a, a, t.matrix);
              const l = xu.multiply([], r, a);
              if (t.meshes)
                for (const e1 of t.meshes) {
                  if ("BLEND" !== e1.material.alphaMode) {
                    s.push({
                      mesh: e1,
                      depth: 0,
                      modelIndex: n,
                      worldViewProjection: l,
                      nodeModelMatrix: a,
                    });
                    continue;
                  }
                  const t = Mu.transformMat4([], e1.centroid, l);
                  t[2] > 0 &&
                    o.push({
                      mesh: e1,
                      depth: t[2],
                      modelIndex: n,
                      worldViewProjection: l,
                      nodeModelMatrix: a,
                    });
                }
              if (t.children)
                for (const a of t.children) yA(e1, a, i, r, n, o, s);
            }
            function xA(e1, t, i, r) {
              const n = i.shadowRenderer;
              if (!n) return;
              const o = n.getShadowPassDepthMode(),
                s = n.getShadowPassColorMode(),
                a = n.calculateShadowPassMatrixFromMatrix(t),
                l = RM(a);
              i.getOrCreateProgram("modelDepth", {
                defines: ["DEPTH_TEXTURE"],
              }).draw(
                i,
                i.context.gl.TRIANGLES,
                o,
                xx.disabled,
                s,
                Ex.backCCW,
                l,
                r.id,
                e1.vertexBuffer,
                e1.indexBuffer,
                e1.segments,
                r.paint,
                i.transform.zoom,
                void 0,
                void 0,
              );
            }
            function vA(e1, t, i) {
              const r = t.updateZoomBasedPaintProperties(),
                n = (function (e1, t, i) {
                  let r,
                    n,
                    o,
                    s = e1.terrain ? e1.terrain.exaggeration() : 0;
                  if (e1.terrain && s > 0) {
                    const t = e1.terrain,
                      n = t.findDEMTileFor(i);
                    n && n.dem ? (r = qm.create(t, i, n)) : (s = 0);
                  }
                  if (
                    (0 === s &&
                      ((t.terrainElevationMin = 0),
                      (t.terrainElevationMax = 0)),
                    s === t.validForExaggeration &&
                      (0 === s ||
                        (r &&
                          r._demTile &&
                          r._demTile.tileID === t.validForDEMTile.id &&
                          r._dem._timestamp === t.validForDEMTile.timestamp)))
                  )
                    return !1;
                  for (const e1 in t.instancesPerModel) {
                    const i = t.instancesPerModel[e1];
                    for (let e1 = 0; e1 < i.instancedDataArray.length; ++e1) {
                      const a =
                        (r
                          ? s *
                            r.getElevationAt(
                              0 | i.instancedDataArray.float32[16 * e1],
                              0 | i.instancedDataArray.float32[16 * e1 + 1],
                              !0,
                              !0,
                            )
                          : 0) + i.instancesEvaluatedElevation[e1];
                      (i.instancedDataArray.float32[16 * e1 + 6] = a),
                        (n = n ? Math.min(t.terrainElevationMin, a) : a),
                        (o = o ? Math.max(t.terrainElevationMax, a) : a);
                    }
                  }
                  return (
                    (t.terrainElevationMin = n || 0),
                    (t.terrainElevationMax = o || 0),
                    (t.validForExaggeration = s),
                    (t.validForDEMTile =
                      r && r._demTile
                        ? {
                            id: r._demTile.tileID,
                            timestamp: r._dem._timestamp,
                          }
                        : {
                            id: void 0,
                            timestamp: 0,
                          }),
                    !0
                  );
                })(e1, t, i);
              (r || n) && ((t.uploaded = !1), t.upload(e1.context));
            }
            const bA = {
              shadowUniformsInitialized: !1,
              useSingleShadowCascade: !1,
              tileMatrix: new Float64Array(16),
              shadowTileMatrix: new Float32Array(16),
              aabb: new Hu([0, 0, 0], [sr, sr, 0]),
            };
            function wA(e1, t) {
              const i = 1 << e1.canonical.z,
                r = t.getFreeCameraOptions().position,
                n = t.elevation,
                o = e1.canonical.x / i,
                s = (e1.canonical.x + 1) / i,
                a = e1.canonical.y / i,
                l = (e1.canonical.y + 1) / i;
              let c = t._centerAltitude;
              if (n) {
                const t = n.getMinMaxForTile(e1);
                t && t.max > c && (c = t.max);
              }
              const h = z(r.x, o, s) - r.x,
                u = z(r.y, a, l) - r.y,
                d = Zd(c, t.center.lat) - r.z;
              return t._zoomFromMercatorZ(Math.sqrt(h * h + u * u + d * d));
            }
            function TA(e1, t, i, r, n, o, s) {
              const a = e1.context,
                l = "shadow" === e1.renderPass,
                c = e1.shadowRenderer,
                h =
                  l && c
                    ? c.getShadowPassDepthMode()
                    : new gx(a.gl.LEQUAL, gx.ReadWrite, e1.depthRangeFor3D),
                u = e1.isTileAffectedByFog(o);
              if (i.meshes)
                for (const d of i.meshes) {
                  const p = ["MODEL_POSITION_ON_GPU"],
                    f = [];
                  let m, _, g;
                  r.instancedDataArray.length > 20 &&
                    p.push("INSTANCED_ARRAYS");
                  const y = $E(e1, t.paint.get("model-cutoff-fade-range"));
                  if ((y.shouldRenderCutoff && p.push("RENDER_CUTOFF"), l && c))
                    (m = e1.getOrCreateProgram("modelDepth", {
                      defines: p,
                    })),
                      (_ = RM(
                        s.shadowTileMatrix,
                        s.shadowTileMatrix,
                        Float32Array.from(i.matrix),
                      )),
                      (g = c.getShadowPassColorMode());
                  else {
                    _A(p, f, d, e1),
                      (m = e1.getOrCreateProgram("model", {
                        defines: p,
                        overrideFog: u,
                      }));
                    const r = d.material,
                      l = r.pbrMetallicRoughness,
                      h = t.paint.get("model-opacity");
                    (_ = DM(
                      o.projMatrix,
                      Float32Array.from(i.matrix),
                      new Float32Array(16),
                      e1,
                      h,
                      l.baseColorFactor,
                      r.emissiveFactor,
                      l.metallicFactor,
                      l.roughnessFactor,
                      r,
                      t,
                      n,
                    )),
                      c &&
                        (s.shadowUniformsInitialized
                          ? m.setShadowUniformValues(
                              a,
                              c.getShadowUniformValues(),
                            )
                          : (c.setupShadows(
                              o.toUnwrapped(),
                              m,
                              "model-tile",
                              o.overscaledZ,
                            ),
                            (s.shadowUniformsInitialized = !0))),
                      (g =
                        y.shouldRenderCutoff ||
                        h < 1 ||
                        "OPAQUE" !== r.alphaMode
                          ? bx.alphaBlended
                          : bx.unblended);
                  }
                  e1.uploadCommonUniforms(a, m, o.toUnwrapped(), null, y);
                  const x = d.material.doubleSided ? Ex.disabled : Ex.backCCW;
                  if (r.instancedDataArray.length > 20)
                    f.push(r.instancedDataBuffer),
                      m.draw(
                        e1,
                        a.gl.TRIANGLES,
                        h,
                        xx.disabled,
                        g,
                        x,
                        _,
                        t.id,
                        d.vertexBuffer,
                        d.indexBuffer,
                        d.segments,
                        t.paint,
                        e1.transform.zoom,
                        void 0,
                        f,
                        r.instancedDataArray.length,
                      );
                  else {
                    const i = l ? "u_instance" : "u_normal_matrix";
                    for (let n = 0; n < r.instancedDataArray.length; ++n)
                      (_[i] = new Float32Array(
                        r.instancedDataArray.arrayBuffer,
                        64 * n,
                        16,
                      )),
                        m.draw(
                          e1,
                          a.gl.TRIANGLES,
                          h,
                          xx.disabled,
                          g,
                          x,
                          _,
                          t.id,
                          d.vertexBuffer,
                          d.indexBuffer,
                          d.segments,
                          t.paint,
                          e1.transform.zoom,
                          void 0,
                          f,
                        );
                  }
                }
              if (i.children)
                for (const a of i.children) TA(e1, t, a, r, n, o, s);
            }
            const EA = [1, -1, 1];
            function MA(e1, t, i, r) {
              if (!i.modelManager) return !0;
              const n = i.modelManager;
              if (!i.shadowRenderer) return !0;
              const o = i.shadowRenderer,
                s = t.aabb;
              let a = !0,
                l = e1.maxHeight;
              if (0 === l) {
                let t = 0;
                for (const i in e1.instancesPerModel) {
                  const e1 = n.getModel(i, r);
                  e1
                    ? (t = Math.max(
                        t,
                        Math.max(
                          Math.max(e1.aabb.max[0], e1.aabb.max[1]),
                          e1.aabb.max[2],
                        ),
                      ))
                    : (a = !1);
                }
                (l = e1.maxScale * t * 1.41 + e1.maxVerticalOffset),
                  a && (e1.maxHeight = l);
              }
              (s.max[2] = l),
                (s.min[2] += e1.terrainElevationMin),
                (s.max[2] += e1.terrainElevationMax),
                Mu.transformMat4(s.min, s.min, t.tileMatrix),
                Mu.transformMat4(s.max, s.max, t.tileMatrix);
              const c = s.intersects(o.getCurrentCascadeFrustum());
              return (
                0 === i.currentShadowCascade &&
                  (e1.isInsideFirstShadowMapFrustum = 2 === c),
                0 === c
              );
            }
            class AA {}
            class SA {
              constructor() {
                this._storage = new Map();
              }
              getLinesFromTrianglesBuffer(e1, t, i) {
                {
                  const i = this._storage.get(t.id);
                  if (i) return (i.lastUsedFrameIdx = e1), i.buf;
                }
                const r = i.gl,
                  n = r.getBufferParameter(
                    r.ELEMENT_ARRAY_BUFFER,
                    r.BUFFER_SIZE,
                  ),
                  o = new ArrayBuffer(n),
                  s = new Int16Array(o);
                r.getBufferSubData(
                  r.ELEMENT_ARRAY_BUFFER,
                  0,
                  new Int16Array(o),
                );
                const a = new ka();
                for (let e1 = 0; e1 < n / 2; e1 += 3) {
                  const t = s[e1],
                    i = s[e1 + 1],
                    r = s[e1 + 2];
                  a.emplaceBack(t, i), a.emplaceBack(i, r), a.emplaceBack(r, t);
                }
                const l = i.bindVertexArrayOES.current,
                  c = new AA();
                return (
                  (c.buf = new zy(i, a)),
                  (c.lastUsedFrameIdx = e1),
                  this._storage.set(t.id, c),
                  i.bindVertexArrayOES.set(l),
                  c.buf
                );
              }
              update(e1) {
                for (const [t, i] of this._storage)
                  e1 - i.lastUsedFrameIdx > 30 &&
                    (i.buf.destroy(), this._storage.delete(t));
              }
              destroy() {
                for (const [e1, t] of this._storage)
                  t.buf.destroy(), this._storage.delete(e1);
              }
            }
            const IA = {
                symbol: function (e1, t, i, r, n) {
                  if ("translucent" !== e1.renderPass) return;
                  const o = xx.disabled,
                    s = e1.colorModeForRenderPass();
                  i.layout.get("text-variable-anchor") &&
                    (function (e1, t, i, r, n, o, s) {
                      const a = t.transform,
                        l = "map" === n,
                        c = "map" === o;
                      for (const t of e1) {
                        const e1 = r.getTile(t),
                          n = e1.getBucket(i);
                        if (!n || !n.text || !n.text.segments.get().length)
                          continue;
                        const o = a_(n.textSizeData, a.zoom),
                          h = GT(t, n.getProjection(), a),
                          u = a.calculatePixelsToTileUnitsMatrix(e1),
                          d = Jx(
                            h,
                            e1.tileID.canonical,
                            c,
                            l,
                            a,
                            n.getProjection(),
                            u,
                          ),
                          p = n.hasIconTextFit() && n.hasIconData();
                        if (o) {
                          const i = Math.pow(2, a.zoom - e1.tileID.overscaledZ);
                          NM(n, l, c, s, l_, a, d, t, i, o, p);
                        }
                      }
                    })(
                      r,
                      e1,
                      i,
                      t,
                      i.layout.get("text-rotation-alignment"),
                      i.layout.get("text-pitch-alignment"),
                      n,
                    ),
                    0 !== i.paint.get("icon-opacity").constantOr(1) &&
                      VM(
                        e1,
                        t,
                        i,
                        r,
                        !1,
                        i.paint.get("icon-translate"),
                        i.paint.get("icon-translate-anchor"),
                        i.layout.get("icon-rotation-alignment"),
                        i.layout.get("icon-pitch-alignment"),
                        i.layout.get("icon-keep-upright"),
                        o,
                        s,
                      ),
                    0 !== i.paint.get("text-opacity").constantOr(1) &&
                      VM(
                        e1,
                        t,
                        i,
                        r,
                        !0,
                        i.paint.get("text-translate"),
                        i.paint.get("text-translate-anchor"),
                        i.layout.get("text-rotation-alignment"),
                        i.layout.get("text-pitch-alignment"),
                        i.layout.get("text-keep-upright"),
                        o,
                        s,
                      ),
                    t.map.showCollisionBoxes &&
                      (OM(
                        e1,
                        t,
                        i,
                        r,
                        i.paint.get("text-translate"),
                        i.paint.get("text-translate-anchor"),
                        !0,
                      ),
                      OM(
                        e1,
                        t,
                        i,
                        r,
                        i.paint.get("icon-translate"),
                        i.paint.get("icon-translate-anchor"),
                        !1,
                      ));
                },
                circle: function (e1, t, i, r) {
                  if ("translucent" !== e1.renderPass) return;
                  const n = i.paint.get("circle-opacity"),
                    o = i.paint.get("circle-stroke-width"),
                    s = i.paint.get("circle-stroke-opacity"),
                    a =
                      void 0 !== i.layout.get("circle-sort-key").constantOr(1),
                    l = i.paint.get("circle-emissive-strength");
                  if (
                    0 === n.constantOr(1) &&
                    (0 === o.constantOr(1) || 0 === s.constantOr(1))
                  )
                    return;
                  const c = e1.context,
                    h = c.gl,
                    u = e1.transform,
                    d = e1.depthModeForSublayer(0, gx.ReadOnly),
                    p = xx.disabled,
                    f = e1.colorModeForDrapableLayerRenderPass(l),
                    m = "globe" === u.projection.name,
                    _ = [Gd(u.center.lng), qd(u.center.lat)],
                    g = [];
                  for (let n = 0; n < r.length; n++) {
                    const o = r[n],
                      s = t.getTile(o),
                      l = s.getBucket(i);
                    if (!l || l.projection.name !== u.projection.name) continue;
                    const c = l.programConfigurations.get(i.id),
                      h = kp(i),
                      d = e1.isTileAffectedByFog(o);
                    m && h.push("PROJECTION_GLOBE_VIEW");
                    const p = e1.getOrCreateProgram("circle", {
                        config: c,
                        defines: h,
                        overrideFog: d,
                      }),
                      f = l.layoutVertexBuffer,
                      y = l.globeExtVertexBuffer,
                      x = l.indexBuffer,
                      v = u.projection.createInversionMatrix(u, o.canonical),
                      b = {
                        programConfiguration: c,
                        program: p,
                        layoutVertexBuffer: f,
                        globeExtVertexBuffer: y,
                        indexBuffer: x,
                        uniformValues: Lp(e1, o, s, v, _, i),
                        tile: s,
                      };
                    if (a) {
                      const e1 = l.segments.get();
                      for (const t of e1)
                        g.push({
                          segments: new dl([t]),
                          sortKey: t.sortKey,
                          state: b,
                        });
                    } else
                      g.push({
                        segments: l.segments,
                        sortKey: 0,
                        state: b,
                      });
                  }
                  a && g.sort((e1, t) => e1.sortKey - t.sortKey);
                  const y = {
                    useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles,
                  };
                  for (const t of g) {
                    const {
                        programConfiguration: r,
                        program: n,
                        layoutVertexBuffer: o,
                        globeExtVertexBuffer: s,
                        indexBuffer: a,
                        uniformValues: l,
                        tile: m,
                      } = t.state,
                      _ = t.segments;
                    e1.terrain && e1.terrain.setupElevationDraw(m, n, y),
                      e1.uploadCommonUniforms(c, n, m.tileID.toUnwrapped()),
                      n.draw(
                        e1,
                        h.TRIANGLES,
                        d,
                        p,
                        f,
                        Ex.disabled,
                        l,
                        i.id,
                        o,
                        a,
                        _,
                        i.paint,
                        u.zoom,
                        r,
                        [s],
                      );
                  }
                },
                heatmap: function (e1, t, i, r) {
                  if (0 !== i.paint.get("heatmap-opacity")) {
                    if ("offscreen" === e1.renderPass) {
                      const n = e1.context,
                        o = n.gl,
                        s = xx.disabled,
                        a = new bx(
                          [o.ONE, o.ONE, o.ONE, o.ONE],
                          li.transparent,
                          [!0, !0, !0, !0],
                        );
                      !(function (e1, t, i, r) {
                        const n = e1.gl,
                          o = t.width * r,
                          s = t.height * r;
                        e1.activeTexture.set(n.TEXTURE1),
                          e1.viewport.set([0, 0, o, s]);
                        let a = i.heatmapFbo;
                        if (!a || (a && (a.width !== o || a.height !== s))) {
                          a && a.destroy();
                          const t = n.createTexture();
                          n.bindTexture(n.TEXTURE_2D, t),
                            n.texParameteri(
                              n.TEXTURE_2D,
                              n.TEXTURE_WRAP_S,
                              n.CLAMP_TO_EDGE,
                            ),
                            n.texParameteri(
                              n.TEXTURE_2D,
                              n.TEXTURE_WRAP_T,
                              n.CLAMP_TO_EDGE,
                            ),
                            n.texParameteri(
                              n.TEXTURE_2D,
                              n.TEXTURE_MIN_FILTER,
                              n.LINEAR,
                            ),
                            n.texParameteri(
                              n.TEXTURE_2D,
                              n.TEXTURE_MAG_FILTER,
                              n.LINEAR,
                            ),
                            (a = i.heatmapFbo =
                              e1.createFramebuffer(o, s, !0, null)),
                            (function (e1, t, i, r, n, o) {
                              const s = e1.gl;
                              s.texImage2D(
                                s.TEXTURE_2D,
                                0,
                                e1.extRenderToTextureHalfFloat
                                  ? s.RGBA16F
                                  : s.RGBA,
                                n,
                                o,
                                0,
                                s.RGBA,
                                e1.extRenderToTextureHalfFloat
                                  ? s.HALF_FLOAT
                                  : s.UNSIGNED_BYTE,
                                null,
                              ),
                                r.colorAttachment.set(i);
                            })(e1, 0, t, a, o, s);
                        } else
                          n.bindTexture(n.TEXTURE_2D, a.colorAttachment.get()),
                            e1.bindFramebuffer.set(a.framebuffer);
                      })(
                        n,
                        e1,
                        i,
                        "globe" === e1.transform.projection.name ? 0.5 : 0.25,
                      ),
                        n.clear({
                          color: li.transparent,
                        });
                      const l = e1.transform,
                        c = "globe" === l.projection.name,
                        h = c ? ["PROJECTION_GLOBE_VIEW"] : [],
                        u = c ? Ex.frontCCW : Ex.disabled,
                        d = [Gd(l.center.lng), qd(l.center.lat)];
                      for (let p = 0; p < r.length; p++) {
                        const f = r[p];
                        if (t.hasRenderableParent(f)) continue;
                        const m = t.getTile(f),
                          _ = m.getBucket(i);
                        if (!_ || _.projection.name !== l.projection.name)
                          continue;
                        const g = e1.isTileAffectedByFog(f),
                          y = _.programConfigurations.get(i.id),
                          x = e1.getOrCreateProgram("heatmap", {
                            config: y,
                            defines: h,
                            overrideFog: g,
                          }),
                          { zoom: v } = e1.transform;
                        e1.terrain && e1.terrain.setupElevationDraw(m, x),
                          e1.uploadCommonUniforms(n, x, f.toUnwrapped());
                        const b = l.projection.createInversionMatrix(
                          l,
                          f.canonical,
                        );
                        x.draw(
                          e1,
                          o.TRIANGLES,
                          gx.disabled,
                          s,
                          a,
                          u,
                          vM(
                            e1,
                            f,
                            m,
                            b,
                            d,
                            v,
                            i.paint.get("heatmap-intensity"),
                          ),
                          i.id,
                          _.layoutVertexBuffer,
                          _.indexBuffer,
                          _.segments,
                          i.paint,
                          e1.transform.zoom,
                          y,
                          c ? [_.globeExtVertexBuffer] : null,
                        );
                      }
                      n.viewport.set([0, 0, e1.width, e1.height]);
                    } else
                      "translucent" === e1.renderPass &&
                        (e1.context.setColorMode(e1.colorModeForRenderPass()),
                        (function (e1, t) {
                          const i = e1.context,
                            r = i.gl,
                            n = t.heatmapFbo;
                          if (!n) return;
                          i.activeTexture.set(r.TEXTURE0),
                            r.bindTexture(
                              r.TEXTURE_2D,
                              n.colorAttachment.get(),
                            ),
                            i.activeTexture.set(r.TEXTURE1);
                          let o = t.colorRampTexture;
                          o ||
                            (o = t.colorRampTexture =
                              new gy(i, t.colorRamp, r.RGBA)),
                            o.bind(r.LINEAR, r.CLAMP_TO_EDGE),
                            e1.getOrCreateProgram("heatmapTexture").draw(
                              e1,
                              r.TRIANGLES,
                              gx.disabled,
                              xx.disabled,
                              e1.colorModeForRenderPass(),
                              Ex.disabled,
                              ((e1, t, i, r) => ({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: t.paint.get("heatmap-opacity"),
                              }))(0, t),
                              t.id,
                              e1.viewportBuffer,
                              e1.quadTriangleIndexBuffer,
                              e1.viewportSegments,
                              t.paint,
                              e1.transform.zoom,
                            );
                        })(e1, i));
                  }
                },
                line: function (e1, t, i, r) {
                  if ("translucent" !== e1.renderPass) return;
                  const n = i.paint.get("line-opacity"),
                    o = i.paint.get("line-width");
                  if (0 === n.constantOr(1) || 0 === o.constantOr(1)) return;
                  const s = i.paint.get("line-emissive-strength"),
                    a = e1.depthModeForSublayer(0, gx.ReadOnly),
                    l = e1.colorModeForDrapableLayerRenderPass(s),
                    c =
                      e1.terrain && e1.terrain.renderingToTexture
                        ? 1
                        : ht.devicePixelRatio,
                    h = i.paint.get("line-dasharray"),
                    u = h.constantOr(1),
                    d = i.layout.get("line-cap"),
                    p = i.paint.get("line-pattern"),
                    f = p.constantOr(1),
                    m = i.paint.get("line-pattern").constantOr(1),
                    _ = 1 !== i.paint.get("line-opacity").constantOr(1);
                  let g = !m && _;
                  const y = i.paint.get("line-gradient"),
                    x = f ? "linePattern" : "line",
                    v = e1.context,
                    b = v.gl,
                    w = kb(i);
                  e1.terrain &&
                    e1.terrain.clipOrMaskOverlapStencilType() &&
                    (g = !1);
                  for (const n of r) {
                    const r = t.getTile(n);
                    if (f && !r.patternsLoaded()) continue;
                    const o = r.getBucket(i);
                    if (!o) continue;
                    e1.prepareDrawTile();
                    const s = o.programConfigurations.get(i.id),
                      m = e1.isTileAffectedByFog(n),
                      _ = e1.getOrCreateProgram(x, {
                        config: s,
                        defines: w,
                        overrideFog: m,
                      }),
                      T = p.constantOr(null);
                    if (T && r.imageAtlas) {
                      const e1 = r.imageAtlas.patternPositions[T.toString()];
                      e1 && s.setConstantPatternPositions(e1);
                    }
                    const E = h.constantOr(null),
                      M = d.constantOr(null);
                    if (!f && E && M && r.lineAtlas) {
                      const e1 = r.lineAtlas.getDash(E, M);
                      e1 && s.setConstantPatternPositions(e1);
                    }
                    let [A, S] = i.paint.get("line-trim-offset");
                    if ("round" === M || "square" === M) {
                      const e1 = 1;
                      A !== S && (0 === A && (A -= e1), 1 === S && (S += e1));
                    }
                    const I = e1.terrain ? n.projMatrix : null,
                      C = f
                        ? Pb(e1, r, i, I, c)
                        : Db(e1, r, i, I, o.lineClipsArray.length, c, [A, S]);
                    if (y) {
                      const r = o.gradients[i.id];
                      let s = r.texture;
                      if (i.gradientVersion !== r.version) {
                        let a = 256;
                        if (i.stepInterpolant) {
                          const i = t.getSource().maxzoom,
                            r =
                              n.canonical.z === i
                                ? Math.ceil(
                                    1 << (e1.transform.maxZoom - n.canonical.z),
                                  )
                                : 1;
                          a = z(
                            U((o.maxLineLength / sr) * 1024 * r),
                            256,
                            v.maxTextureSize,
                          );
                        }
                        (r.gradient = Yp({
                          expression: i.gradientExpression(),
                          evaluationKey: "lineProgress",
                          resolution: a,
                          image: r.gradient || void 0,
                          clips: o.lineClipsArray,
                        })),
                          r.texture
                            ? r.texture.update(r.gradient)
                            : (r.texture = new gy(v, r.gradient, b.RGBA)),
                          (r.version = i.gradientVersion),
                          (s = r.texture);
                      }
                      v.activeTexture.set(b.TEXTURE1),
                        s.bind(
                          i.stepInterpolant ? b.NEAREST : b.LINEAR,
                          b.CLAMP_TO_EDGE,
                        );
                    }
                    u &&
                      (v.activeTexture.set(b.TEXTURE0),
                      r.lineAtlasTexture.bind(b.LINEAR, b.REPEAT),
                      s.updatePaintBuffers()),
                      f &&
                        (v.activeTexture.set(b.TEXTURE0),
                        r.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE),
                        s.updatePaintBuffers()),
                      e1.uploadCommonUniforms(v, _, n.toUnwrapped());
                    const D = (t) => {
                      _.draw(
                        e1,
                        b.TRIANGLES,
                        a,
                        t,
                        l,
                        Ex.disabled,
                        C,
                        i.id,
                        o.layoutVertexBuffer,
                        o.indexBuffer,
                        o.segments,
                        i.paint,
                        e1.transform.zoom,
                        s,
                        [o.layoutVertexBuffer2],
                      );
                    };
                    if (g) {
                      const t = e1.stencilModeForClipping(n).ref;
                      0 === t &&
                        e1.terrain &&
                        v.clear({
                          stencil: 0,
                        });
                      const i = {
                        func: b.EQUAL,
                        mask: 255,
                      };
                      (C.u_alpha_discard_threshold = 0.8),
                        D(new xx(i, t, 255, b.KEEP, b.KEEP, b.INVERT)),
                        (C.u_alpha_discard_threshold = 0),
                        D(new xx(i, t, 255, b.KEEP, b.KEEP, b.KEEP));
                    } else D(e1.stencilModeForClipping(n));
                  }
                  g &&
                    (e1.resetStencilClippingMasks(),
                    e1.terrain &&
                      v.clear({
                        stencil: 0,
                      }));
                },
                fill: function (e1, t, i, r) {
                  const n = i.paint.get("fill-color"),
                    o = i.paint.get("fill-opacity");
                  if (0 === o.constantOr(1)) return;
                  const s = i.paint.get("fill-emissive-strength"),
                    a = e1.colorModeForDrapableLayerRenderPass(s),
                    l = i.paint.get("fill-pattern"),
                    c =
                      e1.opaquePassEnabledForLayer() &&
                      !l.constantOr(1) &&
                      1 === n.constantOr(li.transparent).a &&
                      1 === o.constantOr(0)
                        ? "opaque"
                        : "translucent";
                  if (e1.renderPass === c) {
                    const n = e1.depthModeForSublayer(
                      1,
                      "opaque" === e1.renderPass ? gx.ReadWrite : gx.ReadOnly,
                    );
                    GM(e1, t, i, r, n, a, !1);
                  }
                  if (
                    "translucent" === e1.renderPass &&
                    i.paint.get("fill-antialias")
                  ) {
                    const n = e1.depthModeForSublayer(
                      i.getPaintProperty("fill-outline-color") ? 2 : 0,
                      gx.ReadOnly,
                    );
                    GM(e1, t, i, r, n, a, !0);
                  }
                },
                "fill-extrusion": function (e1, t, i, r) {
                  const n = i.paint.get("fill-extrusion-opacity"),
                    o = e1.context,
                    s = o.gl,
                    a = e1.terrain,
                    l = a && a.renderingToTexture,
                    c = i.paint.get("fill-extrusion-cutoff-fade-range");
                  if (0 === n) return;
                  const h =
                    e1.conflationActive &&
                    e1.layerUsedInConflation(i, t.getSource());
                  if (
                    (h &&
                      (function (e1, t, i, r) {
                        for (const n of r) {
                          const r = t.getTile(n).getBucket(i);
                          r &&
                            (r.updateReplacement(n, e1.replacementSource),
                            r.uploadCentroid(e1.context));
                        }
                      })(e1, t, i, r),
                    a || h)
                  )
                    for (const n of r) {
                      const r = t.getTile(n).getBucket(i);
                      r && $M(e1.context, t, n, r, i, a, h);
                    }
                  if ("shadow" === e1.renderPass && e1.shadowRenderer) {
                    const o = e1.shadowRenderer;
                    if (
                      a &&
                      n < 0.65 &&
                      i._transitionablePaint._values["fill-extrusion-opacity"]
                        .value.expression instanceof bo
                    )
                      return;
                    const s = o.getShadowPassDepthMode(),
                      l = o.getShadowPassColorMode();
                    qM(e1, t, i, r, s, xx.disabled, l, h);
                  } else if ("translucent" === e1.renderPass) {
                    const u = !i.paint
                      .get("fill-extrusion-pattern")
                      .constantOr(1);
                    if (!l) {
                      const o = new gx(
                        e1.context.gl.LEQUAL,
                        gx.ReadWrite,
                        e1.depthRangeFor3D,
                      );
                      0 === c && 1 === n && u
                        ? qM(e1, t, i, r, o, xx.disabled, bx.unblended, h)
                        : (qM(e1, t, i, r, o, xx.disabled, bx.disabled, h),
                          qM(
                            e1,
                            t,
                            i,
                            r,
                            o,
                            e1.stencilModeFor3D(),
                            e1.colorModeForRenderPass(),
                            h,
                          ),
                          e1.resetStencilClippingMasks());
                    }
                    if (
                      e1.style.enable3dLights() &&
                      u &&
                      ((!a && "globe" !== e1.transform.projection.name) || l)
                    ) {
                      const n = i.paint.get("fill-extrusion-opacity"),
                        c = i.paint.get(
                          "fill-extrusion-ambient-occlusion-intensity",
                        ),
                        u = i.paint.get(
                          "fill-extrusion-ambient-occlusion-ground-radius",
                        ),
                        d = i.paint.get("fill-extrusion-flood-light-intensity"),
                        p = i.paint
                          .get("fill-extrusion-flood-light-color")
                          .toArray01()
                          .slice(0, 3),
                        f = c > 0 && u > 0,
                        m = d > 0,
                        _ = (e1, t, i) => (1 - i) * e1 + i * t,
                        g = (o) => {
                          const a = e1.depthModeForSublayer(
                              1,
                              gx.ReadOnly,
                              s.LEQUAL,
                              !0,
                            ),
                            l = i.paint.get(
                              o
                                ? "fill-extrusion-ambient-occlusion-ground-attenuation"
                                : "fill-extrusion-flood-light-ground-attenuation",
                            ),
                            f = _(0.1, 3, l),
                            m = e1._showOverdrawInspector;
                          if (!m) {
                            const l = new xx(
                                {
                                  func: s.ALWAYS,
                                  mask: 255,
                                },
                                255,
                                255,
                                s.KEEP,
                                s.KEEP,
                                s.REPLACE,
                              ),
                              m = new bx(
                                [s.ONE, s.ONE, s.ONE, s.ONE],
                                li.transparent,
                                [!1, !1, !1, !0],
                                s.MIN,
                              );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              a,
                              l,
                              m,
                              Ex.disabled,
                              o,
                              "sdf",
                              n,
                              c,
                              u,
                              d,
                              p,
                              f,
                              h,
                              !1,
                            );
                          }
                          {
                            const l = m
                                ? xx.disabled
                                : new xx(
                                    {
                                      func: s.EQUAL,
                                      mask: 255,
                                    },
                                    255,
                                    255,
                                    s.KEEP,
                                    s.DECR,
                                    s.DECR,
                                  ),
                              _ = m
                                ? e1.colorModeForRenderPass()
                                : new bx(
                                    [
                                      s.ONE_MINUS_DST_ALPHA,
                                      s.DST_ALPHA,
                                      s.ONE,
                                      s.ONE,
                                    ],
                                    li.transparent,
                                    [!0, !0, !0, !0],
                                  );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              a,
                              l,
                              _,
                              Ex.disabled,
                              o,
                              "color",
                              n,
                              c,
                              u,
                              d,
                              p,
                              f,
                              h,
                              !1,
                            );
                          }
                        };
                      if (l) {
                        const l = (o, a, l) => {
                          const f = e1.depthModeForSublayer(
                              1,
                              gx.ReadOnly,
                              s.LEQUAL,
                              !1,
                            ),
                            m = i.paint.get(
                              o
                                ? "fill-extrusion-ambient-occlusion-ground-attenuation"
                                : "fill-extrusion-flood-light-ground-attenuation",
                            ),
                            g = _(0.1, 3, m);
                          {
                            const l = new bx(
                              [s.ONE, s.ONE, s.ONE, s.ONE],
                              li.transparent,
                              [!1, !1, !1, !0],
                            );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              f,
                              xx.disabled,
                              l,
                              Ex.disabled,
                              o,
                              "clear",
                              n,
                              c,
                              u,
                              d,
                              p,
                              g,
                              h,
                              a,
                            );
                          }
                          {
                            const l = new xx(
                                {
                                  func: s.ALWAYS,
                                  mask: 255,
                                },
                                255,
                                255,
                                s.KEEP,
                                s.KEEP,
                                s.REPLACE,
                              ),
                              m = new bx(
                                [s.ONE, s.ONE, s.ONE, s.ONE],
                                li.transparent,
                                [!1, !1, !1, !0],
                                s.MIN,
                              );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              f,
                              l,
                              m,
                              Ex.disabled,
                              o,
                              "sdf",
                              n,
                              c,
                              u,
                              d,
                              p,
                              g,
                              h,
                              a,
                            );
                          }
                          {
                            const l = o ? s.ZERO : s.ONE_MINUS_DST_ALPHA,
                              m = new xx(
                                {
                                  func: s.EQUAL,
                                  mask: 255,
                                },
                                255,
                                255,
                                s.KEEP,
                                s.DECR,
                                s.DECR,
                              ),
                              _ = new bx(
                                [l, s.DST_ALPHA, s.ONE_MINUS_DST_ALPHA, s.ZERO],
                                li.transparent,
                                [!0, !0, !0, !0],
                              );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              f,
                              m,
                              _,
                              Ex.disabled,
                              o,
                              "color",
                              n,
                              c,
                              u,
                              d,
                              p,
                              g,
                              h,
                              a,
                            );
                          }
                          {
                            const m = new bx(
                              [s.ONE, s.ONE, s.ONE, o ? s.ZERO : s.ONE],
                              li.transparent,
                              [!1, !1, !1, !0],
                              o ? s.FUNC_ADD : s.MAX,
                            );
                            ZM(
                              e1,
                              t,
                              i,
                              r,
                              f,
                              xx.disabled,
                              m,
                              Ex.disabled,
                              o,
                              "clear",
                              n,
                              c,
                              u,
                              d,
                              p,
                              g,
                              h,
                              a,
                              l,
                            );
                          }
                        };
                        if (f || m) {
                          let t;
                          if ((e1.prepareDrawTile(), a)) {
                            const e1 = a.drapeBufferSize[0],
                              i = a.drapeBufferSize[1];
                            (t = a.framebufferCopyTexture),
                              (t &&
                                (!t ||
                                  (t.size[0] === e1 && t.size[1] === i))) ||
                                (t && t.destroy(),
                                (t = a.framebufferCopyTexture =
                                  new gy(
                                    o,
                                    new $p({
                                      width: e1,
                                      height: i,
                                    }),
                                    s.RGBA,
                                  ))),
                              t.bind(s.LINEAR, s.CLAMP_TO_EDGE),
                              s.copyTexImage2D(
                                s.TEXTURE_2D,
                                0,
                                s.RGBA,
                                0,
                                0,
                                e1,
                                i,
                                0,
                              );
                          }
                          f && l(!0, !1, t), m && l(!1, !0, t);
                        }
                      } else f && g(!0), m && g(!1);
                    }
                  }
                },
                hillshade: function (e1, t, i, r) {
                  if (
                    "offscreen" !== e1.renderPass &&
                    "translucent" !== e1.renderPass
                  )
                    return;
                  const n = e1.context,
                    o = e1.terrain && e1.terrain.renderingToTexture,
                    [s, a] =
                      "translucent" !== e1.renderPass || o
                        ? [{}, r]
                        : e1.stencilConfigForOverlap(r);
                  for (const r of a) {
                    const n = t.getTile(r);
                    if (
                      n.needsHillshadePrepare &&
                      "offscreen" === e1.renderPass
                    )
                      jE(e1, n, i);
                    else if ("translucent" === e1.renderPass) {
                      const t = e1.depthModeForSublayer(0, gx.ReadOnly),
                        a = i.paint.get("hillshade-emissive-strength"),
                        l = e1.colorModeForDrapableLayerRenderPass(a),
                        c =
                          o && e1.terrain
                            ? e1.terrain.stencilModeForRTTOverlap(r)
                            : s[r.overscaledZ];
                      UE(e1, r, n, i, t, c, l);
                    }
                  }
                  n.viewport.set([0, 0, e1.width, e1.height]),
                    e1.resetStencilClippingMasks();
                },
                raster: function (e1, t, i, r, n, o) {
                  if ("translucent" !== e1.renderPass) return;
                  if (0 === i.paint.get("raster-opacity")) return;
                  const s = e1.context,
                    a = s.gl,
                    l = t.getSource(),
                    c = (function (e1, t, i) {
                      const r = [];
                      let n, o;
                      if (e1.paint.get("raster-color")) {
                        r.push("RASTER_COLOR"),
                          (n = e1.paint.get("raster-color-mix")),
                          (o = e1.paint.get("raster-color-range")),
                          t.activeTexture.set(i.TEXTURE2);
                        let s = e1.colorRampTexture;
                        s ||
                          (s = e1.colorRampTexture =
                            new gy(t, e1.colorRamp, i.RGBA)),
                          s.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                      }
                      return {
                        mix: n,
                        range: o,
                        defines: r,
                      };
                    })(i, s, a),
                    h = c.defines;
                  let u = !1;
                  if (l instanceof qb && !r.length) {
                    if ("globe" !== e1.transform.projection.name) return;
                    if (l.onNorthPole)
                      (u = !0), h.push("PROJECTION_GLOBE_VIEW");
                    else {
                      if (!l.onSouthPole) return;
                      (u = !0), h.push("PROJECTION_GLOBE_VIEW");
                    }
                  }
                  const d = e1.colorModeForDrapableLayerRenderPass(),
                    p = e1.terrain && e1.terrain.renderingToTexture,
                    f = !e1.options.moving,
                    m =
                      "nearest" === i.paint.get("raster-resampling")
                        ? a.NEAREST
                        : a.LINEAR;
                  if (u) {
                    const r = t.getSource();
                    if (!(r instanceof qb)) return;
                    const n = r.texture;
                    if (!n) return;
                    const o = e1.globeSharedBuffers;
                    if (!o) return;
                    const l = new gx(
                        a.LEQUAL,
                        gx.ReadWrite,
                        e1.depthRangeFor3D,
                      ),
                      h = Float32Array.from(e1.transform.projMatrix);
                    let u = Md(0, 0, e1.transform);
                    const p = Float32Array.from(xd(ad(new ku(0, 0, 0)))),
                      f = {
                        opacity: 1,
                        mix: 0,
                      };
                    e1.terrain && e1.terrain.prepareDrawTile(),
                      s.activeTexture.set(a.TEXTURE0),
                      n.bind(m, a.CLAMP_TO_EDGE),
                      s.activeTexture.set(a.TEXTURE1),
                      n.bind(m, a.CLAMP_TO_EDGE),
                      n.useMipmap &&
                        s.extTextureFilterAnisotropic &&
                        e1.transform.pitch > 20 &&
                        a.texParameterf(
                          a.TEXTURE_2D,
                          s.extTextureFilterAnisotropic
                            .TEXTURE_MAX_ANISOTROPY_EXT,
                          s.extTextureFilterAnisotropicMax,
                        );
                    const [_, g, y, x] = o.getPoleBuffers(0, !0);
                    let v;
                    r.onNorthPole
                      ? ((v = _), (e1.renderDefaultNorthPole = !1))
                      : ((u = xu.scale(xu.create(), u, [1, -1, 1])),
                        (v = g),
                        (e1.renderDefaultSouthPole = !1));
                    const b = bM(
                        h,
                        p,
                        u,
                        [0, 0],
                        1,
                        f,
                        i,
                        r.perspectiveTransform || [0, 0],
                        2,
                        c.mix || [0, 0, 0, 0],
                        c.range || [0, 0],
                      ),
                      w = e1.getOrCreateProgram("raster", {
                        defines: c.defines,
                      });
                    return (
                      e1.uploadCommonUniforms(s, w, null),
                      void w.draw(
                        e1,
                        a.TRIANGLES,
                        l,
                        xx.disabled,
                        d,
                        Ex.disabled,
                        b,
                        i.id,
                        v,
                        y,
                        x,
                      )
                    );
                  }
                  if (!r.length) return;
                  const [_, g] =
                      l instanceof qb || p
                        ? [{}, r]
                        : e1.stencilConfigForOverlap(r),
                    y = g[g.length - 1].overscaledZ;
                  for (const r of g) {
                    const n = p
                        ? gx.disabled
                        : e1.depthModeForSublayer(
                            r.overscaledZ - y,
                            1 === i.paint.get("raster-opacity")
                              ? gx.ReadWrite
                              : gx.ReadOnly,
                            a.LESS,
                          ),
                      h = r.toUnwrapped(),
                      u = t.getTile(r);
                    if (p && (!u || !u.hasData())) continue;
                    if (!u.texture) continue;
                    const g = p
                        ? r.projMatrix
                        : e1.transform.calculateProjMatrix(h, f),
                      x =
                        e1.terrain && p
                          ? e1.terrain.stencilModeForRTTOverlap(r)
                          : _[r.overscaledZ],
                      v = o ? 0 : i.paint.get("raster-fade-duration");
                    u.registerFadeDuration(v);
                    const b = t.findLoadedParent(r, 0),
                      w = QE(u, b, t, e1.transform, v);
                    let T, E;
                    e1.terrain && e1.terrain.prepareDrawTile(),
                      s.activeTexture.set(a.TEXTURE0),
                      u.texture.bind(m, a.CLAMP_TO_EDGE),
                      s.activeTexture.set(a.TEXTURE1),
                      b
                        ? (b.texture.bind(m, a.CLAMP_TO_EDGE),
                          (T = Math.pow(
                            2,
                            b.tileID.overscaledZ - u.tileID.overscaledZ,
                          )),
                          (E = [
                            (u.tileID.canonical.x * T) % 1,
                            (u.tileID.canonical.y * T) % 1,
                          ]))
                        : u.texture.bind(m, a.CLAMP_TO_EDGE),
                      u.texture.useMipmap &&
                        s.extTextureFilterAnisotropic &&
                        e1.transform.pitch > 20 &&
                        a.texParameterf(
                          a.TEXTURE_2D,
                          s.extTextureFilterAnisotropic
                            .TEXTURE_MAX_ANISOTROPY_EXT,
                          s.extTextureFilterAnisotropicMax,
                        );
                    const M = l instanceof qb ? l.perspectiveTransform : [0, 0],
                      A = new Float32Array(16),
                      S = bM(
                        g,
                        A,
                        A,
                        E || [0, 0],
                        T || 1,
                        w,
                        i,
                        M,
                        2,
                        c.mix || [0, 0, 0, 0],
                        c.range || [0, 0],
                      ),
                      I = e1.isTileAffectedByFog(r),
                      C = e1.getOrCreateProgram("raster", {
                        defines: c.defines,
                        overrideFog: I,
                      });
                    if ((e1.uploadCommonUniforms(s, C, h), l instanceof qb))
                      l.boundsBuffer &&
                        l.boundsSegments &&
                        C.draw(
                          e1,
                          a.TRIANGLES,
                          n,
                          xx.disabled,
                          d,
                          Ex.disabled,
                          S,
                          i.id,
                          l.boundsBuffer,
                          e1.quadTriangleIndexBuffer,
                          l.boundsSegments,
                        );
                    else {
                      const {
                        tileBoundsBuffer: t,
                        tileBoundsIndexBuffer: r,
                        tileBoundsSegments: o,
                      } = e1.getTileBoundsBuffers(u);
                      C.draw(
                        e1,
                        a.TRIANGLES,
                        n,
                        x,
                        d,
                        Ex.disabled,
                        S,
                        i.id,
                        t,
                        r,
                        o,
                      );
                    }
                  }
                  e1.resetStencilClippingMasks();
                },
                background: function (e1, t, i, r) {
                  const n = i.paint.get("background-color"),
                    o = i.paint.get("background-opacity"),
                    s = i.paint.get("background-emissive-strength");
                  if (0 === o) return;
                  const a = e1.context,
                    l = a.gl,
                    c = e1.transform,
                    h = c.tileSize,
                    u = i.paint.get("background-pattern");
                  if (e1.isPatternMissing(u, i.scope)) return;
                  const d =
                    !u && 1 === n.a && 1 === o && e1.opaquePassEnabledForLayer()
                      ? "opaque"
                      : "translucent";
                  if (e1.renderPass !== d) return;
                  const p = xx.disabled,
                    f = e1.depthModeForSublayer(
                      0,
                      "opaque" === d ? gx.ReadWrite : gx.ReadOnly,
                    ),
                    m = e1.colorModeForDrapableLayerRenderPass(s),
                    _ = u ? "backgroundPattern" : "background";
                  let g,
                    y = r;
                  y ||
                    ((g = e1.getBackgroundTiles()),
                    (y = Object.values(g).map((e1) => e1.tileID))),
                    u &&
                      (a.activeTexture.set(l.TEXTURE0),
                      e1.imageManager.bind(e1.context, i.scope));
                  for (const d of y) {
                    const y = e1.isTileAffectedByFog(d),
                      x = e1.getOrCreateProgram(_, {
                        overrideFog: y,
                      }),
                      v = d.toUnwrapped(),
                      b = r
                        ? d.projMatrix
                        : e1.transform.calculateProjMatrix(v);
                    e1.prepareDrawTile();
                    const w = t
                        ? t.getTile(d)
                        : g
                        ? g[d.key]
                        : new Iy(d, h, c.zoom, e1),
                      T = u
                        ? CM(b, s, o, e1, u, i.scope, {
                            tileID: d,
                            tileSize: h,
                          })
                        : IM(b, s, o, n);
                    e1.uploadCommonUniforms(a, x, v);
                    const {
                      tileBoundsBuffer: E,
                      tileBoundsIndexBuffer: M,
                      tileBoundsSegments: A,
                    } = e1.getTileBoundsBuffers(w);
                    x.draw(
                      e1,
                      l.TRIANGLES,
                      f,
                      p,
                      m,
                      Ex.disabled,
                      T,
                      i.id,
                      E,
                      M,
                      A,
                    );
                  }
                },
                sky: function (e1, t, i) {
                  const r = e1._atmosphere ? Ed(e1.transform.zoom) : 1,
                    n = i.paint.get("sky-opacity") * r;
                  if (0 === n) return;
                  const o = e1.context,
                    s = i.paint.get("sky-type"),
                    a = new gx(o.gl.LEQUAL, gx.ReadOnly, [0, 1]),
                    l = (e1.frameCounter / 1e3) % 1;
                  "atmosphere" === s
                    ? "offscreen" === e1.renderPass
                      ? i.needsSkyboxCapture(e1) &&
                        ((function (e1, t, i, r) {
                          const n = e1.context,
                            o = n.gl;
                          let s = t.skyboxFbo;
                          if (!s) {
                            (s = t.skyboxFbo =
                              n.createFramebuffer(32, 32, !0, null)),
                              (t.skyboxGeometry = new cA(n)),
                              (t.skyboxTexture = n.gl.createTexture()),
                              o.bindTexture(
                                o.TEXTURE_CUBE_MAP,
                                t.skyboxTexture,
                              ),
                              o.texParameteri(
                                o.TEXTURE_CUBE_MAP,
                                o.TEXTURE_WRAP_S,
                                o.CLAMP_TO_EDGE,
                              ),
                              o.texParameteri(
                                o.TEXTURE_CUBE_MAP,
                                o.TEXTURE_WRAP_T,
                                o.CLAMP_TO_EDGE,
                              ),
                              o.texParameteri(
                                o.TEXTURE_CUBE_MAP,
                                o.TEXTURE_MIN_FILTER,
                                o.LINEAR,
                              ),
                              o.texParameteri(
                                o.TEXTURE_CUBE_MAP,
                                o.TEXTURE_MAG_FILTER,
                                o.LINEAR,
                              );
                            for (let e1 = 0; e1 < 6; ++e1)
                              o.texImage2D(
                                o.TEXTURE_CUBE_MAP_POSITIVE_X + e1,
                                0,
                                o.RGBA,
                                32,
                                32,
                                0,
                                o.RGBA,
                                o.UNSIGNED_BYTE,
                                null,
                              );
                          }
                          n.bindFramebuffer.set(s.framebuffer),
                            n.viewport.set([0, 0, 32, 32]);
                          const a = t.getCenter(e1, !0),
                            l = e1.getOrCreateProgram("skyboxCapture"),
                            c = new Float64Array(16);
                          xu.identity(c),
                            xu.rotateY(c, c, 0.5 * -Math.PI),
                            hA(e1, t, l, c, a, 0),
                            xu.identity(c),
                            xu.rotateY(c, c, 0.5 * Math.PI),
                            hA(e1, t, l, c, a, 1),
                            xu.identity(c),
                            xu.rotateX(c, c, 0.5 * -Math.PI),
                            hA(e1, t, l, c, a, 2),
                            xu.identity(c),
                            xu.rotateX(c, c, 0.5 * Math.PI),
                            hA(e1, t, l, c, a, 3),
                            xu.identity(c),
                            hA(e1, t, l, c, a, 4),
                            xu.identity(c),
                            xu.rotateY(c, c, Math.PI),
                            hA(e1, t, l, c, a, 5),
                            n.viewport.set([0, 0, e1.width, e1.height]);
                        })(e1, i),
                        i.markSkyboxValid(e1))
                      : "sky" === e1.renderPass &&
                        (function (e1, t, i, r, n) {
                          const o = e1.context,
                            s = o.gl,
                            a = e1.transform,
                            l = e1.getOrCreateProgram("skybox");
                          o.activeTexture.set(s.TEXTURE0),
                            s.bindTexture(s.TEXTURE_CUBE_MAP, t.skyboxTexture);
                          const c = ((e1, t, i, r, n) => ({
                            u_matrix: e1,
                            u_sun_direction: t,
                            u_cubemap: 0,
                            u_opacity: r,
                            u_temporal_offset: n,
                          }))(a.skyboxMatrix, t.getCenter(e1, !1), 0, r, n);
                          e1.uploadCommonUniforms(o, l),
                            l.draw(
                              e1,
                              s.TRIANGLES,
                              i,
                              xx.disabled,
                              e1.colorModeForRenderPass(),
                              Ex.backCW,
                              c,
                              "skybox",
                              t.skyboxGeometry.vertexBuffer,
                              t.skyboxGeometry.indexBuffer,
                              t.skyboxGeometry.segment,
                            );
                        })(e1, i, a, n, l)
                    : "gradient" === s &&
                      "sky" === e1.renderPass &&
                      (function (e1, t, i, r, n) {
                        const o = e1.context,
                          s = o.gl,
                          a = e1.transform,
                          l = e1.getOrCreateProgram("skyboxGradient");
                        t.skyboxGeometry || (t.skyboxGeometry = new cA(o)),
                          o.activeTexture.set(s.TEXTURE0);
                        let c = t.colorRampTexture;
                        c ||
                          (c = t.colorRampTexture =
                            new gy(o, t.colorRamp, s.RGBA)),
                          c.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                        const h = ((e1, t, i, r, n) => ({
                          u_matrix: e1,
                          u_color_ramp: 0,
                          u_center_direction: t,
                          u_radius: w(i),
                          u_opacity: r,
                          u_temporal_offset: n,
                        }))(
                          a.skyboxMatrix,
                          t.getCenter(e1, !1),
                          t.paint.get("sky-gradient-radius"),
                          r,
                          n,
                        );
                        e1.uploadCommonUniforms(o, l),
                          l.draw(
                            e1,
                            s.TRIANGLES,
                            i,
                            xx.disabled,
                            e1.colorModeForRenderPass(),
                            Ex.backCW,
                            h,
                            "skyboxGradient",
                            t.skyboxGeometry.vertexBuffer,
                            t.skyboxGeometry.indexBuffer,
                            t.skyboxGeometry.segment,
                          );
                      })(e1, i, a, n, l);
                },
                debug: function (e1, t, i) {
                  for (let r = 0; r < i.length; r++) iA(e1, t, i[r]);
                },
                custom: function (e1, t, i, r) {
                  const n = e1.context,
                    o = i.implementation;
                  if (
                    !e1.transform.projection.unsupportedLayers ||
                    !e1.transform.projection.unsupportedLayers.includes(
                      "custom",
                    ) ||
                    (e1.terrain &&
                      (e1.terrain.renderingToTexture ||
                        "offscreen" === e1.renderPass) &&
                      i.isLayerDraped(t))
                  ) {
                    if ("offscreen" === e1.renderPass) {
                      const t = o.prerender;
                      if (t) {
                        if (
                          (e1.setCustomLayerDefaults(),
                          n.setColorMode(e1.colorModeForRenderPass()),
                          "globe" === e1.transform.projection.name)
                        ) {
                          const i = e1.transform.pointMerc;
                          t.call(
                            o,
                            n.gl,
                            e1.transform.customLayerMatrix(),
                            e1.transform.getProjection(),
                            e1.transform.globeToMercatorMatrix(),
                            Ed(e1.transform.zoom),
                            [i.x, i.y],
                            e1.transform.pixelsPerMeterRatio,
                          );
                        } else
                          t.call(o, n.gl, e1.transform.customLayerMatrix());
                        n.setDirty(), e1.setBaseState();
                      }
                    } else if ("translucent" === e1.renderPass) {
                      if (e1.terrain && e1.terrain.renderingToTexture) {
                        const t = o.renderToTile;
                        if (t) {
                          const i = r[0].canonical,
                            s = new ep(i.x + r[0].wrap * (1 << i.z), i.y, i.z);
                          n.setDepthMode(gx.disabled),
                            n.setStencilMode(xx.disabled),
                            n.setColorMode(e1.colorModeForRenderPass()),
                            e1.setCustomLayerDefaults(),
                            t.call(o, n.gl, s),
                            n.setDirty(),
                            e1.setBaseState();
                        }
                        return;
                      }
                      e1.setCustomLayerDefaults(),
                        n.setColorMode(e1.colorModeForRenderPass()),
                        n.setStencilMode(xx.disabled);
                      const t =
                        "3d" === o.renderingMode
                          ? new gx(
                              e1.context.gl.LEQUAL,
                              gx.ReadWrite,
                              e1.depthRangeFor3D,
                            )
                          : e1.depthModeForSublayer(0, gx.ReadOnly);
                      if (
                        (n.setDepthMode(t),
                        "globe" === e1.transform.projection.name)
                      ) {
                        const t = e1.transform.pointMerc;
                        o.render(
                          n.gl,
                          e1.transform.customLayerMatrix(),
                          e1.transform.getProjection(),
                          e1.transform.globeToMercatorMatrix(),
                          Ed(e1.transform.zoom),
                          [t.x, t.y],
                          e1.transform.pixelsPerMeterRatio,
                        );
                      } else o.render(n.gl, e1.transform.customLayerMatrix());
                      n.setDirty(),
                        e1.setBaseState(),
                        n.bindFramebuffer.set(null);
                    }
                  } else
                    W(
                      "Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.",
                    );
                },
                model: function (e1, t, i, r) {
                  if ("opaque" === e1.renderPass) return;
                  const n = i.paint.get("model-opacity");
                  if (0 === n) return;
                  const o = i.paint.get("model-cast-shadows");
                  if ("shadow" === e1.renderPass) {
                    if (!o) return;
                    if (
                      e1.terrain &&
                      n < 0.65 &&
                      i._transitionablePaint._values["model-opacity"].value
                        .expression instanceof bo
                    )
                      return;
                  }
                  const s = e1.shadowRenderer,
                    a = i.paint.get("model-receive-shadows");
                  s && ((s.useNormalOffset = !0), a || (s.enabled = !1));
                  const l = () => {
                      s && ((s.useNormalOffset = !0), a || (s.enabled = !0));
                    },
                    c = t.getSource();
                  if (
                    "light-beam" === e1.renderPass &&
                    "batched-model" !== c.type
                  )
                    return;
                  if ("vector" === c.type || "geojson" === c.type)
                    return (
                      (function (e1, t, i, r) {
                        const n = e1.transform;
                        if ("mercator" !== n.projection.name)
                          return void W(
                            `Drawing 3D models for ${n.projection.name} projection is not yet implemented`,
                          );
                        const o = n.getFreeCameraOptions().position;
                        if (!e1.modelManager) return;
                        const s = e1.modelManager,
                          a = e1.shadowRenderer;
                        if (
                          !i._unevaluatedLayout._values.hasOwnProperty(
                            "model-id",
                          )
                        )
                          return;
                        const l = i._unevaluatedLayout._values["model-id"],
                          c = {
                            ...i.layout.get("model-id").parameters,
                          };
                        for (const h of r) {
                          const r = t.getTile(h).getBucket(i);
                          if (!r || r.projection.name !== n.projection.name)
                            continue;
                          const u = wA(h, n);
                          c.zoom = u;
                          const d = l.possiblyEvaluate(c);
                          if (
                            (vA(e1, r, h),
                            (bA.shadowUniformsInitialized = !1),
                            (bA.useSingleShadowCascade =
                              !!a &&
                              0 === a.getMaxCascadeForTile(h.toUnwrapped())),
                            "shadow" === e1.renderPass && a)
                          ) {
                            if (
                              1 === e1.currentShadowCascade &&
                              r.isInsideFirstShadowMapFrustum
                            )
                              continue;
                            const t = n.calculatePosMatrix(
                              h.toUnwrapped(),
                              n.worldSize,
                            );
                            if (
                              (bA.tileMatrix.set(t),
                              (bA.shadowTileMatrix = Float32Array.from(
                                a.calculateShadowPassMatrixFromMatrix(t),
                              )),
                              bA.aabb.min.fill(0),
                              (bA.aabb.max[0] = bA.aabb.max[1] = sr),
                              (bA.aabb.max[2] = 0),
                              MA(r, bA, e1, i.scope))
                            )
                              continue;
                          }
                          const p = 1 << h.canonical.z,
                            f = [
                              ((o.x - h.wrap) * p - h.canonical.x) * sr,
                              (o.y * p - h.canonical.y) * sr,
                              o.z * p * sr,
                            ];
                          for (let t in r.instancesPerModel) {
                            const n = r.instancesPerModel[t];
                            n.features.length > 0 &&
                              (t = d.evaluate(n.features[0].feature, {}));
                            const o = s.getModel(t, i.scope);
                            if (o && o.uploaded)
                              for (const t of o.nodes)
                                TA(e1, i, t, n, f, h, bA);
                          }
                        }
                      })(e1, t, i, r),
                      void l()
                    );
                  if (!c.loaded()) return;
                  if ("batched-model" === c.type)
                    return (
                      (function (e1, t, i, r) {
                        const n = e1.context,
                          o = e1.transform,
                          s = e1.style.fog,
                          a = e1.shadowRenderer;
                        if ("mercator" !== o.projection.name)
                          return void W(
                            `Drawing 3D landmark models for ${o.projection.name} projection is not yet implemented`,
                          );
                        const l = e1.transform.getFreeCameraOptions().position,
                          c = Mu.scale(
                            [],
                            [l.x, l.y, l.z],
                            e1.transform.worldSize,
                          );
                        Mu.negate(c, c);
                        const h = xu.identity([]),
                          u = Kd(o.center.lat, o.zoom),
                          d = xu.fromScaling([], [1, 1, 1 / u]);
                        xu.translate(h, h, c);
                        const p = i.paint.get("model-opacity"),
                          f = new gx(
                            n.gl.LEQUAL,
                            gx.ReadWrite,
                            e1.depthRangeFor3D,
                          ),
                          m = new gx(
                            n.gl.LEQUAL,
                            gx.ReadOnly,
                            e1.depthRangeFor3D,
                          ),
                          _ = function (l, c) {
                            for (const u of r) {
                              const r = t.getTile(u).getBucket(i);
                              if (!r || !r.uploaded) continue;
                              let _ = !1;
                              a &&
                                (_ =
                                  0 ===
                                  a.getMaxCascadeForTile(u.toUnwrapped()));
                              const g = o.calculatePosMatrix(
                                  u.toUnwrapped(),
                                  o.worldSize,
                                ),
                                y = r.modelTraits;
                              for (const t of r.getNodesInfo()) {
                                if (t.hiddenByReplacement) continue;
                                if (!t.node.meshes) continue;
                                const r = t.node,
                                  x = "light-beam" === e1.renderPass,
                                  v = [...g],
                                  b = t.evaluatedScale;
                                let w = 0;
                                e1.terrain &&
                                  r.elevation &&
                                  (w = r.elevation * e1.terrain.exaggeration()),
                                  xu.translate(v, v, [
                                    (r.anchor ? r.anchor[0] : 0) * (b[0] - 1),
                                    (r.anchor ? r.anchor[1] : 0) * (b[1] - 1),
                                    w,
                                  ]),
                                  b !== vv && xu.scale(v, v, b),
                                  xu.multiply(v, v, r.matrix);
                                const T = xu.multiply([], d, v);
                                xu.multiply(T, h, T);
                                const E = xu.invert([], T);
                                xu.transpose(E, E), xu.scale(E, E, EA);
                                const M = xu.multiply([], o.projMatrix, v);
                                for (let h = 0; h < r.meshes.length; ++h) {
                                  const d = r.meshes[h],
                                    g = h === r.lightMeshIndex;
                                  if (g) {
                                    if (
                                      !x &&
                                      !e1.terrain &&
                                      e1.shadowRenderer
                                    ) {
                                      e1.currentLayer <
                                        e1.firstLightBeamLayer &&
                                        (e1.firstLightBeamLayer =
                                          e1.currentLayer);
                                      continue;
                                    }
                                  } else if (x) continue;
                                  const b = {
                                      defines: [],
                                    },
                                    w = [];
                                  _A(b.defines, w, d, e1),
                                    4 & y || b.defines.push("DIFFUSE_SHADED"),
                                    _ &&
                                      b.defines.push("SHADOWS_SINGLE_CASCADE");
                                  const A = "shadow" === e1.renderPass;
                                  if (A) {
                                    xA(d, v, e1, i);
                                    continue;
                                  }
                                  let S = null;
                                  if (s) {
                                    const t = mA(v, e1.transform);
                                    if (
                                      ((S = new Float32Array(t)),
                                      "globe" !== o.projection.name)
                                    ) {
                                      const e1 = d.aabb.min,
                                        i = d.aabb.max,
                                        [r, n] = s.getOpacityForBounds(
                                          t,
                                          e1[0],
                                          e1[1],
                                          i[0],
                                          i[1],
                                        );
                                      b.overrideFog = r >= sw || n >= sw;
                                    }
                                  }
                                  const I = e1.getOrCreateProgram("model", b);
                                  !A &&
                                    a &&
                                    ((a.useNormalOffset = !!d.normalBuffer),
                                    a.setupShadowsFromMatrix(
                                      v,
                                      I,
                                      a.useNormalOffset,
                                    )),
                                    e1.uploadCommonUniforms(
                                      n,
                                      I,
                                      u.toUnwrapped(),
                                      S,
                                    );
                                  const C = d.material,
                                    z = C.pbrMetallicRoughness;
                                  (z.metallicFactor = 0.9),
                                    (z.roughnessFactor = 0.5);
                                  const D = DM(
                                    new Float32Array(M),
                                    new Float32Array(T),
                                    new Float32Array(E),
                                    e1,
                                    p,
                                    z.baseColorFactor,
                                    C.emissiveFactor,
                                    z.metallicFactor,
                                    z.roughnessFactor,
                                    C,
                                    i,
                                  );
                                  I.draw(
                                    e1,
                                    n.gl.TRIANGLES,
                                    c && !g ? f : m,
                                    xx.disabled,
                                    l
                                      ? g || p < 1 || t.hasTranslucentParts
                                        ? bx.alphaBlended
                                        : bx.unblended
                                      : bx.disabled,
                                    Ex.backCCW,
                                    D,
                                    i.id,
                                    d.vertexBuffer,
                                    d.indexBuffer,
                                    d.segments,
                                    i.paint,
                                    e1.transform.zoom,
                                    void 0,
                                    w,
                                  );
                                }
                              }
                            }
                          };
                        (function (e1, t, i, r) {
                          const n = e1.terrain ? e1.terrain.exaggeration() : 0,
                            o = e1.transform.zoom;
                          for (const s of r) {
                            const r = t.getTile(s).getBucket(i);
                            r &&
                              (e1.conflationActive &&
                                r.updateReplacement(s, e1.replacementSource),
                              r.evaluateScale(e1, i),
                              e1.terrain &&
                                n > 0 &&
                                r.elevationUpdate(e1.terrain, n, s, i.source),
                              r.needsReEvaluation(e1, o, i) && r.evaluate(i));
                          }
                        })(e1, t, i, r),
                          1 === p ? _(!0, !0) : (_(!1, !0), _(!0, !1));
                      })(e1, t, i, r),
                      void l()
                    );
                  const h = c.getModels(),
                    u = [],
                    d = e1.transform.getFreeCameraOptions().position,
                    p = Mu.scale([], [d.x, d.y, d.z], e1.transform.worldSize);
                  Mu.negate(p, p);
                  const f = [],
                    m = [];
                  let _ = 0;
                  for (const t of h) {
                    const r = i.paint.get("model-rotation").constantOr(null),
                      n = i.paint.get("model-scale").constantOr(null),
                      o = i.paint.get("model-translation").constantOr(null);
                    t.computeModelMatrix(e1, r, n, o, !0, !0, !1);
                    const s = xu.identity([]),
                      a = Kd(t.position.lat, e1.transform.zoom),
                      l = xu.fromScaling([], [1, 1, 1 / a]);
                    xu.translate(s, s, p),
                      u.push({
                        zScaleMatrix: l,
                        negCameraPosMatrix: s,
                      });
                    for (const i of t.nodes)
                      yA(
                        e1.transform,
                        i,
                        t.matrix,
                        e1.transform.projMatrix,
                        _,
                        f,
                        m,
                      );
                    _++;
                  }
                  if (
                    (f.sort((e1, t) => t.depth - e1.depth),
                    "shadow" !== e1.renderPass)
                  ) {
                    if (1 === n)
                      for (const t of m)
                        gA(
                          t,
                          e1,
                          i,
                          u[t.modelIndex],
                          xx.disabled,
                          e1.colorModeForRenderPass(),
                        );
                    else {
                      for (const t of m)
                        gA(t, e1, i, u[t.modelIndex], xx.disabled, bx.disabled);
                      for (const t of m)
                        gA(
                          t,
                          e1,
                          i,
                          u[t.modelIndex],
                          e1.stencilModeFor3D(),
                          e1.colorModeForRenderPass(),
                        );
                      e1.resetStencilClippingMasks();
                    }
                    for (const t of f)
                      gA(
                        t,
                        e1,
                        i,
                        u[t.modelIndex],
                        xx.disabled,
                        e1.colorModeForRenderPass(),
                      );
                    l();
                  } else {
                    for (const t of m) xA(t.mesh, t.nodeModelMatrix, e1, i);
                    for (const t of f) xA(t.mesh, t.nodeModelMatrix, e1, i);
                    l();
                  }
                },
              },
              CA = {
                modelUpload: function (e1, t, i) {
                  const r = t.getSource();
                  if (!r.loaded()) return;
                  if ("vector" === r.type || "geojson" === r.type)
                    return void (
                      e1.modelManager && e1.modelManager.upload(e1, i)
                    );
                  if ("batched-model" === r.type) return;
                  const n = r.getModels();
                  for (const t of n) t.upload(e1.context);
                },
              };
            class zA {
              constructor(e1, t) {
                (this.context = new Mx(e1)),
                  (this.transform = t),
                  (this._tileTextures = {}),
                  (this.frameCopies = []),
                  (this.loadTimeStamps = []),
                  this.setup(),
                  (this.numSublayers =
                    Ax.maxUnderzooming + Ax.maxOverzooming + 1),
                  (this.depthEpsilon = 1 / Math.pow(2, 16)),
                  (this.deferredRenderGpuTimeQueries = []),
                  (this.gpuTimers = {}),
                  (this.frameCounter = 0),
                  (this._backgroundTiles = {}),
                  (this.conflationActive = !1),
                  (this.replacementSource = new Vv()),
                  (this.longestCutoffRange = 0),
                  (this.minCutoffZoom = 0),
                  (this._fogVisible = !1),
                  (this._cachedTileFogOpacities = {}),
                  (this._shadowRenderer = new LA(this)),
                  (this._wireframeDebugCache = new SA()),
                  (this.renderDefaultNorthPole = !0),
                  (this.renderDefaultSouthPole = !0);
              }
              updateTerrain(e1, t) {
                const i =
                  !!e1 &&
                  !!e1.terrain &&
                  this.transform.projection.supportsTerrain;
                if (!(i || (this._terrain && this._terrain.enabled))) return;
                this._terrain || (this._terrain = new rM(this, e1));
                const r = this._terrain;
                (this.transform.elevation = i ? r : null),
                  r.update(e1, this.transform, t),
                  this.transform.elevation &&
                    !r.enabled &&
                    (this.transform.elevation = null);
              }
              _updateFog(e1) {
                const t = e1.fog;
                if (
                  !t ||
                  "globe" === this.transform.projection.name ||
                  t.getOpacity(this.transform.pitch) < 1 ||
                  t.properties.get("horizon-blend") < 0.03
                )
                  return void (this.transform.fogCullDistSq = null);
                const [i, r] = t.getFovAdjustedRange(this.transform._fov);
                if (i > r) return void (this.transform.fogCullDistSq = null);
                const n = i + 0.78 * (r - i);
                this.transform.fogCullDistSq = n * n;
              }
              get terrain() {
                return this.transform._terrainEnabled() &&
                  this._terrain &&
                  this._terrain.enabled
                  ? this._terrain
                  : null;
              }
              get shadowRenderer() {
                return this._shadowRenderer && this._shadowRenderer.enabled
                  ? this._shadowRenderer
                  : null;
              }
              get wireframeDebugCache() {
                return this._wireframeDebugCache;
              }
              resize(e1, t) {
                if (
                  ((this.width = e1 * ht.devicePixelRatio),
                  (this.height = t * ht.devicePixelRatio),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.style)
                )
                  for (const e1 of this.style.order)
                    this.style._mergedLayers[e1].resize();
              }
              setup() {
                const e1 = this.context,
                  i = new Ta();
                i.emplaceBack(0, 0),
                  i.emplaceBack(sr, 0),
                  i.emplaceBack(0, sr),
                  i.emplaceBack(sr, sr),
                  (this.tileExtentBuffer = e1.createVertexBuffer(
                    i,
                    Pu.members,
                  )),
                  (this.tileExtentSegments = dl.simpleSegment(0, 0, 4, 2));
                const r = new Ta();
                r.emplaceBack(0, 0),
                  r.emplaceBack(sr, 0),
                  r.emplaceBack(0, sr),
                  r.emplaceBack(sr, sr),
                  (this.debugBuffer = e1.createVertexBuffer(r, Pu.members)),
                  (this.debugSegments = dl.simpleSegment(0, 0, 4, 5));
                const n = new Ta();
                n.emplaceBack(-1, -1),
                  n.emplaceBack(1, -1),
                  n.emplaceBack(-1, 1),
                  n.emplaceBack(1, 1),
                  (this.viewportBuffer = e1.createVertexBuffer(n, Pu.members)),
                  (this.viewportSegments = dl.simpleSegment(0, 0, 4, 2));
                const o = new Ma();
                o.emplaceBack(0, 0, 0, 0),
                  o.emplaceBack(sr, 0, sr, 0),
                  o.emplaceBack(0, sr, 0, sr),
                  o.emplaceBack(sr, sr, sr, sr),
                  (this.mercatorBoundsBuffer = e1.createVertexBuffer(
                    o,
                    Ay.members,
                  )),
                  (this.mercatorBoundsSegments = dl.simpleSegment(0, 0, 4, 2));
                const s = new Va();
                s.emplaceBack(0, 1, 2),
                  s.emplaceBack(2, 1, 3),
                  (this.quadTriangleIndexBuffer = e1.createIndexBuffer(s));
                const a = new Wa();
                for (const e1 of [0, 1, 3, 2, 0]) a.emplaceBack(e1);
                (this.debugIndexBuffer = e1.createIndexBuffer(a)),
                  (this.emptyTexture = new gy(
                    e1,
                    new $p(
                      {
                        width: 1,
                        height: 1,
                      },
                      Uint8Array.of(0, 0, 0, 0),
                    ),
                    e1.gl.RGBA,
                  )),
                  (this.identityMat = xu.create());
                const l = this.context.gl;
                (this.stencilClearMode = new xx(
                  {
                    func: l.ALWAYS,
                    mask: 0,
                  },
                  0,
                  255,
                  l.ZERO,
                  l.ZERO,
                  l.ZERO,
                )),
                  this.loadTimeStamps.push(t.performance.now());
              }
              getMercatorTileBoundsBuffers() {
                return {
                  tileBoundsBuffer: this.mercatorBoundsBuffer,
                  tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                  tileBoundsSegments: this.mercatorBoundsSegments,
                };
              }
              getTileBoundsBuffers(e1) {
                return (
                  e1._makeTileBoundsBuffers(
                    this.context,
                    this.transform.projection,
                  ),
                  e1._tileBoundsBuffer
                    ? {
                        tileBoundsBuffer: e1._tileBoundsBuffer,
                        tileBoundsIndexBuffer: e1._tileBoundsIndexBuffer,
                        tileBoundsSegments: e1._tileBoundsSegments,
                      }
                    : this.getMercatorTileBoundsBuffers()
                );
              }
              clearStencil() {
                const e1 = this.context.gl;
                (this.nextStencilID = 1),
                  (this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}),
                  this.getOrCreateProgram("clippingMask").draw(
                    this,
                    e1.TRIANGLES,
                    gx.disabled,
                    this.stencilClearMode,
                    bx.disabled,
                    Ex.disabled,
                    JE(this.identityMat),
                    "$clipping",
                    this.viewportBuffer,
                    this.quadTriangleIndexBuffer,
                    this.viewportSegments,
                  );
              }
              resetStencilClippingMasks() {
                this.terrain ||
                  ((this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}));
              }
              _renderTileClippingMasks(e1, t, i) {
                if (
                  !t ||
                  this.currentStencilSource === t.id ||
                  !e1.isTileClipped() ||
                  !i ||
                  0 === i.length
                )
                  return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                  let e1 = !1;
                  for (const t of i)
                    if (void 0 === this._tileClippingMaskIDs[t.key]) {
                      e1 = !0;
                      break;
                    }
                  if (!e1) return;
                }
                this.currentStencilSource = t.id;
                const r = this.context,
                  n = r.gl;
                this.nextStencilID + i.length > 256 && this.clearStencil(),
                  r.setColorMode(bx.disabled),
                  r.setDepthMode(gx.disabled);
                const o = this.getOrCreateProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e1 of i) {
                  const i = t.getTile(e1),
                    r = (this._tileClippingMaskIDs[e1.key] = this
                      .nextStencilID++),
                    {
                      tileBoundsBuffer: s,
                      tileBoundsIndexBuffer: a,
                      tileBoundsSegments: l,
                    } = this.getTileBoundsBuffers(i);
                  o.draw(
                    this,
                    n.TRIANGLES,
                    gx.disabled,
                    new xx(
                      {
                        func: n.ALWAYS,
                        mask: 0,
                      },
                      r,
                      255,
                      n.KEEP,
                      n.KEEP,
                      n.REPLACE,
                    ),
                    bx.disabled,
                    Ex.disabled,
                    JE(e1.projMatrix),
                    "$clipping",
                    s,
                    a,
                    l,
                  );
                }
              }
              stencilModeFor3D() {
                (this.currentStencilSource = void 0),
                  this.nextStencilID + 1 > 256 && this.clearStencil();
                const e1 = this.nextStencilID++,
                  t = this.context.gl;
                return new xx(
                  {
                    func: t.NOTEQUAL,
                    mask: 255,
                  },
                  e1,
                  255,
                  t.KEEP,
                  t.KEEP,
                  t.REPLACE,
                );
              }
              stencilModeForClipping(e1) {
                if (this.terrain)
                  return this.terrain.stencilModeForRTTOverlap(e1);
                const t = this.context.gl;
                return new xx(
                  {
                    func: t.EQUAL,
                    mask: 255,
                  },
                  this._tileClippingMaskIDs[e1.key],
                  0,
                  t.KEEP,
                  t.KEEP,
                  t.REPLACE,
                );
              }
              stencilConfigForOverlap(e1) {
                const t = this.context.gl,
                  i = e1.sort((e1, t) => t.overscaledZ - e1.overscaledZ),
                  r = i[i.length - 1].overscaledZ,
                  n = i[0].overscaledZ - r + 1;
                if (n > 1) {
                  (this.currentStencilSource = void 0),
                    this.nextStencilID + n > 256 && this.clearStencil();
                  const e1 = {};
                  for (let i = 0; i < n; i++)
                    e1[i + r] = new xx(
                      {
                        func: t.GEQUAL,
                        mask: 255,
                      },
                      i + this.nextStencilID,
                      255,
                      t.KEEP,
                      t.KEEP,
                      t.REPLACE,
                    );
                  return (this.nextStencilID += n), [e1, i];
                }
                return [
                  {
                    [r]: xx.disabled,
                  },
                  i,
                ];
              }
              colorModeForRenderPass() {
                const e1 = this.context.gl;
                if (this._showOverdrawInspector) {
                  const t = 1 / 8;
                  return new bx(
                    [e1.CONSTANT_COLOR, e1.ONE, e1.CONSTANT_COLOR, e1.ONE],
                    new li(t, t, t, 0),
                    [!0, !0, !0, !0],
                  );
                }
                return "opaque" === this.renderPass
                  ? bx.unblended
                  : bx.alphaBlended;
              }
              colorModeForDrapableLayerRenderPass(e1) {
                const t = this.context.gl;
                return (() =>
                  this.style &&
                  this.style.enable3dLights() &&
                  this.terrain &&
                  this.terrain.renderingToTexture)() &&
                  "translucent" === this.renderPass
                  ? new bx(
                      [
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.CONSTANT_ALPHA,
                        t.ONE_MINUS_SRC_ALPHA,
                      ],
                      new li(0, 0, 0, void 0 === e1 ? 0 : e1),
                      [!0, !0, !0, !0],
                    )
                  : this.colorModeForRenderPass();
              }
              depthModeForSublayer(e1, t, i, r = !1) {
                if (!this.opaquePassEnabledForLayer() && !r) return gx.disabled;
                const n =
                  1 -
                  ((1 + this.currentLayer) * this.numSublayers + e1) *
                    this.depthEpsilon;
                return new gx(i || this.context.gl.LEQUAL, t, [n, n]);
              }
              opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
              }
              render(e1, i) {
                this._wireframeDebugCache.update(this.frameCounter),
                  (this.style = e1),
                  (this.options = i);
                const r = this.style._mergedLayers,
                  n = this.style.order,
                  o = n.map((e1) => r[e1]),
                  s = this.style._mergedSourceCaches;
                (this.imageManager = e1.imageManager),
                  (this.modelManager = e1.modelManager),
                  (this.symbolFadeChange = e1.placement.symbolFadeChange(
                    ht.now(),
                  )),
                  this.imageManager.beginFrame();
                let a = 0,
                  l = !1;
                for (const e1 in s) {
                  const t = s[e1];
                  t.used &&
                    (t.prepare(this.context),
                    t.getSource().usedInConflation && ++a);
                }
                const c = {},
                  h = {},
                  u = {},
                  d = {},
                  p = {};
                for (const e1 in s) {
                  const t = s[e1];
                  (c[e1] = t.getVisibleCoordinates()),
                    (h[e1] = c[e1].slice().reverse()),
                    (u[e1] = t.getVisibleCoordinates(!0).reverse()),
                    (d[e1] = t.getShadowCasterCoordinates()),
                    (p[e1] = t.sortCoordinatesByDistance(c[e1]));
                }
                const f = (e1) => {
                  const t = this.style.getLayerSourceCache(e1);
                  return t && t.used ? t.getSource() : null;
                };
                if (a) {
                  const e1 = [];
                  for (const t of o)
                    this.layerUsedInConflation(t, f(t)) && e1.push(t);
                  if (e1 && e1.length > 1) {
                    const t = [];
                    for (const i of e1) {
                      const e1 = this.style.getLayerSourceCache(i);
                      e1 &&
                        e1.used &&
                        e1.getSource().usedInConflation &&
                        t.push({
                          layer: i.fqid,
                          cache: e1,
                        });
                    }
                    this.replacementSource.setSources(t), (l = !0);
                  }
                }
                l || this.replacementSource.clear(),
                  (this.conflationActive = l),
                  (this.minCutoffZoom = 0),
                  (this.longestCutoffRange = 0);
                for (const e1 of o) {
                  const t = e1.cutoffRange();
                  if (
                    ((this.longestCutoffRange = Math.max(
                      t,
                      this.longestCutoffRange,
                    )),
                    t > 0)
                  ) {
                    const t = f(e1);
                    t &&
                      (this.minCutoffZoom = Math.max(
                        t.minzoom,
                        this.minCutoffZoom,
                      )),
                      e1.minzoom &&
                        (this.minCutoffZoom = Math.max(
                          e1.minzoom,
                          this.minCutoffZoom,
                        ));
                  }
                }
                this.opaquePassCutoff = 1 / 0;
                for (let e1 = 0; e1 < o.length; e1++)
                  if (o[e1].is3D()) {
                    this.opaquePassCutoff = e1;
                    break;
                  }
                const m = this.style && this.style.fog;
                m
                  ? ((this._fogVisible =
                      0 !== m.getOpacity(this.transform.pitch)),
                    this._fogVisible &&
                      "globe" !== this.transform.projection.name &&
                      (this._fogVisible = m.isVisibleOnFrustum(
                        this.transform.cameraFrustum,
                      )))
                  : (this._fogVisible = !1),
                  (this._cachedTileFogOpacities = {}),
                  this.terrain &&
                    (this.terrain.updateTileBinding(u),
                    (this.opaquePassCutoff = 0));
                const _ = this._shadowRenderer;
                if (_) {
                  _.updateShadowParameters(
                    this.transform,
                    this.style.directionalLight,
                  );
                  for (const e1 in s)
                    for (const t of c[e1]) {
                      let e1 = {
                        min: 0,
                        max: 0,
                      };
                      this.terrain &&
                        (e1 = this.terrain.getMinMaxForTile(t) || e1),
                        _.addShadowReceiver(t.toUnwrapped(), e1.min, e1.max);
                    }
                }
                "globe" !== this.transform.projection.name ||
                  this.globeSharedBuffers ||
                  (this.globeSharedBuffers = new kd(this.context));
                for (const t of o) {
                  if (t.isHidden(this.transform.zoom)) continue;
                  const i = e1.getLayerSourceCache(t);
                  this.uploadLayer(this, t, i);
                }
                if (
                  (this.style.fog && this.transform.projection.supportsFog
                    ? (this._atmosphere || (this._atmosphere = new fA()),
                      this._atmosphere.update(this))
                    : this._atmosphere &&
                      (this._atmosphere.destroy(), (this._atmosphere = void 0)),
                  !Ye.has(this.context.gl))
                )
                  return;
                this.renderPass = "offscreen";
                for (const t of o) {
                  const i = e1.getLayerSourceCache(t);
                  if (!t.hasOffscreenPass() || t.isHidden(this.transform.zoom))
                    continue;
                  const r = i ? h[i.id] : void 0;
                  ("custom" === t.type ||
                    "raster" === t.type ||
                    t.isSky() ||
                    (r && r.length)) &&
                    this.renderLayer(this, i, t, r);
                }
                this.depthRangeFor3D = [
                  0,
                  1 - (o.length + 2) * this.numSublayers * this.depthEpsilon,
                ];
                const g = this.terrain;
                g &&
                  (this.style.hasSymbolLayers() ||
                    this.style.hasCircleLayers()) &&
                  !this.transform.isOrthographic &&
                  g.drawDepth(),
                  this._shadowRenderer &&
                    ((this.renderPass = "shadow"),
                    this._shadowRenderer.drawShadowPass(this.style, d)),
                  this.context.bindFramebuffer.set(null),
                  this.context.viewport.set([0, 0, this.width, this.height]);
                const y =
                    "globe" === this.transform.projection.name ||
                    this.transform.isHorizonVisible(),
                  x = (() => {
                    if (i.showOverdrawInspector) return li.black;
                    if (
                      this.style.fog &&
                      this.transform.projection.supportsFog &&
                      !y
                    ) {
                      const e1 = this.style.fog.properties
                        .get("color")
                        .toArray01();
                      return new li(...e1);
                    }
                    if (
                      this.style.fog &&
                      this.transform.projection.supportsFog &&
                      y
                    ) {
                      const e1 = this.style.fog.properties
                        .get("space-color")
                        .toArray01();
                      return new li(...e1);
                    }
                    return li.transparent;
                  })();
                if (
                  (this.context.clear({
                    color: x,
                    depth: 1,
                  }),
                  this.clearStencil(),
                  (this._showOverdrawInspector = i.showOverdrawInspector),
                  (this.renderPass = "opaque"),
                  this.style.fog &&
                    this.transform.projection.supportsFog &&
                    this._atmosphere &&
                    !this._showOverdrawInspector &&
                    y &&
                    this._atmosphere.drawStars(this, this.style.fog),
                  !this.terrain)
                )
                  for (
                    this.currentLayer = n.length - 1;
                    this.currentLayer >= 0;
                    this.currentLayer--
                  ) {
                    const t = o[this.currentLayer],
                      i = e1.getLayerSourceCache(t);
                    if (t.isSky()) continue;
                    const r = i ? (t.is3D() ? p : h)[i.id] : void 0;
                    this._renderTileClippingMasks(t, i, r),
                      this.renderLayer(this, i, t, r);
                  }
                if (
                  (this.style.fog &&
                    this.transform.projection.supportsFog &&
                    this._atmosphere &&
                    !this._showOverdrawInspector &&
                    y &&
                    this._atmosphere.drawAtmosphereGlow(this, this.style.fog),
                  (this.renderPass = "sky"),
                  (!this._atmosphere || Ed(this.transform.zoom) > 0) &&
                    ("globe" === this.transform.projection.name ||
                      this.transform.isHorizonVisible()))
                )
                  for (
                    this.currentLayer = 0;
                    this.currentLayer < n.length;
                    this.currentLayer++
                  ) {
                    const t = o[this.currentLayer],
                      i = e1.getLayerSourceCache(t);
                    t.isSky() &&
                      this.renderLayer(this, i, t, i ? h[i.id] : void 0);
                  }
                (this.renderPass = "translucent"),
                  (this.currentLayer = 0),
                  (this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER);
                let v = 0;
                for (
                  _ && (v = _.getShadowCastingLayerCount());
                  this.currentLayer < n.length;

                ) {
                  const t = o[this.currentLayer],
                    i = e1.getLayerSourceCache(t);
                  if (t.isSky()) {
                    ++this.currentLayer;
                    continue;
                  }
                  if (g && this.style.isLayerDraped(t)) {
                    if (t.isHidden(this.transform.zoom)) {
                      ++this.currentLayer;
                      continue;
                    }
                    this.currentLayer = g.renderBatch(this.currentLayer);
                    continue;
                  }
                  let r;
                  if (
                    (i &&
                      (r = ("symbol" === t.type ? u : t.is3D() ? p : h)[i.id]),
                    this._renderTileClippingMasks(t, i, i ? c[i.id] : void 0),
                    this.renderLayer(this, i, t, r),
                    !g &&
                      _ &&
                      v > 0 &&
                      t.hasShadowPass() &&
                      0 == --v &&
                      (_.drawGroundShadows(),
                      this.firstLightBeamLayer <= this.currentLayer))
                  ) {
                    const t = this.currentLayer;
                    for (
                      this.renderPass = "light-beam",
                        this.currentLayer = this.firstLightBeamLayer;
                      this.currentLayer <= t;
                      this.currentLayer++
                    ) {
                      const t = o[this.currentLayer];
                      if (!t.hasLightBeamPass()) continue;
                      const i = e1.getLayerSourceCache(t);
                      this.renderLayer(this, i, t, i ? h[i.id] : void 0);
                    }
                    (this.currentLayer = t), (this.renderPass = "translucent");
                  }
                  ++this.currentLayer;
                }
                if (
                  (this.terrain && this.terrain.postRender(),
                  this.options.showTileBoundaries ||
                    this.options.showQueryGeometry ||
                    this.options.showTileAABBs)
                ) {
                  let t = null;
                  o.forEach((i) => {
                    const r = e1.getLayerSourceCache(i);
                    r &&
                      !i.isHidden(this.transform.zoom) &&
                      r.getVisibleCoordinates().length &&
                      (!t || t.getSource().maxzoom < r.getSource().maxzoom) &&
                      (t = r);
                  }),
                    t &&
                      this.options.showTileBoundaries &&
                      IA.debug(this, t, t.getVisibleCoordinates());
                }
                this.options.showPadding &&
                  (function (e1) {
                    const t = e1.transform.padding;
                    rA(e1, e1.transform.height - (t.top || 0), 3, KM),
                      rA(e1, t.bottom || 0, 3, JM),
                      nA(e1, t.left || 0, 3, QM),
                      nA(e1, e1.transform.width - (t.right || 0), 3, eA);
                    const i = e1.transform.centerPoint;
                    !(function (e1, t, i, r) {
                      oA(e1, t - 1, i - 10, 2, 20, r),
                        oA(e1, t - 10, i - 1, 20, 2, r);
                    })(e1, i.x, e1.transform.height - i.y, tA);
                  })(this),
                  this.context.setDefault(),
                  (this.frameCounter =
                    (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER),
                  this.tileLoaded &&
                    this.options.speedIndexTiming &&
                    (this.loadTimeStamps.push(t.performance.now()),
                    this.saveCanvasCopy()),
                  l || (this.conflationActive = !1);
              }
              uploadLayer(e1, t, i) {
                this.gpuTimingStart(t),
                  (!e1.transform.projection.unsupportedLayers ||
                    !e1.transform.projection.unsupportedLayers.includes(
                      t.type,
                    ) ||
                    (e1.terrain && "custom" === t.type)) &&
                    CA[`${t.type}Upload`] &&
                    CA[`${t.type}Upload`](e1, i, t.scope),
                  this.gpuTimingEnd();
              }
              renderLayer(e1, t, i, r) {
                i.isHidden(this.transform.zoom) ||
                  (("background" === i.type ||
                    "sky" === i.type ||
                    "custom" === i.type ||
                    "model" === i.type ||
                    "raster" === i.type ||
                    (r && r.length)) &&
                    ((this.id = i.id),
                    this.gpuTimingStart(i),
                    (!e1.transform.projection.unsupportedLayers ||
                      !e1.transform.projection.unsupportedLayers.includes(
                        i.type,
                      ) ||
                      (e1.terrain && "custom" === i.type)) &&
                      IA[i.type](
                        e1,
                        t,
                        i,
                        r,
                        this.style.placement.variableOffsets,
                        this.options.isInitialLoad,
                      ),
                    this.gpuTimingEnd()));
              }
              gpuTimingStart(e1) {
                if (!this.options.gpuTiming) return;
                const t = this.context.extTimerQuery,
                  i = this.context.gl;
                let r = this.gpuTimers[e1.id];
                r ||
                  (r = this.gpuTimers[e1.id] =
                    {
                      calls: 0,
                      cpuTime: 0,
                      query: i.createQuery(),
                    }),
                  r.calls++,
                  i.beginQuery(t.TIME_ELAPSED_EXT, r.query);
              }
              gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                  const e1 = this.context.extTimerQuery,
                    t = this.context.gl,
                    i = t.createQuery();
                  this.deferredRenderGpuTimeQueries.push(i),
                    t.beginQuery(e1.TIME_ELAPSED_EXT, i);
                }
              }
              gpuTimingDeferredRenderEnd() {
                this.options.gpuTimingDeferredRender &&
                  this.context.gl.endQuery(
                    this.context.extTimerQuery.TIME_ELAPSED_EXT,
                  );
              }
              gpuTimingEnd() {
                this.options.gpuTiming &&
                  this.context.gl.endQuery(
                    this.context.extTimerQuery.TIME_ELAPSED_EXT,
                  );
              }
              collectGpuTimers() {
                const e1 = this.gpuTimers;
                return (this.gpuTimers = {}), e1;
              }
              collectDeferredRenderGpuQueries() {
                const e1 = this.deferredRenderGpuTimeQueries;
                return (this.deferredRenderGpuTimeQueries = []), e1;
              }
              queryGpuTimers(e1) {
                const t = {};
                for (const i in e1) {
                  const r = e1[i],
                    n = this.context.extTimerQuery,
                    o =
                      n.getQueryParameter(
                        r.query,
                        this.context.gl.QUERY_RESULT,
                      ) / 1e6;
                  n.deleteQueryEXT(r.query), (t[i] = o);
                }
                return t;
              }
              queryGpuTimeDeferredRender(e1) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t = this.context.extTimerQuery,
                  i = this.context.gl;
                let r = 0;
                for (const n of e1)
                  (r += t.getQueryParameter(n, i.QUERY_RESULT) / 1e6),
                    t.deleteQueryEXT(n);
                return r;
              }
              translatePosMatrix(e1, t, i, r, n) {
                if (!i[0] && !i[1]) return e1;
                const o = n
                  ? "map" === r
                    ? this.transform.angle
                    : 0
                  : "viewport" === r
                  ? -this.transform.angle
                  : 0;
                if (o) {
                  const e1 = Math.sin(o),
                    t = Math.cos(o);
                  i = [i[0] * t - i[1] * e1, i[0] * e1 + i[1] * t];
                }
                const s = [
                    n ? i[0] : Xx(t, i[0], this.transform.zoom),
                    n ? i[1] : Xx(t, i[1], this.transform.zoom),
                    0,
                  ],
                  a = new Float32Array(16);
                return xu.translate(a, e1, s), a;
              }
              saveTileTexture(e1) {
                const t = this._tileTextures[e1.size[0]];
                t ? t.push(e1) : (this._tileTextures[e1.size[0]] = [e1]);
              }
              getTileTexture(e1) {
                const t = this._tileTextures[e1];
                return t && t.length > 0 ? t.pop() : null;
              }
              isPatternMissing(e1, t) {
                return (
                  null === e1 ||
                  (void 0 !== e1 &&
                    !this.imageManager.getPattern(e1.toString(), t))
                );
              }
              terrainRenderModeElevated() {
                return (
                  this.style &&
                  !!this.style.getTerrain() &&
                  !!this.terrain &&
                  !this.terrain.renderingToTexture
                );
              }
              terrainUseFloatDEM() {
                return null != this.context.extTextureFloatLinear;
              }
              currentGlobalDefines(e1, t, i) {
                const r =
                    void 0 === i
                      ? this.terrain && this.terrain.renderingToTexture
                      : i,
                  n = this.terrain && 0 === this.terrain.exaggeration(),
                  o = [];
                return (
                  this.style &&
                    this.style.enable3dLights() &&
                    ("globeRaster" === e1 || "terrainRaster" === e1
                      ? (o.push("LIGHTING_3D_MODE"),
                        o.push("LIGHTING_3D_ALPHA_EMISSIVENESS"))
                      : r || o.push("LIGHTING_3D_MODE")),
                  "shadow" === this.renderPass
                    ? this._shadowMapDebug || o.push("DEPTH_TEXTURE")
                    : this.shadowRenderer &&
                      (this.shadowRenderer.useNormalOffset
                        ? o.push(
                            "RENDER_SHADOWS",
                            "DEPTH_TEXTURE",
                            "NORMAL_OFFSET",
                          )
                        : o.push("RENDER_SHADOWS", "DEPTH_TEXTURE")),
                  this.terrainRenderModeElevated() &&
                    (o.push("TERRAIN"),
                    this.terrainUseFloatDEM() &&
                      o.push("TERRAIN_DEM_FLOAT_FORMAT"),
                    n && o.push("ZERO_EXAGGERATION")),
                  "globe" === this.transform.projection.name && o.push("GLOBE"),
                  !this._fogVisible ||
                    r ||
                    (void 0 !== t && !t) ||
                    o.push("FOG", "FOG_DITHERING"),
                  r && o.push("RENDER_TO_TEXTURE"),
                  this._showOverdrawInspector && o.push("OVERDRAW_INSPECTOR"),
                  o
                );
              }
              getOrCreateProgram(e1, t) {
                this.cache = this.cache || {};
                const i = (t && t.defines) || [],
                  r = t && t.config,
                  n = this.currentGlobalDefines(
                    e1,
                    t && t.overrideFog,
                    t && t.overrideRtt,
                  ).concat(i),
                  o = aM.cacheKey(kE[e1], e1, n, r);
                return (
                  this.cache[o] ||
                    (this.cache[o] = new aM(
                      this.context,
                      e1,
                      kE[e1],
                      r,
                      LM[e1],
                      n,
                    )),
                  this.cache[o]
                );
              }
              setCustomLayerDefaults() {
                this.context.unbindVAO(),
                  this.context.cullFace.setDefault(),
                  this.context.frontFace.setDefault(),
                  this.context.cullFaceSide.setDefault(),
                  this.context.activeTexture.setDefault(),
                  this.context.pixelStoreUnpack.setDefault(),
                  this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.context.pixelStoreUnpackFlipY.setDefault();
              }
              setBaseState() {
                const e1 = this.context.gl;
                this.context.cullFace.set(!1),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.blendEquation.set(e1.FUNC_ADD);
              }
              initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas &&
                  ((this.debugOverlayCanvas =
                    t.document.createElement("canvas")),
                  (this.debugOverlayCanvas.width = 512),
                  (this.debugOverlayCanvas.height = 512),
                  (this.debugOverlayTexture = new gy(
                    this.context,
                    this.debugOverlayCanvas,
                    this.context.gl.RGBA,
                  )));
              }
              destroy() {
                this._terrain && this._terrain.destroy(),
                  this._atmosphere &&
                    (this._atmosphere.destroy(), (this._atmosphere = void 0)),
                  this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                  this.emptyTexture.destroy(),
                  this.debugOverlayTexture &&
                    this.debugOverlayTexture.destroy(),
                  this._wireframeDebugCache.destroy();
              }
              prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
              }
              uploadCommonLightUniforms(e1, t) {
                if (this.style.enable3dLights()) {
                  const i = this.style.directionalLight,
                    r = this.style.ambientLight;
                  if (i && r) {
                    const n = ((e1, t) => {
                      const i = e1.properties.get("direction"),
                        r = e1.properties.get("color").toArray01(),
                        n = e1.properties.get("intensity"),
                        o = t.properties.get("color").toArray01(),
                        s = t.properties.get("intensity"),
                        a = [i.x, i.y, i.z],
                        l = se(o, s),
                        c = se(r, n);
                      return {
                        u_lighting_ambient_color: l,
                        u_lighting_directional_dir: a,
                        u_lighting_directional_color: c,
                        u_ground_radiance: nM(a, c, l),
                      };
                    })(i, r);
                    t.setLightsUniformValues(e1, n);
                  }
                }
              }
              uploadCommonUniforms(e1, t, i, r, n) {
                if (
                  (this.uploadCommonLightUniforms(e1, t),
                  this.terrain && this.terrain.renderingToTexture)
                )
                  return;
                const o = this.style.fog;
                if (o) {
                  const n = o.getOpacity(this.transform.pitch),
                    s = ((e1, t, i, r, n, o, s, a, l, c, h, u) => {
                      const d = e1.transform,
                        p = t.properties.get("color").toArray01();
                      p[3] = r;
                      const f = (e1.frameCounter / 1e3) % 1,
                        [m, _] = t.properties.get("vertical-range");
                      return {
                        u_fog_matrix: i
                          ? d.calculateFogTileMatrix(i)
                          : u || e1.identityMat,
                        u_fog_range: t.getFovAdjustedRange(d._fov),
                        u_fog_color: p,
                        u_fog_horizon_blend: t.properties.get("horizon-blend"),
                        u_fog_vertical_limit: [Math.min(m, _), _],
                        u_fog_temporal_offset: f,
                        u_frustum_tl: n,
                        u_frustum_tr: o,
                        u_frustum_br: s,
                        u_frustum_bl: a,
                        u_globe_pos: l,
                        u_globe_radius: c,
                        u_viewport: h,
                        u_globe_transition: Ed(d.zoom),
                        u_is_globe: +("globe" === d.projection.name),
                      };
                    })(
                      this,
                      o,
                      i,
                      n,
                      this.transform.frustumCorners.TL,
                      this.transform.frustumCorners.TR,
                      this.transform.frustumCorners.BR,
                      this.transform.frustumCorners.BL,
                      this.transform.globeCenterInViewSpace,
                      this.transform.globeRadius,
                      [
                        this.transform.width * ht.devicePixelRatio,
                        this.transform.height * ht.devicePixelRatio,
                      ],
                      r,
                    );
                  t.setFogUniformValues(e1, s);
                }
                n && t.setCutoffUniformValues(e1, n.uniformValues);
              }
              setTileLoadedFlag(e1) {
                this.tileLoaded = e1;
              }
              saveCanvasCopy() {
                const e1 = this.canvasCopy();
                e1 && (this.frameCopies.push(e1), (this.tileLoaded = !1));
              }
              canvasCopy() {
                const e1 = this.context.gl,
                  t = e1.createTexture();
                return (
                  e1.bindTexture(e1.TEXTURE_2D, t),
                  e1.copyTexImage2D(
                    e1.TEXTURE_2D,
                    0,
                    e1.RGBA,
                    0,
                    0,
                    e1.drawingBufferWidth,
                    e1.drawingBufferHeight,
                    0,
                  ),
                  t
                );
              }
              getCanvasCopiesAndTimestamps() {
                return {
                  canvasCopies: this.frameCopies,
                  timeStamps: this.loadTimeStamps,
                };
              }
              averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e1 = this.style && this.style.fog;
                return !!e1 && 0 !== e1.getOpacity(this.transform.pitch);
              }
              getBackgroundTiles() {
                const e1 = this._backgroundTiles,
                  t = (this._backgroundTiles = {}),
                  i = this.transform.coveringTiles({
                    tileSize: 512,
                  });
                for (const r of i)
                  t[r.key] =
                    e1[r.key] || new Iy(r, 512, this.transform.tileZoom, this);
                return t;
              }
              clearBackgroundTiles() {
                this._backgroundTiles = {};
              }
              layerUsedInConflation(e1, t) {
                return !(
                  !e1.is3D() ||
                  (e1.minzoom && e1.minzoom > this.transform.zoom) ||
                  ("building" !== e1.sourceLayer &&
                    (!t || "batched-model" !== t.type))
                );
              }
              isTileAffectedByFog(e1) {
                if (!this.style || !this.style.fog) return !1;
                if ("globe" === this.transform.projection.name) return !0;
                let t = this._cachedTileFogOpacities[e1.key];
                return (
                  t ||
                    (this._cachedTileFogOpacities[e1.key] = t =
                      this.style.fog.getOpacityForTile(e1)),
                  t[0] >= sw || t[1] >= sw
                );
              }
            }
            const DA = 2048;
            class PA {
              constructor(e1, t) {
                (this.aabb = e1), (this.lastCascade = t);
              }
            }
            class RA {
              add(e1, t) {
                const i = this.receivers[e1.key];
                void 0 !== i
                  ? ((i.aabb.min[0] = Math.min(i.aabb.min[0], t.min[0])),
                    (i.aabb.min[1] = Math.min(i.aabb.min[1], t.min[1])),
                    (i.aabb.min[2] = Math.min(i.aabb.min[2], t.min[2])),
                    (i.aabb.max[0] = Math.max(i.aabb.max[0], t.max[0])),
                    (i.aabb.max[1] = Math.max(i.aabb.max[1], t.max[1])),
                    (i.aabb.max[2] = Math.max(i.aabb.max[2], t.max[2])))
                  : (this.receivers[e1.key] = new PA(t, null));
              }
              clear() {
                this.receivers = {};
              }
              get(e1) {
                return this.receivers[e1.key];
              }
              computeRequiredCascades(e1, t, i) {
                const r = Hu.fromPoints(e1.points);
                let n = 0;
                for (const e1 in this.receivers) {
                  const o = this.receivers[e1];
                  if (!o) continue;
                  if (!r.intersectsAabb(o.aabb)) continue;
                  (o.aabb.min = r.closestPoint(o.aabb.min)),
                    (o.aabb.max = r.closestPoint(o.aabb.max));
                  const s = o.aabb.getCorners();
                  for (let e1 = 0; e1 < i.length; e1++) {
                    let r = !0;
                    for (const n of s) {
                      const o = [n[0] * t, n[1] * t, n[2]];
                      if (
                        (Mu.transformMat4(o, o, i[e1].matrix),
                        o[0] < -1 || o[0] > 1 || o[1] < -1 || o[1] > 1)
                      ) {
                        r = !1;
                        break;
                      }
                    }
                    if (((o.lastCascade = e1), (n = Math.max(n, e1)), r)) break;
                  }
                }
                return n + 1;
              }
            }
            class LA {
              constructor(e1) {
                (this.painter = e1),
                  (this._enabled = !1),
                  (this._shadowLayerCount = 0),
                  (this._numCascadesToRender = 0),
                  (this._cascades = []),
                  (this._groundShadowTiles = []),
                  (this._receivers = new RA()),
                  (this._depthMode = new gx(
                    e1.context.gl.LEQUAL,
                    gx.ReadWrite,
                    [0, 1],
                  )),
                  (this._uniformValues = {
                    u_light_matrix_0: new Float32Array(16),
                    u_light_matrix_1: new Float32Array(16),
                    u_shadow_intensity: 0,
                    u_fade_range: [0, 0],
                    u_shadow_normal_offset: [1, 1, 1],
                    u_shadow_texel_size: 1,
                    u_shadow_map_resolution: 1,
                    u_shadow_direction: [0, 0, 1],
                    u_shadow_bias: [36e-5, 0.0012, 0.012],
                    u_shadowmap_0: 0,
                    u_shadowmap_1: 0,
                  }),
                  (this.useNormalOffset = !1);
              }
              destroy() {
                for (const e1 of this._cascades)
                  e1.texture.destroy(), e1.framebuffer.destroy();
                this._cascades = [];
              }
              updateShadowParameters(e1, t) {
                const i = this.painter;
                if (
                  ((this._enabled = !1),
                  (this._shadowLayerCount = 0),
                  this._receivers.clear(),
                  !t || !t.properties)
                )
                  return;
                const r = t.properties.get("shadow-intensity");
                if (!t.shadowsEnabled() || r <= 0) return;
                if (
                  ((this._shadowLayerCount = i.style.order.reduce((t, r) => {
                    const n = i.style._mergedLayers[r];
                    return (
                      t + (n.hasShadowPass() && !n.isHidden(e1.zoom) ? 1 : 0)
                    );
                  }, 0)),
                  (this._enabled = this._shadowLayerCount > 0),
                  !this._enabled)
                )
                  return;
                const n = i.context,
                  o = DA,
                  s = DA;
                if (0 === this._cascades.length)
                  for (let e1 = 0; e1 < 2; ++e1) {
                    const e1 = i._shadowMapDebug,
                      t = n.gl,
                      r = n.createFramebuffer(o, s, e1, "texture"),
                      a = new gy(
                        n,
                        {
                          width: o,
                          height: s,
                          data: null,
                        },
                        t.DEPTH_COMPONENT,
                      );
                    if ((r.depthAttachment.set(a.texture), e1)) {
                      const e1 = new gy(
                        n,
                        {
                          width: o,
                          height: s,
                          data: null,
                        },
                        t.RGBA,
                      );
                      r.colorAttachment.set(e1.texture);
                    }
                    this._cascades.push({
                      framebuffer: r,
                      texture: a,
                      matrix: [],
                      far: 0,
                      boundingSphereRadius: 0,
                      frustum: new $u(),
                      scale: 0,
                    });
                  }
                this.shadowDirection = OA(t);
                let a = 0;
                if (e1.elevation) {
                  const t = e1.elevation,
                    i = [1e4, -10000];
                  t.visibleDemTiles
                    .filter((e1) => e1.dem)
                    .forEach((e1) => {
                      const t = e1.dem.tree;
                      (i[0] = Math.min(i[0], t.minimums[0])),
                        (i[1] = Math.max(i[1], t.maximums[0]));
                    }),
                    1e4 !== i[0] && (a = (i[1] - i[0]) * t.exaggeration());
                }
                const l = 1.5 * e1.cameraToCenterDistance,
                  c = 3 * l,
                  h = new Float64Array(16);
                for (let t = 0; t < 2; ++t) {
                  const i = this._cascades[t];
                  let r = e1.height / 50,
                    n = 1;
                  0 === t ? (n = l) : ((r = l), (n = c));
                  const [o, s] = FA(e1, this.shadowDirection, r, n, DA, a);
                  (i.scale = e1.scale),
                    (i.matrix = o),
                    (i.boundingSphereRadius = s),
                    xu.invert(h, i.matrix),
                    (i.frustum = $u.fromInvProjectionMatrix(h, 1, 0, !0)),
                    (i.far = n);
                }
                (this._uniformValues.u_fade_range = [
                  0.75 * this._cascades[1].far,
                  this._cascades[1].far,
                ]),
                  (this._uniformValues.u_shadow_intensity = r),
                  (this._uniformValues.u_shadow_direction = [
                    this.shadowDirection[0],
                    this.shadowDirection[1],
                    this.shadowDirection[2],
                  ]),
                  (this._uniformValues.u_shadow_texel_size = 0.00048828125),
                  (this._uniformValues.u_shadow_map_resolution = DA),
                  (this._uniformValues.u_shadowmap_0 = zM.ShadowMap0),
                  (this._uniformValues.u_shadowmap_1 = zM.ShadowMap0 + 1),
                  (this._groundShadowTiles = i.transform.coveringTiles({
                    tileSize: 512,
                    renderWorldCopies: !0,
                  }));
                const u = i.transform.elevation;
                for (const e1 of this._groundShadowTiles) {
                  let t = {
                    min: 0,
                    max: 0,
                  };
                  if (u) {
                    const i = u.getMinMaxForTile(e1);
                    i && (t = i);
                  }
                  this.addShadowReceiver(e1.toUnwrapped(), t.min, t.max);
                }
              }
              get enabled() {
                return this._enabled;
              }
              set enabled(e1) {
                this._enabled = e1;
              }
              drawShadowPass(e1, t) {
                if (!this._enabled) return;
                const i = this.painter,
                  r = i.context;
                (this._numCascadesToRender =
                  this._receivers.computeRequiredCascades(
                    i.transform.getFrustum(0),
                    i.transform.worldSize,
                    this._cascades,
                  )),
                  r.viewport.set([0, 0, DA, DA]);
                for (let n = 0; n < this._numCascadesToRender; ++n) {
                  (i.currentShadowCascade = n),
                    r.bindFramebuffer.set(
                      this._cascades[n].framebuffer.framebuffer,
                    ),
                    r.clear({
                      color: li.white,
                      depth: 1,
                    });
                  for (const r of e1.order) {
                    const n = e1._mergedLayers[r];
                    if (!n.hasShadowPass() || n.isHidden(i.transform.zoom))
                      continue;
                    const o = e1.getLayerSourceCache(n),
                      s = o ? t[o.id] : void 0;
                    ("model" === n.type || (s && s.length)) &&
                      i.renderLayer(i, o, n, s);
                  }
                }
                i.currentShadowCascade = 0;
              }
              drawGroundShadows() {
                if (!this._enabled) return;
                const e1 = this.painter,
                  t = e1.style,
                  i = e1.context,
                  r = t.directionalLight,
                  n = t.ambientLight;
                if (!r || !n) return;
                const o = [],
                  s = $E(e1, e1.longestCutoffRange);
                s.shouldRenderCutoff && o.push("RENDER_CUTOFF");
                const a = BA(r, n),
                  l = new gx(i.gl.LEQUAL, gx.ReadOnly, e1.depthRangeFor3D);
                for (const t of this._groundShadowTiles) {
                  const r = t.toUnwrapped(),
                    n = e1.isTileAffectedByFog(t),
                    c = e1.getOrCreateProgram("groundShadow", {
                      defines: o,
                      overrideFog: n,
                    });
                  this.setupShadows(r, c),
                    e1.uploadCommonUniforms(i, c, r, null, s);
                  const h = {
                    u_matrix: e1.transform.calculateProjMatrix(r),
                    u_ground_shadow_factor: a,
                  };
                  c.draw(
                    e1,
                    i.gl.TRIANGLES,
                    l,
                    xx.disabled,
                    bx.multiply,
                    Ex.disabled,
                    h,
                    "ground_shadow",
                    e1.tileExtentBuffer,
                    e1.quadTriangleIndexBuffer,
                    e1.tileExtentSegments,
                    {},
                    e1.transform.zoom,
                    null,
                    null,
                  );
                }
              }
              getShadowPassColorMode() {
                return this.painter._shadowMapDebug
                  ? bx.unblended
                  : bx.disabled;
              }
              getShadowPassDepthMode() {
                return this._depthMode;
              }
              getShadowCastingLayerCount() {
                return this._shadowLayerCount;
              }
              calculateShadowPassMatrixFromTile(e1) {
                const t = this.painter.transform,
                  i = t.calculatePosMatrix(e1, t.worldSize);
                return (
                  xu.multiply(
                    i,
                    this._cascades[this.painter.currentShadowCascade].matrix,
                    i,
                  ),
                  Float32Array.from(i)
                );
              }
              calculateShadowPassMatrixFromMatrix(e1) {
                return (
                  xu.multiply(
                    e1,
                    this._cascades[this.painter.currentShadowCascade].matrix,
                    e1,
                  ),
                  Float32Array.from(e1)
                );
              }
              setupShadows(e1, t, i, r = 0) {
                if (!this._enabled) return;
                const n = this.painter.transform,
                  o = this.painter.context,
                  s = o.gl,
                  a = this._uniformValues,
                  l = new Float64Array(16),
                  c = n.calculatePosMatrix(e1, n.worldSize);
                for (let e1 = 0; e1 < 2; e1++)
                  xu.multiply(l, this._cascades[e1].matrix, c),
                    (a[0 === e1 ? "u_light_matrix_0" : "u_light_matrix_1"] =
                      Float32Array.from(l)),
                    o.activeTexture.set(s.TEXTURE0 + zM.ShadowMap0 + e1),
                    this._cascades[e1].texture.bind(s.NEAREST, s.CLAMP_TO_EDGE);
                if (((this.useNormalOffset = !!i), this.useNormalOffset)) {
                  const t = Qd(e1.canonical),
                    o = ((2 / n.tileSize) * sr) / DA,
                    s = o * this._cascades[0].boundingSphereRadius,
                    l = o * this._cascades[1].boundingSphereRadius,
                    c =
                      ("vector-tile" === i ? 1 : 3) /
                      Math.pow(
                        2,
                        r - e1.canonical.z - (1 - n.zoom + Math.floor(n.zoom)),
                      );
                  (a.u_shadow_normal_offset = [t, s * c, l * c]),
                    (a.u_shadow_bias = [6e-5, 0.0012, 0.012]);
                } else a.u_shadow_bias = [36e-5, 0.0012, 0.012];
                t.setShadowUniformValues(o, a);
              }
              setupShadowsFromMatrix(e1, t, i = !1) {
                if (!this._enabled) return;
                const r = this.painter.context,
                  n = r.gl,
                  o = this._uniformValues,
                  s = new Float64Array(16);
                for (let t = 0; t < 2; t++)
                  xu.multiply(s, this._cascades[t].matrix, e1),
                    (o[0 === t ? "u_light_matrix_0" : "u_light_matrix_1"] =
                      Float32Array.from(s)),
                    r.activeTexture.set(n.TEXTURE0 + zM.ShadowMap0 + t),
                    this._cascades[t].texture.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                if (((this.useNormalOffset = i), i)) {
                  const e1 = 5;
                  (o.u_shadow_normal_offset = [1, e1, e1]),
                    (o.u_shadow_bias = [6e-5, 0.0012, 0.012]);
                } else o.u_shadow_bias = [36e-5, 0.0012, 0.012];
                t.setShadowUniformValues(r, o);
              }
              getShadowUniformValues() {
                return this._uniformValues;
              }
              getCurrentCascadeFrustum() {
                return this._cascades[this.painter.currentShadowCascade]
                  .frustum;
              }
              computeSimplifiedTileShadowVolume(e1, t, i, r) {
                if (r[2] >= 0) return {};
                const n = (function (e1, t, i) {
                    const r = i / (1 << e1.canonical.z);
                    return new Hu(
                      [
                        e1.canonical.x * r + e1.wrap * i,
                        e1.canonical.y * r + e1.wrap * i,
                        0,
                      ],
                      [
                        (e1.canonical.x + 1) * r + e1.wrap * i,
                        (e1.canonical.y + 1) * r + e1.wrap * i,
                        t,
                      ],
                    );
                  })(e1, t, i).getCorners(),
                  o = t / -r[2];
                r[0] < 0
                  ? (Mu.add(n[0], n[0], [r[0] * o, 0, 0]),
                    Mu.add(n[3], n[3], [r[0] * o, 0, 0]))
                  : r[0] > 0 &&
                    (Mu.add(n[1], n[1], [r[0] * o, 0, 0]),
                    Mu.add(n[2], n[2], [r[0] * o, 0, 0])),
                  r[1] < 0
                    ? (Mu.add(n[0], n[0], [0, r[1] * o, 0]),
                      Mu.add(n[1], n[1], [0, r[1] * o, 0]))
                    : r[1] > 0 &&
                      (Mu.add(n[2], n[2], [0, r[1] * o, 0]),
                      Mu.add(n[3], n[3], [0, r[1] * o, 0]));
                const s = {};
                return (
                  (s.vertices = n),
                  (s.planes = [
                    kA(n[1], n[0], n[4]),
                    kA(n[2], n[1], n[5]),
                    kA(n[3], n[2], n[6]),
                    kA(n[0], n[3], n[7]),
                  ]),
                  s
                );
              }
              addShadowReceiver(e1, t, i) {
                this._receivers.add(e1, Hu.fromTileIdAndHeight(e1, t, i));
              }
              getMaxCascadeForTile(e1) {
                const t = this._receivers.get(e1);
                return t && t.lastCascade ? t.lastCascade : 0;
              }
            }
            function kA(e1, t, i) {
              const r = Mu.sub([], i, t),
                n = Mu.sub([], e1, t),
                o = Mu.cross([], r, n),
                s = Mu.length(o);
              return 0 === s
                ? [0, 0, 1, 0]
                : (Mu.scale(o, o, 1 / s), [o[0], o[1], o[2], -Mu.dot(o, t)]);
            }
            function OA(e1) {
              const t = e1.properties.get("direction"),
                i = J(t.x, t.y, t.z);
              i[2] = z(i[2], 0, 75);
              const r = K([i[0], i[1], i[2]]);
              return Mu.fromValues(r.x, r.y, r.z);
            }
            function BA(e1, t) {
              const i = e1.properties.get("color"),
                r = e1.properties.get("intensity"),
                n = e1.properties.get("direction"),
                o = [n.x, n.y, n.z],
                s = t.properties.get("color"),
                a = t.properties.get("intensity"),
                l = Math.max(Mu.dot([0, 0, 1], o), 0),
                c = [0, 0, 0];
              Mu.scale(c, s.toArray01Linear().slice(0, 3), a);
              const h = [0, 0, 0];
              return (
                Mu.scale(h, i.toArray01Linear().slice(0, 3), l * r),
                ae([
                  c[0] > 0 ? c[0] / (c[0] + h[0]) : 0,
                  c[1] > 0 ? c[1] / (c[1] + h[1]) : 0,
                  c[2] > 0 ? c[2] / (c[2] + h[2]) : 0,
                ])
              );
            }
            function FA(e1, t, i, r, n, o) {
              const s = e1.zoom,
                a = e1.scale,
                l = e1.worldSize,
                c = 1 / l,
                h = e1.aspect,
                u = Math.sqrt(1 + h * h) * Math.tan(0.5 * e1.fovX),
                d = u * u,
                p = r - i,
                f = r + i;
              let m, _;
              d > p / f
                ? ((m = r), (_ = r * u))
                : ((m = 0.5 * f * (1 + d)),
                  (_ =
                    0.5 *
                    Math.sqrt(
                      p * p + 2 * (r * r + i * i) * d + f * f * d * d,
                    )));
              const g = e1.projection.pixelsPerMeter(e1.center.lat, l),
                y = e1._camera.getCameraToWorldMercator(),
                x = [0, 0, -m * c];
              Mu.transformMat4(x, x, y);
              let v = _ * c;
              const b = e1._edgeInsets;
              if (
                !(
                  (0 === b.left &&
                    0 === b.top &&
                    0 === b.right &&
                    0 === b.bottom) ||
                  (b.left === b.right && b.top === b.bottom)
                )
              ) {
                const t = e1._camera.getWorldToCamera(
                    e1.worldSize,
                    "meters" === e1.projection.zAxisUnit ? g : 1,
                  ),
                  n = e1._camera.getCameraToClipPerspective(
                    e1._fov,
                    e1.width / e1.height,
                    i,
                    r,
                  );
                (n[8] = (2 * -e1.centerOffset.x) / e1.width),
                  (n[9] = (2 * e1.centerOffset.y) / e1.height);
                const o = new Float64Array(16);
                xu.mul(o, n, t);
                const c = new Float64Array(16);
                xu.invert(c, o);
                const h = $u.fromInvProjectionMatrix(c, l, s, !0);
                for (const t of h.points) {
                  const i =
                    (((w = t)[0] /= a),
                    (w[1] /= a),
                    (w[2] = Zd(w[2], e1._center.lat)),
                    w);
                  v = Math.max(v, Mu.len(Mu.subtract([], x, i)));
                }
              }
              var w;
              v *= n / (n - 1);
              const T = Math.acos(t[2]),
                E = Math.atan2(-t[0], -t[1]),
                M = new jx();
              (M.position = x), M.setPitchBearing(T, E);
              const A = M.getWorldToCamera(l, g),
                S = v * l,
                I = Math.min(e1._mercatorZfromZoom(17) * l * -2, -2 * S),
                C = M.getCameraToClipOrthographic(
                  -S,
                  S,
                  -S,
                  S,
                  I,
                  (S + o * g) / t[2],
                ),
                z = new Float64Array(16);
              xu.multiply(z, C, A);
              const D = Mu.fromValues(
                  (Math.floor(1e6 * x[0]) / 1e6) * l,
                  (Math.floor(1e6 * x[1]) / 1e6) * l,
                  0,
                ),
                P = 0.5 * n,
                R = [0, 0, 0];
              Mu.transformMat4(R, D, z), Mu.scale(R, R, P);
              const L = [Math.floor(R[0]), Math.floor(R[1]), Math.floor(R[2])],
                k = [0, 0, 0];
              Mu.sub(k, R, L), Mu.scale(k, k, -1 / P);
              const O = new Float64Array(16);
              return (
                xu.identity(O),
                xu.translate(O, O, k),
                xu.multiply(z, O, z),
                [z, S]
              );
            }
            class NA extends It {
              constructor(e1) {
                super(),
                  (this.requestManager = e1),
                  (this.models = {
                    "": {},
                  }),
                  (this.numModelsLoading = {});
              }
              loadModel(e1, t) {
                return aT(this.requestManager.transformRequest(t, ye.Model).url)
                  .then((t) => {
                    if (!t) return;
                    const i = _T(t),
                      r = new bv(e1, void 0, void 0, i);
                    return r.computeBoundsAndApplyParent(), r;
                  })
                  .catch((i) => {
                    this.fire(
                      new St(
                        new Error(
                          `Could not load model ${e1} from ${t}: ${i.message}`,
                        ),
                      ),
                    );
                  });
              }
              load(e1, t) {
                this.models[t] || (this.models[t] = {});
                const i = Object.keys(e1);
                this.numModelsLoading[t] =
                  (this.numModelsLoading[t] || 0) + i.length;
                const r = [];
                for (const t of i) r.push(this.loadModel(t, e1[t]));
                Promise.allSettled(r)
                  .then((e1) => {
                    for (let r = 0; r < e1.length; r++) {
                      const { status: n, value: o } = e1[r];
                      "fulfilled" === n && o && (this.models[t][i[r]] = o);
                    }
                    (this.numModelsLoading[t] -= i.length),
                      this.fire(
                        new At("data", {
                          dataType: "style",
                        }),
                      );
                  })
                  .catch((e1) => {
                    this.fire(
                      new St(new Error(`Could not load models: ${e1.message}`)),
                    );
                  });
              }
              isLoaded() {
                for (const e1 in this.numModelsLoading)
                  if (this.numModelsLoading[e1] > 0) return !1;
                return !0;
              }
              hasModel(e1, t) {
                return !!this.getModel(e1, t);
              }
              getModel(e1, t) {
                return (
                  this.models[t] || (this.models[t] = {}), this.models[t][e1]
                );
              }
              addModel(e1, t, i) {
                this.models[i] || (this.models[i] = {}),
                  this.hasModel(e1, i) && this.removeModel(e1, i),
                  this.load(
                    {
                      [e1]: this.requestManager.normalizeModelURL(t),
                    },
                    i,
                  );
              }
              addModels(e1, t) {
                const i = {};
                for (const t in e1)
                  i[t] = this.requestManager.normalizeModelURL(e1[t]);
                this.load(i, t);
              }
              removeModel(e1, t) {
                this.models[t] || (this.models[t] = {});
                const i = this.models[t][e1];
                delete this.models[t][e1], i.destroy();
              }
              listModels(e1) {
                return (
                  this.models[e1] || (this.models[e1] = {}),
                  Object.keys(this.models[e1])
                );
              }
              upload(e1, t) {
                this.models[t] || (this.models[t] = {});
                for (const i in this.models[t])
                  this.models[t][i].upload(e1.context);
              }
            }
            const UA = (e1, t) =>
                ws(
                  e1,
                  t && t.filter((e1) => "source.canvas" !== e1.identifier),
                ),
              VA = O(CT, [
                "addLayer",
                "removeLayer",
                "setLights",
                "setPaintProperty",
                "setLayoutProperty",
                "setSlot",
                "setFilter",
                "addSource",
                "removeSource",
                "setLayerZoomRange",
                "setLight",
                "setTransition",
                "setGeoJSONSourceData",
                "setTerrain",
                "setFog",
                "setProjection",
                "setCamera",
                "addImport",
                "removeImport",
                "setImportUrl",
                "setImportData",
                "setImportConfig",
              ]),
              jA = O(CT, ["setCenter", "setZoom", "setBearing", "setPitch"]),
              GA = {
                version: 8,
                layers: [],
                sources: {},
              },
              qA = {
                duration: 300,
                delay: 0,
              },
              ZA = new Set([
                "fill",
                "line",
                "background",
                "hillshade",
                "raster",
              ]);
            class $A extends It {
              constructor(e1, t = {}) {
                super(),
                  (this.map = e1),
                  (this.scope = t.scope || ""),
                  (this.fragments = []),
                  (this.importDepth = t.importDepth || 0),
                  (this.importsCache = t.importsCache || new Map()),
                  (this.resolvedImports = t.resolvedImports || new Set()),
                  (this.transition = k({}, qA)),
                  (this._buildingIndex = new MT(this)),
                  (this.crossTileSymbolIndex = new wE()),
                  (this._mergedOrder = []),
                  (this._drapedFirstOrder = []),
                  (this._mergedLayers = {}),
                  (this._mergedSourceCaches = {}),
                  (this._mergedOtherSourceCaches = {}),
                  (this._mergedSymbolSourceCaches = {}),
                  (this._has3DLayers = !1),
                  (this._hasCircleLayers = !1),
                  (this._hasSymbolLayers = !1),
                  (this._changes = t.styleChanges || new ga()),
                  (this.dispatcher = t.dispatcher
                    ? t.dispatcher
                    : new _w(Uw(), this)),
                  t.imageManager
                    ? (this.imageManager = t.imageManager)
                    : ((this.imageManager = new Qb()),
                      this.imageManager.setEventedParent(this)),
                  this.imageManager.createScope(this.scope),
                  (this.glyphManager = t.glyphManager
                    ? t.glyphManager
                    : new K_(
                        e1._requestManager,
                        t.localFontFamily
                          ? 2
                          : t.localIdeographFontFamily
                          ? 1
                          : 0,
                        t.localFontFamily || t.localIdeographFontFamily,
                      )),
                  t.modelManager
                    ? (this.modelManager = t.modelManager)
                    : ((this.modelManager = new NA(e1._requestManager)),
                      this.modelManager.setEventedParent(this)),
                  (this._layers = {}),
                  (this._serializedLayers = {}),
                  (this._sourceCaches = {}),
                  (this._otherSourceCaches = {}),
                  (this._symbolSourceCaches = {}),
                  (this._loaded = !1),
                  (this._precompileDone = !1),
                  (this._shouldPrecompile = !1),
                  (this._availableImages = []),
                  (this._order = []),
                  (this._markersNeedUpdate = !1),
                  (this.options = new Map()),
                  (this._configDependentLayers = new Set()),
                  this.dispatcher.broadcast("setReferrer", ve());
                const i = this;
                (this._rtlTextPluginCallback = $A.registerForPluginStateChange(
                  (e1) => {
                    i.dispatcher.broadcast(
                      "syncRTLPluginState",
                      {
                        pluginStatus: e1.pluginStatus,
                        pluginURL: e1.pluginURL,
                      },
                      (e1, t) => {
                        if ((Ws(e1), t && t.every((e1) => e1)))
                          for (const e1 in i._sourceCaches) {
                            const t = i._sourceCaches[e1],
                              r = t.getSource().type;
                            ("vector" !== r && "geojson" !== r) || t.reload();
                          }
                      },
                    );
                  },
                )),
                  this.on("data", (e1) => {
                    if (
                      "source" !== e1.dataType ||
                      "metadata" !== e1.sourceDataType
                    )
                      return;
                    const t = this.getOwnSource(e1.sourceId);
                    if (t && t.vectorLayerIds)
                      for (const e1 in this._layers) {
                        const i = this._layers[e1];
                        i.source === t.id && this._validateLayer(i);
                      }
                  });
              }
              loadURL(e1, t = {}) {
                this.fire(
                  new At("dataloading", {
                    dataType: "style",
                  }),
                );
                const i = "boolean" == typeof t.validate ? t.validate : !De(e1);
                (e1 = this.map._requestManager.normalizeStyleURL(
                  e1,
                  t.accessToken,
                )),
                  this.resolvedImports.add(e1);
                const r = this.importsCache.get(e1);
                if (r) return this._load(r, i);
                const n = this.map._requestManager.transformRequest(
                  e1,
                  ye.Style,
                );
                this._request = we(n, (t, r) => {
                  if (((this._request = null), t)) this.fire(new St(t));
                  else if (r)
                    return this.importsCache.set(e1, r), this._load(r, i);
                });
              }
              loadJSON(e1, t = {}) {
                this.fire(
                  new At("dataloading", {
                    dataType: "style",
                  }),
                ),
                  (this._request = ht.frame(() => {
                    (this._request = null), this._load(e1, !1 !== t.validate);
                  }));
              }
              loadEmpty() {
                this.fire(
                  new At("dataloading", {
                    dataType: "style",
                  }),
                ),
                  this._load(GA, !1);
              }
              _loadImports(e1, t) {
                if (this.importDepth >= 4)
                  return (
                    W("Style doesn't support nesting deeper than 5"),
                    this._reloadImports()
                  );
                const i = [];
                for (const r of e1) {
                  const e1 = this._createFragmentStyle(r),
                    n = new Promise((t) => e1.on("style.import.load", t));
                  if ((i.push(n), this.resolvedImports.has(r.url))) {
                    e1.loadEmpty();
                    continue;
                  }
                  const o = r.data || this.importsCache.get(r.url);
                  o
                    ? e1.loadJSON(o, {
                        validate: t,
                      })
                    : r.url
                    ? e1.loadURL(r.url, {
                        validate: t,
                      })
                    : e1.loadEmpty(),
                    this.fragments.push({
                      style: e1,
                      id: r.id,
                      config: r.config,
                    });
                }
                Promise.all(i).then(() => this._reloadImports());
              }
              _createFragmentStyle(e1) {
                const t = this.scope ? pa(e1.id, this.scope) : e1.id,
                  i = new $A(this.map, {
                    scope: t,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                  });
                return (
                  i.setEventedParent(this.map, {
                    style: i,
                  }),
                  i.setConfig(e1.config),
                  i
                );
              }
              _reloadImports() {
                this.mergeAll(),
                  this._updateMapProjection(),
                  this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options,
                  });
                const e1 = this.isRootStyle();
                (this._shouldPrecompile = e1),
                  this.fire(
                    new At("data", {
                      dataType: "style",
                    }),
                  ),
                  this.fire(new At(e1 ? "style.load" : "style.import.load"));
              }
              _load(e1, t) {
                const i = e1.schema;
                if (
                  this.isRootStyle() &&
                  (e1.fragment || (i && !1 !== e1.fragment))
                ) {
                  const i = k({}, GA, {
                    imports: [
                      {
                        id: "basemap",
                        data: e1,
                        url: "",
                      },
                    ],
                  });
                  return void this._load(i, t);
                }
                if ((this.updateSchema(i), t && UA(this, hs(e1)))) return;
                (this._loaded = !0), (this.stylesheet = $(e1));
                for (const t in e1.sources)
                  this.addSource(t, e1.sources[t], {
                    validate: !1,
                  });
                (this._changes.changed = !1),
                  e1.sprite
                    ? this._loadSprite(e1.sprite)
                    : (this.imageManager.setLoaded(!0, this.scope),
                      this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0,
                      })),
                  this.glyphManager.setURL(e1.glyphs, this.scope);
                const r = IT(this.stylesheet.layers);
                if (
                  ((this._order = r.map((e1) => e1.id)),
                  this.stylesheet.light &&
                    W(
                      "The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.",
                    ),
                  this.stylesheet.lights)
                ) {
                  if (
                    1 === this.stylesheet.lights.length &&
                    "flat" === this.stylesheet.lights[0].type
                  ) {
                    const e1 = this.stylesheet.lights[0];
                    this.light = new tw(e1.properties, e1.id);
                  } else this.setLights(this.stylesheet.lights);
                }
                this.light || (this.light = new tw(this.stylesheet.light)),
                  (this._layers = {}),
                  (this._serializedLayers = {});
                for (const e1 of r) {
                  const t = Kb(e1, this.options);
                  t.setScope(this.scope),
                    t.isConfigDependent &&
                      this._configDependentLayers.add(t.fqid),
                    t.setEventedParent(this, {
                      layer: {
                        id: t.id,
                      },
                    }),
                    (this._layers[t.id] = t),
                    (this._layers[t.id] = t),
                    (this._serializedLayers[t.id] = t.serialize());
                  const i = this.getOwnLayerSourceCache(t),
                    r =
                      !!this.directionalLight &&
                      this.directionalLight.shadowsEnabled();
                  i && t.canCastShadows() && r && (i.castsShadows = !0);
                }
                this.stylesheet.models &&
                  this.modelManager.addModels(
                    this.stylesheet.models,
                    this.scope,
                  );
                const n = this.stylesheet.terrain;
                if (
                  (n &&
                    !this.terrainSetForDrapingOnly() &&
                    this._createTerrain(n, 1),
                  this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                  this.stylesheet.transition &&
                    this.setTransition(this.stylesheet.transition),
                  this.mergeAll(),
                  this._updateMapProjection(),
                  this.map._triggerCameraUpdate(this.camera),
                  this.fire(
                    new At("data", {
                      dataType: "style",
                    }),
                  ),
                  e1.imports)
                )
                  this._loadImports(e1.imports, t);
                else {
                  this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options,
                  });
                  const e1 = this.isRootStyle();
                  (this._shouldPrecompile = e1),
                    this.fire(new At(e1 ? "style.load" : "style.import.load"));
                }
              }
              isRootStyle() {
                return 0 === this.importDepth;
              }
              mergeAll() {
                let e1, t, i, r, n, o, s, a;
                this.forEachFragmentStyle((l) => {
                  if (l.stylesheet) {
                    if (
                      (null != l.light && (e1 = l.light), l.stylesheet.lights)
                    )
                      for (const e1 of l.stylesheet.lights)
                        "ambient" === e1.type &&
                          null != l.ambientLight &&
                          (t = l.ambientLight),
                          "directional" === e1.type &&
                            null != l.directionalLight &&
                            (i = l.directionalLight);
                    (l.stylesheet.terrain ||
                      (l.stylesheet.projection &&
                        "globe" === l.stylesheet.projection.name)) &&
                      null != l.terrain &&
                      (!r ||
                        (r && 0 === r.drapeRenderMode) ||
                        1 === l.terrain.drapeRenderMode) &&
                      (r = l.terrain),
                      l.stylesheet.fog && null != l.fog && (n = l.fog),
                      null != l.stylesheet.camera && (a = l.stylesheet.camera),
                      null != l.stylesheet.projection &&
                        (o = l.stylesheet.projection),
                      null != l.stylesheet.transition &&
                        (s = l.stylesheet.transition);
                  }
                }),
                  (this.light = e1),
                  (this.ambientLight = t),
                  (this.directionalLight = i),
                  (this.terrain = r),
                  (this.fog = n),
                  (this.camera = a || {
                    "camera-projection": "perspective",
                  }),
                  (this.projection = o || {
                    name: "mercator",
                  }),
                  (this.transition = k({}, qA, s)),
                  this.mergeSources(),
                  this.mergeLayers();
              }
              forEachFragmentStyle(e1) {
                const t = (i) => {
                  for (const e1 of i.fragments) t(e1.style);
                  e1(i);
                };
                t(this);
              }
              mergeTerrain() {
                let e1;
                this.forEachFragmentStyle((t) => {
                  null != t.terrain &&
                    (!e1 ||
                      (e1 && 0 === e1.drapeRenderMode) ||
                      1 === t.terrain.drapeRenderMode) &&
                    (e1 = t.terrain);
                }),
                  (this.terrain = e1);
              }
              mergeProjection() {
                let e1;
                this.forEachFragmentStyle((t) => {
                  null != t.stylesheet.projection &&
                    (e1 = t.stylesheet.projection);
                }),
                  (this.projection = e1 || {
                    name: "mercator",
                  });
              }
              mergeSources() {
                const e1 = {},
                  t = {},
                  i = {};
                this.forEachFragmentStyle((r) => {
                  for (const t in r._sourceCaches) {
                    const i = pa(t, r.scope);
                    e1[i] = r._sourceCaches[t];
                  }
                  for (const e1 in r._otherSourceCaches) {
                    const i = pa(e1, r.scope);
                    t[i] = r._otherSourceCaches[e1];
                  }
                  for (const e1 in r._symbolSourceCaches) {
                    const t = pa(e1, r.scope);
                    i[t] = r._symbolSourceCaches[e1];
                  }
                }),
                  (this._mergedSourceCaches = e1),
                  (this._mergedOtherSourceCaches = t),
                  (this._mergedSymbolSourceCaches = i);
              }
              mergeLayers() {
                const e1 = {},
                  t = [],
                  i = {};
                (this._has3DLayers = !1),
                  (this._hasCircleLayers = !1),
                  (this._hasSymbolLayers = !1),
                  this.forEachFragmentStyle((i) => {
                    for (const r of i._order) {
                      const n = i._layers[r];
                      if ("slot" === n.type) {
                        const t = fa(r);
                        if (e1[t]) continue;
                        e1[t] = [];
                      }
                      n.slot && e1[n.slot] ? e1[n.slot].push(n) : t.push(n);
                    }
                  }),
                  (this._mergedOrder = []);
                const r = (t = []) => {
                  for (const n of t)
                    if ("slot" === n.type) {
                      const t = fa(n.id);
                      e1[t] && r(e1[t]);
                    } else {
                      const e1 = pa(n.id, n.scope);
                      this._mergedOrder.push(e1),
                        (i[e1] = n),
                        n.is3D() && (this._has3DLayers = !0),
                        "circle" === n.type && (this._hasCircleLayers = !0),
                        "symbol" === n.type && (this._hasSymbolLayers = !0);
                    }
                };
                r(t),
                  (this._mergedLayers = i),
                  this.updateDrapeFirstLayers(),
                  this._buildingIndex.processLayersChanged();
              }
              terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
              }
              getCamera() {
                return this.stylesheet.camera;
              }
              setCamera(e1) {
                return (
                  (this.stylesheet.camera = k({}, this.stylesheet.camera, e1)),
                  (this.camera = this.stylesheet.camera),
                  this
                );
              }
              setProjection(e1) {
                e1
                  ? (this.stylesheet.projection = e1)
                  : delete this.stylesheet.projection,
                  this.mergeProjection(),
                  this._updateMapProjection();
              }
              applyProjectionUpdate() {
                this._loaded &&
                  (this.dispatcher.broadcast(
                    "setProjection",
                    this.map.transform.projectionOptions,
                  ),
                  this.map.transform.projection.requiresDraping
                    ? this.getTerrain() ||
                      this.stylesheet.terrain ||
                      this.setTerrainForDraping()
                    : this.terrainSetForDrapingOnly() && this.setTerrain(null));
              }
              _updateMapProjection() {
                this.isRootStyle() &&
                  (this.map._useExplicitProjection
                    ? this.applyProjectionUpdate()
                    : this.map._prioritizeAndUpdateProjection(
                        null,
                        this.projection,
                      ));
              }
              _loadSprite(e1) {
                this._spriteRequest = (function (e1, t, i) {
                  let r, n, o;
                  const s = ht.devicePixelRatio > 1 ? "@2x" : "";
                  let a = we(
                      t.transformRequest(
                        t.normalizeSpriteURL(e1, s, ".json"),
                        ye.SpriteJSON,
                      ),
                      (e1, t) => {
                        (a = null), o || ((o = e1), (r = t), c());
                      },
                    ),
                    l = Ie(
                      t.transformRequest(
                        t.normalizeSpriteURL(e1, s, ".png"),
                        ye.SpriteImage,
                      ),
                      (e1, t) => {
                        (l = null), o || ((o = e1), (n = t), c());
                      },
                    );
                  function c() {
                    if (o) i(o);
                    else if (r && n) {
                      const e1 = ht.getImageData(n),
                        t = {};
                      for (const i in r) {
                        const {
                            width: n,
                            height: o,
                            x: s,
                            y: a,
                            sdf: l,
                            pixelRatio: c,
                            stretchX: h,
                            stretchY: u,
                            content: d,
                          } = r[i],
                          p = new $p({
                            width: n,
                            height: o,
                          });
                        $p.copy(
                          e1,
                          p,
                          {
                            x: s,
                            y: a,
                          },
                          {
                            x: 0,
                            y: 0,
                          },
                          {
                            width: n,
                            height: o,
                          },
                        ),
                          (t[i] = {
                            data: p,
                            pixelRatio: c,
                            sdf: l,
                            stretchX: h,
                            stretchY: u,
                            content: d,
                          });
                      }
                      i(null, t);
                    }
                  }
                  return {
                    cancel() {
                      a && (a.cancel(), (a = null)),
                        l && (l.cancel(), (l = null));
                    },
                  };
                })(e1, this.map._requestManager, (e1, t) => {
                  if (((this._spriteRequest = null), e1)) this.fire(new St(e1));
                  else if (t)
                    for (const e1 in t)
                      this.imageManager.addImage(e1, this.scope, t[e1]);
                  this.imageManager.setLoaded(!0, this.scope),
                    (this._availableImages = this.imageManager.listImages(
                      this.scope,
                    )),
                    this.dispatcher.broadcast("setImages", {
                      scope: this.scope,
                      images: this._availableImages,
                    }),
                    this.dispatcher.broadcast("spriteLoaded", {
                      scope: this.scope,
                      isLoaded: !0,
                    }),
                    this.fire(
                      new At("data", {
                        dataType: "style",
                      }),
                    );
                });
              }
              _validateLayer(e1) {
                const t = this.getOwnSource(e1.source);
                if (!t) return;
                const i = e1.sourceLayer;
                i &&
                  ("geojson" === t.type ||
                    (t.vectorLayerIds && -1 === t.vectorLayerIds.indexOf(i))) &&
                  this.fire(
                    new St(
                      new Error(
                        `Source layer "${i}" does not exist on source "${t.id}" as specified by style layer "${e1.id}"`,
                      ),
                    ),
                  );
              }
              loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._changes.updatedSourceCaches).length)
                  return !1;
                for (const e1 in this._sourceCaches)
                  if (!this._sourceCaches[e1].loaded()) return !1;
                if (!this.imageManager.isLoaded()) return !1;
                if (!this.modelManager.isLoaded()) return !1;
                for (const { style: e1 } of this.fragments)
                  if (!e1.loaded()) return !1;
                return !0;
              }
              _serializeImports() {
                if (this.stylesheet.imports)
                  return this.stylesheet.imports.map((e1, t) => {
                    const i = this.fragments[t];
                    return i && i.style && (e1.data = i.style.serialize()), e1;
                  });
              }
              _serializeSources() {
                const e1 = {};
                for (const t in this._sourceCaches) {
                  const i = this._sourceCaches[t].getSource();
                  e1[i.id] || (e1[i.id] = i.serialize());
                }
                return e1;
              }
              _serializeLayers(e1) {
                const t = [];
                for (const i of e1) {
                  const e1 = this._layers[i];
                  e1 && "custom" !== e1.type && t.push(e1.serialize());
                }
                return t;
              }
              hasLightTransitions() {
                return (
                  !(!this.light || !this.light.hasTransition()) ||
                  !(!this.ambientLight || !this.ambientLight.hasTransition()) ||
                  !(
                    !this.directionalLight ||
                    !this.directionalLight.hasTransition()
                  )
                );
              }
              hasFogTransition() {
                return !!this.fog && this.fog.hasTransition();
              }
              hasTransitions() {
                if (this.hasLightTransitions()) return !0;
                if (this.hasFogTransition()) return !0;
                for (const e1 in this._sourceCaches)
                  if (this._sourceCaches[e1].hasTransition()) return !0;
                for (const e1 in this._layers)
                  if (this._layers[e1].hasTransition()) return !0;
                return !1;
              }
              get order() {
                return this.terrain
                  ? this._drapedFirstOrder
                  : this._mergedOrder;
              }
              isLayerDraped(e1) {
                return (
                  !!this.terrain &&
                  ("function" == typeof e1.isLayerDraped
                    ? e1.isLayerDraped(this.getLayerSourceCache(e1))
                    : ZA.has(e1.type))
                );
              }
              _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
              }
              _checkLayer(e1) {
                const t = this.getOwnLayer(e1);
                if (t) return t;
                this.fire(
                  new St(
                    new Error(
                      `The layer '${e1}' does not exist in the map's style.`,
                    ),
                  ),
                );
              }
              _checkSource(e1) {
                const t = this.getOwnSource(e1);
                if (t) return t;
                this.fire(
                  new St(
                    new Error(
                      `The source '${e1}' does not exist in the map's style.`,
                    ),
                  ),
                );
              }
              update(e1) {
                if (!this._loaded) return;
                this.ambientLight && this.ambientLight.recalculate(e1),
                  this.directionalLight &&
                    this.directionalLight.recalculate(e1);
                const t = this.calculateLightsBrightness();
                (e1.brightness = t || 0),
                  t !== this._brightness &&
                    ((this._brightness = t),
                    this.dispatcher.broadcast("setBrightness", t));
                const i = this._changes.changed;
                if (this._changes.changed) {
                  const t = this._changes.getLayerUpdatesByScope();
                  for (const e1 in t) {
                    const { updatedIds: i, removedIds: r } = t[e1];
                    (i || r) && this._updateWorkerLayers(e1, i, r);
                  }
                  this.updateSourceCaches(),
                    this._updateTilesForChangedImages(),
                    this.updateLayers(e1),
                    this.light && this.light.updateTransitions(e1),
                    this.ambientLight &&
                      this.ambientLight.updateTransitions(e1),
                    this.directionalLight &&
                      this.directionalLight.updateTransitions(e1),
                    this.fog && this.fog.updateTransitions(e1),
                    this._changes.reset();
                }
                const r = {};
                for (const e1 in this._mergedSourceCaches) {
                  const t = this._mergedSourceCaches[e1];
                  (r[e1] = t.used), (t.used = !1);
                }
                for (const t of this._mergedOrder) {
                  const i = this._mergedLayers[t];
                  if (
                    (i.recalculate(e1, this._availableImages),
                    !i.isHidden(e1.zoom))
                  ) {
                    const e1 = this.getOwnLayerSourceCache(i);
                    e1 && (e1.used = !0);
                  }
                  if (!this._precompileDone && this._shouldPrecompile)
                    for (let t = i.minzoom || 0; t < (i.maxzoom || 25.5); t++) {
                      const t = this.map.painter;
                      if (t) {
                        const r = i.getProgramIds();
                        if (!r) continue;
                        for (const n of r) {
                          const r = i.getDefaultProgramParams(n, e1.zoom);
                          r &&
                            ((t.style = this),
                            this.fog &&
                              ((t._fogVisible = !0),
                              (r.overrideFog = !0),
                              t.getOrCreateProgram(n, r)),
                            (t._fogVisible = !1),
                            (r.overrideFog = !1),
                            t.getOrCreateProgram(n, r),
                            (this.stylesheet.terrain ||
                              (this.stylesheet.projection &&
                                "globe" === this.stylesheet.projection.name)) &&
                              ((r.overrideRtt = !0),
                              t.getOrCreateProgram(n, r)));
                        }
                      }
                    }
                }
                this._shouldPrecompile && (this._precompileDone = !0);
                for (const e1 in r) {
                  const t = this._mergedSourceCaches[e1];
                  r[e1] !== t.used &&
                    t.getSource().fire(
                      new At("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: t.getSource().id,
                      }),
                    );
                }
                this.light && this.light.recalculate(e1),
                  this.terrain && this.terrain.recalculate(e1),
                  this.fog && this.fog.recalculate(e1),
                  (this.z = e1.zoom),
                  this._markersNeedUpdate &&
                    (this._updateMarkersOpacity(),
                    (this._markersNeedUpdate = !1)),
                  i &&
                    this.fire(
                      new At("data", {
                        dataType: "style",
                      }),
                    );
                for (const { style: t } of this.fragments) t.update(e1);
              }
              _updateTilesForChangedImages() {
                const e1 = Array.from(this._changes.changedImages.keys());
                if (e1.length) {
                  for (const t in this._sourceCaches)
                    this._sourceCaches[t].reloadTilesForDependencies(
                      ["icons", "patterns"],
                      e1,
                    );
                  this._changes.changedImages.clear();
                }
              }
              _updateWorkerLayers(e1, t, i) {
                const r = this.getFragmentStyle(e1);
                this.dispatcher.broadcast("updateLayers", {
                  layers: t ? r._serializeLayers(t) : [],
                  scope: e1,
                  removedIds: i || [],
                  options: r.options,
                });
              }
              setState(e1) {
                if ((this._checkLoaded(), UA(this, hs(e1)))) return !1;
                (e1 = $(e1)).layers = IT(e1.layers);
                const t = (function (e1, t) {
                  if (!e1)
                    return [
                      {
                        command: CT.setStyle,
                        args: [t],
                      },
                    ];
                  let i = [];
                  try {
                    if (!x(e1.version, t.version))
                      return [
                        {
                          command: CT.setStyle,
                          args: [t],
                        },
                      ];
                    x(e1.center, t.center) ||
                      i.push({
                        command: CT.setCenter,
                        args: [t.center],
                      }),
                      x(e1.zoom, t.zoom) ||
                        i.push({
                          command: CT.setZoom,
                          args: [t.zoom],
                        }),
                      x(e1.bearing, t.bearing) ||
                        i.push({
                          command: CT.setBearing,
                          args: [t.bearing],
                        }),
                      x(e1.pitch, t.pitch) ||
                        i.push({
                          command: CT.setPitch,
                          args: [t.pitch],
                        }),
                      x(e1.sprite, t.sprite) ||
                        i.push({
                          command: CT.setSprite,
                          args: [t.sprite],
                        }),
                      x(e1.glyphs, t.glyphs) ||
                        i.push({
                          command: CT.setGlyphs,
                          args: [t.glyphs],
                        }),
                      x(e1.transition, t.transition) ||
                        i.push({
                          command: CT.setTransition,
                          args: [t.transition],
                        }),
                      x(e1.light, t.light) ||
                        i.push({
                          command: CT.setLight,
                          args: [t.light],
                        }),
                      x(e1.fog, t.fog) ||
                        i.push({
                          command: CT.setFog,
                          args: [t.fog],
                        }),
                      x(e1.projection, t.projection) ||
                        i.push({
                          command: CT.setProjection,
                          args: [t.projection],
                        }),
                      x(e1.lights, t.lights) ||
                        i.push({
                          command: CT.setLights,
                          args: [t.lights],
                        }),
                      x(e1.camera, t.camera) ||
                        i.push({
                          command: CT.setCamera,
                          args: [t.camera],
                        });
                    const r = {},
                      n = [];
                    !(function (e1, t, i, r) {
                      let n;
                      for (n in ((t = t || {}), (e1 = e1 || {})))
                        e1.hasOwnProperty(n) &&
                          (t.hasOwnProperty(n) || DT(n, i, r));
                      for (n in t) {
                        if (!t.hasOwnProperty(n)) continue;
                        const o = t[n];
                        e1.hasOwnProperty(n)
                          ? x(e1[n], o) ||
                            ("geojson" === e1[n].type &&
                            "geojson" === o.type &&
                            RT(e1, t, n)
                              ? i.push({
                                  command: CT.setGeoJSONSourceData,
                                  args: [n, o.data],
                                })
                              : PT(n, t, i, r))
                          : zT(n, t, i);
                      }
                    })(e1.sources, t.sources, n, r);
                    const o = [];
                    e1.layers &&
                      e1.layers.forEach((e1) => {
                        e1.source && r[e1.source]
                          ? i.push({
                              command: CT.removeLayer,
                              args: [e1.id],
                            })
                          : o.push(e1);
                      });
                    let s = e1.terrain;
                    s &&
                      r[s.source] &&
                      (i.push({
                        command: CT.setTerrain,
                        args: [void 0],
                      }),
                      (s = void 0)),
                      (i = i.concat(n)),
                      x(s, t.terrain) ||
                        i.push({
                          command: CT.setTerrain,
                          args: [t.terrain],
                        }),
                      (function (e1, t, i) {
                        t = t || [];
                        const r = (e1 = e1 || []).map(kT),
                          n = t.map(kT),
                          o = e1.reduce(OT, {}),
                          s = t.reduce(OT, {}),
                          a = r.slice(),
                          l = Object.create(null);
                        let c, h, u, d, p, f, m;
                        for (c = 0, h = 0; c < r.length; c++)
                          (u = r[c]),
                            s.hasOwnProperty(u)
                              ? h++
                              : (i.push({
                                  command: CT.removeLayer,
                                  args: [u],
                                }),
                                a.splice(a.indexOf(u, h), 1));
                        for (c = 0, h = 0; c < n.length; c++)
                          (u = n[n.length - 1 - c]),
                            a[a.length - 1 - c] !== u &&
                              (o.hasOwnProperty(u)
                                ? (i.push({
                                    command: CT.removeLayer,
                                    args: [u],
                                  }),
                                  a.splice(a.lastIndexOf(u, a.length - h), 1))
                                : h++,
                              (f = a[a.length - c]),
                              i.push({
                                command: CT.addLayer,
                                args: [s[u], f],
                              }),
                              a.splice(a.length - c, 0, u),
                              (l[u] = !0));
                        for (c = 0; c < n.length; c++)
                          if (
                            ((u = n[c]),
                            (d = o[u]),
                            (p = s[u]),
                            !l[u] && !x(d, p))
                          ) {
                            if (
                              x(d.source, p.source) &&
                              x(d["source-layer"], p["source-layer"]) &&
                              x(d.type, p.type)
                            ) {
                              for (m in (LT(
                                d.layout,
                                p.layout,
                                i,
                                u,
                                null,
                                CT.setLayoutProperty,
                              ),
                              LT(
                                d.paint,
                                p.paint,
                                i,
                                u,
                                null,
                                CT.setPaintProperty,
                              ),
                              x(d.slot, p.slot) ||
                                i.push({
                                  command: CT.setSlot,
                                  args: [u, p.slot],
                                }),
                              x(d.filter, p.filter) ||
                                i.push({
                                  command: CT.setFilter,
                                  args: [u, p.filter],
                                }),
                              (x(d.minzoom, p.minzoom) &&
                                x(d.maxzoom, p.maxzoom)) ||
                                i.push({
                                  command: CT.setLayerZoomRange,
                                  args: [u, p.minzoom, p.maxzoom],
                                }),
                              d))
                                d.hasOwnProperty(m) &&
                                  "layout" !== m &&
                                  "paint" !== m &&
                                  "filter" !== m &&
                                  "metadata" !== m &&
                                  "minzoom" !== m &&
                                  "maxzoom" !== m &&
                                  "slot" !== m &&
                                  (0 === m.indexOf("paint.")
                                    ? LT(
                                        d[m],
                                        p[m],
                                        i,
                                        u,
                                        m.slice(6),
                                        CT.setPaintProperty,
                                      )
                                    : x(d[m], p[m]) ||
                                      i.push({
                                        command: CT.setLayerProperty,
                                        args: [u, m, p[m]],
                                      }));
                              for (m in p)
                                p.hasOwnProperty(m) &&
                                  !d.hasOwnProperty(m) &&
                                  "layout" !== m &&
                                  "paint" !== m &&
                                  "filter" !== m &&
                                  "metadata" !== m &&
                                  "minzoom" !== m &&
                                  "maxzoom" !== m &&
                                  "slot" !== m &&
                                  (0 === m.indexOf("paint.")
                                    ? LT(
                                        d[m],
                                        p[m],
                                        i,
                                        u,
                                        m.slice(6),
                                        CT.setPaintProperty,
                                      )
                                    : x(d[m], p[m]) ||
                                      i.push({
                                        command: CT.setLayerProperty,
                                        args: [u, m, p[m]],
                                      }));
                            } else
                              i.push({
                                command: CT.removeLayer,
                                args: [u],
                              }),
                                (f = a[a.lastIndexOf(u) + 1]),
                                i.push({
                                  command: CT.addLayer,
                                  args: [p, f],
                                });
                          }
                      })(o, t.layers, i),
                      (function (e1 = [], t = [], i) {
                        t = t || [];
                        const r = (e1 = e1 || []).map(kT),
                          n = t.map(kT),
                          o = e1.reduce(OT, {}),
                          s = t.reduce(OT, {}),
                          a = r.slice();
                        let l, c, h, u;
                        for (l = 0, c = 0; l < r.length; l++)
                          (h = r[l]),
                            s.hasOwnProperty(h)
                              ? c++
                              : (i.push({
                                  command: CT.removeImport,
                                  args: [h],
                                }),
                                a.splice(a.indexOf(h, c), 1));
                        for (l = 0, c = 0; l < n.length; l++)
                          (h = n[n.length - 1 - l]),
                            a[a.length - 1 - l] !== h &&
                              (o.hasOwnProperty(h)
                                ? (i.push({
                                    command: CT.removeImport,
                                    args: [h],
                                  }),
                                  a.splice(a.lastIndexOf(h, a.length - c), 1))
                                : c++,
                              (u = a[a.length - l]),
                              i.push({
                                command: CT.addImport,
                                args: [s[h], u],
                              }),
                              a.splice(a.length - l, 0, h));
                        for (const e1 of t) {
                          const t = o[e1.id];
                          if (!t || x(t, e1)) continue;
                          x(t.config, e1.config) ||
                            i.push({
                              command: CT.setImportConfig,
                              args: [e1.id, e1.config],
                            }),
                            x(t.url, e1.url) ||
                              i.push({
                                command: CT.setImportUrl,
                                args: [e1.id, e1.url],
                              });
                          const r = e1.data;
                          x(t && t.data, r) ||
                            i.push({
                              command: CT.setImportData,
                              args: [e1.id, r],
                            });
                        }
                      })(e1.imports, t.imports, i);
                  } catch (e1) {
                    console.warn("Unable to compute style diff:", e1),
                      (i = [
                        {
                          command: CT.setStyle,
                          args: [t],
                        },
                      ]);
                  }
                  return i;
                })(this.serialize(), e1).filter((e1) => !(e1.command in jA));
                if (0 === t.length) return !1;
                const i = t.filter((e1) => !(e1.command in VA));
                if (i.length > 0)
                  throw new Error(
                    `Unimplemented: ${i.map((e1) => e1.command).join(", ")}.`,
                  );
                return (
                  t.forEach((e1) => {
                    this[e1.command].apply(this, e1.args);
                  }),
                  (this.stylesheet = e1),
                  this.mergeAll(),
                  this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options,
                  }),
                  !0
                );
              }
              addImage(e1, t) {
                return this.getImage(e1)
                  ? this.fire(
                      new St(
                        new Error("An image with this name already exists."),
                      ),
                    )
                  : (this.imageManager.addImage(e1, this.scope, t),
                    this._afterImageUpdated(e1),
                    this);
              }
              updateImage(e1, t) {
                this.imageManager.updateImage(e1, this.scope, t);
              }
              getImage(e1) {
                return this.imageManager.getImage(e1, this.scope);
              }
              removeImage(e1) {
                return this.getImage(e1)
                  ? (this.imageManager.removeImage(e1, this.scope),
                    this._afterImageUpdated(e1),
                    this)
                  : this.fire(
                      new St(new Error("No image with this name exists.")),
                    );
              }
              _afterImageUpdated(e1) {
                (this._availableImages = this.imageManager.listImages(
                  this.scope,
                )),
                  this._changes.changedImages.add(e1),
                  (this._changes.changed = !0),
                  this.dispatcher.broadcast("setImages", {
                    scope: this.scope,
                    images: this._availableImages,
                  }),
                  this.fire(
                    new At("data", {
                      dataType: "style",
                    }),
                  );
              }
              listImages() {
                return this._checkLoaded(), this._availableImages.slice();
              }
              addModel(e1, t, i = {}) {
                return (
                  this._checkLoaded(),
                  this._validate(vs, `models.${e1}`, t, null, i) ||
                    (this.modelManager.addModel(e1, t, this.scope),
                    (this._changes.changed = !0)),
                  this
                );
              }
              hasModel(e1) {
                return this.modelManager.hasModel(e1, this.scope);
              }
              removeModel(e1) {
                return this.hasModel(e1)
                  ? (this.modelManager.removeModel(e1, this.scope), this)
                  : this.fire(
                      new St(new Error("No model with this ID exists.")),
                    );
              }
              listModels() {
                return (
                  this._checkLoaded(), this.modelManager.listModels(this.scope)
                );
              }
              addSource(e1, t, i = {}) {
                if ((this._checkLoaded(), void 0 !== this.getOwnSource(e1)))
                  throw new Error(`There is already a source with ID "${e1}".`);
                if (!t.type)
                  throw new Error(
                    `The type property must be defined, but only the following properties were given: ${Object.keys(
                      t,
                    ).join(", ")}.`,
                  );
                if (
                  ["vector", "raster", "geojson", "video", "image"].indexOf(
                    t.type,
                  ) >= 0 &&
                  this._validate(us, `sources.${e1}`, t, null, i)
                )
                  return;
                this.map &&
                  this.map._collectResourceTiming &&
                  (t.collectResourceTiming = !0);
                const r = vT(e1, t, this.dispatcher, this);
                (r.scope = this.scope),
                  r.setEventedParent(this, () => ({
                    isSourceLoaded: this._isSourceCacheLoaded(r.id),
                    source: r.serialize(),
                    sourceId: r.id,
                  }));
                const n = (e1) => {
                  const t = (e1 ? "symbol:" : "other:") + r.id,
                    i = pa(t, this.scope),
                    n = (this._sourceCaches[t] = new Ax(i, r, e1));
                  ((e1 ? this._symbolSourceCaches : this._otherSourceCaches)[
                    r.id
                  ] = n),
                    n.onAdd(this.map);
                };
                n(!1),
                  ("vector" !== t.type && "geojson" !== t.type) || n(!0),
                  r.onAdd && r.onAdd(this.map),
                  this.mergeSources(),
                  (this._changes.changed = !0);
              }
              removeSource(e1) {
                this._checkLoaded();
                const t = this.getOwnSource(e1);
                if (!t) throw new Error("There is no source with this ID");
                for (const t in this._layers)
                  if (this._layers[t].source === e1)
                    return this.fire(
                      new St(
                        new Error(
                          `Source "${e1}" cannot be removed while layer "${t}" is using it.`,
                        ),
                      ),
                    );
                if (this.terrain && this.terrain.get().source === e1)
                  return this.fire(
                    new St(
                      new Error(
                        `Source "${e1}" cannot be removed while terrain is using it.`,
                      ),
                    ),
                  );
                const i = this.getOwnSourceCaches(e1);
                for (const e1 of i) {
                  const t = fa(e1.id);
                  delete this._sourceCaches[t],
                    delete this._changes.updatedSourceCaches[e1.id],
                    e1.fire(
                      new At("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: e1.getSource().id,
                      }),
                    ),
                    e1.setEventedParent(null),
                    e1.clearTiles();
                }
                return (
                  delete this._otherSourceCaches[e1],
                  delete this._symbolSourceCaches[e1],
                  this.mergeSources(),
                  t.setEventedParent(null),
                  t.onRemove && t.onRemove(this.map),
                  (this._changes.changed = !0),
                  this
                );
              }
              setGeoJSONSourceData(e1, t) {
                this._checkLoaded(),
                  this.getOwnSource(e1).setData(t),
                  (this._changes.changed = !0);
              }
              getOwnSource(e1) {
                const t = this.getOwnSourceCache(e1);
                return t && t.getSource();
              }
              getOwnSources() {
                const e1 = [];
                for (const t in this._otherSourceCaches) {
                  const i = this.getOwnSourceCache(t);
                  i && e1.push(i.getSource());
                }
                return e1;
              }
              setLights(e1) {
                if ((this._checkLoaded(), !e1))
                  return (
                    delete this.ambientLight, void delete this.directionalLight
                  );
                const t = this._getTransitionParameters();
                for (const i of e1) {
                  if (this._validate(ps, "lights", i)) return;
                  switch (i.type) {
                    case "ambient":
                      if (this.ambientLight) {
                        const e1 = this.ambientLight;
                        e1.set(i), e1.updateTransitions(t);
                      } else
                        this.ambientLight = new gw(
                          i,
                          yw,
                          this.scope,
                          this.options,
                        );
                      break;
                    case "directional":
                      if (this.directionalLight) {
                        const e1 = this.directionalLight;
                        e1.set(i), e1.updateTransitions(t);
                      } else
                        this.directionalLight = new gw(
                          i,
                          xw,
                          this.scope,
                          this.options,
                        );
                  }
                }
                const i = new ea(this.z || 0, t);
                this.ambientLight && this.ambientLight.recalculate(i),
                  this.directionalLight && this.directionalLight.recalculate(i),
                  (this._brightness = this.calculateLightsBrightness()),
                  this.dispatcher.broadcast("setBrightness", this._brightness);
              }
              calculateLightsBrightness() {
                const e1 = this.directionalLight,
                  t = this.ambientLight;
                if (!e1 || !t) return;
                const i = (e1) =>
                    0.2126 *
                      (e1[0] <= 0.03928
                        ? e1[0] / 12.92
                        : Math.pow((e1[0] + 0.055) / 1.055, 2.4)) +
                    0.7152 *
                      (e1[1] <= 0.03928
                        ? e1[1] / 12.92
                        : Math.pow((e1[1] + 0.055) / 1.055, 2.4)) +
                    0.0722 *
                      (e1[2] <= 0.03928
                        ? e1[2] / 12.92
                        : Math.pow((e1[2] + 0.055) / 1.055, 2.4)),
                  r = e1.properties.get("color").toArray01(),
                  n = e1.properties.get("intensity"),
                  o = e1.properties.get("direction"),
                  s = 1 - J(o.x, o.y, o.z)[2] / 90,
                  a = i(r) * n * s,
                  l = t.properties.get("color").toArray01(),
                  c = t.properties.get("intensity");
                return (a + i(l) * c) / 2;
              }
              getBrightness() {
                return this._brightness;
              }
              getLights() {
                if (!this.enable3dLights()) return null;
                const e1 = [];
                return (
                  this.directionalLight && e1.push(this.directionalLight.get()),
                  this.ambientLight && e1.push(this.ambientLight.get()),
                  e1
                );
              }
              enable3dLights() {
                return !!this.ambientLight && !!this.directionalLight;
              }
              getFragmentStyle(e1) {
                if (!e1) return this;
                const t = this.fragments.find(({ id: t }) => t === e1);
                if (!t) throw new Error(`Style import not found: ${e1}`);
                return t.style;
              }
              setConfigProperty(e1, t, i) {
                const r = xo(i);
                if ("success" !== r.result) return void UA(this, r.value);
                const n = r.value.expression,
                  o = this.getFragmentStyle(e1);
                o.options.set(t, n), o.updateConfigDependencies();
              }
              setConfig(e1, t) {
                if ((this.options.clear(), e1)) {
                  for (const t in e1) {
                    const i = xo(e1[t]);
                    "success" === i.result &&
                      this.options.set(t, i.value.expression);
                  }
                  this.updateSchema(t);
                }
              }
              updateSchema(e1) {
                if (e1)
                  for (const t in e1) {
                    if (this.options.has(t)) continue;
                    const i = xo(e1[t].default);
                    "success" === i.result &&
                      this.options.set(t, i.value.expression);
                  }
              }
              updateConfigDependencies() {
                for (const e1 of this._configDependentLayers) {
                  const t = this.getLayer(e1);
                  t && (t.possiblyEvaluateVisibility(), this._updateLayer(t));
                }
                this.ambientLight &&
                  this.ambientLight.scope === this.scope &&
                  this.ambientLight.updateConfig(this.options),
                  this.directionalLight &&
                    this.directionalLight.scope === this.scope &&
                    this.directionalLight.updateConfig(this.options),
                  (this._changes.changed = !0);
              }
              addLayer(e1, t, i = {}) {
                this._checkLoaded();
                const r = e1.id;
                if (this._layers[r])
                  return void this.fire(
                    new St(
                      new Error(
                        `Layer with id "${r}" already exists on this map`,
                      ),
                    ),
                  );
                let n;
                if ("custom" === e1.type) {
                  if (
                    UA(
                      this,
                      (function (e1) {
                        const t = [],
                          i = e1.id;
                        return (
                          void 0 === i &&
                            t.push({
                              message: `layers.${i}: missing required property "id"`,
                            }),
                          void 0 === e1.render &&
                            t.push({
                              message: `layers.${i}: missing required method "render"`,
                            }),
                          e1.renderingMode &&
                            "2d" !== e1.renderingMode &&
                            "3d" !== e1.renderingMode &&
                            t.push({
                              message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`,
                            }),
                          t
                        );
                      })(e1),
                    )
                  )
                    return;
                  n = Kb(e1, this.options);
                } else {
                  if (
                    ("object" == typeof e1.source &&
                      (this.addSource(r, e1.source),
                      (e1 = k((e1 = $(e1)), {
                        source: r,
                      }))),
                    this._validate(
                      _s,
                      `layers.${r}`,
                      e1,
                      {
                        arrayIndex: -1,
                      },
                      i,
                    ))
                  )
                    return;
                  (n = Kb(e1, this.options)),
                    this._validateLayer(n),
                    n.setEventedParent(this, {
                      layer: {
                        id: r,
                      },
                    }),
                    (this._serializedLayers[n.id] = n.serialize());
                }
                n.isConfigDependent && this._configDependentLayers.add(n.fqid),
                  n.setScope(this.scope);
                const o = t ? this._order.indexOf(t) : this._order.length;
                if (t && -1 === o)
                  return void this.fire(
                    new St(
                      new Error(
                        `Layer with id "${t}" does not exist on this map.`,
                      ),
                    ),
                  );
                this._order.splice(o, 0, r),
                  (this._layerOrderChanged = !0),
                  (this._layers[r] = n);
                const s = this.getOwnLayerSourceCache(n),
                  a =
                    !!this.directionalLight &&
                    this.directionalLight.shadowsEnabled();
                s && n.canCastShadows() && a && (s.castsShadows = !0);
                const l = this._changes.getRemovedLayer(n);
                if (l && n.source && s && "custom" !== n.type) {
                  this._changes.discardLayerRemoval(n);
                  const e1 = pa(n.source, n.scope);
                  l.type !== n.type
                    ? (this._changes.updatedSourceCaches[e1] = "clear")
                    : ((this._changes.updatedSourceCaches[e1] = "reload"),
                      s.pause());
                }
                this._updateLayer(n),
                  n.onAdd && n.onAdd(this.map),
                  (n.scope = this.scope),
                  this.mergeLayers();
              }
              moveLayer(e1, t) {
                if (
                  (this._checkLoaded(),
                  (this._changes.changed = !0),
                  !this._checkLayer(e1))
                )
                  return;
                if (e1 === t) return;
                const i = this._order.indexOf(e1);
                this._order.splice(i, 1);
                const r = t ? this._order.indexOf(t) : this._order.length;
                t && -1 === r
                  ? this.fire(
                      new St(
                        new Error(
                          `Layer with id "${t}" does not exist on this map.`,
                        ),
                      ),
                    )
                  : (this._order.splice(r, 0, e1),
                    (this._layerOrderChanged = !0),
                    this.mergeLayers());
              }
              removeLayer(e1) {
                this._checkLoaded();
                const t = this._checkLayer(e1);
                if (!t) return;
                t.setEventedParent(null);
                const i = this._order.indexOf(e1);
                this._order.splice(i, 1),
                  delete this._layers[e1],
                  delete this._serializedLayers[e1],
                  (this._changes.changed = !0),
                  (this._layerOrderChanged = !0),
                  this._configDependentLayers.delete(t.fqid),
                  this._changes.removeLayer(t);
                const r = this.getOwnLayerSourceCache(t);
                if (r && r.castsShadows) {
                  let e1 = !1;
                  for (const i in this._layers)
                    if (
                      this._layers[i].source === t.source &&
                      this._layers[i].canCastShadows()
                    ) {
                      e1 = !0;
                      break;
                    }
                  r.castsShadows = e1;
                }
                t.onRemove && t.onRemove(this.map), this.mergeLayers();
              }
              getOwnLayer(e1) {
                return this._layers[e1];
              }
              hasLayer(e1) {
                return e1 in this._mergedLayers;
              }
              hasLayerType(e1) {
                for (const t in this._layers)
                  if (this._layers[t].type === e1) return !0;
                return !1;
              }
              setLayerZoomRange(e1, t, i) {
                this._checkLoaded();
                const r = this._checkLayer(e1);
                r &&
                  ((r.minzoom === t && r.maxzoom === i) ||
                    (null != t && (r.minzoom = t),
                    null != i && (r.maxzoom = i),
                    this._updateLayer(r)));
              }
              setSlot(e1, t) {
                this._checkLoaded();
                const i = this._checkLayer(e1);
                i && i.slot !== t && ((i.slot = t), this._updateLayer(i));
              }
              setFilter(e1, t, i = {}) {
                this._checkLoaded();
                const r = this._checkLayer(e1);
                if (r && !x(r.filter, t))
                  return null == t
                    ? ((r.filter = void 0), void this._updateLayer(r))
                    : void (
                        this._validate(
                          gs,
                          `layers.${r.id}.filter`,
                          t,
                          {
                            layerType: r.type,
                          },
                          i,
                        ) || ((r.filter = $(t)), this._updateLayer(r))
                      );
              }
              getFilter(e1) {
                const t = this._checkLayer(e1);
                if (t) return $(t.filter);
              }
              setLayoutProperty(e1, t, i, r = {}) {
                this._checkLoaded();
                const n = this._checkLayer(e1);
                n &&
                  (x(n.getLayoutProperty(t), i) ||
                    (n.setLayoutProperty(t, i, r),
                    n.isConfigDependent &&
                      this._configDependentLayers.add(n.fqid),
                    this._updateLayer(n)));
              }
              getLayoutProperty(e1, t) {
                const i = this._checkLayer(e1);
                if (i) return i.getLayoutProperty(t);
              }
              setPaintProperty(e1, t, i, r = {}) {
                this._checkLoaded();
                const n = this._checkLayer(e1);
                if (!n) return;
                if (x(n.getPaintProperty(t), i)) return;
                const o = n.setPaintProperty(t, i, r);
                n.isConfigDependent && this._configDependentLayers.add(n.fqid),
                  o && this._updateLayer(n),
                  (this._changes.changed = !0),
                  this._changes.updatedPaintProps.add(n.fqid);
              }
              getPaintProperty(e1, t) {
                const i = this._checkLayer(e1);
                if (i) return i.getPaintProperty(t);
              }
              setFeatureState(e1, t) {
                this._checkLoaded();
                const i = e1.source,
                  r = e1.sourceLayer,
                  n = this._checkSource(i);
                if (!n) return;
                const o = n.type;
                if ("geojson" === o && r)
                  return void this.fire(
                    new St(
                      new Error(
                        "GeoJSON sources cannot have a sourceLayer parameter.",
                      ),
                    ),
                  );
                if ("vector" === o && !r)
                  return void this.fire(
                    new St(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types.",
                      ),
                    ),
                  );
                void 0 === e1.id &&
                  this.fire(
                    new St(
                      new Error("The feature id parameter must be provided."),
                    ),
                  );
                const s = this.getOwnSourceCaches(i);
                for (const i of s) i.setFeatureState(r, e1.id, t);
              }
              removeFeatureState(e1, t) {
                this._checkLoaded();
                const i = e1.source,
                  r = this._checkSource(i);
                if (!r) return;
                const n = r.type,
                  o = "vector" === n ? e1.sourceLayer : void 0;
                if ("vector" === n && !o)
                  return void this.fire(
                    new St(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types.",
                      ),
                    ),
                  );
                if (t && "string" != typeof e1.id && "number" != typeof e1.id)
                  return void this.fire(
                    new St(
                      new Error(
                        "A feature id is required to remove its specific state property.",
                      ),
                    ),
                  );
                const s = this.getOwnSourceCaches(i);
                for (const i of s) i.removeFeatureState(o, e1.id, t);
              }
              getFeatureState(e1) {
                this._checkLoaded();
                const t = e1.source,
                  i = e1.sourceLayer,
                  r = this._checkSource(t);
                if (r) {
                  if ("vector" !== r.type || i)
                    return (
                      void 0 === e1.id &&
                        this.fire(
                          new St(
                            new Error(
                              "The feature id parameter must be provided.",
                            ),
                          ),
                        ),
                      this.getOwnSourceCaches(t)[0].getFeatureState(i, e1.id)
                    );
                  this.fire(
                    new St(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types.",
                      ),
                    ),
                  );
                }
              }
              setTransition(e1) {
                return (
                  (this.stylesheet.transition = k(
                    {},
                    this.stylesheet.transition,
                    e1,
                  )),
                  (this.transition = this.stylesheet.transition),
                  this
                );
              }
              getTransition() {
                return k({}, this.stylesheet.transition);
              }
              serialize() {
                this._checkLoaded();
                const e1 = this.getTerrain(),
                  t =
                    e1 && this.terrain && this.terrain.scope === this.scope
                      ? e1
                      : void 0;
                return Z(
                  {
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    imports: this._serializeImports(),
                    schema: this.stylesheet.schema,
                    camera: this.stylesheet.camera,
                    light: this.stylesheet.light,
                    lights: this.stylesheet.lights,
                    terrain: t,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: this._serializeSources(),
                    layers: this._serializeLayers(this._order),
                  },
                  (e1) => void 0 !== e1,
                );
              }
              _updateLayer(e1) {
                this._changes.updateLayer(e1);
                const t = this.getLayerSourceCache(e1),
                  i = pa(e1.source, e1.scope);
                e1.source &&
                  !this._changes.updatedSourceCaches[i] &&
                  t &&
                  "raster" !== t.getSource().type &&
                  ((this._changes.updatedSourceCaches[i] = "reload"),
                  t.pause()),
                  (this._changes.changed = !0),
                  e1.invalidateCompiledFilter();
              }
              _flattenAndSortRenderedFeatures(e1) {
                const t = (e1) =>
                    "fill-extrusion" === this._mergedLayers[e1].type,
                  i = this.order,
                  r = {},
                  n = [];
                for (let o = i.length - 1; o >= 0; o--) {
                  const s = i[o];
                  if (t(s)) {
                    r[s] = o;
                    for (const t of e1) {
                      const e1 = t[s];
                      if (e1) for (const t of e1) n.push(t);
                    }
                  }
                }
                n.sort((e1, t) => t.intersectionZ - e1.intersectionZ);
                const o = [];
                for (let s = i.length - 1; s >= 0; s--) {
                  const a = i[s];
                  if (t(a))
                    for (let e1 = n.length - 1; e1 >= 0; e1--) {
                      const t = n[e1].feature;
                      if (r[t.layer.id] < s) break;
                      o.push(t), n.pop();
                    }
                  else
                    for (const t of e1) {
                      const e1 = t[a];
                      if (e1) for (const t of e1) o.push(t.feature);
                    }
                }
                return o;
              }
              queryRenderedFeatures(e1, t, i) {
                t &&
                  t.filter &&
                  this._validate(
                    gs,
                    "queryRenderedFeatures.filter",
                    t.filter,
                    null,
                    t,
                  ),
                  (t.scope = this.scope),
                  (t.availableImages = this._availableImages),
                  (t.serializedLayers = this._serializedLayers);
                const r = {};
                if (t && t.layers) {
                  if (!Array.isArray(t.layers))
                    return (
                      this.fire(
                        new St(
                          new Error("parameters.layers must be an Array."),
                        ),
                      ),
                      []
                    );
                  for (const e1 of t.layers) {
                    const t = this._mergedLayers[e1];
                    if (!t)
                      return (
                        this.fire(
                          new St(
                            new Error(
                              `The layer '${e1}' does not exist in the map's style and cannot be queried for features.`,
                            ),
                          ),
                        ),
                        []
                      );
                    r[t.source] = !0;
                  }
                }
                const n = [],
                  o = t.serializedLayers || {},
                  s =
                    t && t.layers
                      ? t.layers.some((e1) => {
                          const t = this.getLayer(e1);
                          return t && t.is3D();
                        })
                      : this.has3DLayers(),
                  a = vw.createFromScreenPoints(e1, i);
                for (const e1 in this._mergedSourceCaches) {
                  const l = this._mergedSourceCaches[e1].getSource();
                  if (!l || l.scope !== t.scope) continue;
                  const c = this._mergedSourceCaches[e1].getSource().id;
                  (t.layers && !r[c]) ||
                    n.push(
                      wT(
                        this._mergedSourceCaches[e1],
                        this._mergedLayers,
                        o,
                        a,
                        t,
                        i,
                        s,
                        !!this.map._showQueryGeometry,
                      ),
                    );
                }
                return (
                  this.placement &&
                    n.push(
                      (function (e1, t, i, r, n, o, s) {
                        const a = {},
                          l = o.queryRenderedSymbols(r),
                          c = [];
                        for (const e1 of Object.keys(l).map(Number))
                          c.push(s[e1]);
                        c.sort(ET);
                        for (const i of c) {
                          const r = i.featureIndex.lookupSymbolFeatures(
                            l[i.bucketInstanceId],
                            t,
                            i.bucketIndex,
                            i.sourceLayerIndex,
                            n.filter,
                            n.layers,
                            n.availableImages,
                            e1,
                          );
                          for (const e1 in r) {
                            const t = (a[e1] = a[e1] || []),
                              n = r[e1];
                            n.sort((e1, t) => {
                              const r = i.featureSortOrder;
                              if (r) {
                                const i = r.indexOf(e1.featureIndex);
                                return r.indexOf(t.featureIndex) - i;
                              }
                              return t.featureIndex - e1.featureIndex;
                            });
                            for (const e1 of n) t.push(e1);
                          }
                        }
                        for (const t in a)
                          a[t].forEach((r) => {
                            const n = r.feature,
                              o = i(e1[t]);
                            if (!o) return;
                            const s = o.getFeatureState(
                              n.layer["source-layer"],
                              n.id,
                            );
                            (n.source = n.layer.source),
                              n.layer["source-layer"] &&
                                (n.sourceLayer = n.layer["source-layer"]),
                              (n.state = s);
                          });
                        return a;
                      })(
                        this._mergedLayers,
                        o,
                        this.getLayerSourceCache.bind(this),
                        a.screenGeometry,
                        t,
                        this.placement.collisionIndex,
                        this.placement.retainedQueryData,
                      ),
                    ),
                  this._flattenAndSortRenderedFeatures(n)
                );
              }
              querySourceFeatures(e1, t) {
                t &&
                  t.filter &&
                  this._validate(
                    gs,
                    "querySourceFeatures.filter",
                    t.filter,
                    null,
                    t,
                  );
                const i = this.getOwnSourceCaches(e1);
                let r = [];
                for (const e1 of i) r = r.concat(TT(e1, t));
                return r;
              }
              addSourceType(e1, t, i) {
                return $A.getSourceType(e1)
                  ? i(new Error(`A source type called "${e1}" already exists.`))
                  : ($A.setSourceType(e1, t),
                    t.workerSourceURL
                      ? void this.dispatcher.broadcast(
                          "loadWorkerSource",
                          {
                            name: e1,
                            url: t.workerSourceURL,
                          },
                          i,
                        )
                      : i(null, null));
              }
              getFlatLight() {
                return this.light.getLight();
              }
              setFlatLight(e1, t, i = {}) {
                this._checkLoaded();
                const r = this.light.getLight();
                let n = !1;
                for (const t in e1)
                  if (!x(e1[t], r[t])) {
                    n = !0;
                    break;
                  }
                if (!n) return;
                const o = this._getTransitionParameters();
                this.light.setLight(e1, t, i), this.light.updateTransitions(o);
              }
              getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode
                  ? this.terrain.get()
                  : null;
              }
              setTerrainForDraping() {
                this.setTerrain(
                  {
                    source: "",
                    exaggeration: 0,
                  },
                  0,
                );
              }
              setTerrain(e1, t = 1) {
                if ((this._checkLoaded(), !e1))
                  return (
                    delete this.terrain,
                    delete this.stylesheet.terrain,
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0)
                  );
                let i = e1;
                if (1 === t) {
                  if ("object" == typeof i.source) {
                    const e1 = "terrain-dem-src";
                    this.addSource(e1, i.source),
                      (i = $(i)),
                      (i = k(i, {
                        source: e1,
                      }));
                  }
                  if (this._validate(fs, "terrain", i)) return;
                }
                if (
                  !this.terrain ||
                  (this.terrain && t !== this.terrain.drapeRenderMode)
                ) {
                  if (!i) return;
                  this._createTerrain(i, t),
                    this.fire(
                      new At("data", {
                        dataType: "style",
                      }),
                    );
                } else {
                  const t = this.terrain,
                    r = t.get();
                  for (const e1 of Object.keys(Ct.terrain))
                    !i.hasOwnProperty(e1) &&
                      Ct.terrain[e1].default &&
                      (i[e1] = Ct.terrain[e1].default);
                  for (const i in e1)
                    if (!x(e1[i], r[i])) {
                      t.set(e1), (this.stylesheet.terrain = e1);
                      const i = this._getTransitionParameters({
                        duration: 0,
                      });
                      t.updateTransitions(i),
                        this.fire(
                          new At("data", {
                            dataType: "style",
                          }),
                        );
                      break;
                    }
                }
                this.mergeTerrain(),
                  this.updateDrapeFirstLayers(),
                  (this._markersNeedUpdate = !0);
              }
              _createFog(e1) {
                const t = (this.fog = new dw(e1, this.map.transform));
                this.stylesheet.fog = t.get();
                const i = this._getTransitionParameters({
                  duration: 0,
                });
                t.updateTransitions(i);
              }
              _updateMarkersOpacity() {
                0 !== this.map._markers.length &&
                  this.map._requestDomTask(() => {
                    for (const e1 of this.map._markers) e1._evaluateOpacity();
                  });
              }
              getFog() {
                return this.fog ? this.fog.get() : null;
              }
              setFog(e1) {
                if ((this._checkLoaded(), !e1))
                  return (
                    delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0)
                  );
                if (this.fog) {
                  const t = this.fog;
                  if (!x(t.get(), e1)) {
                    t.set(e1), (this.stylesheet.fog = t.get());
                    const i = this._getTransitionParameters({
                      duration: 0,
                    });
                    t.updateTransitions(i);
                  }
                } else this._createFog(e1);
                this._markersNeedUpdate = !0;
              }
              _getTransitionParameters(e1) {
                return {
                  now: ht.now(),
                  transition: k(this.transition, e1),
                };
              }
              updateDrapeFirstLayers() {
                if (!this.terrain) return;
                const e1 = [],
                  t = [];
                for (const i in this._mergedLayers)
                  this.isLayerDraped(this._mergedLayers[i])
                    ? e1.push(i)
                    : t.push(i);
                (this._drapedFirstOrder = []),
                  this._drapedFirstOrder.push(...e1),
                  this._drapedFirstOrder.push(...t);
              }
              _createTerrain(e1, t) {
                const i = (this.terrain = new rw(e1, t));
                i.setScope(this.scope),
                  (this.stylesheet.terrain = e1),
                  this.mergeTerrain(),
                  this.updateDrapeFirstLayers(),
                  this._force3DLayerUpdate();
                const r = this._getTransitionParameters({
                  duration: 0,
                });
                i.updateTransitions(r);
              }
              _force3DLayerUpdate() {
                for (const e1 in this._layers) {
                  const t = this._layers[e1];
                  "fill-extrusion" === t.type && this._updateLayer(t);
                }
              }
              _forceSymbolLayerUpdate() {
                for (const e1 in this._layers) {
                  const t = this._layers[e1];
                  "symbol" === t.type && this._updateLayer(t);
                }
              }
              _validate(e1, t, i, r, n = {}) {
                if (n && !1 === n.validate) return !1;
                const o = k({}, this.serialize());
                return UA(
                  this,
                  e1.call(
                    hs,
                    k(
                      {
                        key: t,
                        style: o,
                        value: i,
                        styleSpec: Ct,
                      },
                      r,
                    ),
                  ),
                );
              }
              _remove() {
                this._request &&
                  (this._request.cancel(), (this._request = null)),
                  this._spriteRequest &&
                    (this._spriteRequest.cancel(),
                    (this._spriteRequest = null)),
                  Ys.off("pluginStateChange", this._rtlTextPluginCallback);
                for (const e1 in this._mergedLayers)
                  this._mergedLayers[e1].setEventedParent(null);
                for (const e1 in this._mergedSourceCaches)
                  this._mergedSourceCaches[e1].clearTiles(),
                    this._mergedSourceCaches[e1].setEventedParent(null);
                this.setEventedParent(null),
                  delete this.fog,
                  delete this.terrain,
                  delete this.ambientLight,
                  delete this.directionalLight,
                  this.isRootStyle() &&
                    (this.imageManager.setEventedParent(null),
                    this.modelManager.setEventedParent(null),
                    this.dispatcher.remove());
              }
              clearSource(e1) {
                const t = this.getSourceCaches(e1);
                for (const e1 of t) e1.clearTiles();
              }
              clearSources() {
                for (const e1 in this._mergedSourceCaches)
                  this._mergedSourceCaches[e1].clearTiles();
              }
              reloadSource(e1) {
                const t = this.getSourceCaches(e1);
                for (const e1 of t) e1.resume(), e1.reload();
              }
              updateSources(e1) {
                let t;
                this.directionalLight && (t = OA(this.directionalLight));
                for (const i in this._mergedSourceCaches)
                  this._mergedSourceCaches[i].update(e1, void 0, void 0, t);
              }
              _generateCollisionBoxes() {
                for (const e1 in this._sourceCaches) {
                  const t = this._sourceCaches[e1];
                  t.resume(), t.reload();
                }
              }
              _updatePlacement(e1, t, i, r, n = !1) {
                let o = !1,
                  s = !1;
                const a = {},
                  l = {};
                for (const t of this._mergedOrder) {
                  const i = this._mergedLayers[t];
                  if ("symbol" !== i.type) continue;
                  const r = pa(i.source, i.scope);
                  let n = a[r];
                  if (!n) {
                    const e1 = this.getLayerSourceCache(i);
                    if (!e1) continue;
                    const t = e1
                      .getRenderableIds(!0)
                      .map((t) => e1.getTileByID(t));
                    (l[r] = t.slice()),
                      (n = a[r] =
                        t.sort(
                          (e1, t) =>
                            t.tileID.overscaledZ - e1.tileID.overscaledZ ||
                            (e1.tileID.isLessThan(t.tileID) ? -1 : 1),
                        ));
                  }
                  const s = this.crossTileSymbolIndex.addLayer(
                    i,
                    n,
                    e1.center.lng,
                    e1.projection,
                  );
                  o = o || s;
                }
                if (
                  (this.crossTileSymbolIndex.pruneUnusedLayers(
                    this._mergedOrder,
                  ),
                  (n = n || this._layerOrderChanged || 0 === i),
                  this._layerOrderChanged && this.fire(new At("neworder")),
                  (n ||
                    !this.pauseablePlacement ||
                    (this.pauseablePlacement.isDone() &&
                      !this.placement.stillRecent(ht.now(), e1.zoom))) &&
                    ((this.pauseablePlacement = new hE(
                      e1,
                      this._mergedOrder,
                      n,
                      t,
                      i,
                      r,
                      this.placement,
                      this.fog && e1.projection.supportsFog
                        ? this.fog.state
                        : null,
                      this._buildingIndex,
                    )),
                    (this._layerOrderChanged = !1)),
                  this.pauseablePlacement.isDone()
                    ? this.placement.setStale()
                    : (this.pauseablePlacement.continuePlacement(
                        this._mergedOrder,
                        this._mergedLayers,
                        a,
                        l,
                      ),
                      this.pauseablePlacement.isDone() &&
                        ((this.placement = this.pauseablePlacement.commit(
                          ht.now(),
                        )),
                        (s = !0)),
                      o && this.pauseablePlacement.placement.setStale()),
                  s || o)
                )
                  for (const e1 of this._mergedOrder) {
                    const t = this._mergedLayers[e1];
                    "symbol" === t.type &&
                      this.placement.updateLayerOpacities(
                        t,
                        a[pa(t.source, t.scope)],
                      );
                  }
                return (
                  !this.pauseablePlacement.isDone() ||
                  this.placement.hasTransitions(ht.now())
                );
              }
              _releaseSymbolFadeTiles() {
                for (const e1 in this._sourceCaches)
                  this._sourceCaches[e1].releaseSymbolFadeTiles();
              }
              addImport(e1) {
                this._checkLoaded();
                const t = (this.stylesheet.imports =
                    this.stylesheet.imports || []),
                  i = t.findIndex(({ id: t }) => t === e1.id);
                return -1 !== i
                  ? this.fire(
                      new St(
                        new Error(
                          `Import with id '${e1.id}' already exists in the map's style.`,
                        ),
                      ),
                    )
                  : (t.push(e1), this._loadImports([e1], !0), this);
              }
              setImportUrl(e1, t) {
                this._checkLoaded();
                const i = this.stylesheet.imports || [],
                  r = this.getImportIndex(e1);
                if (-1 === r) return this;
                i[r].url = t;
                const n = this.fragments[r];
                n.style = this._createFragmentStyle({
                  id: e1,
                  url: t,
                });
                const o = new Promise((e1) =>
                  n.style.on("style.import.load", e1),
                );
                return (
                  n.style.loadURL(t), o.then(() => this._reloadImports()), this
                );
              }
              setImportData(e1, t) {
                this._checkLoaded();
                const i = this.getImportIndex(e1),
                  r = this.stylesheet.imports || [];
                return -1 === i
                  ? this
                  : t
                  ? (this.fragments[i].style.setState(t),
                    this._reloadImports(),
                    this)
                  : (delete r[i].data, this.setImportUrl(e1, r[i].url));
              }
              setImportConfig(e1, t) {
                this._checkLoaded();
                const i = this.getImportIndex(e1),
                  r = this.stylesheet.imports || [];
                if (-1 === i) return this;
                t ? (r[i].config = t) : delete r[i].config;
                const n = this.fragments[i],
                  o = n.style.stylesheet && n.style.stylesheet.schema;
                return (
                  (n.config = t),
                  n.style.setConfig(t, o),
                  n.style.updateConfigDependencies(),
                  this
                );
              }
              removeImport(e1) {
                this._checkLoaded();
                const t = this.stylesheet.imports || [],
                  i = this.getImportIndex(e1);
                return (
                  -1 === i ||
                    (t.splice(i, 1),
                    this.fragments[i].style._remove(),
                    this.fragments.splice(i, 1),
                    this._reloadImports()),
                  this
                );
              }
              getImportIndex(e1) {
                const t = (this.stylesheet.imports || []).findIndex(
                  (t) => t.id === e1,
                );
                return (
                  -1 === t &&
                    this.fire(
                      new St(
                        new Error(
                          `Import '${e1}' does not exist in the map's style and cannot be updated.`,
                        ),
                      ),
                    ),
                  t
                );
              }
              getLayer(e1) {
                return this._mergedLayers[e1];
              }
              getSources() {
                const e1 = [];
                for (const t in this._mergedOtherSourceCaches) {
                  const i = this._mergedOtherSourceCaches[t];
                  i && e1.push(i.getSource());
                }
                return e1;
              }
              getSource(e1, t) {
                const i = this.getSourceCache(e1, t);
                return i && i.getSource();
              }
              getLayerSource(e1) {
                const t = this.getLayerSourceCache(e1);
                return t && t.getSource();
              }
              getSourceCache(e1, t) {
                const i = pa(e1, t);
                return this._mergedOtherSourceCaches[i];
              }
              getLayerSourceCache(e1) {
                const t = pa(e1.source, e1.scope);
                return "symbol" === e1.type
                  ? this._mergedSymbolSourceCaches[t]
                  : this._mergedOtherSourceCaches[t];
              }
              getSourceCaches(e1) {
                const t = [];
                return (
                  this._mergedOtherSourceCaches[e1] &&
                    t.push(this._mergedOtherSourceCaches[e1]),
                  this._mergedSymbolSourceCaches[e1] &&
                    t.push(this._mergedSymbolSourceCaches[e1]),
                  t
                );
              }
              updateSourceCaches() {
                for (const e1 in this._changes.updatedSourceCaches) {
                  const t = this._changes.updatedSourceCaches[e1];
                  "reload" === t
                    ? this.reloadSource(e1)
                    : "clear" === t && this.clearSource(e1);
                }
              }
              updateLayers(e1) {
                for (const t of this._changes.updatedPaintProps) {
                  const i = this.getLayer(t);
                  i && i.updateTransitions(e1);
                }
              }
              getImages(e1, t, i) {
                this.imageManager.getImages(t.icons, t.scope, i),
                  this._updateTilesForChangedImages();
                const r = (e1) => {
                  e1 && e1.setDependencies(t.tileID.key, t.type, t.icons);
                };
                r(this._otherSourceCaches[t.source]),
                  r(this._symbolSourceCaches[t.source]);
              }
              getGlyphs(e1, t, i) {
                this.glyphManager.getGlyphs(t.stacks, t.scope, i);
              }
              getResource(e1, t, i) {
                return be(t, i);
              }
              getOwnSourceCache(e1) {
                return this._otherSourceCaches[e1];
              }
              getOwnLayerSourceCache(e1) {
                return "symbol" === e1.type
                  ? this._symbolSourceCaches[e1.source]
                  : this._otherSourceCaches[e1.source];
              }
              getOwnSourceCaches(e1) {
                const t = [];
                return (
                  this._otherSourceCaches[e1] &&
                    t.push(this._otherSourceCaches[e1]),
                  this._symbolSourceCaches[e1] &&
                    t.push(this._symbolSourceCaches[e1]),
                  t
                );
              }
              _isSourceCacheLoaded(e1) {
                const t = this.getOwnSourceCaches(e1);
                return 0 === t.length
                  ? (this.fire(
                      new St(new Error(`There is no source with ID '${e1}'`)),
                    ),
                    !1)
                  : t.every((e1) => e1.loaded());
              }
              has3DLayers() {
                return this._has3DLayers;
              }
              hasSymbolLayers() {
                return this._hasSymbolLayers;
              }
              hasCircleLayers() {
                return this._hasCircleLayers;
              }
              _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
              }
              destroy() {
                this._clearWorkerCaches(),
                  this.terrainSetForDrapingOnly() &&
                    (delete this.terrain, delete this.stylesheet.terrain);
              }
            }
            function HA(e1, t) {
              let i = !1,
                r = null;
              const n = () => {
                (r = null), i && (e1(), (r = setTimeout(n, t)), (i = !1));
              };
              return () => ((i = !0), r || n(), r);
            }
            ($A.getSourceType = function (e1) {
              return xT[e1];
            }),
              ($A.setSourceType = function (e1, t) {
                xT[e1] = t;
              }),
              ($A.registerForPluginStateChange = function (e1) {
                return (
                  e1({
                    pluginStatus: $s,
                    pluginURL: Hs,
                  }),
                  Ys.on("pluginStateChange", e1),
                  e1
                );
              });
            class WA {
              constructor(e1) {
                (this._hashName = e1 && encodeURIComponent(e1)),
                  j(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                  (this._updateHash = HA(
                    this._updateHashUnthrottled.bind(this),
                    300,
                  ));
              }
              addTo(e1) {
                return (
                  (this._map = e1),
                  t.addEventListener("hashchange", this._onHashChange, !1),
                  e1.on("moveend", this._updateHash),
                  this
                );
              }
              remove() {
                return this._map
                  ? (this._map.off("moveend", this._updateHash),
                    t.removeEventListener("hashchange", this._onHashChange, !1),
                    clearTimeout(this._updateHash()),
                    (this._map = void 0),
                    this)
                  : this;
              }
              getHashString() {
                const e1 = this._map;
                if (!e1) return "";
                const i = XA(e1);
                if (this._hashName) {
                  const e1 = this._hashName;
                  let r = !1;
                  const n = t.location.hash
                    .slice(1)
                    .split("&")
                    .map((t) => {
                      const n = t.split("=")[0];
                      return n === e1 ? ((r = !0), `${n}=${i}`) : t;
                    })
                    .filter((e1) => e1);
                  return r || n.push(`${e1}=${i}`), `#${n.join("&")}`;
                }
                return `#${i}`;
              }
              _getCurrentHash() {
                const e1 = t.location.hash.replace("#", "");
                if (this._hashName) {
                  let t;
                  return (
                    e1
                      .split("&")
                      .map((e1) => e1.split("="))
                      .forEach((e1) => {
                        e1[0] === this._hashName && (t = e1);
                      }),
                    ((t && t[1]) || "").split("/")
                  );
                }
                return e1.split("/");
              }
              _onHashChange() {
                const e1 = this._map;
                if (!e1) return !1;
                const t = this._getCurrentHash();
                if (t.length >= 3 && !t.some((e1) => isNaN(e1))) {
                  const i =
                    e1.dragRotate.isEnabled() && e1.touchZoomRotate.isEnabled()
                      ? +(t[3] || 0)
                      : e1.getBearing();
                  return (
                    e1.jumpTo({
                      center: [+t[2], +t[1]],
                      zoom: +t[0],
                      bearing: i,
                      pitch: +(t[4] || 0),
                    }),
                    !0
                  );
                }
                return !1;
              }
              _updateHashUnthrottled() {
                const e1 = t.location.href.replace(
                  /(#.+)?$/,
                  this.getHashString(),
                );
                t.history.replaceState(t.history.state, null, e1);
              }
            }
            function XA(e1, t) {
              const i = e1.getCenter(),
                r = Math.round(100 * e1.getZoom()) / 100,
                n = Math.ceil(
                  (r * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10,
                ),
                o = Math.pow(10, n),
                s = Math.round(i.lng * o) / o,
                a = Math.round(i.lat * o) / o,
                l = e1.getBearing(),
                c = e1.getPitch();
              let h = t ? `/${s}/${a}/${r}` : `${r}/${a}/${s}`;
              return (
                (l || c) && (h += "/" + Math.round(10 * l) / 10),
                c && (h += `/${Math.round(c)}`),
                h
              );
            }
            const YA = {
                linearity: 0.3,
                easing: I(0, 0, 0.3, 1),
              },
              KA = k(
                {
                  deceleration: 2500,
                  maxSpeed: 1400,
                },
                YA,
              ),
              JA = k(
                {
                  deceleration: 20,
                  maxSpeed: 1400,
                },
                YA,
              ),
              QA = k(
                {
                  deceleration: 1e3,
                  maxSpeed: 360,
                },
                YA,
              ),
              eS = k(
                {
                  deceleration: 1e3,
                  maxSpeed: 90,
                },
                YA,
              );
            class tS {
              constructor(e1) {
                (this._map = e1), this.clear();
              }
              clear() {
                this._inertiaBuffer = [];
              }
              record(e1) {
                this._drainInertiaBuffer(),
                  this._inertiaBuffer.push({
                    time: ht.now(),
                    settings: e1,
                  });
              }
              _drainInertiaBuffer() {
                const e1 = this._inertiaBuffer,
                  t = ht.now();
                for (; e1.length > 0 && t - e1[0].time > 160; ) e1.shift();
              }
              _onMoveEnd(e1) {
                if (this._map._prefersReducedMotion()) return;
                if (
                  (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                )
                  return;
                const t = {
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  pan: new y(0, 0),
                  pinchAround: void 0,
                  around: void 0,
                };
                for (const { settings: e1 } of this._inertiaBuffer)
                  (t.zoom += e1.zoomDelta || 0),
                    (t.bearing += e1.bearingDelta || 0),
                    (t.pitch += e1.pitchDelta || 0),
                    e1.panDelta && t.pan._add(e1.panDelta),
                    e1.around && (t.around = e1.around),
                    e1.pinchAround && (t.pinchAround = e1.pinchAround);
                const i =
                    this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                    this._inertiaBuffer[0].time,
                  r = {};
                if (t.pan.mag()) {
                  const n = rS(t.pan.mag(), i, k({}, KA, e1 || {}));
                  (r.offset = t.pan.mult(n.amount / t.pan.mag())),
                    (r.center = this._map.transform.center),
                    iS(r, n);
                }
                if (t.zoom) {
                  const e1 = rS(t.zoom, i, JA);
                  (r.zoom = this._map.transform.zoom + e1.amount), iS(r, e1);
                }
                if (t.bearing) {
                  const e1 = rS(t.bearing, i, QA);
                  (r.bearing =
                    this._map.transform.bearing + z(e1.amount, -179, 179)),
                    iS(r, e1);
                }
                if (t.pitch) {
                  const e1 = rS(t.pitch, i, eS);
                  (r.pitch = this._map.transform.pitch + e1.amount), iS(r, e1);
                }
                if (r.zoom || r.bearing) {
                  const e1 =
                    void 0 === t.pinchAround ? t.around : t.pinchAround;
                  r.around = e1
                    ? this._map.unproject(e1)
                    : this._map.getCenter();
                }
                return this.clear(), (r.noMoveStart = !0), r;
              }
            }
            function iS(e1, t) {
              (!e1.duration || e1.duration < t.duration) &&
                ((e1.duration = t.duration), (e1.easing = t.easing));
            }
            function rS(e1, t, i) {
              const { maxSpeed: r, linearity: n, deceleration: o } = i,
                s = z((e1 * n) / (t / 1e3), -r, r),
                a = Math.abs(s) / (o * n);
              return {
                easing: i.easing,
                duration: 1e3 * a,
                amount: s * (a / 2),
              };
            }
            class nS extends At {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(e1, t, i, r = {}) {
                const n = vt(t.getCanvasContainer(), i);
                super(
                  e1,
                  k(
                    {
                      point: n,
                      lngLat: t.unproject(n),
                      originalEvent: i,
                    },
                    r,
                  ),
                ),
                  (this._defaultPrevented = !1),
                  (this.target = t);
              }
            }
            class oS extends At {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(e1, t, i) {
                const r = "touchend" === e1 ? i.changedTouches : i.touches,
                  n = bt(t.getCanvasContainer(), r),
                  o = n.map((e1) => t.unproject(e1)),
                  s = n.reduce(
                    (e1, t, i, r) => e1.add(t.div(r.length)),
                    new y(0, 0),
                  );
                super(e1, {
                  points: n,
                  point: s,
                  lngLats: o,
                  lngLat: t.unproject(s),
                  originalEvent: i,
                }),
                  (this._defaultPrevented = !1);
              }
            }
            class sS extends At {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(e1, t, i) {
                super(e1, {
                  originalEvent: i,
                }),
                  (this._defaultPrevented = !1);
              }
            }
            class aS {
              constructor(e1, t) {
                (this._map = e1), (this._clickTolerance = t.clickTolerance);
              }
              reset() {
                this._mousedownPos = void 0;
              }
              wheel(e1) {
                return this._firePreventable(new sS(e1.type, this._map, e1));
              }
              mousedown(e1, t) {
                return (
                  (this._mousedownPos = t),
                  this._firePreventable(new nS(e1.type, this._map, e1))
                );
              }
              mouseup(e1) {
                this._map.fire(new nS(e1.type, this._map, e1));
              }
              preclick(e1) {
                const t = k({}, e1);
                (t.type = "preclick"),
                  this._map.fire(new nS(t.type, this._map, t));
              }
              click(e1, t) {
                (this._mousedownPos &&
                  this._mousedownPos.dist(t) >= this._clickTolerance) ||
                  (this.preclick(e1),
                  this._map.fire(new nS(e1.type, this._map, e1)));
              }
              dblclick(e1) {
                return this._firePreventable(new nS(e1.type, this._map, e1));
              }
              mouseover(e1) {
                this._map.fire(new nS(e1.type, this._map, e1));
              }
              mouseout(e1) {
                this._map.fire(new nS(e1.type, this._map, e1));
              }
              touchstart(e1) {
                return this._firePreventable(new oS(e1.type, this._map, e1));
              }
              touchmove(e1) {
                this._map.fire(new oS(e1.type, this._map, e1));
              }
              touchend(e1) {
                this._map.fire(new oS(e1.type, this._map, e1));
              }
              touchcancel(e1) {
                this._map.fire(new oS(e1.type, this._map, e1));
              }
              _firePreventable(e1) {
                if ((this._map.fire(e1), e1.defaultPrevented)) return {};
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class lS {
              constructor(e1) {
                this._map = e1;
              }
              reset() {
                (this._delayContextMenu = !1),
                  (this._contextMenuEvent = void 0);
              }
              mousemove(e1) {
                this._map.fire(new nS(e1.type, this._map, e1));
              }
              mousedown() {
                this._delayContextMenu = !0;
              }
              mouseup() {
                (this._delayContextMenu = !1),
                  this._contextMenuEvent &&
                    (this._map.fire(
                      new nS("contextmenu", this._map, this._contextMenuEvent),
                    ),
                    delete this._contextMenuEvent);
              }
              contextmenu(e1) {
                this._delayContextMenu
                  ? (this._contextMenuEvent = e1)
                  : this._map.fire(new nS(e1.type, this._map, e1)),
                  this._map.listens("contextmenu") && e1.preventDefault();
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class cS {
              constructor(e1, t) {
                (this._map = e1),
                  (this._el = e1.getCanvasContainer()),
                  (this._container = e1.getContainer()),
                  (this._clickTolerance = t.clickTolerance || 1);
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              enable() {
                this.isEnabled() || (this._enabled = !0);
              }
              disable() {
                this.isEnabled() && (this._enabled = !1);
              }
              mousedown(e1, t) {
                this.isEnabled() &&
                  e1.shiftKey &&
                  0 === e1.button &&
                  (_t(),
                  (this._startPos = this._lastPos = t),
                  (this._active = !0));
              }
              mousemoveWindow(e1, t) {
                if (!this._active) return;
                const i = t,
                  r = this._startPos,
                  n = this._lastPos;
                if (
                  !r ||
                  !n ||
                  n.equals(i) ||
                  (!this._box && i.dist(r) < this._clickTolerance)
                )
                  return;
                (this._lastPos = i),
                  this._box ||
                    ((this._box = ut(
                      "div",
                      "mapboxgl-boxzoom",
                      this._container,
                    )),
                    this._container.classList.add("mapboxgl-crosshair"),
                    this._fireEvent("boxzoomstart", e1));
                const o = Math.min(r.x, i.x),
                  s = Math.max(r.x, i.x),
                  a = Math.min(r.y, i.y),
                  l = Math.max(r.y, i.y);
                this._map._requestDomTask(() => {
                  this._box &&
                    ((this._box.style.transform = `translate(${o}px,${a}px)`),
                    (this._box.style.width = s - o + "px"),
                    (this._box.style.height = l - a + "px"));
                });
              }
              mouseupWindow(e1, t) {
                if (!this._active) return;
                const i = this._startPos,
                  r = t;
                if (i && 0 === e1.button) {
                  if ((this.reset(), xt(), i.x !== r.x || i.y !== r.y))
                    return (
                      this._map.fire(
                        new At("boxzoomend", {
                          originalEvent: e1,
                        }),
                      ),
                      {
                        cameraAnimation: (e1) =>
                          e1.fitScreenCoordinates(
                            i,
                            r,
                            this._map.getBearing(),
                            {
                              linear: !1,
                            },
                          ),
                      }
                    );
                  this._fireEvent("boxzoomcancel", e1);
                }
              }
              keydown(e1) {
                this._active &&
                  27 === e1.keyCode &&
                  (this.reset(), this._fireEvent("boxzoomcancel", e1));
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  this._container.classList.remove("mapboxgl-crosshair"),
                  this._box && (this._box.remove(), (this._box = null)),
                  gt(),
                  delete this._startPos,
                  delete this._lastPos;
              }
              _fireEvent(e1, t) {
                return this._map.fire(
                  new At(e1, {
                    originalEvent: t,
                  }),
                );
              }
            }
            function hS(e1, t) {
              const i = {};
              for (let r = 0; r < e1.length; r++) i[e1[r].identifier] = t[r];
              return i;
            }
            class uS {
              constructor(e1) {
                this.reset(), (this.numTouches = e1.numTouches);
              }
              reset() {
                (this.centroid = void 0),
                  (this.startTime = 0),
                  (this.touches = {}),
                  (this.aborted = !1);
              }
              touchstart(e1, t, i) {
                (this.centroid || i.length > this.numTouches) &&
                  (this.aborted = !0),
                  this.aborted ||
                    (0 === this.startTime && (this.startTime = e1.timeStamp),
                    i.length === this.numTouches &&
                      ((this.centroid = (function (e1) {
                        const t = new y(0, 0);
                        for (const i of e1) t._add(i);
                        return t.div(e1.length);
                      })(t)),
                      (this.touches = hS(i, t))));
              }
              touchmove(e1, t, i) {
                if (this.aborted || !this.centroid) return;
                const r = hS(i, t);
                for (const e1 in this.touches) {
                  const t = r[e1];
                  (!t || t.dist(this.touches[e1]) > 30) && (this.aborted = !0);
                }
              }
              touchend(e1, t, i) {
                if (
                  ((!this.centroid || e1.timeStamp - this.startTime > 500) &&
                    (this.aborted = !0),
                  0 === i.length)
                ) {
                  const e1 = !this.aborted && this.centroid;
                  if ((this.reset(), e1)) return e1;
                }
              }
            }
            class dS {
              constructor(e1) {
                (this.singleTap = new uS(e1)),
                  (this.numTaps = e1.numTaps),
                  this.reset();
              }
              reset() {
                (this.lastTime = 1 / 0),
                  (this.lastTap = void 0),
                  (this.count = 0),
                  this.singleTap.reset();
              }
              touchstart(e1, t, i) {
                this.singleTap.touchstart(e1, t, i);
              }
              touchmove(e1, t, i) {
                this.singleTap.touchmove(e1, t, i);
              }
              touchend(e1, t, i) {
                const r = this.singleTap.touchend(e1, t, i);
                if (r) {
                  const t = e1.timeStamp - this.lastTime < 500,
                    i = !this.lastTap || this.lastTap.dist(r) < 30;
                  if (
                    ((t && i) || this.reset(),
                    this.count++,
                    (this.lastTime = e1.timeStamp),
                    (this.lastTap = r),
                    this.count === this.numTaps)
                  )
                    return this.reset(), r;
                }
              }
            }
            class pS {
              constructor() {
                (this._zoomIn = new dS({
                  numTouches: 1,
                  numTaps: 2,
                })),
                  (this._zoomOut = new dS({
                    numTouches: 2,
                    numTaps: 1,
                  })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  this._zoomIn.reset(),
                  this._zoomOut.reset();
              }
              touchstart(e1, t, i) {
                this._zoomIn.touchstart(e1, t, i),
                  this._zoomOut.touchstart(e1, t, i);
              }
              touchmove(e1, t, i) {
                this._zoomIn.touchmove(e1, t, i),
                  this._zoomOut.touchmove(e1, t, i);
              }
              touchend(e1, t, i) {
                const r = this._zoomIn.touchend(e1, t, i),
                  n = this._zoomOut.touchend(e1, t, i);
                return r
                  ? ((this._active = !0),
                    e1.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (t) =>
                        t.easeTo(
                          {
                            duration: 300,
                            zoom: t.getZoom() + 1,
                            around: t.unproject(r),
                          },
                          {
                            originalEvent: e1,
                          },
                        ),
                    })
                  : n
                  ? ((this._active = !0),
                    e1.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (t) =>
                        t.easeTo(
                          {
                            duration: 300,
                            zoom: t.getZoom() - 1,
                            around: t.unproject(n),
                          },
                          {
                            originalEvent: e1,
                          },
                        ),
                    })
                  : void 0;
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            const fS = {
              0: 1,
              2: 2,
            };
            class mS {
              constructor(e1) {
                this.reset(), (this._clickTolerance = e1.clickTolerance || 1);
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._moved = !1),
                  (this._lastPoint = void 0),
                  (this._eventButton = void 0);
              }
              _correctButton(e1, t) {
                return !1;
              }
              _move(e1, t) {
                return {};
              }
              mousedown(e1, t) {
                if (this._lastPoint) return;
                const i = wt(e1);
                this._correctButton(e1, i) &&
                  ((this._lastPoint = t), (this._eventButton = i));
              }
              mousemoveWindow(e1, t) {
                const i = this._lastPoint;
                if (i) {
                  if (
                    (e1.preventDefault(),
                    null != this._eventButton &&
                      (function (e1, t) {
                        const i = fS[t];
                        return void 0 === e1.buttons || (e1.buttons & i) !== i;
                      })(e1, this._eventButton))
                  )
                    this.reset();
                  else if (this._moved || !(t.dist(i) < this._clickTolerance))
                    return (
                      (this._moved = !0),
                      (this._lastPoint = t),
                      this._move(i, t)
                    );
                }
              }
              mouseupWindow(e1) {
                this._lastPoint &&
                  wt(e1) === this._eventButton &&
                  (this._moved && xt(), this.reset());
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class _S extends mS {
              mousedown(e1, t) {
                super.mousedown(e1, t), this._lastPoint && (this._active = !0);
              }
              _correctButton(e1, t) {
                return 0 === t && !e1.ctrlKey;
              }
              _move(e1, t) {
                return {
                  around: t,
                  panDelta: t.sub(e1),
                };
              }
            }
            class gS extends mS {
              _correctButton(e1, t) {
                return (0 === t && e1.ctrlKey) || 2 === t;
              }
              _move(e1, t) {
                const i = 0.8 * (t.x - e1.x);
                if (i)
                  return (
                    (this._active = !0),
                    {
                      bearingDelta: i,
                    }
                  );
              }
              contextmenu(e1) {
                e1.preventDefault();
              }
            }
            class yS extends mS {
              _correctButton(e1, t) {
                return (0 === t && e1.ctrlKey) || 2 === t;
              }
              _move(e1, t) {
                const i = -0.5 * (t.y - e1.y);
                if (i)
                  return (
                    (this._active = !0),
                    {
                      pitchDelta: i,
                    }
                  );
              }
              contextmenu(e1) {
                e1.preventDefault();
              }
            }
            class xS {
              constructor(e1, t) {
                (this._map = e1),
                  (this._el = e1.getCanvasContainer()),
                  (this._minTouches = 1),
                  (this._clickTolerance = t.clickTolerance || 1),
                  this.reset(),
                  j(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
              }
              reset() {
                (this._active = !1),
                  (this._touches = {}),
                  (this._sum = new y(0, 0));
              }
              touchstart(e1, t, i) {
                return this._calculateTransform(e1, t, i);
              }
              touchmove(e1, t, i) {
                if (this._active && !(i.length < this._minTouches)) {
                  if (this._map._cooperativeGestures && !this._map.isMoving()) {
                    if (1 === i.length && !ie())
                      return void this._showTouchPanBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility &&
                      ((this._alertContainer.style.visibility = "hidden"),
                      clearTimeout(this._alertTimer));
                  }
                  return (
                    e1.cancelable && e1.preventDefault(),
                    this._calculateTransform(e1, t, i)
                  );
                }
              }
              touchend(e1, t, i) {
                this._calculateTransform(e1, t, i),
                  this._active && i.length < this._minTouches && this.reset();
              }
              touchcancel() {
                this.reset();
              }
              _calculateTransform(e1, t, i) {
                i.length > 0 && (this._active = !0);
                const r = hS(i, t),
                  n = new y(0, 0),
                  o = new y(0, 0);
                let s = 0;
                for (const e1 in r) {
                  const t = r[e1],
                    i = this._touches[e1];
                  i && (n._add(t), o._add(t.sub(i)), s++, (r[e1] = t));
                }
                if (((this._touches = r), s < this._minTouches || !o.mag()))
                  return;
                const a = o.div(s);
                return (
                  this._sum._add(a),
                  this._sum.mag() < this._clickTolerance
                    ? void 0
                    : {
                        around: n.div(s),
                        panDelta: a,
                      }
                );
              }
              enable() {
                (this._enabled = !0),
                  this._map._cooperativeGestures &&
                    (this._addTouchPanBlocker(),
                    this._el.classList.add(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page",
                    ));
              }
              disable() {
                (this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove(),
                    this._el.classList.remove(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page",
                    )),
                  this.reset();
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              _addTouchPanBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = ut(
                    "div",
                    "mapboxgl-touch-pan-blocker",
                    this._map._container,
                  )),
                  (this._alertContainer.textContent = this._map._getUIString(
                    "TouchPanBlocker.Message",
                  )),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth)),
                  )}px`));
              }
              _showTouchPanBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-touch-pan-blocker-show",
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-touch-pan-blocker-show",
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 500));
              }
            }
            class vS {
              constructor() {
                this.reset();
              }
              reset() {
                (this._active = !1), (this._firstTwoTouches = void 0);
              }
              _start(e1) {}
              _move(e1, t, i) {
                return {};
              }
              touchstart(e1, t, i) {
                this._firstTwoTouches ||
                  i.length < 2 ||
                  ((this._firstTwoTouches = [i[0].identifier, i[1].identifier]),
                  this._start([t[0], t[1]]));
              }
              touchmove(e1, t, i) {
                const r = this._firstTwoTouches;
                if (!r) return;
                e1.preventDefault();
                const [n, o] = r,
                  s = bS(i, t, n),
                  a = bS(i, t, o);
                if (!s || !a) return;
                const l = this._aroundCenter ? null : s.add(a).div(2);
                return this._move([s, a], l, e1);
              }
              touchend(e1, t, i) {
                if (!this._firstTwoTouches) return;
                const [r, n] = this._firstTwoTouches,
                  o = bS(i, t, r),
                  s = bS(i, t, n);
                (o && s) || (this._active && xt(), this.reset());
              }
              touchcancel() {
                this.reset();
              }
              enable(e1) {
                (this._enabled = !0),
                  (this._aroundCenter = !!e1 && "center" === e1.around);
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            function bS(e1, t, i) {
              for (let r = 0; r < e1.length; r++)
                if (e1[r].identifier === i) return t[r];
            }
            function wS(e1, t) {
              return Math.log(e1 / t) / Math.LN2;
            }
            class TS extends vS {
              reset() {
                super.reset(), (this._distance = 0), (this._startDistance = 0);
              }
              _start(e1) {
                this._startDistance = this._distance = e1[0].dist(e1[1]);
              }
              _move(e1, t) {
                const i = this._distance;
                if (
                  ((this._distance = e1[0].dist(e1[1])),
                  this._active ||
                    !(Math.abs(wS(this._distance, this._startDistance)) < 0.1))
                )
                  return (
                    (this._active = !0),
                    {
                      zoomDelta: wS(this._distance, i),
                      pinchAround: t,
                    }
                  );
              }
            }
            function ES(e1, t) {
              return (180 * e1.angleWith(t)) / Math.PI;
            }
            class MS extends vS {
              reset() {
                super.reset(),
                  (this._minDiameter = 0),
                  (this._startVector = void 0),
                  (this._vector = void 0);
              }
              _start(e1) {
                (this._startVector = this._vector = e1[0].sub(e1[1])),
                  (this._minDiameter = e1[0].dist(e1[1]));
              }
              _move(e1, t) {
                const i = this._vector;
                if (
                  ((this._vector = e1[0].sub(e1[1])),
                  i && (this._active || !this._isBelowThreshold(this._vector)))
                )
                  return (
                    (this._active = !0),
                    {
                      bearingDelta: ES(this._vector, i),
                      pinchAround: t,
                    }
                  );
              }
              _isBelowThreshold(e1) {
                this._minDiameter = Math.min(this._minDiameter, e1.mag());
                const t = (25 / (Math.PI * this._minDiameter)) * 360,
                  i = this._startVector;
                if (!i) return !1;
                const r = ES(e1, i);
                return Math.abs(r) < t;
              }
            }
            function AS(e1) {
              return Math.abs(e1.y) > Math.abs(e1.x);
            }
            class SS extends vS {
              constructor(e1) {
                super(), (this._map = e1);
              }
              reset() {
                super.reset(),
                  (this._valid = void 0),
                  (this._firstMove = void 0),
                  (this._lastPoints = void 0);
              }
              _start(e1) {
                (this._lastPoints = e1),
                  AS(e1[0].sub(e1[1])) && (this._valid = !1);
              }
              _move(e1, t, i) {
                const r = this._lastPoints;
                if (!r) return;
                const n = e1[0].sub(r[0]),
                  o = e1[1].sub(r[1]);
                return (this._map._cooperativeGestures &&
                  !ie() &&
                  i.touches.length < 3) ||
                  ((this._valid = this.gestureBeginsVertically(
                    n,
                    o,
                    i.timeStamp,
                  )),
                  !this._valid)
                  ? void 0
                  : ((this._lastPoints = e1),
                    (this._active = !0),
                    {
                      pitchDelta: ((n.y + o.y) / 2) * -0.5,
                    });
              }
              gestureBeginsVertically(e1, t, i) {
                if (void 0 !== this._valid) return this._valid;
                const r = e1.mag() >= 2,
                  n = t.mag() >= 2;
                if (!r && !n) return;
                if (!r || !n)
                  return (
                    null == this._firstMove && (this._firstMove = i),
                    i - this._firstMove < 100 && void 0
                  );
                const o = e1.y > 0 == t.y > 0;
                return AS(e1) && AS(t) && o;
              }
            }
            const IS = {
              panStep: 100,
              bearingStep: 15,
              pitchStep: 10,
            };
            class CS {
              constructor() {
                const e1 = IS;
                (this._panStep = e1.panStep),
                  (this._bearingStep = e1.bearingStep),
                  (this._pitchStep = e1.pitchStep),
                  (this._rotationDisabled = !1);
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              keydown(e1) {
                if (e1.altKey || e1.ctrlKey || e1.metaKey) return;
                let t = 0,
                  i = 0,
                  r = 0,
                  n = 0,
                  o = 0;
                switch (e1.keyCode) {
                  case 61:
                  case 107:
                  case 171:
                  case 187:
                    t = 1;
                    break;
                  case 189:
                  case 109:
                  case 173:
                    t = -1;
                    break;
                  case 37:
                    e1.shiftKey ? (i = -1) : (e1.preventDefault(), (n = -1));
                    break;
                  case 39:
                    e1.shiftKey ? (i = 1) : (e1.preventDefault(), (n = 1));
                    break;
                  case 38:
                    e1.shiftKey ? (r = 1) : (e1.preventDefault(), (o = -1));
                    break;
                  case 40:
                    e1.shiftKey ? (r = -1) : (e1.preventDefault(), (o = 1));
                    break;
                  default:
                    return;
                }
                return (
                  this._rotationDisabled && ((i = 0), (r = 0)),
                  {
                    cameraAnimation: (s) => {
                      const a = s.getZoom();
                      s.easeTo(
                        {
                          duration: 300,
                          easeId: "keyboardHandler",
                          easing: zS,
                          zoom: t
                            ? Math.round(a) + t * (e1.shiftKey ? 2 : 1)
                            : a,
                          bearing: s.getBearing() + i * this._bearingStep,
                          pitch: s.getPitch() + r * this._pitchStep,
                          offset: [-n * this._panStep, -o * this._panStep],
                          center: s.getCenter(),
                        },
                        {
                          originalEvent: e1,
                        },
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
              disableRotation() {
                this._rotationDisabled = !0;
              }
              enableRotation() {
                this._rotationDisabled = !1;
              }
            }
            function zS(e1) {
              return e1 * (2 - e1);
            }
            const DS = 4.000244140625;
            class PS {
              constructor(e1, t) {
                (this._map = e1),
                  (this._el = e1.getCanvasContainer()),
                  (this._handler = t),
                  (this._delta = 0),
                  (this._lastDelta = 0),
                  (this._defaultZoomRate = 0.01),
                  (this._wheelZoomRate = 0.0022222222222222222),
                  j(
                    [
                      "_onTimeout",
                      "_addScrollZoomBlocker",
                      "_showBlockerAlert",
                    ],
                    this,
                  );
              }
              setZoomRate(e1) {
                this._defaultZoomRate = e1;
              }
              setWheelZoomRate(e1) {
                this._wheelZoomRate = e1;
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return this._active || void 0 !== this._finishTimeout;
              }
              isZooming() {
                return !!this._zooming;
              }
              enable(e1) {
                this.isEnabled() ||
                  ((this._enabled = !0),
                  (this._aroundCenter = !!e1 && "center" === e1.around),
                  this._map._cooperativeGestures &&
                    this._addScrollZoomBlocker());
              }
              disable() {
                this.isEnabled() &&
                  ((this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove()));
              }
              wheel(e1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                  if (!(e1.ctrlKey || e1.metaKey || this.isZooming() || ie()))
                    return void this._showBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility &&
                    ((this._alertContainer.style.visibility = "hidden"),
                    clearTimeout(this._alertTimer));
                }
                let i =
                  e1.deltaMode === t.WheelEvent.DOM_DELTA_LINE
                    ? 40 * e1.deltaY
                    : e1.deltaY;
                const r = ht.now(),
                  n = r - (this._lastWheelEventTime || 0);
                (this._lastWheelEventTime = r),
                  0 !== i && i % DS == 0
                    ? (this._type = "wheel")
                    : 0 !== i && Math.abs(i) < 4
                    ? (this._type = "trackpad")
                    : n > 400
                    ? ((this._type = null),
                      (this._lastValue = i),
                      (this._timeout = setTimeout(this._onTimeout, 40, e1)))
                    : this._type ||
                      ((this._type =
                        Math.abs(n * i) < 200 ? "trackpad" : "wheel"),
                      this._timeout &&
                        (clearTimeout(this._timeout),
                        (this._timeout = null),
                        (i += this._lastValue))),
                  e1.shiftKey && i && (i /= 4),
                  this._type &&
                    ((this._lastWheelEvent = e1),
                    (this._delta -= i),
                    this._active || this._start(e1)),
                  e1.preventDefault();
              }
              _onTimeout(e1) {
                (this._type = "wheel"),
                  (this._delta -= this._lastValue),
                  this._active || this._start(e1);
              }
              _start(e1) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null),
                  (this._active = !0),
                  this.isZooming() || (this._zooming = !0),
                  this._finishTimeout &&
                    (clearTimeout(this._finishTimeout),
                    delete this._finishTimeout);
                const t = vt(this._el, e1);
                (this._aroundPoint = this._aroundCenter
                  ? this._map.transform.centerPoint
                  : t),
                  (this._aroundCoord = this._map.transform.pointCoordinate3D(
                    this._aroundPoint,
                  )),
                  (this._targetZoom = void 0),
                  this._frameId ||
                    ((this._frameId = !0), this._handler._triggerRenderFrame());
              }
              renderFrame() {
                if (!this._frameId) return;
                if (((this._frameId = null), !this.isActive())) return;
                const e1 = this._map.transform;
                "wheel" === this._type &&
                  e1.projection.wrap &&
                  (e1._center.lng >= 180 || e1._center.lng <= -180) &&
                  ((this._prevEase = null),
                  (this._easing = null),
                  (this._lastWheelEvent = null),
                  (this._lastWheelEventTime = 0));
                const t = () =>
                  e1._terrainEnabled() && this._aroundCoord
                    ? e1.computeZoomRelativeTo(this._aroundCoord)
                    : e1.zoom;
                if (0 !== this._delta) {
                  const i =
                    "wheel" === this._type && Math.abs(this._delta) > DS
                      ? this._wheelZoomRate
                      : this._defaultZoomRate;
                  let r = 2 / (1 + Math.exp(-Math.abs(this._delta * i)));
                  this._delta < 0 && 0 !== r && (r = 1 / r);
                  const n = t(),
                    o = Math.pow(2, n),
                    s =
                      "number" == typeof this._targetZoom
                        ? e1.zoomScale(this._targetZoom)
                        : o;
                  (this._targetZoom = Math.min(
                    e1.maxZoom,
                    Math.max(e1.minZoom, e1.scaleZoom(s * r)),
                  )),
                    "wheel" === this._type &&
                      ((this._startZoom = n),
                      (this._easing = this._smoothOutEasing(200))),
                    (this._lastDelta = this._delta),
                    (this._delta = 0);
                }
                const i =
                    "number" == typeof this._targetZoom
                      ? this._targetZoom
                      : t(),
                  r = this._startZoom,
                  n = this._easing;
                let o,
                  s = !1;
                if ("wheel" === this._type && r && n) {
                  const e1 = Math.min(
                    (ht.now() - this._lastWheelEventTime) / 200,
                    1,
                  );
                  (o = Wr(r, i, n(e1))),
                    e1 < 1 ? this._frameId || (this._frameId = !0) : (s = !0);
                } else (o = i), (s = !0);
                (this._active = !0),
                  s &&
                    ((this._active = !1),
                    (this._finishTimeout = setTimeout(() => {
                      (this._zooming = !1),
                        this._handler._triggerRenderFrame(),
                        delete this._targetZoom,
                        delete this._finishTimeout;
                    }, 200)));
                let a = o - t();
                return (
                  a * this._lastDelta < 0 && (a = 0),
                  {
                    noInertia: !0,
                    needsRenderFrame: !s,
                    zoomDelta: a,
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent,
                  }
                );
              }
              _smoothOutEasing(e1) {
                let t = C;
                if (this._prevEase) {
                  const e1 = this._prevEase,
                    i = (ht.now() - e1.start) / e1.duration,
                    r = e1.easing(i + 0.01) - e1.easing(i),
                    n = (0.27 / Math.sqrt(r * r + 1e-4)) * 0.01;
                  t = I(n, Math.sqrt(0.0729 - n * n), 0.25, 1);
                }
                return (
                  (this._prevEase = {
                    start: ht.now(),
                    duration: e1,
                    easing: t,
                  }),
                  t
                );
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              _addScrollZoomBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = ut(
                    "div",
                    "mapboxgl-scroll-zoom-blocker",
                    this._map._container,
                  )),
                  (this._alertContainer.textContent = /(Mac|iPad)/i.test(
                    t.navigator.userAgent,
                  )
                    ? this._map._getUIString("ScrollZoomBlocker.CmdMessage")
                    : this._map._getUIString("ScrollZoomBlocker.CtrlMessage")),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth)),
                  )}px`));
              }
              _showBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-scroll-zoom-blocker-show",
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-scroll-zoom-blocker-show",
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 200));
              }
            }
            class RS {
              constructor(e1, t) {
                (this._clickZoom = e1), (this._tapZoom = t);
              }
              enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
              }
              disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
              }
              isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
              }
              isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
              }
            }
            class LS {
              constructor() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              blur() {
                this.reset();
              }
              dblclick(e1, t) {
                return (
                  e1.preventDefault(),
                  {
                    cameraAnimation: (i) => {
                      i.easeTo(
                        {
                          duration: 300,
                          zoom: i.getZoom() + (e1.shiftKey ? -1 : 1),
                          around: i.unproject(t),
                        },
                        {
                          originalEvent: e1,
                        },
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class kS {
              constructor() {
                (this._tap = new dS({
                  numTouches: 1,
                  numTaps: 1,
                })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._swipePoint = void 0),
                  (this._swipeTouch = 0),
                  (this._tapTime = 0),
                  this._tap.reset();
              }
              touchstart(e1, t, i) {
                this._swipePoint ||
                  (this._tapTime &&
                    e1.timeStamp - this._tapTime > 500 &&
                    this.reset(),
                  this._tapTime
                    ? i.length > 0 &&
                      ((this._swipePoint = t[0]),
                      (this._swipeTouch = i[0].identifier))
                    : this._tap.touchstart(e1, t, i));
              }
              touchmove(e1, t, i) {
                if (this._tapTime) {
                  if (this._swipePoint) {
                    if (i[0].identifier !== this._swipeTouch) return;
                    const r = t[0],
                      n = r.y - this._swipePoint.y;
                    return (
                      (this._swipePoint = r),
                      e1.preventDefault(),
                      (this._active = !0),
                      {
                        zoomDelta: n / 128,
                      }
                    );
                  }
                } else this._tap.touchmove(e1, t, i);
              }
              touchend(e1, t, i) {
                this._tapTime
                  ? this._swipePoint && 0 === i.length && this.reset()
                  : this._tap.touchend(e1, t, i) &&
                    (this._tapTime = e1.timeStamp);
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class OS {
              constructor(e1, t, i) {
                (this._el = e1), (this._mousePan = t), (this._touchPan = i);
              }
              enable(e1) {
                (this._inertiaOptions = e1 || {}),
                  this._mousePan.enable(),
                  this._touchPan.enable(),
                  this._el.classList.add("mapboxgl-touch-drag-pan");
              }
              disable() {
                this._mousePan.disable(),
                  this._touchPan.disable(),
                  this._el.classList.remove("mapboxgl-touch-drag-pan");
              }
              isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
              }
              isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
              }
            }
            class BS {
              constructor(e1, t, i) {
                (this._pitchWithRotate = e1.pitchWithRotate),
                  (this._mouseRotate = t),
                  (this._mousePitch = i);
              }
              enable() {
                this._mouseRotate.enable(),
                  this._pitchWithRotate && this._mousePitch.enable();
              }
              disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
              }
              isEnabled() {
                return (
                  this._mouseRotate.isEnabled() &&
                  (!this._pitchWithRotate || this._mousePitch.isEnabled())
                );
              }
              isActive() {
                return (
                  this._mouseRotate.isActive() || this._mousePitch.isActive()
                );
              }
            }
            class FS {
              constructor(e1, t, i, r) {
                (this._el = e1),
                  (this._touchZoom = t),
                  (this._touchRotate = i),
                  (this._tapDragZoom = r),
                  (this._rotationDisabled = !1),
                  (this._enabled = !0);
              }
              enable(e1) {
                this._touchZoom.enable(e1),
                  this._rotationDisabled || this._touchRotate.enable(e1),
                  this._tapDragZoom.enable(),
                  this._el.classList.add("mapboxgl-touch-zoom-rotate");
              }
              disable() {
                this._touchZoom.disable(),
                  this._touchRotate.disable(),
                  this._tapDragZoom.disable(),
                  this._el.classList.remove("mapboxgl-touch-zoom-rotate");
              }
              isEnabled() {
                return (
                  this._touchZoom.isEnabled() &&
                  (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                  this._tapDragZoom.isEnabled()
                );
              }
              isActive() {
                return (
                  this._touchZoom.isActive() ||
                  this._touchRotate.isActive() ||
                  this._tapDragZoom.isActive()
                );
              }
              disableRotation() {
                (this._rotationDisabled = !0), this._touchRotate.disable();
              }
              enableRotation() {
                (this._rotationDisabled = !1),
                  this._touchZoom.isEnabled() && this._touchRotate.enable();
              }
            }
            const NS = (e1) => e1.zoom || e1.drag || e1.pitch || e1.rotate;
            class US extends At {}
            class VS {
              constructor() {
                (this.constants = [1, 1, 0.01]), (this.radius = 0);
              }
              setup(e1, t) {
                const i = Mu.sub([], t, e1);
                this.radius = Mu.length(
                  i[2] < 0 ? Mu.div([], i, this.constants) : [i[0], i[1], 0],
                );
              }
              projectRay(e1) {
                Mu.div(e1, e1, this.constants),
                  Mu.normalize(e1, e1),
                  Mu.mul(e1, e1, this.constants);
                const t = Mu.scale([], e1, this.radius);
                if (t[2] > 0) {
                  const e1 = Mu.scale([], [0, 0, 1], Mu.dot(t, [0, 0, 1])),
                    i = Mu.scale(
                      [],
                      Mu.normalize([], [t[0], t[1], 0]),
                      this.radius,
                    ),
                    r = Mu.add(
                      [],
                      t,
                      Mu.scale([], Mu.sub([], Mu.add([], i, e1), t), 2),
                    );
                  (t[0] = r[0]), (t[1] = r[1]);
                }
                return t;
              }
            }
            function jS(e1) {
              return (
                (e1.panDelta && e1.panDelta.mag()) ||
                e1.zoomDelta ||
                e1.bearingDelta ||
                e1.pitchDelta
              );
            }
            class GS {
              constructor(e1, i) {
                (this._map = e1),
                  (this._el = this._map.getCanvasContainer()),
                  (this._handlers = []),
                  (this._handlersById = {}),
                  (this._changes = []),
                  (this._inertia = new tS(e1)),
                  (this._bearingSnap = i.bearingSnap),
                  (this._previousActiveHandlers = {}),
                  (this._trackingEllipsoid = new VS()),
                  (this._dragOrigin = null),
                  (this._eventsInProgress = {}),
                  this._addDefaultHandlers(i),
                  j(["handleEvent", "handleWindowEvent"], this);
                const r = this._el;
                this._listeners = [
                  [
                    r,
                    "touchstart",
                    {
                      passive: !0,
                    },
                  ],
                  [
                    r,
                    "touchmove",
                    {
                      passive: !1,
                    },
                  ],
                  [r, "touchend", void 0],
                  [r, "touchcancel", void 0],
                  [r, "mousedown", void 0],
                  [r, "mousemove", void 0],
                  [r, "mouseup", void 0],
                  [
                    t.document,
                    "mousemove",
                    {
                      capture: !0,
                    },
                  ],
                  [t.document, "mouseup", void 0],
                  [r, "mouseover", void 0],
                  [r, "mouseout", void 0],
                  [r, "dblclick", void 0],
                  [r, "click", void 0],
                  [
                    r,
                    "keydown",
                    {
                      capture: !1,
                    },
                  ],
                  [r, "keyup", void 0],
                  [
                    r,
                    "wheel",
                    {
                      passive: !1,
                    },
                  ],
                  [r, "contextmenu", void 0],
                  [t, "blur", void 0],
                ];
                for (const [e1, i, r] of this._listeners)
                  e1.addEventListener(
                    i,
                    e1 === t.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    r,
                  );
              }
              destroy() {
                for (const [e1, i, r] of this._listeners)
                  e1.removeEventListener(
                    i,
                    e1 === t.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    r,
                  );
              }
              _addDefaultHandlers(e1) {
                const t = this._map,
                  i = t.getCanvasContainer();
                this._add("mapEvent", new aS(t, e1));
                const r = (t.boxZoom = new cS(t, e1));
                this._add("boxZoom", r);
                const n = new pS(),
                  o = new LS();
                (t.doubleClickZoom = new RS(o, n)),
                  this._add("tapZoom", n),
                  this._add("clickZoom", o);
                const s = new kS();
                this._add("tapDragZoom", s);
                const a = (t.touchPitch = new SS(t));
                this._add("touchPitch", a);
                const l = new gS(e1),
                  c = new yS(e1);
                (t.dragRotate = new BS(e1, l, c)),
                  this._add("mouseRotate", l, ["mousePitch"]),
                  this._add("mousePitch", c, ["mouseRotate"]);
                const h = new _S(e1),
                  u = new xS(t, e1);
                (t.dragPan = new OS(i, h, u)),
                  this._add("mousePan", h),
                  this._add("touchPan", u, ["touchZoom", "touchRotate"]);
                const d = new MS(),
                  p = new TS();
                (t.touchZoomRotate = new FS(i, p, d, s)),
                  this._add("touchRotate", d, ["touchPan", "touchZoom"]),
                  this._add("touchZoom", p, ["touchPan", "touchRotate"]),
                  this._add("blockableMapEvent", new lS(t));
                const f = (t.scrollZoom = new PS(t, this));
                this._add("scrollZoom", f, ["mousePan"]);
                const m = (t.keyboard = new CS());
                this._add("keyboard", m);
                for (const i of [
                  "boxZoom",
                  "doubleClickZoom",
                  "tapDragZoom",
                  "touchPitch",
                  "dragRotate",
                  "dragPan",
                  "touchZoomRotate",
                  "scrollZoom",
                  "keyboard",
                ])
                  e1.interactive && e1[i] && t[i].enable(e1[i]);
              }
              _add(e1, t, i) {
                this._handlers.push({
                  handlerName: e1,
                  handler: t,
                  allowed: i,
                }),
                  (this._handlersById[e1] = t);
              }
              stop(e1) {
                if (!this._updatingCamera) {
                  for (const { handler: e1 } of this._handlers) e1.reset();
                  this._inertia.clear(),
                    this._fireEvents({}, {}, e1),
                    (this._changes = []),
                    (this._originalZoom = void 0);
                }
              }
              isActive() {
                for (const { handler: e1 } of this._handlers)
                  if (e1.isActive()) return !0;
                return !1;
              }
              isZooming() {
                return (
                  !!this._eventsInProgress.zoom ||
                  this._map.scrollZoom.isZooming()
                );
              }
              isRotating() {
                return !!this._eventsInProgress.rotate;
              }
              isMoving() {
                return !!NS(this._eventsInProgress) || this.isZooming();
              }
              _isDragging() {
                return !!this._eventsInProgress.drag;
              }
              _blockedByActive(e1, t, i) {
                for (const r in e1)
                  if (r !== i && (!t || t.indexOf(r) < 0)) return !0;
                return !1;
              }
              handleWindowEvent(e1) {
                this.handleEvent(e1, `${e1.type}Window`);
              }
              _getMapTouches(e1) {
                const t = [];
                for (const i of e1) this._el.contains(i.target) && t.push(i);
                return t;
              }
              handleEvent(e1, t) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e1.type,
                  r = i ? void 0 : e1,
                  n = {
                    needsRenderFrame: !1,
                  },
                  o = {},
                  s = {},
                  a = e1.touches ? this._getMapTouches(e1.touches) : void 0,
                  l = a ? bt(this._el, a) : i ? void 0 : vt(this._el, e1);
                for (const { handlerName: i, handler: c, allowed: h } of this
                  ._handlers) {
                  if (!c.isEnabled()) continue;
                  let u;
                  this._blockedByActive(s, h, i)
                    ? c.reset()
                    : c[t || e1.type] &&
                      ((u = c[t || e1.type](e1, l, a)),
                      this.mergeHandlerResult(n, o, u, i, r),
                      u && u.needsRenderFrame && this._triggerRenderFrame()),
                    (u || c.isActive()) && (s[i] = c);
                }
                const c = {};
                for (const e1 in this._previousActiveHandlers)
                  s[e1] || (c[e1] = r);
                (this._previousActiveHandlers = s),
                  (Object.keys(c).length || jS(n)) &&
                    (this._changes.push([n, o, c]), this._triggerRenderFrame()),
                  (Object.keys(s).length || jS(n)) && this._map._stop(!0),
                  (this._updatingCamera = !1);
                const { cameraAnimation: h } = n;
                h &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  h(this._map));
              }
              mergeHandlerResult(e1, t, i, r, n) {
                if (!i) return;
                k(e1, i);
                const o = {
                  handlerName: r,
                  originalEvent: i.originalEvent || n,
                };
                void 0 !== i.zoomDelta && (t.zoom = o),
                  void 0 !== i.panDelta && (t.drag = o),
                  void 0 !== i.pitchDelta && (t.pitch = o),
                  void 0 !== i.bearingDelta && (t.rotate = o);
              }
              _applyChanges() {
                const e1 = {},
                  t = {},
                  i = {};
                for (const [r, n, o] of this._changes)
                  r.panDelta &&
                    (e1.panDelta = (e1.panDelta || new y(0, 0))._add(
                      r.panDelta,
                    )),
                    r.zoomDelta &&
                      (e1.zoomDelta = (e1.zoomDelta || 0) + r.zoomDelta),
                    r.bearingDelta &&
                      (e1.bearingDelta =
                        (e1.bearingDelta || 0) + r.bearingDelta),
                    r.pitchDelta &&
                      (e1.pitchDelta = (e1.pitchDelta || 0) + r.pitchDelta),
                    void 0 !== r.around && (e1.around = r.around),
                    void 0 !== r.aroundCoord &&
                      (e1.aroundCoord = r.aroundCoord),
                    void 0 !== r.pinchAround &&
                      (e1.pinchAround = r.pinchAround),
                    r.noInertia && (e1.noInertia = r.noInertia),
                    k(t, n),
                    k(i, o);
                this._updateMapTransform(e1, t, i), (this._changes = []);
              }
              _updateMapTransform(e1, t, i) {
                const r = this._map,
                  n = r.transform,
                  o = (e1) => [e1.x, e1.y, e1.z];
                if (
                  ((e1) => {
                    const t = this._eventsInProgress.drag;
                    return t && !this._handlersById[t.handlerName].isActive();
                  })() &&
                  !jS(e1)
                ) {
                  const e1 = n.zoom;
                  (n.cameraElevationReference = "sea"),
                    null != this._originalZoom &&
                    n._orthographicProjectionAtLowPitch &&
                    "globe" !== n.projection.name &&
                    0 === n.pitch
                      ? ((n.cameraElevationReference = "ground"),
                        (n.zoom = this._originalZoom))
                      : (n.recenterOnTerrain(),
                        (n.cameraElevationReference = "ground")),
                    e1 !== n.zoom && this._map._update(!0);
                }
                if ((n._isCameraConstrained && r._stop(!0), !jS(e1)))
                  return void this._fireEvents(t, i, !0);
                let {
                  panDelta: s,
                  zoomDelta: a,
                  bearingDelta: l,
                  pitchDelta: c,
                  around: h,
                  aroundCoord: u,
                  pinchAround: d,
                } = e1;
                n._isCameraConstrained &&
                  (a > 0 && (a = 0), (n._isCameraConstrained = !1)),
                  void 0 !== d && (h = d),
                  (a ||
                    ((e1) => t[e1] && !this._eventsInProgress[e1])("drag")) &&
                    h &&
                    ((this._dragOrigin = o(n.pointCoordinate3D(h))),
                    (this._originalZoom = n.zoom),
                    this._trackingEllipsoid.setup(
                      n._camera.position,
                      this._dragOrigin,
                    )),
                  (n.cameraElevationReference = "sea"),
                  r._stop(!0),
                  (h = h || r.transform.centerPoint),
                  l && (n.bearing += l),
                  c && (n.pitch += c),
                  n._updateCameraState();
                const p = [0, 0, 0];
                if (s) {
                  if ("mercator" === n.projection.name) {
                    const e1 = this._trackingEllipsoid.projectRay(
                        n.screenPointToMercatorRay(h).dir,
                      ),
                      t = this._trackingEllipsoid.projectRay(
                        n.screenPointToMercatorRay(h.sub(s)).dir,
                      );
                    (p[0] = t[0] - e1[0]), (p[1] = t[1] - e1[1]);
                  } else {
                    const e1 = n.pointCoordinate(h);
                    if ("globe" === n.projection.name) {
                      s = s.rotate(-n.angle);
                      const t = n._pixelsPerMercatorPixel / n.worldSize;
                      (p[0] = -s.x * Jd(Hd(e1.y)) * t),
                        (p[1] = -s.y * Jd(n.center.lat) * t);
                    } else {
                      const t = n.pointCoordinate(h.sub(s));
                      e1 && t && ((p[0] = t.x - e1.x), (p[1] = t.y - e1.y));
                    }
                  }
                }
                const f = n.zoom,
                  m = [0, 0, 0];
                if (a) {
                  const e1 = o(u || n.pointCoordinate3D(h)),
                    t = {
                      dir: Mu.normalize([], Mu.sub([], e1, n._camera.position)),
                    };
                  if (t.dir[2] < 0) {
                    const i = n.zoomDeltaToMovement(e1, a);
                    Mu.scale(m, t.dir, i);
                  }
                }
                const _ = Mu.add(p, p, m);
                n._translateCameraConstrained(_),
                  a && Math.abs(n.zoom - f) > 1e-4 && n.recenterOnTerrain(),
                  (n.cameraElevationReference = "ground"),
                  this._map._update(),
                  e1.noInertia || this._inertia.record(e1),
                  this._fireEvents(t, i, !0);
              }
              _fireEvents(e1, t, i) {
                const r = NS(this._eventsInProgress),
                  n = NS(e1),
                  o = {};
                for (const t in e1) {
                  const { originalEvent: i } = e1[t];
                  this._eventsInProgress[t] || (o[`${t}start`] = i),
                    (this._eventsInProgress[t] = e1[t]);
                }
                !r && n && this._fireEvent("movestart", n.originalEvent);
                for (const e1 in o) this._fireEvent(e1, o[e1]);
                n && this._fireEvent("move", n.originalEvent);
                for (const t in e1) {
                  const { originalEvent: i } = e1[t];
                  this._fireEvent(t, i);
                }
                const s = {};
                let a;
                for (const e1 in this._eventsInProgress) {
                  const { handlerName: i, originalEvent: r } =
                    this._eventsInProgress[e1];
                  this._handlersById[i].isActive() ||
                    (delete this._eventsInProgress[e1],
                    (a = t[i] || r),
                    (s[`${e1}end`] = a));
                }
                for (const e1 in s) this._fireEvent(e1, s[e1]);
                const l = NS(this._eventsInProgress);
                if (i && (r || n) && !l) {
                  this._updatingCamera = !0;
                  const e1 = this._inertia._onMoveEnd(
                      this._map.dragPan._inertiaOptions,
                    ),
                    t = (e1) =>
                      0 !== e1 &&
                      -this._bearingSnap < e1 &&
                      e1 < this._bearingSnap;
                  e1
                    ? (t(e1.bearing || this._map.getBearing()) &&
                        (e1.bearing = 0),
                      this._map.easeTo(e1, {
                        originalEvent: a,
                      }))
                    : (this._map.fire(
                        new At("moveend", {
                          originalEvent: a,
                        }),
                      ),
                      t(this._map.getBearing()) && this._map.resetNorth()),
                    (this._updatingCamera = !1);
                }
              }
              _fireEvent(e1, t) {
                this._map.fire(
                  new At(
                    e1,
                    t
                      ? {
                          originalEvent: t,
                        }
                      : {},
                  ),
                );
              }
              _requestFrame() {
                return (
                  this._map.triggerRepaint(),
                  this._map._renderTaskQueue.add((e1) => {
                    (this._frameId = void 0),
                      this.handleEvent(
                        new US("renderFrame", {
                          timeStamp: e1,
                        }),
                      ),
                      this._applyChanges();
                  })
                );
              }
              _triggerRenderFrame() {
                void 0 === this._frameId &&
                  (this._frameId = this._requestFrame());
              }
            }
            const qS =
              "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
            class ZS extends It {
              constructor(e1, t) {
                super(),
                  (this._moving = !1),
                  (this._zooming = !1),
                  (this.transform = e1),
                  (this._bearingSnap = t.bearingSnap),
                  (this._respectPrefersReducedMotion =
                    !1 !== t.respectPrefersReducedMotion),
                  j(["_renderFrameCallback"], this);
              }
              getCenter() {
                return new Nd(
                  this.transform.center.lng,
                  this.transform.center.lat,
                );
              }
              setCenter(e1, t) {
                return this.jumpTo(
                  {
                    center: e1,
                  },
                  t,
                );
              }
              panBy(e1, t, i) {
                return (
                  (e1 = y.convert(e1).mult(-1)),
                  this.panTo(
                    this.transform.center,
                    k(
                      {
                        offset: e1,
                      },
                      t,
                    ),
                    i,
                  )
                );
              }
              panTo(e1, t, i) {
                return this.easeTo(
                  k(
                    {
                      center: e1,
                    },
                    t,
                  ),
                  i,
                );
              }
              getZoom() {
                return this.transform.zoom;
              }
              setZoom(e1, t) {
                return (
                  this.jumpTo(
                    {
                      zoom: e1,
                    },
                    t,
                  ),
                  this
                );
              }
              zoomTo(e1, t, i) {
                return this.easeTo(
                  k(
                    {
                      zoom: e1,
                    },
                    t,
                  ),
                  i,
                );
              }
              zoomIn(e1, t) {
                return this.zoomTo(this.getZoom() + 1, e1, t), this;
              }
              zoomOut(e1, t) {
                return this.zoomTo(this.getZoom() - 1, e1, t), this;
              }
              getBearing() {
                return this.transform.bearing;
              }
              setBearing(e1, t) {
                return (
                  this.jumpTo(
                    {
                      bearing: e1,
                    },
                    t,
                  ),
                  this
                );
              }
              getPadding() {
                return this.transform.padding;
              }
              setPadding(e1, t) {
                return (
                  this.jumpTo(
                    {
                      padding: e1,
                    },
                    t,
                  ),
                  this
                );
              }
              rotateTo(e1, t, i) {
                return this.easeTo(
                  k(
                    {
                      bearing: e1,
                    },
                    t,
                  ),
                  i,
                );
              }
              resetNorth(e1, t) {
                return (
                  this.rotateTo(
                    0,
                    k(
                      {
                        duration: 1e3,
                      },
                      e1,
                    ),
                    t,
                  ),
                  this
                );
              }
              resetNorthPitch(e1, t) {
                return (
                  this.easeTo(
                    k(
                      {
                        bearing: 0,
                        pitch: 0,
                        duration: 1e3,
                      },
                      e1,
                    ),
                    t,
                  ),
                  this
                );
              }
              snapToNorth(e1, t) {
                return Math.abs(this.getBearing()) < this._bearingSnap
                  ? this.resetNorth(e1, t)
                  : this;
              }
              getPitch() {
                return this.transform.pitch;
              }
              setPitch(e1, t) {
                return (
                  this.jumpTo(
                    {
                      pitch: e1,
                    },
                    t,
                  ),
                  this
                );
              }
              cameraForBounds(e1, t) {
                e1 = Ql.convert(e1);
                const i = (t && t.bearing) || 0,
                  r = (t && t.pitch) || 0,
                  n = e1.getNorthWest(),
                  o = e1.getSouthEast();
                return this._cameraForBounds(this.transform, n, o, i, r, t);
              }
              _extendCameraOptions(e1) {
                const t = {
                  top: 0,
                  bottom: 0,
                  right: 0,
                  left: 0,
                };
                if (
                  "number" ==
                  typeof (e1 = k(
                    {
                      padding: t,
                      offset: [0, 0],
                      maxZoom: this.transform.maxZoom,
                    },
                    e1,
                  )).padding
                ) {
                  const t = e1.padding;
                  e1.padding = {
                    top: t,
                    bottom: t,
                    right: t,
                    left: t,
                  };
                }
                return (e1.padding = k(t, e1.padding)), e1;
              }
              _minimumAABBFrustumDistance(e1, t) {
                const i = t.max[0] - t.min[0],
                  r = t.max[1] - t.min[1];
                return i / r > e1.aspect
                  ? i / (2 * Math.tan(0.5 * e1.fovX) * e1.aspect)
                  : r / (2 * Math.tan(0.5 * e1.fovY) * e1.aspect);
              }
              _cameraForBoundsOnGlobe(e1, t, i, r, n, o) {
                const s = e1.clone(),
                  a = this._extendCameraOptions(o);
                (s.bearing = r), (s.pitch = n);
                const l = Nd.convert(t),
                  c = Nd.convert(i),
                  h = 0.5 * (l.lat + c.lat),
                  u = 0.5 * (l.lng + c.lng),
                  d = md(h, u),
                  p = Mu.normalize([], d),
                  f = Mu.normalize([], Mu.cross([], p, [0, 1, 0])),
                  m = Mu.cross([], f, p),
                  _ = [
                    f[0],
                    f[1],
                    f[2],
                    0,
                    m[0],
                    m[1],
                    m[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1,
                  ],
                  g = [
                    d,
                    md(l.lat, l.lng),
                    md(c.lat, l.lng),
                    md(c.lat, c.lng),
                    md(l.lat, c.lng),
                    md(h, l.lng),
                    md(h, c.lng),
                    md(l.lat, u),
                    md(c.lat, u),
                  ];
                let y = Hu.fromPoints(
                  g.map((e1) => [Mu.dot(f, e1), Mu.dot(m, e1), Mu.dot(p, e1)]),
                );
                const x = Mu.transformMat4([], y.center, _);
                0 === Mu.squaredLength(x) && Mu.set(x, 0, 0, 1),
                  Mu.normalize(x, x),
                  Mu.scale(x, x, Yu),
                  (s.center = (function ([e1, t, i]) {
                    const r = Math.hypot(e1, t, i),
                      n = Math.atan2(e1, i),
                      o = 0.5 * Math.PI - Math.acos(-t / r);
                    return new Nd(T(n), T(o));
                  })(x));
                const v = s.getWorldToCameraMatrix(),
                  b = xu.invert(new Float64Array(16), v);
                (y = Hu.applyTransform(y, xu.multiply([], v, _))),
                  Mu.transformMat4(x, x, v);
                const w = 0.5 * (y.max[2] - y.min[2]),
                  E = this._minimumAABBFrustumDistance(s, y),
                  M = Mu.scale([], [0, 0, 1], w),
                  A = Mu.add(M, x, M),
                  S = E + (0 === s.pitch ? 0 : Mu.distance(x, A)),
                  I = s.globeCenterInViewSpace,
                  C = Mu.sub([], x, [I[0], I[1], I[2]]);
                Mu.normalize(C, C), Mu.scale(C, C, S);
                const z = Mu.add([], x, C);
                Mu.transformMat4(z, z, b);
                const D = Od / Yu,
                  P = Mu.length(z),
                  R = Zd(Math.max(P * D - Od, Number.EPSILON), 0),
                  L = Math.min(s.zoomFromMercatorZAdjusted(R), a.maxZoom);
                return L > 0.5 * (Wu + Xu)
                  ? (s.setProjection({
                      name: "mercator",
                    }),
                    (s.zoom = L),
                    this._cameraForBounds(s, t, i, r, n, o))
                  : {
                      center: s.center,
                      zoom: L,
                      bearing: r,
                      pitch: n,
                    };
              }
              queryTerrainElevation(e1, t) {
                const i = this.transform.elevation;
                return i
                  ? ((t = k(
                      {},
                      {
                        exaggerated: !0,
                      },
                      t,
                    )),
                    i.getAtPoint(ep.fromLngLat(e1), null, t.exaggerated))
                  : null;
              }
              _cameraForBounds(e1, t, i, r, n, o) {
                if ("globe" === e1.projection.name)
                  return this._cameraForBoundsOnGlobe(e1, t, i, r, n, o);
                const s = e1.clone(),
                  a = this._extendCameraOptions(o),
                  l = s.padding;
                (s.bearing = r), (s.pitch = n);
                const c = Nd.convert(t),
                  h = Nd.convert(i),
                  u = new Nd(c.lng, h.lat),
                  d = new Nd(h.lng, c.lat),
                  p = s.project(c),
                  f = s.project(h),
                  m = this.queryTerrainElevation(c),
                  _ = this.queryTerrainElevation(h),
                  g = this.queryTerrainElevation(u),
                  x = this.queryTerrainElevation(d),
                  v = [
                    [p.x, p.y, Math.min(m || 0, _ || 0, g || 0, x || 0)],
                    [f.x, f.y, Math.max(m || 0, _ || 0, g || 0, x || 0)],
                  ];
                let b = Hu.fromPoints(v);
                const T = s.getWorldToCameraMatrix(),
                  E = xu.invert(new Float64Array(16), T);
                b = Hu.applyTransform(b, T);
                const M = Mu.sub([], b.max, b.min),
                  A = l.left || 0,
                  S = l.right || 0,
                  I = l.bottom || 0,
                  C = l.top || 0,
                  { left: z, right: D, top: P, bottom: R } = a.padding,
                  L = 0.5 * (A + S),
                  k = 0.5 * (C + I),
                  O = Math.min(
                    s.scaleZoom(
                      s.scale *
                        Math.min(
                          (s.width - (A + S + z + D)) / M[0],
                          (s.height - (I + C + R + P)) / M[1],
                        ),
                    ),
                    a.maxZoom,
                  ),
                  B = s.scale / s.zoomScale(O);
                b = new Hu(
                  [b.min[0] - (z + L) * B, b.min[1] - (R + k) * B, b.min[2]],
                  [b.max[0] + (D + L) * B, b.max[1] + (P + k) * B, b.max[2]],
                );
                const F = 0.5 * M[2],
                  N = this._minimumAABBFrustumDistance(s, b),
                  U = [0, 0, 1, 0];
                uu.transformMat4(U, U, T), uu.normalize(U, U);
                const V = Mu.scale([], U, N + F),
                  j = Mu.add([], b.center, V),
                  G = (
                    "number" == typeof a.offset.x &&
                    "number" == typeof a.offset.y
                      ? new y(a.offset.x, a.offset.y)
                      : y.convert(a.offset)
                  ).rotate(-w(r));
                (b.center[0] -= G.x * B),
                  (b.center[1] += G.y * B),
                  Mu.transformMat4(b.center, b.center, E),
                  Mu.transformMat4(j, j, E);
                const q = [b.center[0], b.center[1], j[2] * s.pixelsPerMeter];
                Mu.scale(q, q, 1 / s.worldSize);
                const Z = $d(q[0]),
                  $ = Hd(q[1]),
                  H = Math.min(s._zoomFromMercatorZ(q[2]), a.maxZoom),
                  W = new Nd(Z, $);
                return s.mercatorFromTransition && H < 0.5 * (Wu + Xu)
                  ? (s.setProjection({
                      name: "globe",
                    }),
                    (s.zoom = H),
                    this._cameraForBounds(s, t, i, r, n, o))
                  : {
                      center: W,
                      zoom: H,
                      bearing: r,
                      pitch: n,
                    };
              }
              fitBounds(e1, t, i) {
                const r = this.cameraForBounds(e1, t);
                return this._fitInternal(r, t, i);
              }
              fitScreenCoordinates(e1, t, i, r, n) {
                const o = y.convert(e1),
                  s = y.convert(t),
                  a = new y(Math.min(o.x, s.x), Math.min(o.y, s.y)),
                  l = new y(Math.max(o.x, s.x), Math.max(o.y, s.y));
                if (
                  "mercator" === this.transform.projection.name &&
                  this.transform.anyCornerOffEdge(o, s)
                )
                  return this;
                const c = this.transform.pointLocation3D(a),
                  h = this.transform.pointLocation3D(l),
                  u = this.transform.pointLocation3D(new y(a.x, l.y)),
                  d = this.transform.pointLocation3D(new y(l.x, a.y)),
                  p = [
                    Math.min(c.lng, h.lng, u.lng, d.lng),
                    Math.min(c.lat, h.lat, u.lat, d.lat),
                  ],
                  f = [
                    Math.max(c.lng, h.lng, u.lng, d.lng),
                    Math.max(c.lat, h.lat, u.lat, d.lat),
                  ],
                  m = r && r.pitch ? r.pitch : this.getPitch(),
                  _ = this._cameraForBounds(this.transform, p, f, i, m, r);
                return this._fitInternal(_, r, n);
              }
              _fitInternal(e1, t, i) {
                return e1
                  ? (delete (t = k(e1, t)).padding,
                    t.linear ? this.easeTo(t, i) : this.flyTo(t, i))
                  : this;
              }
              jumpTo(e1, t) {
                this.stop();
                const i = e1.preloadOnly
                  ? this.transform.clone()
                  : this.transform;
                let r = !1,
                  n = !1,
                  o = !1;
                return (
                  "zoom" in e1 &&
                    i.zoom !== +e1.zoom &&
                    ((r = !0), (i.zoom = +e1.zoom)),
                  void 0 !== e1.center && (i.center = Nd.convert(e1.center)),
                  "bearing" in e1 &&
                    i.bearing !== +e1.bearing &&
                    ((n = !0), (i.bearing = +e1.bearing)),
                  "pitch" in e1 &&
                    i.pitch !== +e1.pitch &&
                    ((o = !0), (i.pitch = +e1.pitch)),
                  null == e1.padding ||
                    i.isPaddingEqual(e1.padding) ||
                    (i.padding = e1.padding),
                  e1.preloadOnly
                    ? (this._preloadTiles(i), this)
                    : (this.fire(new At("movestart", t)).fire(
                        new At("move", t),
                      ),
                      r &&
                        this.fire(new At("zoomstart", t))
                          .fire(new At("zoom", t))
                          .fire(new At("zoomend", t)),
                      n &&
                        this.fire(new At("rotatestart", t))
                          .fire(new At("rotate", t))
                          .fire(new At("rotateend", t)),
                      o &&
                        this.fire(new At("pitchstart", t))
                          .fire(new At("pitch", t))
                          .fire(new At("pitchend", t)),
                      this.fire(new At("moveend", t)))
                );
              }
              getFreeCameraOptions() {
                return (
                  this.transform.projection.supportsFreeCamera || W(qS),
                  this.transform.getFreeCameraOptions()
                );
              }
              setFreeCameraOptions(e1, t) {
                const i = this.transform;
                if (!i.projection.supportsFreeCamera) return W(qS), this;
                this.stop();
                const r = i.zoom,
                  n = i.pitch,
                  o = i.bearing;
                i.setFreeCameraOptions(e1);
                const s = r !== i.zoom,
                  a = n !== i.pitch,
                  l = o !== i.bearing;
                return (
                  this.fire(new At("movestart", t)).fire(new At("move", t)),
                  s &&
                    this.fire(new At("zoomstart", t))
                      .fire(new At("zoom", t))
                      .fire(new At("zoomend", t)),
                  l &&
                    this.fire(new At("rotatestart", t))
                      .fire(new At("rotate", t))
                      .fire(new At("rotateend", t)),
                  a &&
                    this.fire(new At("pitchstart", t))
                      .fire(new At("pitch", t))
                      .fire(new At("pitchend", t)),
                  this.fire(new At("moveend", t)),
                  this
                );
              }
              easeTo(e1, t) {
                this._stop(!1, e1.easeId),
                  (!1 ===
                    (e1 = k(
                      {
                        offset: [0, 0],
                        duration: 500,
                        easing: C,
                      },
                      e1,
                    )).animate ||
                    this._prefersReducedMotion(e1)) &&
                    (e1.duration = 0);
                const i = this.transform,
                  r = this.getZoom(),
                  n = this.getBearing(),
                  o = this.getPitch(),
                  s = this.getPadding(),
                  a = "zoom" in e1 ? +e1.zoom : r,
                  l =
                    "bearing" in e1 ? this._normalizeBearing(e1.bearing, n) : n,
                  c = "pitch" in e1 ? +e1.pitch : o,
                  h = "padding" in e1 ? e1.padding : i.padding,
                  u = y.convert(e1.offset);
                let d, p, f;
                if ("globe" === i.projection.name) {
                  const t = ep.fromLngLat(i.center),
                    r = u.rotate(-i.angle);
                  (t.x += r.x / i.worldSize), (t.y += r.y / i.worldSize);
                  const n = t.toLngLat(),
                    o = Nd.convert(e1.center || n);
                  this._normalizeCenter(o),
                    (d = i.centerPoint.add(r)),
                    (p = new y(t.x, t.y).mult(i.worldSize)),
                    (f = new y(Gd(o.lng), qd(o.lat)).mult(i.worldSize).sub(p));
                } else {
                  d = i.centerPoint.add(u);
                  const t = i.pointLocation(d),
                    r = Nd.convert(e1.center || t);
                  this._normalizeCenter(r),
                    (p = i.project(t)),
                    (f = i.project(r).sub(p));
                }
                const m = i.zoomScale(a - r);
                let _, g;
                e1.around &&
                  ((_ = Nd.convert(e1.around)), (g = i.locationPoint(_)));
                const x = this._zooming || a !== r,
                  v = this._rotating || n !== l,
                  b = this._pitching || c !== o,
                  w = !i.isPaddingEqual(h),
                  T = (i) => (y) => {
                    if (
                      (x && (i.zoom = Wr(r, a, y)),
                      v && (i.bearing = Wr(n, l, y)),
                      b && (i.pitch = Wr(o, c, y)),
                      w &&
                        (i.interpolatePadding(s, h, y),
                        (d = i.centerPoint.add(u))),
                      _)
                    )
                      i.setLocationAtPoint(_, g);
                    else {
                      const e1 = i.zoomScale(i.zoom - r),
                        t = a > r ? Math.min(2, m) : Math.max(0.5, m),
                        n = Math.pow(t, 1 - y),
                        o = i.unproject(p.add(f.mult(y * n)).mult(e1));
                      i.setLocationAtPoint(
                        i.renderWorldCopies ? o.wrap() : o,
                        d,
                      );
                    }
                    return e1.preloadOnly || this._fireMoveEvents(t), i;
                  };
                if (e1.preloadOnly) {
                  const t = this._emulate(T, e1.duration, i);
                  return this._preloadTiles(t), this;
                }
                const E = {
                  moving: this._moving,
                  zooming: this._zooming,
                  rotating: this._rotating,
                  pitching: this._pitching,
                };
                return (
                  (this._zooming = x),
                  (this._rotating = v),
                  (this._pitching = b),
                  (this._padding = w),
                  (this._easeId = e1.easeId),
                  this._prepareEase(t, e1.noMoveStart, E),
                  this._ease(
                    T(i),
                    (e1) => {
                      "sea" === i.cameraElevationReference &&
                        i.recenterOnTerrain(),
                        this._afterEase(t, e1);
                    },
                    e1,
                  ),
                  this
                );
              }
              _prepareEase(e1, t, i = {}) {
                (this._moving = !0),
                  (this.transform.cameraElevationReference = "sea"),
                  this.transform._orthographicProjectionAtLowPitch &&
                    0 === this.transform.pitch &&
                    "globe" !== this.transform.projection.name &&
                    (this.transform.cameraElevationReference = "ground"),
                  t || i.moving || this.fire(new At("movestart", e1)),
                  this._zooming &&
                    !i.zooming &&
                    this.fire(new At("zoomstart", e1)),
                  this._rotating &&
                    !i.rotating &&
                    this.fire(new At("rotatestart", e1)),
                  this._pitching &&
                    !i.pitching &&
                    this.fire(new At("pitchstart", e1));
              }
              _fireMoveEvents(e1) {
                this.fire(new At("move", e1)),
                  this._zooming && this.fire(new At("zoom", e1)),
                  this._rotating && this.fire(new At("rotate", e1)),
                  this._pitching && this.fire(new At("pitch", e1));
              }
              _afterEase(e1, t) {
                if (this._easeId && t && this._easeId === t) return;
                (this._easeId = void 0),
                  (this.transform.cameraElevationReference = "ground");
                const i = this._zooming,
                  r = this._rotating,
                  n = this._pitching;
                (this._moving = !1),
                  (this._zooming = !1),
                  (this._rotating = !1),
                  (this._pitching = !1),
                  (this._padding = !1),
                  i && this.fire(new At("zoomend", e1)),
                  r && this.fire(new At("rotateend", e1)),
                  n && this.fire(new At("pitchend", e1)),
                  this.fire(new At("moveend", e1));
              }
              flyTo(e1, t) {
                if (this._prefersReducedMotion(e1)) {
                  const i = O(e1, [
                    "center",
                    "zoom",
                    "bearing",
                    "pitch",
                    "around",
                  ]);
                  return this.jumpTo(i, t);
                }
                this.stop(),
                  (e1 = k(
                    {
                      offset: [0, 0],
                      speed: 1.2,
                      curve: 1.42,
                      easing: C,
                    },
                    e1,
                  ));
                const i = this.transform,
                  r = this.getZoom(),
                  n = this.getBearing(),
                  o = this.getPitch(),
                  s = this.getPadding(),
                  a = "zoom" in e1 ? z(+e1.zoom, i.minZoom, i.maxZoom) : r,
                  l =
                    "bearing" in e1 ? this._normalizeBearing(e1.bearing, n) : n,
                  c = "pitch" in e1 ? +e1.pitch : o,
                  h = "padding" in e1 ? e1.padding : i.padding,
                  u = i.zoomScale(a - r),
                  d = y.convert(e1.offset);
                let p = i.centerPoint.add(d);
                const f = i.pointLocation(p),
                  m = Nd.convert(e1.center || f);
                this._normalizeCenter(m);
                const _ = i.project(f),
                  g = i.project(m).sub(_);
                let x = e1.curve;
                const v = Math.max(i.width, i.height),
                  b = v / u,
                  w = g.mag();
                if ("minZoom" in e1) {
                  const t = z(Math.min(e1.minZoom, r, a), i.minZoom, i.maxZoom),
                    n = v / i.zoomScale(t - r);
                  x = Math.sqrt((n / w) * 2);
                }
                const T = x * x;
                function E(e1) {
                  const t =
                    (b * b - v * v + (e1 ? -1 : 1) * T * T * w * w) /
                    (2 * (e1 ? b : v) * T * w);
                  return Math.log(Math.sqrt(t * t + 1) - t);
                }
                function M(e1) {
                  return (Math.exp(e1) - Math.exp(-e1)) / 2;
                }
                function A(e1) {
                  return (Math.exp(e1) + Math.exp(-e1)) / 2;
                }
                const S = E(0);
                let I = function (e1) {
                    return A(S) / A(S + x * e1);
                  },
                  D = function (e1) {
                    var t;
                    return (
                      (v * ((A(S) * (M((t = S + x * e1)) / A(t)) - M(S)) / T)) /
                      w
                    );
                  },
                  P = (E(1) - S) / x;
                if (Math.abs(w) < 1e-6 || !isFinite(P)) {
                  if (Math.abs(v - b) < 1e-6) return this.easeTo(e1, t);
                  const i = b < v ? -1 : 1;
                  (P = Math.abs(Math.log(b / v)) / x),
                    (D = function () {
                      return 0;
                    }),
                    (I = function (e1) {
                      return Math.exp(i * x * e1);
                    });
                }
                (e1.duration =
                  "duration" in e1
                    ? +e1.duration
                    : (1e3 * P) /
                      ("screenSpeed" in e1 ? +e1.screenSpeed / x : +e1.speed)),
                  e1.maxDuration &&
                    e1.duration > e1.maxDuration &&
                    (e1.duration = 0);
                const R = n !== l,
                  L = c !== o,
                  B = !i.isPaddingEqual(h),
                  F = (i) => (u) => {
                    const f = u * P,
                      y = 1 / I(f);
                    (i.zoom = 1 === u ? a : r + i.scaleZoom(y)),
                      R && (i.bearing = Wr(n, l, u)),
                      L && (i.pitch = Wr(o, c, u)),
                      B &&
                        (i.interpolatePadding(s, h, u),
                        (p = i.centerPoint.add(d)));
                    const x =
                      1 === u ? m : i.unproject(_.add(g.mult(D(f))).mult(y));
                    return (
                      i.setLocationAtPoint(
                        i.renderWorldCopies ? x.wrap() : x,
                        p,
                      ),
                      i._updateCameraOnTerrain(),
                      e1.preloadOnly || this._fireMoveEvents(t),
                      i
                    );
                  };
                if (e1.preloadOnly) {
                  const t = this._emulate(F, e1.duration, i);
                  return this._preloadTiles(t), this;
                }
                return (
                  (this._zooming = !0),
                  (this._rotating = R),
                  (this._pitching = L),
                  (this._padding = B),
                  this._prepareEase(t, !1),
                  this._ease(F(i), () => this._afterEase(t), e1),
                  this
                );
              }
              isEasing() {
                return !!this._easeFrameId;
              }
              stop() {
                return this._stop();
              }
              _stop(e1, t) {
                if (
                  (this._easeFrameId &&
                    (this._cancelRenderFrame(this._easeFrameId),
                    (this._easeFrameId = void 0),
                    (this._onEaseFrame = void 0)),
                  this._onEaseEnd)
                ) {
                  const e1 = this._onEaseEnd;
                  (this._onEaseEnd = void 0), e1.call(this, t);
                }
                if (!e1) {
                  const e1 = this.handlers;
                  e1 && e1.stop(!1);
                }
                return this;
              }
              _ease(e1, t, i) {
                !1 === i.animate || 0 === i.duration
                  ? (e1(1), t())
                  : ((this._easeStart = ht.now()),
                    (this._easeOptions = i),
                    (this._onEaseFrame = e1),
                    (this._onEaseEnd = t),
                    (this._easeFrameId = this._requestRenderFrame(
                      this._renderFrameCallback,
                    )));
              }
              _renderFrameCallback() {
                const e1 = Math.min(
                    (ht.now() - this._easeStart) / this._easeOptions.duration,
                    1,
                  ),
                  t = this._onEaseFrame;
                t && t(this._easeOptions.easing(e1)),
                  e1 < 1
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback,
                      ))
                    : this.stop();
              }
              _normalizeBearing(e1, t) {
                e1 = P(e1, -180, 180);
                const i = Math.abs(e1 - t);
                return (
                  Math.abs(e1 - 360 - t) < i && (e1 -= 360),
                  Math.abs(e1 + 360 - t) < i && (e1 += 360),
                  e1
                );
              }
              _normalizeCenter(e1) {
                const t = this.transform;
                if (!t.renderWorldCopies || t.maxBounds) return;
                const i = e1.lng - t.center.lng;
                e1.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
              }
              _prefersReducedMotion(e1) {
                return (
                  this._respectPrefersReducedMotion &&
                  ht.prefersReducedMotion &&
                  !(e1 && e1.essential)
                );
              }
              _emulate(e1, t, i) {
                const r = Math.ceil((15 * t) / 1e3),
                  n = [],
                  o = e1(i.clone());
                for (let e1 = 0; e1 <= r; e1++) {
                  const t = o(e1 / r);
                  n.push(t.clone());
                }
                return n;
              }
            }
            class $S {
              constructor(e1 = {}) {
                (this.options = e1),
                  j(
                    [
                      "_toggleAttribution",
                      "_updateEditLink",
                      "_updateData",
                      "_updateCompact",
                    ],
                    this,
                  );
              }
              getDefaultPosition() {
                return "bottom-right";
              }
              onAdd(e1) {
                const t = this.options && this.options.compact;
                return (
                  (this._map = e1),
                  (this._container = ut(
                    "div",
                    "mapboxgl-ctrl mapboxgl-ctrl-attrib",
                  )),
                  (this._compactButton = ut(
                    "button",
                    "mapboxgl-ctrl-attrib-button",
                    this._container,
                  )),
                  ut(
                    "span",
                    "mapboxgl-ctrl-icon",
                    this._compactButton,
                  ).setAttribute("aria-hidden", "true"),
                  (this._compactButton.type = "button"),
                  this._compactButton.addEventListener(
                    "click",
                    this._toggleAttribution,
                  ),
                  this._setElementTitle(
                    this._compactButton,
                    "ToggleAttribution",
                  ),
                  (this._innerContainer = ut(
                    "div",
                    "mapboxgl-ctrl-attrib-inner",
                    this._container,
                  )),
                  t && this._container.classList.add("mapboxgl-compact"),
                  this._updateAttributions(),
                  this._updateEditLink(),
                  this._map.on("styledata", this._updateData),
                  this._map.on("sourcedata", this._updateData),
                  this._map.on("moveend", this._updateEditLink),
                  void 0 === t &&
                    (this._map.on("resize", this._updateCompact),
                    this._updateCompact()),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("styledata", this._updateData),
                  this._map.off("sourcedata", this._updateData),
                  this._map.off("moveend", this._updateEditLink),
                  this._map.off("resize", this._updateCompact),
                  (this._map = void 0),
                  (this._attribHTML = void 0);
              }
              _setElementTitle(e1, t) {
                const i = this._map._getUIString(`AttributionControl.${t}`);
                e1.setAttribute("aria-label", i),
                  e1.removeAttribute("title"),
                  e1.firstElementChild &&
                    e1.firstElementChild.setAttribute("title", i);
              }
              _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show")
                  ? (this._container.classList.remove("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "false"))
                  : (this._container.classList.add("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "true"));
              }
              _updateEditLink() {
                let e1 = this._editLink;
                e1 ||
                  (e1 = this._editLink =
                    this._container.querySelector(".mapbox-improve-map"));
                const t = [
                  {
                    key: "owner",
                    value: this.styleOwner,
                  },
                  {
                    key: "id",
                    value: this.styleId,
                  },
                  {
                    key: "access_token",
                    value:
                      this._map._requestManager._customAccessToken ||
                      n.ACCESS_TOKEN,
                  },
                ];
                if (e1) {
                  const i = t.reduce(
                    (e1, i, r) => (
                      i.value &&
                        (e1 += `${i.key}=${i.value}${
                          r < t.length - 1 ? "&" : ""
                        }`),
                      e1
                    ),
                    "?",
                  );
                  (e1.href = `${n.FEEDBACK_URL}/${i}#${XA(this._map, !0)}`),
                    (e1.rel = "noopener nofollow"),
                    this._setElementTitle(e1, "MapFeedback");
                }
              }
              _updateData(e1) {
                !e1 ||
                  ("metadata" !== e1.sourceDataType &&
                    "visibility" !== e1.sourceDataType &&
                    "style" !== e1.dataType) ||
                  (this._updateAttributions(), this._updateEditLink());
              }
              _updateAttributions() {
                if (!this._map.style) return;
                let e1 = [];
                if (this._map.style.stylesheet) {
                  const e1 = this._map.style.stylesheet;
                  (this.styleOwner = e1.owner), (this.styleId = e1.id);
                }
                const t = this._map.style._mergedSourceCaches;
                for (const i in t) {
                  const r = t[i];
                  if (r.used) {
                    const t = r.getSource();
                    t.attribution &&
                      e1.indexOf(t.attribution) < 0 &&
                      e1.push(t.attribution);
                  }
                }
                e1.sort((e1, t) => e1.length - t.length),
                  (e1 = e1.filter((t, i) => {
                    for (let r = i + 1; r < e1.length; r++)
                      if (e1[r].indexOf(t) >= 0) return !1;
                    return !0;
                  })),
                  this.options.customAttribution &&
                    (Array.isArray(this.options.customAttribution)
                      ? (e1 = [...this.options.customAttribution, ...e1])
                      : e1.unshift(this.options.customAttribution));
                const i = e1.join(" | ");
                i !== this._attribHTML &&
                  ((this._attribHTML = i),
                  e1.length
                    ? ((this._innerContainer.innerHTML = i),
                      this._container.classList.remove("mapboxgl-attrib-empty"))
                    : this._container.classList.add("mapboxgl-attrib-empty"),
                  (this._editLink = null));
              }
              _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640
                  ? this._container.classList.add("mapboxgl-compact")
                  : this._container.classList.remove(
                      "mapboxgl-compact",
                      "mapboxgl-compact-show",
                    );
              }
            }
            class HS {
              constructor() {
                j(["_updateLogo", "_updateCompact"], this);
              }
              onAdd(e1) {
                (this._map = e1),
                  (this._container = ut("div", "mapboxgl-ctrl"));
                const t = ut("a", "mapboxgl-ctrl-logo");
                return (
                  (t.target = "_blank"),
                  (t.rel = "noopener nofollow"),
                  (t.href = "https://www.mapbox.com/"),
                  t.setAttribute(
                    "aria-label",
                    this._map._getUIString("LogoControl.Title"),
                  ),
                  t.setAttribute("rel", "noopener nofollow"),
                  this._container.appendChild(t),
                  (this._container.style.display = "none"),
                  this._map.on("sourcedata", this._updateLogo),
                  this._updateLogo(),
                  this._map.on("resize", this._updateCompact),
                  this._updateCompact(),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("sourcedata", this._updateLogo),
                  this._map.off("resize", this._updateCompact);
              }
              getDefaultPosition() {
                return "bottom-left";
              }
              _updateLogo(e1) {
                (e1 && "metadata" !== e1.sourceDataType) ||
                  (this._container.style.display = this._logoRequired()
                    ? "block"
                    : "none");
              }
              _logoRequired() {
                if (!this._map.style) return !0;
                const e1 = this._map.style._sourceCaches;
                if (0 === Object.entries(e1).length) return !0;
                for (const t in e1) {
                  const i = e1[t].getSource();
                  if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo)
                    return !1;
                }
                return !0;
              }
              _updateCompact() {
                const e1 = this._container.children;
                if (e1.length) {
                  const t = e1[0];
                  this._map.getCanvasContainer().offsetWidth < 250
                    ? t.classList.add("mapboxgl-compact")
                    : t.classList.remove("mapboxgl-compact");
                }
              }
            }
            class WS {
              constructor() {
                (this._queue = []),
                  (this._id = 0),
                  (this._cleared = !1),
                  (this._currentlyRunning = !1);
              }
              add(e1) {
                const t = ++this._id;
                return (
                  this._queue.push({
                    callback: e1,
                    id: t,
                    cancelled: !1,
                  }),
                  t
                );
              }
              remove(e1) {
                const t = this._currentlyRunning,
                  i = t ? this._queue.concat(t) : this._queue;
                for (const t of i)
                  if (t.id === e1) return void (t.cancelled = !0);
              }
              run(e1 = 0) {
                const t = (this._currentlyRunning = this._queue);
                this._queue = [];
                for (const i of t)
                  if (!i.cancelled && (i.callback(e1), this._cleared)) break;
                (this._cleared = !1), (this._currentlyRunning = !1);
              }
              clear() {
                this._currentlyRunning && (this._cleared = !0),
                  (this._queue = []);
              }
            }
            function XS(e1, t, i) {
              if (((e1 = new Nd(e1.lng, e1.lat)), t)) {
                const r = new Nd(e1.lng - 360, e1.lat),
                  n = new Nd(e1.lng + 360, e1.lat),
                  o = 360 * Math.ceil(Math.abs(e1.lng - i.center.lng) / 360),
                  s = i.locationPoint(e1).distSqr(t),
                  a = t.x < 0 || t.y < 0 || t.x > i.width || t.y > i.height;
                i.locationPoint(r).distSqr(t) < s &&
                (a || Math.abs(r.lng - i.center.lng) < o)
                  ? (e1 = r)
                  : i.locationPoint(n).distSqr(t) < s &&
                    (a || Math.abs(n.lng - i.center.lng) < o) &&
                    (e1 = n);
              }
              for (; Math.abs(e1.lng - i.center.lng) > 180; ) {
                const t = i.locationPoint(e1);
                if (t.x >= 0 && t.y >= 0 && t.x <= i.width && t.y <= i.height)
                  break;
                e1.lng > i.center.lng ? (e1.lng -= 360) : (e1.lng += 360);
              }
              return e1;
            }
            const YS = {
              center: "translate(-50%,-50%)",
              top: "translate(-50%,0)",
              "top-left": "translate(0,0)",
              "top-right": "translate(-100%,0)",
              bottom: "translate(-50%,-100%)",
              "bottom-left": "translate(0,-100%)",
              "bottom-right": "translate(-100%,-100%)",
              left: "translate(0,-50%)",
              right: "translate(-100%,-50%)",
            };
            class KS extends It {
              constructor(e1, i) {
                if (
                  (super(),
                  (e1 instanceof t.HTMLElement || i) &&
                    (e1 = k(
                      {
                        element: e1,
                      },
                      i,
                    )),
                  j(
                    [
                      "_update",
                      "_onMove",
                      "_onUp",
                      "_addDragHandler",
                      "_onMapClick",
                      "_onKeyPress",
                      "_clearFadeTimer",
                    ],
                    this,
                  ),
                  (this._anchor = (e1 && e1.anchor) || "center"),
                  (this._color = (e1 && e1.color) || "#3FB1CE"),
                  (this._scale = (e1 && e1.scale) || 1),
                  (this._draggable = (e1 && e1.draggable) || !1),
                  (this._clickTolerance = (e1 && e1.clickTolerance) || 0),
                  (this._isDragging = !1),
                  (this._state = "inactive"),
                  (this._rotation = (e1 && e1.rotation) || 0),
                  (this._rotationAlignment =
                    (e1 && e1.rotationAlignment) || "auto"),
                  (this._pitchAlignment =
                    (e1 && e1.pitchAlignment && e1.pitchAlignment) || "auto"),
                  (this._updateMoving = () => this._update(!0)),
                  (this._occludedOpacity = (e1 && e1.occludedOpacity) || 0.2),
                  e1 && e1.element)
                )
                  (this._element = e1.element),
                    (this._offset = y.convert((e1 && e1.offset) || [0, 0]));
                else {
                  (this._defaultMarker = !0), (this._element = ut("div"));
                  const t = 41,
                    i = 27,
                    r = dt(
                      "svg",
                      {
                        display: "block",
                        height: t * this._scale + "px",
                        width: i * this._scale + "px",
                        viewBox: `0 0 ${i} ${t}`,
                      },
                      this._element,
                    ),
                    n = dt(
                      "radialGradient",
                      {
                        id: "shadowGradient",
                      },
                      dt("defs", {}, r),
                    );
                  dt(
                    "stop",
                    {
                      offset: "10%",
                      "stop-opacity": 0.4,
                    },
                    n,
                  ),
                    dt(
                      "stop",
                      {
                        offset: "100%",
                        "stop-opacity": 0.05,
                      },
                      n,
                    ),
                    dt(
                      "ellipse",
                      {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)",
                      },
                      r,
                    ),
                    dt(
                      "path",
                      {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z",
                      },
                      r,
                    ),
                    dt(
                      "path",
                      {
                        opacity: 0.25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z",
                      },
                      r,
                    ),
                    dt(
                      "circle",
                      {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5,
                      },
                      r,
                    ),
                    (this._offset = y.convert((e1 && e1.offset) || [0, -14]));
                }
                this._element.hasAttribute("aria-label") ||
                  this._element.setAttribute("aria-label", "Map marker"),
                  this._element.hasAttribute("role") ||
                    this._element.setAttribute("role", "img"),
                  this._element.classList.add("mapboxgl-marker"),
                  this._element.addEventListener("dragstart", (e1) => {
                    e1.preventDefault();
                  }),
                  this._element.addEventListener("mousedown", (e1) => {
                    e1.preventDefault();
                  });
                const r = this._element.classList;
                for (const e1 in YS) r.remove(`mapboxgl-marker-anchor-${e1}`);
                r.add(`mapboxgl-marker-anchor-${this._anchor}`);
                const n =
                  e1 && e1.className ? e1.className.trim().split(/\s+/) : [];
                r.add(...n), (this._popup = null);
              }
              addTo(e1) {
                return (
                  e1 === this._map ||
                    (this.remove(),
                    (this._map = e1),
                    e1.getCanvasContainer().appendChild(this._element),
                    e1.on("move", this._updateMoving),
                    e1.on("moveend", this._update),
                    e1.on("remove", this._clearFadeTimer),
                    e1._addMarker(this),
                    this.setDraggable(this._draggable),
                    this._update(),
                    e1.on("click", this._onMapClick)),
                  this
                );
              }
              remove() {
                const e1 = this._map;
                return (
                  e1 &&
                    (e1.off("click", this._onMapClick),
                    e1.off("move", this._updateMoving),
                    e1.off("moveend", this._update),
                    e1.off("mousedown", this._addDragHandler),
                    e1.off("touchstart", this._addDragHandler),
                    e1.off("mouseup", this._onUp),
                    e1.off("touchend", this._onUp),
                    e1.off("mousemove", this._onMove),
                    e1.off("touchmove", this._onMove),
                    e1.off("remove", this._clearFadeTimer),
                    e1._removeMarker(this),
                    (this._map = void 0)),
                  this._clearFadeTimer(),
                  this._element.remove(),
                  this._popup && this._popup.remove(),
                  this
                );
              }
              getLngLat() {
                return this._lngLat;
              }
              setLngLat(e1) {
                return (
                  (this._lngLat = Nd.convert(e1)),
                  (this._pos = null),
                  this._popup && this._popup.setLngLat(this._lngLat),
                  this._update(!0),
                  this
                );
              }
              getElement() {
                return this._element;
              }
              setPopup(e1) {
                if (
                  (this._popup &&
                    (this._popup.remove(),
                    (this._popup = null),
                    this._element.removeAttribute("role"),
                    this._element.removeEventListener(
                      "keypress",
                      this._onKeyPress,
                    ),
                    this._originalTabIndex ||
                      this._element.removeAttribute("tabindex")),
                  e1)
                ) {
                  if (!("offset" in e1.options)) {
                    const t = 38.1,
                      i = 13.5,
                      r = Math.sqrt(Math.pow(i, 2) / 2);
                    e1.options.offset = this._defaultMarker
                      ? {
                          top: [0, 0],
                          "top-left": [0, 0],
                          "top-right": [0, 0],
                          bottom: [0, -t],
                          "bottom-left": [r, -1 * (t - i + r)],
                          "bottom-right": [-r, -1 * (t - i + r)],
                          left: [i, -1 * (t - i)],
                          right: [-i, -1 * (t - i)],
                        }
                      : this._offset;
                  }
                  (this._popup = e1),
                    (e1._marker = this),
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    this._element.setAttribute("role", "button"),
                    (this._originalTabIndex =
                      this._element.getAttribute("tabindex")),
                    this._originalTabIndex ||
                      this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener(
                      "keypress",
                      this._onKeyPress,
                    ),
                    this._element.setAttribute("aria-expanded", "false");
                }
                return this;
              }
              _onKeyPress(e1) {
                const t = e1.code,
                  i = e1.charCode || e1.keyCode;
                ("Space" !== t && "Enter" !== t && 32 !== i && 13 !== i) ||
                  this.togglePopup();
              }
              _onMapClick(e1) {
                const t = e1.originalEvent.target,
                  i = this._element;
                this._popup && (t === i || i.contains(t)) && this.togglePopup();
              }
              getPopup() {
                return this._popup;
              }
              togglePopup() {
                const e1 = this._popup;
                return e1
                  ? (e1.isOpen()
                      ? (e1.remove(),
                        this._element.setAttribute("aria-expanded", "false"))
                      : this._map &&
                        (e1.addTo(this._map),
                        this._element.setAttribute("aria-expanded", "true")),
                    this)
                  : this;
              }
              _behindTerrain() {
                const e1 = this._map,
                  t = this._pos;
                if (!e1 || !t) return !1;
                const i = e1.unproject(t),
                  r = e1.getFreeCameraOptions();
                if (!r.position) return !1;
                const n = r.position.toLngLat();
                return n.distanceTo(i) < 0.9 * n.distanceTo(this._lngLat);
              }
              _evaluateOpacity() {
                const e1 = this._map;
                if (!e1) return;
                const t = this._pos;
                if (
                  !t ||
                  t.x < 0 ||
                  t.x > e1.transform.width ||
                  t.y < 0 ||
                  t.y > e1.transform.height
                )
                  return void this._clearFadeTimer();
                const i = e1.unproject(t);
                let r;
                e1._showingGlobe() && Dd(e1.transform, this._lngLat)
                  ? (r = 0)
                  : ((r = 1 - e1._queryFogOpacity(i)),
                    e1.transform._terrainEnabled() &&
                      e1.getTerrain() &&
                      this._behindTerrain() &&
                      (r *= this._occludedOpacity)),
                  (this._element.style.opacity = `${r}`),
                  (this._element.style.pointerEvents = r > 0 ? "auto" : "none"),
                  this._popup && this._popup._setOpacity(r),
                  (this._fadeTimer = null);
              }
              _clearFadeTimer() {
                this._fadeTimer &&
                  (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
              }
              _updateDOM() {
                const e1 = this._pos;
                if (!e1 || !this._map) return;
                const t = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${
                  e1.x
                }px,${e1.y}px)\n            ${
                  YS[this._anchor]
                }\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${
                  t.x
                }px,${t.y}px)\n        `;
              }
              _calculateXYTransform() {
                const e1 = this._pos,
                  t = this._map,
                  i = this.getPitchAlignment();
                if (!t || !e1 || "map" !== i) return "";
                if (!t._showingGlobe()) {
                  const e1 = t.getPitch();
                  return e1 ? `rotateX(${e1}deg)` : "";
                }
                const r = T(zd(t.transform, this._lngLat)),
                  n = e1.sub(Cd(t.transform)),
                  o = Math.abs(n.x) + Math.abs(n.y);
                if (0 === o) return "";
                const s = r / o;
                return `rotateX(${-n.y * s}deg) rotateY(${n.x * s}deg)`;
              }
              _calculateZTransform() {
                const e1 = this._pos,
                  t = this._map;
                if (!t || !e1) return "";
                let i = 0;
                const r = this.getRotationAlignment();
                if ("map" === r) {
                  if (t._showingGlobe()) {
                    const e1 = t.project(
                        new Nd(this._lngLat.lng, this._lngLat.lat + 0.001),
                      ),
                      r = t
                        .project(
                          new Nd(this._lngLat.lng, this._lngLat.lat - 0.001),
                        )
                        .sub(e1);
                    i = T(Math.atan2(r.y, r.x)) - 90;
                  } else i = -t.getBearing();
                } else if ("horizon" === r) {
                  const r = D(4, 6, t.getZoom()),
                    n = Cd(t.transform);
                  n.y += r * t.transform.height;
                  const o = e1.sub(n),
                    s = T(Math.atan2(o.y, o.x));
                  i = (s > 90 ? s - 270 : s + 90) * (1 - r);
                }
                return (i += this._rotation), i ? `rotateZ(${i}deg)` : "";
              }
              _update(e1) {
                t.cancelAnimationFrame(this._updateFrameId);
                const i = this._map;
                i &&
                  (i.transform.renderWorldCopies &&
                    (this._lngLat = XS(this._lngLat, this._pos, i.transform)),
                  (this._pos = i.project(this._lngLat)),
                  !0 === e1
                    ? (this._updateFrameId = t.requestAnimationFrame(() => {
                        this._element &&
                          this._pos &&
                          this._anchor &&
                          ((this._pos = this._pos.round()), this._updateDOM());
                      }))
                    : (this._pos = this._pos.round()),
                  i._requestDomTask(() => {
                    this._map &&
                      (this._element &&
                        this._pos &&
                        this._anchor &&
                        this._updateDOM(),
                      (i._showingGlobe() || i.getTerrain() || i.getFog()) &&
                        !this._fadeTimer &&
                        (this._fadeTimer = setTimeout(
                          this._evaluateOpacity.bind(this),
                          60,
                        )));
                  }));
              }
              getOffset() {
                return this._offset;
              }
              setOffset(e1) {
                return (this._offset = y.convert(e1)), this._update(), this;
              }
              addClassName(e1) {
                return this._element.classList.add(e1), this;
              }
              removeClassName(e1) {
                return this._element.classList.remove(e1), this;
              }
              toggleClassName(e1) {
                return this._element.classList.toggle(e1);
              }
              _onMove(e1) {
                const t = this._map;
                if (!t) return;
                const i = this._pointerdownPos,
                  r = this._positionDelta;
                if (i && r) {
                  if (!this._isDragging) {
                    const r = this._clickTolerance || t._clickTolerance;
                    if (e1.point.dist(i) < r) return;
                    this._isDragging = !0;
                  }
                  (this._pos = e1.point.sub(r)),
                    (this._lngLat = t.unproject(this._pos)),
                    this.setLngLat(this._lngLat),
                    (this._element.style.pointerEvents = "none"),
                    "pending" === this._state &&
                      ((this._state = "active"),
                      this.fire(new At("dragstart"))),
                    this.fire(new At("drag"));
                }
              }
              _onUp() {
                (this._element.style.pointerEvents = "auto"),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1);
                const e1 = this._map;
                e1 &&
                  (e1.off("mousemove", this._onMove),
                  e1.off("touchmove", this._onMove)),
                  "active" === this._state && this.fire(new At("dragend")),
                  (this._state = "inactive");
              }
              _addDragHandler(e1) {
                const t = this._map,
                  i = this._pos;
                t &&
                  i &&
                  this._element.contains(e1.originalEvent.target) &&
                  (e1.preventDefault(),
                  (this._positionDelta = e1.point.sub(i)),
                  (this._pointerdownPos = e1.point),
                  (this._state = "pending"),
                  t.on("mousemove", this._onMove),
                  t.on("touchmove", this._onMove),
                  t.once("mouseup", this._onUp),
                  t.once("touchend", this._onUp));
              }
              setDraggable(e1) {
                this._draggable = !!e1;
                const t = this._map;
                return (
                  t &&
                    (e1
                      ? (t.on("mousedown", this._addDragHandler),
                        t.on("touchstart", this._addDragHandler))
                      : (t.off("mousedown", this._addDragHandler),
                        t.off("touchstart", this._addDragHandler))),
                  this
                );
              }
              isDraggable() {
                return this._draggable;
              }
              setRotation(e1) {
                return (this._rotation = e1 || 0), this._update(), this;
              }
              getRotation() {
                return this._rotation;
              }
              setRotationAlignment(e1) {
                return (
                  (this._rotationAlignment = e1 || "auto"), this._update(), this
                );
              }
              getRotationAlignment() {
                return "auto" === this._rotationAlignment ||
                  ("horizon" === this._rotationAlignment &&
                    this._map &&
                    !this._map._showingGlobe())
                  ? "viewport"
                  : this._rotationAlignment;
              }
              setPitchAlignment(e1) {
                return (
                  (this._pitchAlignment = e1 || "auto"), this._update(), this
                );
              }
              getPitchAlignment() {
                return "auto" === this._pitchAlignment
                  ? this.getRotationAlignment()
                  : this._pitchAlignment;
              }
              setOccludedOpacity(e1) {
                return (
                  (this._occludedOpacity = e1 || 0.2), this._update(), this
                );
              }
              getOccludedOpacity() {
                return this._occludedOpacity;
              }
            }
            const JS = {
                closeButton: !0,
                closeOnClick: !0,
                focusAfterOpen: !0,
                className: "",
                maxWidth: "240px",
              },
              QS = [
                "a[href]",
                "[tabindex]:not([tabindex='-1'])",
                "[contenteditable]:not([contenteditable='false'])",
                "button:not([disabled])",
                "input:not([disabled])",
                "select:not([disabled])",
                "textarea:not([disabled])",
              ].join(", ");
            function eI(e1 = new y(0, 0), t = "bottom") {
              if ("number" == typeof e1) {
                const i = Math.round(Math.sqrt(0.5 * Math.pow(e1, 2)));
                switch (t) {
                  case "top":
                    return new y(0, e1);
                  case "top-left":
                    return new y(i, i);
                  case "top-right":
                    return new y(-i, i);
                  case "bottom":
                    return new y(0, -e1);
                  case "bottom-left":
                    return new y(i, -i);
                  case "bottom-right":
                    return new y(-i, -i);
                  case "left":
                    return new y(e1, 0);
                  case "right":
                    return new y(-e1, 0);
                }
                return new y(0, 0);
              }
              return e1 instanceof y || Array.isArray(e1)
                ? y.convert(e1)
                : y.convert(e1[t] || [0, 0]);
            }
            class tI {
              constructor(e1) {
                this.jumpTo(e1);
              }
              getValue(e1) {
                if (e1 <= this._startTime) return this._start;
                if (e1 >= this._endTime) return this._end;
                const t = M(
                  (e1 - this._startTime) / (this._endTime - this._startTime),
                );
                return this._start * (1 - t) + this._end * t;
              }
              isEasing(e1) {
                return e1 >= this._startTime && e1 <= this._endTime;
              }
              jumpTo(e1) {
                (this._startTime = -1 / 0),
                  (this._endTime = -1 / 0),
                  (this._start = e1),
                  (this._end = e1);
              }
              easeTo(e1, t, i) {
                (this._start = this.getValue(t)),
                  (this._end = e1),
                  (this._startTime = t),
                  (this._endTime = t + i);
              }
            }
            const iI = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable":
                  "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage":
                  "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage":
                  "Use \u2318 + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map",
              },
              rI = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                performanceMetricsCollection: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                antialias: !1,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                minTileCacheSize: null,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                respectPrefersReducedMotion: !0,
                crossSourceCollisions: !0,
                collectResourceTiming: !1,
                testMode: !1,
              },
              nI = {
                showCompass: !0,
                showZoom: !0,
                visualizePitch: !1,
              };
            class oI {
              constructor(e1, t, i = !1) {
                (this._clickTolerance = 10),
                  (this.element = t),
                  (this.mouseRotate = new gS({
                    clickTolerance: e1.dragRotate._mouseRotate._clickTolerance,
                  })),
                  (this.map = e1),
                  i &&
                    (this.mousePitch = new yS({
                      clickTolerance: e1.dragRotate._mousePitch._clickTolerance,
                    })),
                  j(
                    [
                      "mousedown",
                      "mousemove",
                      "mouseup",
                      "touchstart",
                      "touchmove",
                      "touchend",
                      "reset",
                    ],
                    this,
                  ),
                  t.addEventListener("mousedown", this.mousedown),
                  t.addEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  t.addEventListener("touchmove", this.touchmove),
                  t.addEventListener("touchend", this.touchend),
                  t.addEventListener("touchcancel", this.reset);
              }
              down(e1, t) {
                this.mouseRotate.mousedown(e1, t),
                  this.mousePitch && this.mousePitch.mousedown(e1, t),
                  _t();
              }
              move(e1, t) {
                const i = this.map,
                  r = this.mouseRotate.mousemoveWindow(e1, t),
                  n = r && r.bearingDelta;
                if ((n && i.setBearing(i.getBearing() + n), this.mousePitch)) {
                  const r = this.mousePitch.mousemoveWindow(e1, t),
                    n = r && r.pitchDelta;
                  n && i.setPitch(i.getPitch() + n);
                }
              }
              off() {
                const e1 = this.element;
                e1.removeEventListener("mousedown", this.mousedown),
                  e1.removeEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  e1.removeEventListener("touchmove", this.touchmove),
                  e1.removeEventListener("touchend", this.touchend),
                  e1.removeEventListener("touchcancel", this.reset),
                  this.offTemp();
              }
              offTemp() {
                gt(),
                  t.removeEventListener("mousemove", this.mousemove),
                  t.removeEventListener("mouseup", this.mouseup);
              }
              mousedown(e1) {
                this.down(
                  k({}, e1, {
                    ctrlKey: !0,
                    preventDefault: () => e1.preventDefault(),
                  }),
                  vt(this.element, e1),
                ),
                  t.addEventListener("mousemove", this.mousemove),
                  t.addEventListener("mouseup", this.mouseup);
              }
              mousemove(e1) {
                this.move(e1, vt(this.element, e1));
              }
              mouseup(e1) {
                this.mouseRotate.mouseupWindow(e1),
                  this.mousePitch && this.mousePitch.mouseupWindow(e1),
                  this.offTemp();
              }
              touchstart(e1) {
                1 !== e1.targetTouches.length
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      bt(this.element, e1.targetTouches)[0]),
                    this.down(
                      {
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => e1.preventDefault(),
                      },
                      this._startPos,
                    ));
              }
              touchmove(e1) {
                1 !== e1.targetTouches.length
                  ? this.reset()
                  : ((this._lastPos = bt(this.element, e1.targetTouches)[0]),
                    this.move(
                      {
                        preventDefault: () => e1.preventDefault(),
                      },
                      this._lastPos,
                    ));
              }
              touchend(e1) {
                0 === e1.targetTouches.length &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  this.reset();
              }
              reset() {
                this.mouseRotate.reset(),
                  this.mousePitch && this.mousePitch.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }
            }
            const sI = {
                positionOptions: {
                  enableHighAccuracy: !1,
                  maximumAge: 0,
                  timeout: 6e3,
                },
                fitBoundsOptions: {
                  maxZoom: 15,
                },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
                showUserHeading: !1,
              },
              aI = {
                maxWidth: 100,
                unit: "metric",
              },
              lI = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm",
              },
              cI = {
                version: i,
                supported: rt,
                setRTLTextPlugin: function (e1, t, i = !1) {
                  if ($s === js || $s === Gs || $s === qs)
                    throw new Error(
                      "setRTLTextPlugin cannot be called multiple times.",
                    );
                  (Hs = ht.resolveURL(e1)),
                    ($s = js),
                    (Zs = t),
                    Xs(),
                    i || Js();
                },
                getRTLTextPluginStatus: Ks,
                Map: class extends ZS {
                  constructor(e1) {
                    if (
                      (Qe.mark(Je.create),
                      null != (e1 = k({}, rI, e1)).minZoom &&
                        null != e1.maxZoom &&
                        e1.minZoom > e1.maxZoom)
                    )
                      throw new Error(
                        "maxZoom must be greater than or equal to minZoom",
                      );
                    if (
                      null != e1.minPitch &&
                      null != e1.maxPitch &&
                      e1.minPitch > e1.maxPitch
                    )
                      throw new Error(
                        "maxPitch must be greater than or equal to minPitch",
                      );
                    if (null != e1.minPitch && e1.minPitch < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0",
                      );
                    if (null != e1.maxPitch && e1.maxPitch > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85",
                      );
                    if (
                      (e1.antialias &&
                        (function (e1) {
                          const t = e1.navigator
                            ? e1.navigator.userAgent
                            : null;
                          return (
                            !!(function (e1) {
                              if (null == te) {
                                const t = e1.navigator
                                  ? e1.navigator.userAgent
                                  : null;
                                te =
                                  !!e1.safari ||
                                  !(
                                    !t ||
                                    !(
                                      /\b(iPad|iPhone|iPod)\b/.test(t) ||
                                      (t.match("Safari") && !t.match("Chrome"))
                                    )
                                  );
                              }
                              return te;
                            })(e1) &&
                            t &&
                            (t.match("Version/15.4") ||
                              t.match("Version/15.5") ||
                              t.match(
                                /CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/,
                              ))
                          );
                        })(t) &&
                        ((e1.antialias = !1),
                        W(
                          "Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609",
                        )),
                      super(
                        new mv(
                          e1.minZoom,
                          e1.maxZoom,
                          e1.minPitch,
                          e1.maxPitch,
                          e1.renderWorldCopies,
                        ),
                        e1,
                      ),
                      (this._interactive = e1.interactive),
                      (this._minTileCacheSize = e1.minTileCacheSize),
                      (this._maxTileCacheSize = e1.maxTileCacheSize),
                      (this._failIfMajorPerformanceCaveat =
                        e1.failIfMajorPerformanceCaveat),
                      (this._preserveDrawingBuffer = e1.preserveDrawingBuffer),
                      (this._antialias = e1.antialias),
                      (this._trackResize = e1.trackResize),
                      (this._bearingSnap = e1.bearingSnap),
                      (this._refreshExpiredTiles = e1.refreshExpiredTiles),
                      (this._fadeDuration = e1.fadeDuration),
                      (this._isInitialLoad = !0),
                      (this._crossSourceCollisions = e1.crossSourceCollisions),
                      (this._collectResourceTiming = e1.collectResourceTiming),
                      (this._language = this._parseLanguage(e1.language)),
                      (this._worldview = e1.worldview),
                      (this._renderTaskQueue = new WS()),
                      (this._domRenderTaskQueue = new WS()),
                      (this._controls = []),
                      (this._markers = []),
                      (this._popups = []),
                      (this._mapId = F()),
                      (this._locale = k({}, iI, e1.locale)),
                      (this._clickTolerance = e1.clickTolerance),
                      (this._cooperativeGestures = e1.cooperativeGestures),
                      (this._performanceMetricsCollection =
                        e1.performanceMetricsCollection),
                      (this._containerWidth = 0),
                      (this._containerHeight = 0),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      (this._averageElevationExaggeration = 0),
                      (this._averageElevation = new tI(0)),
                      (this._interactionRange = [1 / 0, -1 / 0]),
                      (this._visibilityHidden = 0),
                      (this._useExplicitProjection = !1),
                      (this._requestManager = new ze(
                        e1.transformRequest,
                        e1.accessToken,
                        e1.testMode,
                      )),
                      (this._silenceAuthErrors = !!e1.testMode),
                      "string" == typeof e1.container)
                    ) {
                      if (
                        ((this._container = t.document.getElementById(
                          e1.container,
                        )),
                        !this._container)
                      )
                        throw new Error(
                          `Container '${e1.container.toString()}' not found.`,
                        );
                    } else {
                      if (!(e1.container instanceof t.HTMLElement))
                        throw new Error(
                          "Invalid type: 'container' must be a String or HTMLElement.",
                        );
                      this._container = e1.container;
                    }
                    if (
                      (this._container.childNodes.length > 0 &&
                        W(
                          "The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.",
                        ),
                      e1.maxBounds && this.setMaxBounds(e1.maxBounds),
                      j(
                        [
                          "_onWindowOnline",
                          "_onWindowResize",
                          "_onVisibilityChange",
                          "_onMapScroll",
                          "_contextLost",
                          "_contextRestored",
                        ],
                        this,
                      ),
                      this._setupContainer(),
                      this._setupPainter(),
                      void 0 === this.painter)
                    )
                      throw new Error("Failed to initialize WebGL.");
                    if (
                      (this.on("move", () => this._update(!1)),
                      this.on("moveend", () => this._update(!1)),
                      this.on("zoom", () => this._update(!0)),
                      void 0 !== t &&
                        ((this._fullscreenchangeEvent =
                          "onfullscreenchange" in t.document
                            ? "fullscreenchange"
                            : "webkitfullscreenchange"),
                        t.addEventListener("online", this._onWindowOnline, !1),
                        t.addEventListener("resize", this._onWindowResize, !1),
                        t.addEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1,
                        ),
                        t.addEventListener(
                          this._fullscreenchangeEvent,
                          this._onWindowResize,
                          !1,
                        ),
                        t.addEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1,
                        )),
                      (this.handlers = new GS(this, e1)),
                      (this._localFontFamily = e1.localFontFamily),
                      (this._localIdeographFontFamily =
                        e1.localIdeographFontFamily),
                      (e1.style || !e1.testMode) &&
                        this.setStyle(e1.style || n.DEFAULT_STYLE, {
                          localFontFamily: this._localFontFamily,
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                        }),
                      e1.projection && this.setProjection(e1.projection),
                      e1.hash &&
                        (this._hash = new WA(
                          ("string" == typeof e1.hash && e1.hash) || void 0,
                        ).addTo(this)),
                      !this._hash || !this._hash._onHashChange())
                    ) {
                      this.jumpTo({
                        center: e1.center,
                        zoom: e1.zoom,
                        bearing: e1.bearing,
                        pitch: e1.pitch,
                      });
                      const t = e1.bounds;
                      t &&
                        (this.resize(),
                        this.fitBounds(
                          t,
                          k({}, e1.fitBoundsOptions, {
                            duration: 0,
                          }),
                        ));
                    }
                    this.resize(),
                      e1.attributionControl &&
                        this.addControl(
                          new $S({
                            customAttribution: e1.customAttribution,
                          }),
                        ),
                      (this._logoControl = new HS()),
                      this.addControl(this._logoControl, e1.logoPosition),
                      this.on("style.load", () => {
                        this.transform.unmodified &&
                          this.jumpTo(this.style.stylesheet);
                      }),
                      this.on("data", (e1) => {
                        this._update("style" === e1.dataType),
                          this.fire(new At(`${e1.dataType}data`, e1));
                      }),
                      this.on("dataloading", (e1) => {
                        this.fire(new At(`${e1.dataType}dataloading`, e1));
                      });
                  }
                  _getMapId() {
                    return this._mapId;
                  }
                  addControl(e1, t) {
                    if (
                      (void 0 === t &&
                        (t = e1.getDefaultPosition
                          ? e1.getDefaultPosition()
                          : "top-right"),
                      !e1 || !e1.onAdd)
                    )
                      return this.fire(
                        new St(
                          new Error(
                            "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.",
                          ),
                        ),
                      );
                    const i = e1.onAdd(this);
                    this._controls.push(e1);
                    const r = this._controlPositions[t];
                    return (
                      -1 !== t.indexOf("bottom")
                        ? r.insertBefore(i, r.firstChild)
                        : r.appendChild(i),
                      this
                    );
                  }
                  removeControl(e1) {
                    if (!e1 || !e1.onRemove)
                      return this.fire(
                        new St(
                          new Error(
                            "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.",
                          ),
                        ),
                      );
                    const t = this._controls.indexOf(e1);
                    return (
                      t > -1 && this._controls.splice(t, 1),
                      e1.onRemove(this),
                      this
                    );
                  }
                  hasControl(e1) {
                    return this._controls.indexOf(e1) > -1;
                  }
                  getContainer() {
                    return this._container;
                  }
                  getCanvasContainer() {
                    return this._canvasContainer;
                  }
                  getCanvas() {
                    return this._canvas;
                  }
                  resize(e1) {
                    if (
                      (this._updateContainerDimensions(),
                      this._containerWidth === this.transform.width &&
                        this._containerHeight === this.transform.height)
                    )
                      return this;
                    this._resizeCanvas(
                      this._containerWidth,
                      this._containerHeight,
                    ),
                      this.transform.resize(
                        this._containerWidth,
                        this._containerHeight,
                      ),
                      this.painter.resize(
                        Math.ceil(this._containerWidth),
                        Math.ceil(this._containerHeight),
                      );
                    const t = !this._moving;
                    return (
                      t &&
                        this.fire(new At("movestart", e1)).fire(
                          new At("move", e1),
                        ),
                      this.fire(new At("resize", e1)),
                      t && this.fire(new At("moveend", e1)),
                      this
                    );
                  }
                  getBounds() {
                    return this.transform.getBounds();
                  }
                  getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                  }
                  setMaxBounds(e1) {
                    return (
                      this.transform.setMaxBounds(Ql.convert(e1)),
                      this._update()
                    );
                  }
                  setMinZoom(e1) {
                    if (
                      (e1 = null == e1 ? -2 : e1) >= -2 &&
                      e1 <= this.transform.maxZoom
                    )
                      return (
                        (this.transform.minZoom = e1),
                        this._update(),
                        this.getZoom() < e1
                          ? this.setZoom(e1)
                          : this.fire(new At("zoomstart"))
                              .fire(new At("zoom"))
                              .fire(new At("zoomend")),
                        this
                      );
                    throw new Error(
                      "minZoom must be between -2 and the current maxZoom, inclusive",
                    );
                  }
                  getMinZoom() {
                    return this.transform.minZoom;
                  }
                  setMaxZoom(e1) {
                    if ((e1 = null == e1 ? 22 : e1) >= this.transform.minZoom)
                      return (
                        (this.transform.maxZoom = e1),
                        this._update(),
                        this.getZoom() > e1
                          ? this.setZoom(e1)
                          : this.fire(new At("zoomstart"))
                              .fire(new At("zoom"))
                              .fire(new At("zoomend")),
                        this
                      );
                    throw new Error(
                      "maxZoom must be greater than the current minZoom",
                    );
                  }
                  getMaxZoom() {
                    return this.transform.maxZoom;
                  }
                  setMinPitch(e1) {
                    if ((e1 = null == e1 ? 0 : e1) < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0",
                      );
                    if (e1 >= 0 && e1 <= this.transform.maxPitch)
                      return (
                        (this.transform.minPitch = e1),
                        this._update(),
                        this.getPitch() < e1
                          ? this.setPitch(e1)
                          : this.fire(new At("pitchstart"))
                              .fire(new At("pitch"))
                              .fire(new At("pitchend")),
                        this
                      );
                    throw new Error(
                      "minPitch must be between 0 and the current maxPitch, inclusive",
                    );
                  }
                  getMinPitch() {
                    return this.transform.minPitch;
                  }
                  setMaxPitch(e1) {
                    if ((e1 = null == e1 ? 85 : e1) > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85",
                      );
                    if (e1 >= this.transform.minPitch)
                      return (
                        (this.transform.maxPitch = e1),
                        this._update(),
                        this.getPitch() > e1
                          ? this.setPitch(e1)
                          : this.fire(new At("pitchstart"))
                              .fire(new At("pitch"))
                              .fire(new At("pitchend")),
                        this
                      );
                    throw new Error(
                      "maxPitch must be greater than or equal to minPitch",
                    );
                  }
                  getMaxPitch() {
                    return this.transform.maxPitch;
                  }
                  getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                  }
                  setRenderWorldCopies(e1) {
                    return (
                      (this.transform.renderWorldCopies = e1),
                      this.transform.renderWorldCopies ||
                        this._forceMarkerAndPopupUpdate(!0),
                      this._update()
                    );
                  }
                  getLanguage() {
                    return this._language;
                  }
                  _parseLanguage(e1) {
                    return "auto" === e1
                      ? t.navigator.language
                      : Array.isArray(e1)
                      ? 0 === e1.length
                        ? void 0
                        : e1.map((e1) =>
                            "auto" === e1 ? t.navigator.language : e1,
                          )
                      : e1;
                  }
                  setLanguage(e1) {
                    const t = this._parseLanguage(e1);
                    if (!this.style || t === this._language) return this;
                    (this._language = t), this.style.clearSources();
                    for (const e1 of this._controls)
                      e1._setLanguage && e1._setLanguage(this._language);
                    return this;
                  }
                  getWorldview() {
                    return this._worldview;
                  }
                  setWorldview(e1) {
                    return this.style && e1 !== this._worldview
                      ? ((this._worldview = e1),
                        this.style.clearSources(),
                        this)
                      : this;
                  }
                  getProjection() {
                    return this.transform.mercatorFromTransition
                      ? {
                          name: "globe",
                          center: [0, 0],
                        }
                      : this.transform.getProjection();
                  }
                  _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                  }
                  setProjection(e1) {
                    return (
                      this._lazyInitEmptyStyle(),
                      e1
                        ? "string" == typeof e1 &&
                          (e1 = {
                            name: e1,
                          })
                        : (e1 = null),
                      (this._useExplicitProjection = !!e1),
                      this._prioritizeAndUpdateProjection(
                        e1,
                        this.style.projection,
                      )
                    );
                  }
                  _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const e1 = this.transform,
                      t = e1.projection.name;
                    let i;
                    "globe" === t && e1.zoom >= Xu
                      ? (e1.setMercatorFromTransition(), (i = !0))
                      : "mercator" === t &&
                        e1.zoom < Xu &&
                        (e1.setProjection({
                          name: "globe",
                        }),
                        (i = !0)),
                      i &&
                        (this.style.applyProjectionUpdate(),
                        this.style._forceSymbolLayerUpdate());
                  }
                  _prioritizeAndUpdateProjection(e1, t) {
                    return this._updateProjection(
                      e1 ||
                        t || {
                          name: "mercator",
                        },
                    );
                  }
                  _updateProjection(e1) {
                    let t;
                    return (
                      (t =
                        "globe" === e1.name && this.transform.zoom >= Xu
                          ? this.transform.setMercatorFromTransition()
                          : this.transform.setProjection(e1)),
                      this.style.applyProjectionUpdate(),
                      t &&
                        (this.painter.clearBackgroundTiles(),
                        this.style.clearSources(),
                        this._update(!0),
                        this._forceMarkerAndPopupUpdate(!0)),
                      this
                    );
                  }
                  project(e1) {
                    return this.transform.locationPoint3D(Nd.convert(e1));
                  }
                  unproject(e1) {
                    return this.transform.pointLocation3D(y.convert(e1));
                  }
                  isMoving() {
                    return (
                      this._moving ||
                      (this.handlers && this.handlers.isMoving()) ||
                      !1
                    );
                  }
                  isZooming() {
                    return (
                      this._zooming ||
                      (this.handlers && this.handlers.isZooming()) ||
                      !1
                    );
                  }
                  isRotating() {
                    return (
                      this._rotating ||
                      (this.handlers && this.handlers.isRotating()) ||
                      !1
                    );
                  }
                  _isDragging() {
                    return (this.handlers && this.handlers._isDragging()) || !1;
                  }
                  _createDelegatedListener(e1, t, i) {
                    if ("mouseenter" === e1 || "mouseover" === e1) {
                      let r = !1;
                      const n = (n) => {
                          const o = t.filter((e1) => this.getLayer(e1)),
                            s = o.length
                              ? this.queryRenderedFeatures(n.point, {
                                  layers: o,
                                })
                              : [];
                          s.length
                            ? r ||
                              ((r = !0),
                              i.call(
                                this,
                                new nS(e1, this, n.originalEvent, {
                                  features: s,
                                }),
                              ))
                            : (r = !1);
                        },
                        o = () => {
                          r = !1;
                        };
                      return {
                        layers: new Set(t),
                        listener: i,
                        delegates: {
                          mousemove: n,
                          mouseout: o,
                        },
                      };
                    }
                    if ("mouseleave" === e1 || "mouseout" === e1) {
                      let r = !1;
                      const n = (n) => {
                          const o = t.filter((e1) => this.getLayer(e1));
                          (o.length
                            ? this.queryRenderedFeatures(n.point, {
                                layers: o,
                              })
                            : []
                          ).length
                            ? (r = !0)
                            : r &&
                              ((r = !1),
                              i.call(this, new nS(e1, this, n.originalEvent)));
                        },
                        o = (t) => {
                          r &&
                            ((r = !1),
                            i.call(this, new nS(e1, this, t.originalEvent)));
                        };
                      return {
                        layers: new Set(t),
                        listener: i,
                        delegates: {
                          mousemove: n,
                          mouseout: o,
                        },
                      };
                    }
                    {
                      const r = (e1) => {
                        const r = t.filter((e1) => this.getLayer(e1)),
                          n = r.length
                            ? this.queryRenderedFeatures(e1.point, {
                                layers: r,
                              })
                            : [];
                        n.length &&
                          ((e1.features = n),
                          i.call(this, e1),
                          delete e1.features);
                      };
                      return {
                        layers: new Set(t),
                        listener: i,
                        delegates: {
                          [e1]: r,
                        },
                      };
                    }
                  }
                  on(e1, t, i) {
                    if (void 0 === i) return super.on(e1, t);
                    if ((Array.isArray(t) || (t = [t]), t)) {
                      for (const e1 of t) if (!this._isValidId(e1)) return this;
                    }
                    const r = this._createDelegatedListener(e1, t, i);
                    (this._delegatedListeners = this._delegatedListeners || {}),
                      (this._delegatedListeners[e1] =
                        this._delegatedListeners[e1] || []),
                      this._delegatedListeners[e1].push(r);
                    for (const e1 in r.delegates) this.on(e1, r.delegates[e1]);
                    return this;
                  }
                  once(e1, t, i) {
                    if (void 0 === i) return super.once(e1, t);
                    if ((Array.isArray(t) || (t = [t]), t)) {
                      for (const e1 of t) if (!this._isValidId(e1)) return this;
                    }
                    const r = this._createDelegatedListener(e1, t, i);
                    for (const e1 in r.delegates)
                      this.once(e1, r.delegates[e1]);
                    return this;
                  }
                  off(e1, t, i) {
                    if (void 0 === i) return super.off(e1, t);
                    t = new Set(Array.isArray(t) ? t : [t]);
                    for (const e1 of t) if (!this._isValidId(e1)) return this;
                    const r = (e1, t) => {
                        if (e1.size !== t.size) return !1;
                        for (const i of e1) if (!t.has(i)) return !1;
                        return !0;
                      },
                      n = this._delegatedListeners
                        ? this._delegatedListeners[e1]
                        : void 0;
                    return (
                      n &&
                        ((e1) => {
                          for (let n = 0; n < e1.length; n++) {
                            const o = e1[n];
                            if (o.listener === i && r(o.layers, t)) {
                              for (const e1 in o.delegates)
                                this.off(e1, o.delegates[e1]);
                              return e1.splice(n, 1), this;
                            }
                          }
                        })(n),
                      this
                    );
                  }
                  queryRenderedFeatures(e1, t) {
                    if (!this.style) return [];
                    if (
                      (void 0 !== t ||
                        void 0 === e1 ||
                        e1 instanceof y ||
                        Array.isArray(e1) ||
                        ((t = e1), (e1 = void 0)),
                      (e1 = e1 || [
                        [0, 0],
                        [this.transform.width, this.transform.height],
                      ]),
                      (t = t || {}).layers && Array.isArray(t.layers))
                    ) {
                      for (const e1 of t.layers)
                        if (!this._isValidId(e1)) return [];
                    }
                    return this.style.queryRenderedFeatures(
                      e1,
                      t,
                      this.transform,
                    );
                  }
                  querySourceFeatures(e1, t) {
                    return this._isValidId(e1)
                      ? this.style.querySourceFeatures(e1, t)
                      : [];
                  }
                  isPointOnSurface(e1) {
                    const { name: t } = this.transform.projection;
                    return (
                      "globe" !== t &&
                        "mercator" !== t &&
                        W(
                          `${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`,
                        ),
                      this.transform.isPointOnSurface(y.convert(e1))
                    );
                  }
                  setStyle(e1, t) {
                    return !1 !==
                      (t = k(
                        {},
                        {
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                          localFontFamily: this._localFontFamily,
                        },
                        t,
                      )).diff &&
                      t.localIdeographFontFamily ===
                        this._localIdeographFontFamily &&
                      t.localFontFamily === this._localFontFamily &&
                      this.style &&
                      e1
                      ? (this._diffStyle(e1, t), this)
                      : ((this._localIdeographFontFamily =
                          t.localIdeographFontFamily),
                        (this._localFontFamily = t.localFontFamily),
                        this._updateStyle(e1, t));
                  }
                  _getUIString(e1) {
                    const t = this._locale[e1];
                    if (null == t) throw new Error(`Missing UI string '${e1}'`);
                    return t;
                  }
                  _updateStyle(e1, t) {
                    return (
                      this.style &&
                        (this.style.setEventedParent(null),
                        this.style._remove(),
                        (this.style = void 0)),
                      e1 &&
                        ((this.style = new $A(this, t || {})),
                        this.style.setEventedParent(this, {
                          style: this.style,
                        }),
                        "string" == typeof e1
                          ? this.style.loadURL(e1)
                          : this.style.loadJSON(e1)),
                      this._updateTerrain(),
                      this
                    );
                  }
                  _lazyInitEmptyStyle() {
                    this.style ||
                      ((this.style = new $A(this, {})),
                      this.style.setEventedParent(this, {
                        style: this.style,
                      }),
                      this.style.loadEmpty());
                  }
                  _diffStyle(e1, t) {
                    if ("string" == typeof e1) {
                      const i = this._requestManager.normalizeStyleURL(e1),
                        r = this._requestManager.transformRequest(i, ye.Style);
                      we(r, (e1, i) => {
                        e1
                          ? this.fire(new St(e1))
                          : i && this._updateDiff(i, t);
                      });
                    } else "object" == typeof e1 && this._updateDiff(e1, t);
                  }
                  _updateDiff(e1, t) {
                    try {
                      this.style.setState(e1) && this._update(!0);
                    } catch (i) {
                      W(
                        `Unable to perform style diff: ${
                          i.message || i.error || i
                        }.  Rebuilding the style from scratch.`,
                      ),
                        this._updateStyle(e1, t);
                    }
                  }
                  getStyle() {
                    if (this.style) return this.style.serialize();
                  }
                  isStyleLoaded() {
                    return this.style
                      ? this.style.loaded()
                      : (W("There is no style added to the map."), !1);
                  }
                  _isValidId(e1) {
                    return (
                      !(function (e1) {
                        return e1.indexOf("\x1f") >= 0;
                      })(e1) ||
                      (this.fire(
                        new St(
                          new Error(
                            `IDs can't contain special symbols: "${e1}".`,
                          ),
                        ),
                      ),
                      !1)
                    );
                  }
                  addSource(e1, t) {
                    return this._isValidId(e1)
                      ? (this._lazyInitEmptyStyle(),
                        this.style.addSource(e1, t),
                        this._update(!0))
                      : this;
                  }
                  isSourceLoaded(e1) {
                    return (
                      !!this._isValidId(e1) &&
                      !!this.style &&
                      this.style._isSourceCacheLoaded(e1)
                    );
                  }
                  areTilesLoaded() {
                    const e1 = this.style && this.style._sourceCaches;
                    for (const t in e1) {
                      const i = e1[t]._tiles;
                      for (const e1 in i) {
                        const t = i[e1];
                        if ("loaded" !== t.state && "errored" !== t.state)
                          return !1;
                      }
                    }
                    return !0;
                  }
                  addSourceType(e1, t, i) {
                    this._lazyInitEmptyStyle(),
                      this.style.addSourceType(e1, t, i);
                  }
                  removeSource(e1) {
                    return this._isValidId(e1)
                      ? (this.style.removeSource(e1),
                        this._updateTerrain(),
                        this._update(!0))
                      : this;
                  }
                  getSource(e1) {
                    return this._isValidId(e1)
                      ? this.style.getOwnSource(e1)
                      : null;
                  }
                  addImage(
                    e1,
                    i,
                    {
                      pixelRatio: r = 1,
                      sdf: n = !1,
                      stretchX: o,
                      stretchY: s,
                      content: a,
                    } = {},
                  ) {
                    if (
                      (this._lazyInitEmptyStyle(),
                      i instanceof t.HTMLImageElement ||
                        (t.ImageBitmap && i instanceof t.ImageBitmap))
                    ) {
                      const {
                        width: t,
                        height: l,
                        data: c,
                      } = ht.getImageData(i);
                      this.style.addImage(e1, {
                        data: new $p(
                          {
                            width: t,
                            height: l,
                          },
                          c,
                        ),
                        pixelRatio: r,
                        stretchX: o,
                        stretchY: s,
                        content: a,
                        sdf: n,
                        version: 0,
                      });
                    } else if (void 0 === i.width || void 0 === i.height)
                      this.fire(
                        new St(
                          new Error(
                            "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                          ),
                        ),
                      );
                    else {
                      const { width: t, height: l } = i,
                        c = i;
                      this.style.addImage(e1, {
                        data: new $p(
                          {
                            width: t,
                            height: l,
                          },
                          new Uint8Array(c.data),
                        ),
                        pixelRatio: r,
                        stretchX: o,
                        stretchY: s,
                        content: a,
                        sdf: n,
                        version: 0,
                        userImage: c,
                      }),
                        c.onAdd && c.onAdd(this, e1);
                    }
                  }
                  updateImage(e1, i) {
                    this._lazyInitEmptyStyle();
                    const r = this.style.getImage(e1);
                    if (!r)
                      return void this.fire(
                        new St(
                          new Error(
                            "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.",
                          ),
                        ),
                      );
                    const n =
                        i instanceof t.HTMLImageElement ||
                        (t.ImageBitmap && i instanceof t.ImageBitmap)
                          ? ht.getImageData(i)
                          : i,
                      { width: o, height: s } = n;
                    void 0 !== o && void 0 !== s
                      ? o === r.data.width && s === r.data.height
                        ? (r.data.replace(
                            n.data,
                            !(
                              i instanceof t.HTMLImageElement ||
                              (t.ImageBitmap && i instanceof t.ImageBitmap)
                            ),
                          ),
                          this.style.updateImage(e1, r))
                        : this.fire(
                            new St(
                              new Error(
                                `The width and height of the updated image (${o}, ${s})\n                must be that same as the previous version of the image\n                (${r.data.width}, ${r.data.height})`,
                              ),
                            ),
                          )
                      : this.fire(
                          new St(
                            new Error(
                              "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                            ),
                          ),
                        );
                  }
                  hasImage(e1) {
                    return e1
                      ? !!this.style && !!this.style.getImage(e1)
                      : (this.fire(
                          new St(new Error("Missing required image id")),
                        ),
                        !1);
                  }
                  removeImage(e1) {
                    this.style.removeImage(e1);
                  }
                  loadImage(e1, i) {
                    Ie(
                      this._requestManager.transformRequest(e1, ye.Image),
                      (e1, r) => {
                        i(
                          e1,
                          r instanceof t.HTMLImageElement
                            ? ht.getImageData(r)
                            : r,
                        );
                      },
                    );
                  }
                  listImages() {
                    return this.style.listImages();
                  }
                  addModel(e1, t) {
                    this._lazyInitEmptyStyle(), this.style.addModel(e1, t);
                  }
                  hasModel(e1) {
                    return e1
                      ? this.style.hasModel(e1)
                      : (this.fire(
                          new St(new Error("Missing required model id")),
                        ),
                        !1);
                  }
                  removeModel(e1) {
                    this.style.removeModel(e1);
                  }
                  listModels() {
                    return this.style.listModels();
                  }
                  addLayer(e1, t) {
                    return this._isValidId(e1.id)
                      ? (this._lazyInitEmptyStyle(),
                        this.style.addLayer(e1, t),
                        this._update(!0))
                      : this;
                  }
                  moveLayer(e1, t) {
                    return this._isValidId(e1)
                      ? (this.style.moveLayer(e1, t), this._update(!0))
                      : this;
                  }
                  removeLayer(e1) {
                    return this._isValidId(e1)
                      ? (this.style.removeLayer(e1), this._update(!0))
                      : this;
                  }
                  getLayer(e1) {
                    return this._isValidId(e1)
                      ? this.style.getOwnLayer(e1)
                      : null;
                  }
                  setLayerZoomRange(e1, t, i) {
                    return this._isValidId(e1)
                      ? (this.style.setLayerZoomRange(e1, t, i),
                        this._update(!0))
                      : this;
                  }
                  setFilter(e1, t, i = {}) {
                    return this._isValidId(e1)
                      ? (this.style.setFilter(e1, t, i), this._update(!0))
                      : this;
                  }
                  getFilter(e1) {
                    return this._isValidId(e1)
                      ? this.style.getFilter(e1)
                      : null;
                  }
                  setPaintProperty(e1, t, i, r = {}) {
                    return this._isValidId(e1)
                      ? (this.style.setPaintProperty(e1, t, i, r),
                        this._update(!0))
                      : this;
                  }
                  getPaintProperty(e1, t) {
                    return this._isValidId(e1)
                      ? this.style.getPaintProperty(e1, t)
                      : null;
                  }
                  setLayoutProperty(e1, t, i, r = {}) {
                    return this._isValidId(e1)
                      ? (this.style.setLayoutProperty(e1, t, i, r),
                        this._update(!0))
                      : this;
                  }
                  getLayoutProperty(e1, t) {
                    return this._isValidId(e1)
                      ? this.style.getLayoutProperty(e1, t)
                      : null;
                  }
                  setConfigProperty(e1, t, i) {
                    return (
                      this.style.setConfigProperty(e1, t, i), this._update(!0)
                    );
                  }
                  setLights(e1) {
                    if (
                      (this._lazyInitEmptyStyle(),
                      e1 && 1 === e1.length && "flat" === e1[0].type)
                    ) {
                      const t = e1[0];
                      t.properties
                        ? this.style.setFlatLight(t.properties, t.id, {})
                        : this.style.setFlatLight({}, "flat");
                    } else
                      this.style.setLights(e1),
                        this.painter.terrain &&
                          (this.painter.terrain.invalidateRenderCache = !0);
                    return this._update(!0);
                  }
                  getLights() {
                    const e1 = this.style.getLights() || [];
                    return (
                      0 === e1.length &&
                        e1.push({
                          id: this.style.light.id,
                          type: "flat",
                          properties: this.style.getFlatLight(),
                        }),
                      e1
                    );
                  }
                  setLight(e1, t = {}) {
                    return (
                      console.log(
                        "The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.",
                      ),
                      this.setLights([
                        {
                          id: "flat",
                          type: "flat",
                          properties: e1,
                        },
                      ])
                    );
                  }
                  getLight() {
                    return (
                      console.log(
                        "The `map.getLight` function is deprecated, prefer using `map.getLights` instead.",
                      ),
                      this.style.getFlatLight()
                    );
                  }
                  setTerrain(e1) {
                    return (
                      this._lazyInitEmptyStyle(),
                      !e1 && this.transform.projection.requiresDraping
                        ? this.style.setTerrainForDraping()
                        : this.style.setTerrain(e1),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      this._update(!0)
                    );
                  }
                  getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                  }
                  setFog(e1) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setFog(e1),
                      this._update(!0)
                    );
                  }
                  getFog() {
                    return this.style ? this.style.getFog() : null;
                  }
                  setCamera(e1) {
                    return (
                      this.style.setCamera(e1), this._triggerCameraUpdate(e1)
                    );
                  }
                  _triggerCameraUpdate(e1) {
                    return this._update(
                      this.transform.setOrthographicProjectionAtLowPitch(
                        "orthographic" === e1["camera-projection"],
                      ),
                    );
                  }
                  getCamera() {
                    return this.style.camera;
                  }
                  _queryFogOpacity(e1) {
                    return this.style && this.style.fog
                      ? this.style.fog.getOpacityAtLatLng(
                          Nd.convert(e1),
                          this.transform,
                        )
                      : 0;
                  }
                  setFeatureState(e1, t) {
                    return this._isValidId(e1.source)
                      ? (this.style.setFeatureState(e1, t), this._update())
                      : this;
                  }
                  removeFeatureState(e1, t) {
                    return this._isValidId(e1.source)
                      ? (this.style.removeFeatureState(e1, t), this._update())
                      : this;
                  }
                  getFeatureState(e1) {
                    return this._isValidId(e1.source)
                      ? this.style.getFeatureState(e1)
                      : null;
                  }
                  _updateContainerDimensions() {
                    if (!this._container) return;
                    const e1 =
                        this._container.getBoundingClientRect().width || 400,
                      i = this._container.getBoundingClientRect().height || 300;
                    let r,
                      n,
                      o,
                      s = this._container;
                    for (; s && (!n || !o); ) {
                      const e1 = t.getComputedStyle(s).transform;
                      e1 &&
                        "none" !== e1 &&
                        ((r = e1.match(/matrix.*\((.+)\)/)[1].split(", ")),
                        r[0] && "0" !== r[0] && "1" !== r[0] && (n = r[0]),
                        r[3] && "0" !== r[3] && "1" !== r[3] && (o = r[3])),
                        (s = s.parentElement);
                    }
                    (this._containerWidth = n ? Math.abs(e1 / n) : e1),
                      (this._containerHeight = o ? Math.abs(i / o) : i);
                  }
                  _detectMissingCSS() {
                    "rgb(250, 128, 114)" !==
                      t
                        .getComputedStyle(this._missingCSSCanary)
                        .getPropertyValue("background-color") &&
                      W(
                        "This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.",
                      );
                  }
                  _setupContainer() {
                    const e1 = this._container;
                    e1.classList.add("mapboxgl-map"),
                      ((this._missingCSSCanary = ut(
                        "div",
                        "mapboxgl-canary",
                        e1,
                      )).style.visibility = "hidden"),
                      this._detectMissingCSS();
                    const t = (this._canvasContainer = ut(
                      "div",
                      "mapboxgl-canvas-container",
                      e1,
                    ));
                    (this._canvas = ut("canvas", "mapboxgl-canvas", t)),
                      this._interactive &&
                        (t.classList.add("mapboxgl-interactive"),
                        this._canvas.setAttribute("tabindex", "0")),
                      this._canvas.addEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1,
                      ),
                      this._canvas.addEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1,
                      ),
                      this._canvas.setAttribute(
                        "aria-label",
                        this._getUIString("Map.Title"),
                      ),
                      this._canvas.setAttribute("role", "region"),
                      this._updateContainerDimensions(),
                      this._resizeCanvas(
                        this._containerWidth,
                        this._containerHeight,
                      );
                    const i = (this._controlContainer = ut(
                        "div",
                        "mapboxgl-control-container",
                        e1,
                      )),
                      r = (this._controlPositions = {});
                    [
                      "top-left",
                      "top-right",
                      "bottom-left",
                      "bottom-right",
                    ].forEach((e1) => {
                      r[e1] = ut("div", `mapboxgl-ctrl-${e1}`, i);
                    }),
                      this._container.addEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1,
                      );
                  }
                  _resizeCanvas(e1, t) {
                    const i = ht.devicePixelRatio || 1;
                    (this._canvas.width = i * Math.ceil(e1)),
                      (this._canvas.height = i * Math.ceil(t)),
                      (this._canvas.style.width = `${e1}px`),
                      (this._canvas.style.height = `${t}px`);
                  }
                  _addMarker(e1) {
                    this._markers.push(e1);
                  }
                  _removeMarker(e1) {
                    const t = this._markers.indexOf(e1);
                    -1 !== t && this._markers.splice(t, 1);
                  }
                  _addPopup(e1) {
                    this._popups.push(e1);
                  }
                  _removePopup(e1) {
                    const t = this._popups.indexOf(e1);
                    -1 !== t && this._popups.splice(t, 1);
                  }
                  _setupPainter() {
                    const e1 = k({}, rt.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat:
                          this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1,
                      }),
                      t = this._canvas.getContext("webgl2", e1);
                    t
                      ? (Ke(t, !0),
                        (this.painter = new zA(t, this.transform)),
                        this.on("data", (e1) => {
                          "source" === e1.dataType &&
                            this.painter.setTileLoadedFlag(!0);
                        }),
                        o.testSupport(t))
                      : this.fire(
                          new St(new Error("Failed to initialize WebGL")),
                        );
                  }
                  _contextLost(e1) {
                    e1.preventDefault(),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this.fire(
                        new At("webglcontextlost", {
                          originalEvent: e1,
                        }),
                      );
                  }
                  _contextRestored(e1) {
                    this._setupPainter(),
                      this.resize(),
                      this._update(),
                      this.fire(
                        new At("webglcontextrestored", {
                          originalEvent: e1,
                        }),
                      );
                  }
                  _onMapScroll(e1) {
                    if (e1.target === this._container)
                      return (
                        (this._container.scrollTop = 0),
                        (this._container.scrollLeft = 0),
                        !1
                      );
                  }
                  loaded() {
                    return (
                      !this._styleDirty &&
                      !this._sourcesDirty &&
                      !!this.style &&
                      this.style.loaded()
                    );
                  }
                  _update(e1) {
                    return this.style
                      ? ((this._styleDirty = this._styleDirty || e1),
                        (this._sourcesDirty = !0),
                        this.triggerRepaint(),
                        this)
                      : this;
                  }
                  _requestRenderFrame(e1) {
                    return this._update(), this._renderTaskQueue.add(e1);
                  }
                  _cancelRenderFrame(e1) {
                    this._renderTaskQueue.remove(e1);
                  }
                  _requestDomTask(e1) {
                    !this.loaded() || (this.loaded() && !this.isMoving())
                      ? e1()
                      : this._domRenderTaskQueue.add(e1);
                  }
                  _render(e1) {
                    let i;
                    this.fire(new At("renderstart"));
                    const r = this.painter.context.extTimerQuery,
                      n = ht.now(),
                      o = this.painter.context.gl;
                    if (
                      (this.listens("gpu-timing-frame") &&
                        ((i = o.createQuery()),
                        o.beginQuery(r.TIME_ELAPSED_EXT, i)),
                      this.painter.context.setDirty(),
                      this.painter.setBaseState(),
                      (this.isMoving() ||
                        this.isRotating() ||
                        this.isZooming()) &&
                        ((this._interactionRange[0] = Math.min(
                          this._interactionRange[0],
                          t.performance.now(),
                        )),
                        (this._interactionRange[1] = Math.max(
                          this._interactionRange[1],
                          t.performance.now(),
                        ))),
                      this._renderTaskQueue.run(e1),
                      this._domRenderTaskQueue.run(e1),
                      this._removed)
                    )
                      return;
                    this._updateProjectionTransition();
                    const s = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                      this._styleDirty = !1;
                      const e1 = this.transform.zoom,
                        t = this.transform.pitch,
                        i = ht.now(),
                        r = new ea(e1, {
                          now: i,
                          fadeDuration: s,
                          pitch: t,
                          transition: this.style.transition,
                        });
                      this.style.update(r);
                    }
                    this.style &&
                      this.style.hasFogTransition() &&
                      ((this.style._markersNeedUpdate = !0),
                      (this._sourcesDirty = !0));
                    let a = !1;
                    if (
                      (this.style && this._sourcesDirty
                        ? ((this._sourcesDirty = !1),
                          this.painter._updateFog(this.style),
                          this._updateTerrain(),
                          (a = this._updateAverageElevation(n)),
                          this.style.updateSources(this.transform),
                          this._forceMarkerAndPopupUpdate())
                        : (a = this._updateAverageElevation(n)),
                      (this._placementDirty =
                        this.style &&
                        this.style._updatePlacement(
                          this.painter.transform,
                          this.showCollisionBoxes,
                          s,
                          this._crossSourceCollisions,
                        )),
                      this.style &&
                        this.painter.render(this.style, {
                          showTileBoundaries: this.showTileBoundaries,
                          wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe,
                          },
                          showOverdrawInspector: this._showOverdrawInspector,
                          showQueryGeometry: !!this._showQueryGeometry,
                          showTileAABBs: this.showTileAABBs,
                          rotating: this.isRotating(),
                          zooming: this.isZooming(),
                          moving: this.isMoving(),
                          fadeDuration: s,
                          isInitialLoad: this._isInitialLoad,
                          showPadding: this.showPadding,
                          gpuTiming: !!this.listens("gpu-timing-layer"),
                          gpuTimingDeferredRender: !!this.listens(
                            "gpu-timing-deferred-render",
                          ),
                          speedIndexTiming: this.speedIndexTiming,
                        }),
                      this.fire(new At("render")),
                      this.loaded() &&
                        !this._loaded &&
                        ((this._loaded = !0), this.fire(new At("load"))),
                      this.style &&
                        this.style.hasTransitions() &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this._placementDirty &&
                        this.style._releaseSymbolFadeTiles(),
                      i)
                    ) {
                      const e1 = ht.now() - n;
                      o.endQuery(r.TIME_ELAPSED_EXT),
                        setTimeout(() => {
                          const r =
                            o.getQueryParameter(i, o.QUERY_RESULT) / 1e6;
                          o.deleteQuery(i),
                            this.fire(
                              new At("gpu-timing-frame", {
                                cpuTime: e1,
                                gpuTime: r,
                              }),
                            ),
                            t.performance.mark("frame-gpu", {
                              startTime: n,
                              detail: {
                                gpuTime: r,
                              },
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                      const e1 = this.painter.collectGpuTimers();
                      setTimeout(() => {
                        const t = this.painter.queryGpuTimers(e1);
                        this.fire(
                          new At("gpu-timing-layer", {
                            layerTimes: t,
                          }),
                        );
                      }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                      const e1 = this.painter.collectDeferredRenderGpuQueries();
                      setTimeout(() => {
                        const t = this.painter.queryGpuTimeDeferredRender(e1);
                        this.fire(
                          new At("gpu-timing-deferred-render", {
                            gpuTime: t,
                          }),
                        );
                      }, 50);
                    }
                    const l =
                      this._sourcesDirty ||
                      this._styleDirty ||
                      this._placementDirty ||
                      a;
                    if (l || this._repaint) this.triggerRepaint();
                    else {
                      const e1 = !this.isMoving() && this.loaded();
                      if ((e1 && (a = this._updateAverageElevation(n, !0)), a))
                        this.triggerRepaint();
                      else if (
                        (this._triggerFrame(!1),
                        e1 &&
                          (this.fire(new At("idle")),
                          (this._isInitialLoad = !1),
                          this.speedIndexTiming))
                      ) {
                        const e1 = this._calculateSpeedIndex();
                        this.fire(
                          new At("speedindexcompleted", {
                            speedIndex: e1,
                          }),
                        ),
                          (this.speedIndexTiming = !1);
                      }
                    }
                    !this._loaded ||
                      this._fullyLoaded ||
                      l ||
                      ((this._fullyLoaded = !0),
                      Qe.mark(Je.fullLoad),
                      this._performanceMetricsCollection &&
                        He(this._requestManager._customAccessToken, {
                          width: this.painter.width,
                          height: this.painter.height,
                          interactionRange: this._interactionRange,
                          visibilityHidden: this._visibilityHidden,
                          terrainEnabled: !!this.painter.style.getTerrain(),
                          fogEnabled: !!this.painter.style.getFog(),
                          projection: this.getProjection().name,
                          zoom: this.transform.zoom,
                          renderer: this.painter.context.renderer,
                          vendor: this.painter.context.vendor,
                        }),
                      this._authenticate());
                  }
                  _forceMarkerAndPopupUpdate(e1) {
                    for (const t of this._markers)
                      e1 &&
                        !this.getRenderWorldCopies() &&
                        (t._lngLat = t._lngLat.wrap()),
                        t._update();
                    for (const t of this._popups)
                      !e1 ||
                        this.getRenderWorldCopies() ||
                        t._trackPointer ||
                        (t._lngLat = t._lngLat.wrap()),
                        t._update();
                  }
                  _updateAverageElevation(e1, t = !1) {
                    const i = (e1) => (
                      (this.transform.averageElevation = e1),
                      this._update(!1),
                      !0
                    );
                    if (!this.painter.averageElevationNeedsEasing())
                      return 0 !== this.transform.averageElevation && i(0);
                    const r =
                      this.transform.elevation &&
                      this.transform.elevation.exaggeration() !==
                        this._averageElevationExaggeration;
                    if (
                      r ||
                      ((t || e1 - this._averageElevationLastSampledAt > 500) &&
                        !this._averageElevation.isEasing(e1))
                    ) {
                      const t = this.transform.averageElevation;
                      let n = this.transform.sampleAverageElevation();
                      this.transform.elevation &&
                        (this._averageElevationExaggeration =
                          this.transform.elevation.exaggeration()),
                        isNaN(n)
                          ? (n = 0)
                          : (this._averageElevationLastSampledAt = e1);
                      const o = Math.abs(t - n);
                      if (o > 1) {
                        if (this._isInitialLoad || r)
                          return this._averageElevation.jumpTo(n), i(n);
                        this._averageElevation.easeTo(n, e1, 300);
                      } else if (o > 1e-4)
                        return this._averageElevation.jumpTo(n), i(n);
                    }
                    return (
                      !!this._averageElevation.isEasing(e1) &&
                      i(this._averageElevation.getValue(e1))
                    );
                  }
                  _authenticate() {
                    Xe(
                      this._getMapId(),
                      this._requestManager._skuToken,
                      this._requestManager._customAccessToken,
                      (e1) => {
                        if (e1 && (e1.message === Ce || 401 === e1.status)) {
                          const e1 = this.painter.context.gl;
                          Ke(e1, !1),
                            this._logoControl instanceof HS &&
                              this._logoControl._updateLogo(),
                            e1 &&
                              e1.clear(
                                e1.DEPTH_BUFFER_BIT |
                                  e1.COLOR_BUFFER_BIT |
                                  e1.STENCIL_BUFFER_BIT,
                              ),
                            this._silenceAuthErrors ||
                              this.fire(
                                new St(
                                  new Error(
                                    "A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/",
                                  ),
                                ),
                              );
                        }
                      },
                    ),
                      Ze(
                        this._getMapId(),
                        this._requestManager._skuToken,
                        this._requestManager._customAccessToken,
                        () => {},
                      );
                  }
                  _updateTerrain() {
                    const e1 = this._isDragging();
                    this.painter.updateTerrain(this.style, e1);
                  }
                  _calculateSpeedIndex() {
                    const e1 = this.painter.canvasCopy(),
                      t = this.painter.getCanvasCopiesAndTimestamps();
                    t.timeStamps.push(performance.now());
                    const i = this.painter.context.gl,
                      r = i.createFramebuffer();
                    function n(e1) {
                      i.framebufferTexture2D(
                        i.FRAMEBUFFER,
                        i.COLOR_ATTACHMENT0,
                        i.TEXTURE_2D,
                        e1,
                        0,
                      );
                      const t = new Uint8Array(
                        i.drawingBufferWidth * i.drawingBufferHeight * 4,
                      );
                      return (
                        i.readPixels(
                          0,
                          0,
                          i.drawingBufferWidth,
                          i.drawingBufferHeight,
                          i.RGBA,
                          i.UNSIGNED_BYTE,
                          t,
                        ),
                        t
                      );
                    }
                    return (
                      i.bindFramebuffer(i.FRAMEBUFFER, r),
                      this._canvasPixelComparison(
                        n(e1),
                        t.canvasCopies.map(n),
                        t.timeStamps,
                      )
                    );
                  }
                  _canvasPixelComparison(e1, t, i) {
                    let r = i[1] - i[0];
                    const n = e1.length / 4;
                    for (let o = 0; o < t.length; o++) {
                      const s = t[o];
                      let a = 0;
                      for (let t = 0; t < s.length; t += 4)
                        s[t] === e1[t] &&
                          s[t + 1] === e1[t + 1] &&
                          s[t + 2] === e1[t + 2] &&
                          s[t + 3] === e1[t + 3] &&
                          (a += 1);
                      r += (i[o + 2] - i[o + 1]) * (1 - a / n);
                    }
                    return r;
                  }
                  remove() {
                    this._hash && this._hash.remove();
                    for (const e1 of this._controls) e1.onRemove(this);
                    (this._controls = []),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this._renderTaskQueue.clear(),
                      this._domRenderTaskQueue.clear(),
                      this.style && this.style.destroy(),
                      this.painter.destroy(),
                      this.handlers && this.handlers.destroy(),
                      (this.handlers = void 0),
                      this.setStyle(null),
                      void 0 !== t &&
                        (t.removeEventListener(
                          "resize",
                          this._onWindowResize,
                          !1,
                        ),
                        t.removeEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1,
                        ),
                        t.removeEventListener(
                          this._fullscreenchangeEvent,
                          this._onWindowResize,
                          !1,
                        ),
                        t.removeEventListener(
                          "online",
                          this._onWindowOnline,
                          !1,
                        ),
                        t.removeEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1,
                        ));
                    const e1 =
                      this.painter.context.gl.getExtension(
                        "WEBGL_lose_context",
                      );
                    e1 && e1.loseContext(),
                      this._canvas.removeEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1,
                      ),
                      this._canvas.removeEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1,
                      ),
                      this._canvasContainer.remove(),
                      this._controlContainer.remove(),
                      this._missingCSSCanary.remove(),
                      (this._canvas = void 0),
                      (this._canvasContainer = void 0),
                      (this._controlContainer = void 0),
                      (this._missingCSSCanary = void 0),
                      this._container.classList.remove("mapboxgl-map"),
                      this._container.removeEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1,
                      ),
                      Ye.delete(this.painter.context.gl),
                      (this._removed = !0),
                      this.fire(new At("remove"));
                  }
                  triggerRepaint() {
                    this._triggerFrame(!0);
                  }
                  _triggerFrame(e1) {
                    (this._renderNextFrame = this._renderNextFrame || e1),
                      this.style &&
                        !this._frame &&
                        (this._frame = ht.frame((e1) => {
                          const t = !!this._renderNextFrame;
                          (this._frame = null),
                            (this._renderNextFrame = null),
                            t && this._render(e1);
                        }));
                  }
                  _preloadTiles(e1) {
                    return (
                      R(
                        this.style
                          ? Object.values(this.style._sourceCaches)
                          : [],
                        (t, i) => t._preloadTiles(e1, i),
                        () => {
                          this.triggerRepaint();
                        },
                      ),
                      this
                    );
                  }
                  _onWindowOnline() {
                    this._update();
                  }
                  _onWindowResize(e1) {
                    this._trackResize &&
                      this.resize({
                        originalEvent: e1,
                      })._update();
                  }
                  _onVisibilityChange() {
                    "hidden" === t.document.visibilityState &&
                      this._visibilityHidden++;
                  }
                  get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                  }
                  set showTileBoundaries(e1) {
                    this._showTileBoundaries !== e1 &&
                      ((this._showTileBoundaries = e1), this._update());
                  }
                  get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                  }
                  set showTerrainWireframe(e1) {
                    this._showTerrainWireframe !== e1 &&
                      ((this._showTerrainWireframe = e1), this._update());
                  }
                  get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                  }
                  set showLayers2DWireframe(e1) {
                    this._showLayers2DWireframe !== e1 &&
                      ((this._showLayers2DWireframe = e1), this._update());
                  }
                  get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                  }
                  set showLayers3DWireframe(e1) {
                    this._showLayers3DWireframe !== e1 &&
                      ((this._showLayers3DWireframe = e1), this._update());
                  }
                  get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                  }
                  set speedIndexTiming(e1) {
                    this._speedIndexTiming !== e1 &&
                      ((this._speedIndexTiming = e1), this._update());
                  }
                  get showPadding() {
                    return !!this._showPadding;
                  }
                  set showPadding(e1) {
                    this._showPadding !== e1 &&
                      ((this._showPadding = e1), this._update());
                  }
                  get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                  }
                  set showCollisionBoxes(e1) {
                    this._showCollisionBoxes !== e1 &&
                      ((this._showCollisionBoxes = e1),
                      e1
                        ? this.style._generateCollisionBoxes()
                        : this._update());
                  }
                  get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                  }
                  set showOverdrawInspector(e1) {
                    this._showOverdrawInspector !== e1 &&
                      ((this._showOverdrawInspector = e1), this._update());
                  }
                  get repaint() {
                    return !!this._repaint;
                  }
                  set repaint(e1) {
                    this._repaint !== e1 &&
                      ((this._repaint = e1), this.triggerRepaint());
                  }
                  get vertices() {
                    return !!this._vertices;
                  }
                  set vertices(e1) {
                    (this._vertices = e1), this._update();
                  }
                  get showTileAABBs() {
                    return !!this._showTileAABBs;
                  }
                  set showTileAABBs(e1) {
                    this._showTileAABBs !== e1 &&
                      ((this._showTileAABBs = e1), e1 && this._update());
                  }
                  _setCacheLimits(e1, t) {
                    !(function (e1, t) {
                      (ce = e1), (he = t);
                    })(e1, t);
                  }
                  get version() {
                    return i;
                  }
                },
                NavigationControl: class {
                  constructor(e1) {
                    (this.options = k({}, nI, e1)),
                      (this._container = ut(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._container.addEventListener("contextmenu", (e1) =>
                        e1.preventDefault(),
                      ),
                      this.options.showZoom &&
                        (j(["_setButtonTitle", "_updateZoomButtons"], this),
                        (this._zoomInButton = this._createButton(
                          "mapboxgl-ctrl-zoom-in",
                          (e1) => {
                            this._map &&
                              this._map.zoomIn(
                                {},
                                {
                                  originalEvent: e1,
                                },
                              );
                          },
                        )),
                        ut(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomInButton,
                        ).setAttribute("aria-hidden", "true"),
                        (this._zoomOutButton = this._createButton(
                          "mapboxgl-ctrl-zoom-out",
                          (e1) => {
                            this._map &&
                              this._map.zoomOut(
                                {},
                                {
                                  originalEvent: e1,
                                },
                              );
                          },
                        )),
                        ut(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomOutButton,
                        ).setAttribute("aria-hidden", "true")),
                      this.options.showCompass &&
                        (j(["_rotateCompassArrow"], this),
                        (this._compass = this._createButton(
                          "mapboxgl-ctrl-compass",
                          (e1) => {
                            const t = this._map;
                            t &&
                              (this.options.visualizePitch
                                ? t.resetNorthPitch(
                                    {},
                                    {
                                      originalEvent: e1,
                                    },
                                  )
                                : t.resetNorth(
                                    {},
                                    {
                                      originalEvent: e1,
                                    },
                                  ));
                          },
                        )),
                        (this._compassIcon = ut(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._compass,
                        )),
                        this._compassIcon.setAttribute("aria-hidden", "true"));
                  }
                  _updateZoomButtons() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t = e1.getZoom(),
                      i = t === e1.getMaxZoom(),
                      r = t === e1.getMinZoom();
                    (this._zoomInButton.disabled = i),
                      (this._zoomOutButton.disabled = r),
                      this._zoomInButton.setAttribute(
                        "aria-disabled",
                        i.toString(),
                      ),
                      this._zoomOutButton.setAttribute(
                        "aria-disabled",
                        r.toString(),
                      );
                  }
                  _rotateCompassArrow() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t = this.options.visualizePitch
                      ? `scale(${
                          1 /
                          Math.pow(
                            Math.cos(e1.transform.pitch * (Math.PI / 180)),
                            0.5,
                          )
                        }) rotateX(${e1.transform.pitch}deg) rotateZ(${
                          e1.transform.angle * (180 / Math.PI)
                        }deg)`
                      : `rotate(${e1.transform.angle * (180 / Math.PI)}deg)`;
                    e1._requestDomTask(() => {
                      this._compassIcon &&
                        (this._compassIcon.style.transform = t);
                    });
                  }
                  onAdd(e1) {
                    return (
                      (this._map = e1),
                      this.options.showZoom &&
                        (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        e1.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                      this.options.showCompass &&
                        (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch &&
                          e1.on("pitch", this._rotateCompassArrow),
                        e1.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        (this._handler = new oI(
                          e1,
                          this._compass,
                          this.options.visualizePitch,
                        ))),
                      this._container
                    );
                  }
                  onRemove() {
                    const e1 = this._map;
                    e1 &&
                      (this._container.remove(),
                      this.options.showZoom &&
                        e1.off("zoom", this._updateZoomButtons),
                      this.options.showCompass &&
                        (this.options.visualizePitch &&
                          e1.off("pitch", this._rotateCompassArrow),
                        e1.off("rotate", this._rotateCompassArrow),
                        this._handler && this._handler.off(),
                        (this._handler = void 0)),
                      (this._map = void 0));
                  }
                  _createButton(e1, t) {
                    const i = ut("button", e1, this._container);
                    return (
                      (i.type = "button"), i.addEventListener("click", t), i
                    );
                  }
                  _setButtonTitle(e1, t) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t}`);
                    e1.setAttribute("aria-label", i),
                      e1.firstElementChild &&
                        e1.firstElementChild.setAttribute("title", i);
                  }
                },
                GeolocateControl: class extends It {
                  constructor(e1) {
                    super(),
                      (this.options = k(
                        {
                          geolocation: t.navigator.geolocation,
                        },
                        sI,
                        e1,
                      )),
                      j(
                        [
                          "_onSuccess",
                          "_onError",
                          "_onZoom",
                          "_finish",
                          "_setupUI",
                          "_updateCamera",
                          "_updateMarker",
                          "_updateMarkerRotation",
                          "_onDeviceOrientation",
                        ],
                        this,
                      ),
                      (this._updateMarkerRotationThrottled = HA(
                        this._updateMarkerRotation,
                        20,
                      )),
                      (this._numberOfWatches = 0);
                  }
                  onAdd(e1) {
                    return (
                      (this._map = e1),
                      (this._container = ut(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._checkGeolocationSupport(this._setupUI),
                      this._container
                    );
                  }
                  onRemove() {
                    void 0 !== this._geolocationWatchID &&
                      (this.options.geolocation.clearWatch(
                        this._geolocationWatchID,
                      ),
                      (this._geolocationWatchID = void 0)),
                      this.options.showUserLocation &&
                        this._userLocationDotMarker &&
                        this._userLocationDotMarker.remove(),
                      this.options.showAccuracyCircle &&
                        this._accuracyCircleMarker &&
                        this._accuracyCircleMarker.remove(),
                      this._container.remove(),
                      this._map.off("zoom", this._onZoom),
                      (this._map = void 0),
                      (this._numberOfWatches = 0),
                      (this._noTimeout = !1);
                  }
                  _checkGeolocationSupport(e1) {
                    const i = (t = !!this.options.geolocation) => {
                      (this._supportsGeolocation = t), e1(t);
                    };
                    void 0 !== this._supportsGeolocation
                      ? e1(this._supportsGeolocation)
                      : void 0 !== t.navigator.permissions
                      ? t.navigator.permissions
                          .query({
                            name: "geolocation",
                          })
                          .then((e1) => i("denied" !== e1.state))
                          .catch(() => i())
                      : i();
                  }
                  _isOutOfMapMaxBounds(e1) {
                    const t = this._map.getMaxBounds(),
                      i = e1.coords;
                    return (
                      !!t &&
                      (i.longitude < t.getWest() ||
                        i.longitude > t.getEast() ||
                        i.latitude < t.getSouth() ||
                        i.latitude > t.getNorth())
                    );
                  }
                  _setErrorState() {
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error",
                          );
                        break;
                      case "ACTIVE_LOCK":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          );
                        break;
                      case "BACKGROUND":
                        (this._watchState = "BACKGROUND_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background-error",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          );
                    }
                  }
                  _onSuccess(e1) {
                    if (this._map) {
                      if (this._isOutOfMapMaxBounds(e1))
                        return (
                          this._setErrorState(),
                          this.fire(new At("outofmaxbounds", e1)),
                          this._updateMarker(),
                          void this._finish()
                        );
                      if (this.options.trackUserLocation)
                        switch (
                          ((this._lastKnownPosition = e1), this._watchState)
                        ) {
                          case "WAITING_ACTIVE":
                          case "ACTIVE_LOCK":
                          case "ACTIVE_ERROR":
                            (this._watchState = "ACTIVE_LOCK"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active-error",
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-active",
                              );
                            break;
                          case "BACKGROUND":
                          case "BACKGROUND_ERROR":
                            (this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-background-error",
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background",
                              );
                        }
                      this.options.showUserLocation &&
                        "OFF" !== this._watchState &&
                        this._updateMarker(e1),
                        (this.options.trackUserLocation &&
                          "ACTIVE_LOCK" !== this._watchState) ||
                          this._updateCamera(e1),
                        this.options.showUserLocation &&
                          this._userLocationDotMarker.removeClassName(
                            "mapboxgl-user-location-dot-stale",
                          ),
                        this.fire(new At("geolocate", e1)),
                        this._finish();
                    }
                  }
                  _updateCamera(e1) {
                    const t = new Nd(e1.coords.longitude, e1.coords.latitude),
                      i = e1.coords.accuracy,
                      r = k(
                        {
                          bearing: this._map.getBearing(),
                        },
                        this.options.fitBoundsOptions,
                      );
                    this._map.fitBounds(t.toBounds(i), r, {
                      geolocateSource: !0,
                    });
                  }
                  _updateMarker(e1) {
                    if (e1) {
                      const t = new Nd(e1.coords.longitude, e1.coords.latitude);
                      this._accuracyCircleMarker.setLngLat(t).addTo(this._map),
                        this._userLocationDotMarker
                          .setLngLat(t)
                          .addTo(this._map),
                        (this._accuracy = e1.coords.accuracy),
                        this.options.showUserLocation &&
                          this.options.showAccuracyCircle &&
                          this._updateCircleRadius();
                    } else
                      this._userLocationDotMarker.remove(),
                        this._accuracyCircleMarker.remove();
                  }
                  _updateCircleRadius() {
                    const e1 = this._map.transform,
                      t = Zd(1, e1._center.lat) * e1.worldSize,
                      i = Math.ceil(2 * this._accuracy * t);
                    (this._circleElement.style.width = `${i}px`),
                      (this._circleElement.style.height = `${i}px`);
                  }
                  _onZoom() {
                    this.options.showUserLocation &&
                      this.options.showAccuracyCircle &&
                      this._updateCircleRadius();
                  }
                  _updateMarkerRotation() {
                    this._userLocationDotMarker &&
                    "number" == typeof this._heading
                      ? (this._userLocationDotMarker.setRotation(this._heading),
                        this._userLocationDotMarker.addClassName(
                          "mapboxgl-user-location-show-heading",
                        ))
                      : (this._userLocationDotMarker.removeClassName(
                          "mapboxgl-user-location-show-heading",
                        ),
                        this._userLocationDotMarker.setRotation(0));
                  }
                  _onError(e1) {
                    if (this._map) {
                      if (this.options.trackUserLocation) {
                        if (1 === e1.code) {
                          (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error",
                            ),
                            (this._geolocateButton.disabled = !0);
                          const e1 = this._map._getUIString(
                            "GeolocateControl.LocationNotAvailable",
                          );
                          this._geolocateButton.setAttribute("aria-label", e1),
                            this._geolocateButton.firstElementChild &&
                              this._geolocateButton.firstElementChild.setAttribute(
                                "title",
                                e1,
                              ),
                            void 0 !== this._geolocationWatchID &&
                              this._clearWatch();
                        } else {
                          if (3 === e1.code && this._noTimeout) return;
                          this._setErrorState();
                        }
                      }
                      "OFF" !== this._watchState &&
                        this.options.showUserLocation &&
                        this._userLocationDotMarker.addClassName(
                          "mapboxgl-user-location-dot-stale",
                        ),
                        this.fire(new At("error", e1)),
                        this._finish();
                    }
                  }
                  _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId),
                      (this._timeoutId = void 0);
                  }
                  _setupUI(e1) {
                    if (void 0 !== this._map) {
                      if (
                        (this._container.addEventListener("contextmenu", (e1) =>
                          e1.preventDefault(),
                        ),
                        (this._geolocateButton = ut(
                          "button",
                          "mapboxgl-ctrl-geolocate",
                          this._container,
                        )),
                        ut(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._geolocateButton,
                        ).setAttribute("aria-hidden", "true"),
                        (this._geolocateButton.type = "button"),
                        !1 === e1)
                      ) {
                        W(
                          "Geolocation support is not available so the GeolocateControl will be disabled.",
                        );
                        const e1 = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable",
                        );
                        (this._geolocateButton.disabled = !0),
                          this._geolocateButton.setAttribute("aria-label", e1),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              e1,
                            );
                      } else {
                        const e1 = this._map._getUIString(
                          "GeolocateControl.FindMyLocation",
                        );
                        this._geolocateButton.setAttribute("aria-label", e1),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              e1,
                            );
                      }
                      this.options.trackUserLocation &&
                        (this._geolocateButton.setAttribute(
                          "aria-pressed",
                          "false",
                        ),
                        (this._watchState = "OFF")),
                        this.options.showUserLocation &&
                          ((this._dotElement = ut(
                            "div",
                            "mapboxgl-user-location",
                          )),
                          this._dotElement.appendChild(
                            ut("div", "mapboxgl-user-location-dot"),
                          ),
                          this._dotElement.appendChild(
                            ut("div", "mapboxgl-user-location-heading"),
                          ),
                          (this._userLocationDotMarker = new KS({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map",
                          })),
                          (this._circleElement = ut(
                            "div",
                            "mapboxgl-user-location-accuracy-circle",
                          )),
                          (this._accuracyCircleMarker = new KS({
                            element: this._circleElement,
                            pitchAlignment: "map",
                          })),
                          this.options.trackUserLocation &&
                            (this._watchState = "OFF"),
                          this._map.on("zoom", this._onZoom)),
                        this._geolocateButton.addEventListener(
                          "click",
                          this.trigger.bind(this),
                        ),
                        (this._setup = !0),
                        this.options.trackUserLocation &&
                          this._map.on("movestart", (e1) => {
                            e1.geolocateSource ||
                              "ACTIVE_LOCK" !== this._watchState ||
                              (e1.originalEvent &&
                                "resize" === e1.originalEvent.type) ||
                              ((this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active",
                              ),
                              this.fire(new At("trackuserlocationend")));
                          });
                    }
                  }
                  _onDeviceOrientation(e1) {
                    this._userLocationDotMarker &&
                      (e1.webkitCompassHeading
                        ? (this._heading = e1.webkitCompassHeading)
                        : !0 === e1.absolute && (this._heading = -1 * e1.alpha),
                      this._updateMarkerRotationThrottled());
                  }
                  trigger() {
                    if (!this._setup)
                      return (
                        W("Geolocate control triggered before added to a map"),
                        !1
                      );
                    if (this.options.trackUserLocation) {
                      switch (this._watchState) {
                        case "OFF":
                          (this._watchState = "WAITING_ACTIVE"),
                            this.fire(new At("trackuserlocationstart"));
                          break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                          this._numberOfWatches--,
                            (this._noTimeout = !1),
                            (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error",
                            ),
                            this.fire(new At("trackuserlocationend"));
                          break;
                        case "BACKGROUND":
                          (this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._lastKnownPosition &&
                              this._updateCamera(this._lastKnownPosition),
                            this.fire(new At("trackuserlocationstart"));
                      }
                      switch (this._watchState) {
                        case "WAITING_ACTIVE":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active",
                            );
                          break;
                        case "ACTIVE_LOCK":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active",
                          );
                          break;
                        case "ACTIVE_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active-error",
                            );
                          break;
                        case "BACKGROUND":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background",
                          );
                          break;
                        case "BACKGROUND_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-background-error",
                            );
                      }
                      if (
                        "OFF" === this._watchState &&
                        void 0 !== this._geolocationWatchID
                      )
                        this._clearWatch();
                      else if (void 0 === this._geolocationWatchID) {
                        let e1;
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting",
                        ),
                          this._geolocateButton.setAttribute(
                            "aria-pressed",
                            "true",
                          ),
                          this._numberOfWatches++,
                          this._numberOfWatches > 1
                            ? ((e1 = {
                                maximumAge: 6e5,
                                timeout: 0,
                              }),
                              (this._noTimeout = !0))
                            : ((e1 = this.options.positionOptions),
                              (this._noTimeout = !1)),
                          (this._geolocationWatchID =
                            this.options.geolocation.watchPosition(
                              this._onSuccess,
                              this._onError,
                              e1,
                            )),
                          this.options.showUserHeading &&
                            this._addDeviceOrientationListener();
                      }
                    } else
                      this.options.geolocation.getCurrentPosition(
                        this._onSuccess,
                        this._onError,
                        this.options.positionOptions,
                      ),
                        (this._timeoutId = setTimeout(this._finish, 1e4));
                    return !0;
                  }
                  _addDeviceOrientationListener() {
                    const e1 = () => {
                      t.addEventListener(
                        "ondeviceorientationabsolute" in t
                          ? "deviceorientationabsolute"
                          : "deviceorientation",
                        this._onDeviceOrientation,
                      );
                    };
                    void 0 !== t.DeviceMotionEvent &&
                    "function" == typeof t.DeviceMotionEvent.requestPermission
                      ? DeviceOrientationEvent.requestPermission()
                          .then((t) => {
                            "granted" === t && e1();
                          })
                          .catch(console.error)
                      : e1();
                  }
                  _clearWatch() {
                    this.options.geolocation.clearWatch(
                      this._geolocationWatchID,
                    ),
                      t.removeEventListener(
                        "deviceorientation",
                        this._onDeviceOrientation,
                      ),
                      t.removeEventListener(
                        "deviceorientationabsolute",
                        this._onDeviceOrientation,
                      ),
                      (this._geolocationWatchID = void 0),
                      this._geolocateButton.classList.remove(
                        "mapboxgl-ctrl-geolocate-waiting",
                      ),
                      this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false",
                      ),
                      this.options.showUserLocation && this._updateMarker(null);
                  }
                },
                AttributionControl: $S,
                ScaleControl: class {
                  constructor(e1) {
                    (this.options = k({}, aI, e1)),
                      (this._isNumberFormatSupported = (function () {
                        try {
                          return (
                            new Intl.NumberFormat("en", {
                              style: "unit",
                              unitDisplay: "short",
                              unit: "meter",
                            }),
                            !0
                          );
                        } catch (e1) {
                          return !1;
                        }
                      })()),
                      j(["_update", "_setScale", "setUnit"], this);
                  }
                  getDefaultPosition() {
                    return "bottom-left";
                  }
                  _update() {
                    const e1 = this.options.maxWidth || 100,
                      t = this._map,
                      i = t._containerHeight / 2,
                      r = t._containerWidth / 2 - e1 / 2,
                      n = t.unproject([r, i]),
                      o = t.unproject([r + e1, i]),
                      s = n.distanceTo(o);
                    if ("imperial" === this.options.unit) {
                      const t = 3.2808 * s;
                      t > 5280
                        ? this._setScale(e1, t / 5280, "mile")
                        : this._setScale(e1, t, "foot");
                    } else
                      "nautical" === this.options.unit
                        ? this._setScale(e1, s / 1852, "nautical-mile")
                        : s >= 1e3
                        ? this._setScale(e1, s / 1e3, "kilometer")
                        : this._setScale(e1, s, "meter");
                  }
                  _setScale(e1, t, i) {
                    this._map._requestDomTask(() => {
                      const r = (function (e1) {
                          const t = Math.pow(
                            10,
                            `${Math.floor(e1)}`.length - 1,
                          );
                          let i = e1 / t;
                          return (
                            (i =
                              i >= 10
                                ? 10
                                : i >= 5
                                ? 5
                                : i >= 3
                                ? 3
                                : i >= 2
                                ? 2
                                : i >= 1
                                ? 1
                                : (function (e1) {
                                    const t = Math.pow(
                                      10,
                                      Math.ceil(-Math.log(e1) / Math.LN10),
                                    );
                                    return Math.round(e1 * t) / t;
                                  })(i)),
                            t * i
                          );
                        })(t),
                        n = r / t;
                      (this._container.innerHTML =
                        this._isNumberFormatSupported && "nautical-mile" !== i
                          ? new Intl.NumberFormat(this._language, {
                              style: "unit",
                              unitDisplay: "short",
                              unit: i,
                            }).format(r)
                          : `${r}&nbsp;${lI[i]}`),
                        (this._container.style.width = e1 * n + "px");
                    });
                  }
                  onAdd(e1) {
                    return (
                      (this._map = e1),
                      (this._language = e1.getLanguage()),
                      (this._container = ut(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-scale",
                        e1.getContainer(),
                      )),
                      (this._container.dir = "auto"),
                      this._map.on("move", this._update),
                      this._update(),
                      this._container
                    );
                  }
                  onRemove() {
                    this._container.remove(),
                      this._map.off("move", this._update),
                      (this._map = void 0);
                  }
                  _setLanguage(e1) {
                    (this._language = e1), this._update();
                  }
                  setUnit(e1) {
                    (this.options.unit = e1), this._update();
                  }
                },
                FullscreenControl: class {
                  constructor(e1) {
                    (this._fullscreen = !1),
                      e1 &&
                        e1.container &&
                        (e1.container instanceof t.HTMLElement
                          ? (this._container = e1.container)
                          : W(
                              "Full screen control 'container' must be a DOM element.",
                            )),
                      j(["_onClickFullscreen", "_changeIcon"], this),
                      "onfullscreenchange" in t.document
                        ? (this._fullscreenchange = "fullscreenchange")
                        : "onwebkitfullscreenchange" in t.document &&
                          (this._fullscreenchange = "webkitfullscreenchange");
                  }
                  onAdd(e1) {
                    return (
                      (this._map = e1),
                      this._container ||
                        (this._container = this._map.getContainer()),
                      (this._controlContainer = ut(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._checkFullscreenSupport()
                        ? this._setupUI()
                        : ((this._controlContainer.style.display = "none"),
                          W("This device does not support fullscreen mode.")),
                      this._controlContainer
                    );
                  }
                  onRemove() {
                    this._controlContainer.remove(),
                      (this._map = null),
                      t.document.removeEventListener(
                        this._fullscreenchange,
                        this._changeIcon,
                      );
                  }
                  _checkFullscreenSupport() {
                    return !(
                      !t.document.fullscreenEnabled &&
                      !t.document.webkitFullscreenEnabled
                    );
                  }
                  _setupUI() {
                    const e1 = (this._fullscreenButton = ut(
                      "button",
                      "mapboxgl-ctrl-fullscreen",
                      this._controlContainer,
                    ));
                    ut("span", "mapboxgl-ctrl-icon", e1).setAttribute(
                      "aria-hidden",
                      "true",
                    ),
                      (e1.type = "button"),
                      this._updateTitle(),
                      this._fullscreenButton.addEventListener(
                        "click",
                        this._onClickFullscreen,
                      ),
                      t.document.addEventListener(
                        this._fullscreenchange,
                        this._changeIcon,
                      );
                  }
                  _updateTitle() {
                    const e1 = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e1),
                      this._fullscreenButton.firstElementChild &&
                        this._fullscreenButton.firstElementChild.setAttribute(
                          "title",
                          e1,
                        );
                  }
                  _getTitle() {
                    return this._map._getUIString(
                      this._isFullscreen()
                        ? "FullscreenControl.Exit"
                        : "FullscreenControl.Enter",
                    );
                  }
                  _isFullscreen() {
                    return this._fullscreen;
                  }
                  _changeIcon() {
                    ((t.document.fullscreenElement ||
                      t.document.webkitFullscreenElement) ===
                      this._container) !==
                      this._fullscreen &&
                      ((this._fullscreen = !this._fullscreen),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-shrink",
                      ),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-fullscreen",
                      ),
                      this._updateTitle());
                  }
                  _onClickFullscreen() {
                    this._isFullscreen()
                      ? t.document.exitFullscreen
                        ? t.document.exitFullscreen()
                        : t.document.webkitCancelFullScreen &&
                          t.document.webkitCancelFullScreen()
                      : this._container.requestFullscreen
                      ? this._container.requestFullscreen()
                      : this._container.webkitRequestFullscreen &&
                        this._container.webkitRequestFullscreen();
                  }
                },
                Popup: class extends It {
                  constructor(e1) {
                    super(),
                      (this.options = k(Object.create(JS), e1)),
                      j(
                        ["_update", "_onClose", "remove", "_onMouseEvent"],
                        this,
                      ),
                      (this._classList = new Set(
                        e1 && e1.className
                          ? e1.className.trim().split(/\s+/)
                          : [],
                      ));
                  }
                  addTo(e1) {
                    return (
                      this._map && this.remove(),
                      (this._map = e1),
                      this.options.closeOnClick &&
                        e1.on("preclick", this._onClose),
                      this.options.closeOnMove && e1.on("move", this._onClose),
                      e1.on("remove", this.remove),
                      this._update(),
                      e1._addPopup(this),
                      this._focusFirstElement(),
                      this._trackPointer
                        ? (e1.on("mousemove", this._onMouseEvent),
                          e1.on("mouseup", this._onMouseEvent),
                          e1._canvasContainer.classList.add(
                            "mapboxgl-track-pointer",
                          ))
                        : e1.on("move", this._update),
                      this.fire(new At("open")),
                      this
                    );
                  }
                  isOpen() {
                    return !!this._map;
                  }
                  remove() {
                    this._content && this._content.remove(),
                      this._container &&
                        (this._container.remove(), (this._container = void 0));
                    const e1 = this._map;
                    return (
                      e1 &&
                        (e1.off("move", this._update),
                        e1.off("move", this._onClose),
                        e1.off("preclick", this._onClose),
                        e1.off("click", this._onClose),
                        e1.off("remove", this.remove),
                        e1.off("mousemove", this._onMouseEvent),
                        e1.off("mouseup", this._onMouseEvent),
                        e1.off("drag", this._onMouseEvent),
                        e1._canvasContainer &&
                          e1._canvasContainer.classList.remove(
                            "mapboxgl-track-pointer",
                          ),
                        e1._removePopup(this),
                        (this._map = void 0)),
                      this.fire(new At("close")),
                      this
                    );
                  }
                  getLngLat() {
                    return this._lngLat;
                  }
                  setLngLat(e1) {
                    (this._lngLat = Nd.convert(e1)),
                      (this._pos = null),
                      (this._trackPointer = !1),
                      this._update();
                    const t = this._map;
                    return (
                      t &&
                        (t.on("move", this._update),
                        t.off("mousemove", this._onMouseEvent),
                        t._canvasContainer.classList.remove(
                          "mapboxgl-track-pointer",
                        )),
                      this
                    );
                  }
                  trackPointer() {
                    (this._trackPointer = !0),
                      (this._pos = null),
                      this._update();
                    const e1 = this._map;
                    return (
                      e1 &&
                        (e1.off("move", this._update),
                        e1.on("mousemove", this._onMouseEvent),
                        e1.on("drag", this._onMouseEvent),
                        e1._canvasContainer.classList.add(
                          "mapboxgl-track-pointer",
                        )),
                      this
                    );
                  }
                  getElement() {
                    return this._container;
                  }
                  setText(e1) {
                    return this.setDOMContent(t.document.createTextNode(e1));
                  }
                  setHTML(e1) {
                    const i = t.document.createDocumentFragment(),
                      r = t.document.createElement("body");
                    let n;
                    for (r.innerHTML = e1; (n = r.firstChild), n; )
                      i.appendChild(n);
                    return this.setDOMContent(i);
                  }
                  getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                  }
                  setMaxWidth(e1) {
                    return (this.options.maxWidth = e1), this._update(), this;
                  }
                  setDOMContent(e1) {
                    let t = this._content;
                    if (t)
                      for (; t.hasChildNodes(); )
                        t.firstChild && t.removeChild(t.firstChild);
                    else
                      t = this._content = ut(
                        "div",
                        "mapboxgl-popup-content",
                        this._container || void 0,
                      );
                    if ((t.appendChild(e1), this.options.closeButton)) {
                      const e1 = (this._closeButton = ut(
                        "button",
                        "mapboxgl-popup-close-button",
                        t,
                      ));
                      (e1.type = "button"),
                        e1.setAttribute("aria-label", "Close popup"),
                        e1.setAttribute("aria-hidden", "true"),
                        (e1.innerHTML = "&#215;"),
                        e1.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                  }
                  addClassName(e1) {
                    return (
                      this._classList.add(e1), this._updateClassList(), this
                    );
                  }
                  removeClassName(e1) {
                    return (
                      this._classList.delete(e1), this._updateClassList(), this
                    );
                  }
                  setOffset(e1) {
                    return (this.options.offset = e1), this._update(), this;
                  }
                  toggleClassName(e1) {
                    let t;
                    return (
                      this._classList.delete(e1)
                        ? (t = !1)
                        : (this._classList.add(e1), (t = !0)),
                      this._updateClassList(),
                      t
                    );
                  }
                  _onMouseEvent(e1) {
                    this._update(e1.point);
                  }
                  _getAnchor(e1) {
                    if (this.options.anchor) return this.options.anchor;
                    const t = this._map,
                      i = this._container,
                      r = this._pos;
                    if (!t || !i || !r) return "bottom";
                    const n = i.offsetWidth,
                      o = i.offsetHeight,
                      s = r.x < n / 2,
                      a = r.x > t.transform.width - n / 2;
                    if (r.y + e1 < o)
                      return s ? "top-left" : a ? "top-right" : "top";
                    if (r.y > t.transform.height - o) {
                      if (s) return "bottom-left";
                      if (a) return "bottom-right";
                    }
                    return s ? "left" : a ? "right" : "bottom";
                  }
                  _updateClassList() {
                    const e1 = this._container;
                    if (!e1) return;
                    const t = [...this._classList];
                    t.push("mapboxgl-popup"),
                      this._anchor &&
                        t.push(`mapboxgl-popup-anchor-${this._anchor}`),
                      this._trackPointer &&
                        t.push("mapboxgl-popup-track-pointer"),
                      (e1.className = t.join(" "));
                  }
                  _update(e1) {
                    const t = this._map,
                      i = this._content;
                    if (!t || (!this._lngLat && !this._trackPointer) || !i)
                      return;
                    let r = this._container;
                    if (
                      (r ||
                        ((r = this._container =
                          ut("div", "mapboxgl-popup", t.getContainer())),
                        (this._tip = ut("div", "mapboxgl-popup-tip", r)),
                        r.appendChild(i)),
                      this.options.maxWidth &&
                        r.style.maxWidth !== this.options.maxWidth &&
                        (r.style.maxWidth = this.options.maxWidth),
                      t.transform.renderWorldCopies &&
                        !this._trackPointer &&
                        (this._lngLat = XS(
                          this._lngLat,
                          this._pos,
                          t.transform,
                        )),
                      !this._trackPointer || e1)
                    ) {
                      const i = (this._pos =
                          this._trackPointer && e1
                            ? e1
                            : t.project(this._lngLat)),
                        r = eI(this.options.offset),
                        n = (this._anchor = this._getAnchor(r.y)),
                        o = eI(this.options.offset, n),
                        s = i.add(o).round();
                      t._requestDomTask(() => {
                        this._container &&
                          n &&
                          (this._container.style.transform = `${YS[n]} translate(${s.x}px,${s.y}px)`);
                      });
                    }
                    if (!this._marker && t._showingGlobe()) {
                      const e1 = Dd(t.transform, this._lngLat) ? 0 : 1;
                      this._setOpacity(e1);
                    }
                    this._updateClassList();
                  }
                  _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                      return;
                    const e1 = this._container.querySelector(QS);
                    e1 && e1.focus();
                  }
                  _onClose() {
                    this.remove();
                  }
                  _setOpacity(e1) {
                    this._container &&
                      (this._container.style.opacity = `${e1}`),
                      this._content &&
                        (this._content.style.pointerEvents = e1
                          ? "auto"
                          : "none");
                  }
                },
                Marker: KS,
                Style: $A,
                LngLat: Nd,
                LngLatBounds: Ql,
                Point: y,
                MercatorCoordinate: ep,
                FreeCameraOptions: Vx,
                Evented: It,
                config: n,
                prewarm: function () {
                  Uw().acquire(Bw);
                },
                clearPrewarmedResources: function () {
                  const e1 = Nw;
                  e1 &&
                    (e1.isPreloaded() && 1 === e1.numActive()
                      ? (e1.release(Bw), (Nw = null))
                      : console.warn(
                          "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()",
                        ));
                },
                get accessToken() {
                  return n.ACCESS_TOKEN;
                },
                set accessToken(e) {
                  n.ACCESS_TOKEN = e;
                },
                get baseApiUrl() {
                  return n.API_URL;
                },
                set baseApiUrl(e) {
                  n.API_URL = e;
                },
                get workerCount() {
                  return Fw.workerCount;
                },
                set workerCount(e) {
                  Fw.workerCount = e;
                },
                get maxParallelImageRequests() {
                  return n.MAX_PARALLEL_IMAGE_REQUESTS;
                },
                set maxParallelImageRequests(e) {
                  n.MAX_PARALLEL_IMAGE_REQUESTS = e;
                },
                clearStorage(e1) {
                  !(function (e1) {
                    if (!pe()) return;
                    const i = t.caches.delete(le);
                    e1 && i.catch(e1).then(() => e1());
                  })(e1);
                },
                workerUrl: "",
                workerClass: null,
                get dracoUrl() {
                  return Zw();
                },
                set dracoUrl(e) {
                  !(function (e1) {
                    (jw = ht.resolveURL(e1)),
                      qw || (qw = new _w(Uw(), new It())),
                      qw.broadcast("setDracoUrl", jw);
                  })(e);
                },
                setNow: ht.setNow,
                restoreNow: ht.restoreNow,
              };
            (e1.A = mw),
              (e1.D = jm),
              (e1.E = sr),
              (e1.F = Zm),
              (e1.K = dE),
              (e1.O = Bu),
              (e1.P = y),
              (e1.T = Bv),
              (e1.V = im),
              (e1.a = Gf),
              (e1.b = sm),
              (e1.c = Kb),
              (e1.d = class extends It {
                constructor(e1, t, i, r, n, o) {
                  super(),
                    (this.actor = e1),
                    (this.layerIndex = t),
                    (this.availableImages = i),
                    (this.loadVectorData = n || Pw),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.deduped = new Dw(e1.scheduler)),
                    (this.isSpriteLoaded = r),
                    (this.scheduler = e1.scheduler),
                    (this.brightness = o);
                }
                loadTile(e1, t) {
                  const i = e1.uid,
                    r = e1 && e1.request,
                    n = r && r.collectResourceTiming,
                    o = (this.loading[i] = new Cw(e1));
                  o.abort = this.loadVectorData(e1, (s, a) => {
                    const l = !this.loading[i];
                    if ((delete this.loading[i], l || s || !a))
                      return (
                        (o.status = "done"), l || (this.loaded[i] = o), t(s)
                      );
                    const c = a.rawData,
                      h = {};
                    a.expires && (h.expires = a.expires),
                      a.cacheControl && (h.cacheControl = a.cacheControl),
                      (o.vectorTile = a.vectorTile || new tm(new Sm(c)));
                    const u = () => {
                      o.parse(
                        o.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        (e1, i) => {
                          if (e1 || !i) return t(e1);
                          const o = {};
                          if (n) {
                            const e1 = it(r);
                            e1.length > 0 &&
                              (o.resourceTiming = JSON.parse(
                                JSON.stringify(e1),
                              ));
                          }
                          t(
                            null,
                            k(
                              {
                                rawTileData: c.slice(0),
                              },
                              i,
                              h,
                              o,
                            ),
                          );
                        },
                      );
                    };
                    this.isSpriteLoaded
                      ? u()
                      : this.once("isSpriteLoaded", () => {
                          this.scheduler
                            ? this.scheduler.add(u, {
                                type: "parseTile",
                                isSymbolTile: e1.isSymbolTile,
                                zoom: e1.tileZoom,
                              })
                            : u();
                        }),
                      (this.loaded = this.loaded || {}),
                      (this.loaded[i] = o);
                  });
                }
                reloadTile(e1, t) {
                  const i = this.loaded,
                    r = e1.uid,
                    n = this;
                  if (i && i[r]) {
                    const o = i[r];
                    (o.showCollisionBoxes = e1.showCollisionBoxes),
                      (o.projection = e1.projection),
                      (o.brightness = e1.brightness),
                      (o.tileTransform = Tg(
                        e1.tileID.canonical,
                        e1.projection,
                      )),
                      (o.extraShadowCaster = e1.extraShadowCaster);
                    const s = (e1, i) => {
                      const r = o.reloadCallback;
                      r &&
                        (delete o.reloadCallback,
                        o.parse(
                          o.vectorTile,
                          n.layerIndex,
                          this.availableImages,
                          n.actor,
                          r,
                        )),
                        t(e1, i);
                    };
                    "parsing" === o.status
                      ? (o.reloadCallback = s)
                      : "done" === o.status &&
                        (o.vectorTile
                          ? o.parse(
                              o.vectorTile,
                              this.layerIndex,
                              this.availableImages,
                              this.actor,
                              s,
                            )
                          : s());
                  }
                }
                abortTile(e1, t) {
                  const i = e1.uid,
                    r = this.loading[i];
                  r && (r.abort && r.abort(), delete this.loading[i]), t();
                }
                removeTile(e1, t) {
                  const i = this.loaded,
                    r = e1.uid;
                  i && i[r] && delete i[r], t();
                }
              }),
              (e1.e = xo),
              (e1.f = it),
              (e1.g = d),
              (e1.h = we),
              (e1.i = Te),
              (e1.j = function (e1, t) {
                const i = _T(e1);
                for (const e1 of i) {
                  for (const t of e1.meshes) gT(t);
                  e1.lights &&
                    ((e1.lightMeshIndex = e1.meshes.length),
                    e1.meshes.push(yT(e1.lights, t)));
                }
                return i;
              }),
              (e1.k = ea),
              (e1.l = function (e1) {
                let t = 0;
                if (new Uint32Array(e1, 0, 1)[0] !== eT) {
                  const i = new Uint32Array(e1, 0, 7),
                    [, , r, n, o, s] = i;
                  (t = i.byteLength + n + o + s + o),
                    (r !== e1.byteLength || t >= e1.byteLength) &&
                      W("Invalid b3dm header information.");
                }
                return sT(e1, t);
              }),
              (e1.m = Hg),
              (e1.n = Qs),
              (e1.o = At),
              (e1.p = _),
              (e1.q = function (e1) {
                fe(),
                  ue &&
                    ue.then((t) => {
                      t.keys().then((i) => {
                        for (let r = 0; r < i.length - e1; r++) t.delete(i[r]);
                      });
                    });
              }),
              (e1.r = AT),
              (e1.s = cI),
              (e1.t = Qd),
              (e1.v = L),
              (e1.w = t);
          });
          define(["./shared"], function (e1) {
            "use strict";
            function t(e1) {
              if (
                "number" == typeof e1 ||
                "boolean" == typeof e1 ||
                "string" == typeof e1 ||
                null == e1
              )
                return JSON.stringify(e1);
              if (Array.isArray(e1)) {
                let r = "[";
                for (const o of e1) r += `${t(o)},`;
                return `${r}]`;
              }
              let r = "{";
              for (const o of Object.keys(e1).sort()) r += `${o}:${t(e1[o])},`;
              return `${r}}`;
            }
            function r(r) {
              let o = "";
              for (const i of e1.r) o += `/${t(r[i])}`;
              return o;
            }
            class o {
              constructor(e1) {
                (this.keyCache = {}), e1 && this.replace(e1);
              }
              replace(e1, t) {
                (this._layerConfigs = {}),
                  (this._layers = {}),
                  this.update(e1, [], t);
              }
              update(t, o, i) {
                this._options = i;
                for (const r of t) {
                  this._layerConfigs[r.id] = r;
                  const t = (this._layers[r.id] = e1.c(r, this._options));
                  t.setScope(this.scope),
                    t.compileFilter(),
                    this.keyCache[r.id] && delete this.keyCache[r.id];
                }
                for (const e1 of o)
                  delete this.keyCache[e1],
                    delete this._layerConfigs[e1],
                    delete this._layers[e1];
                this.familiesBySource = {};
                const s = (function (e1, t) {
                  const o = {};
                  for (let i = 0; i < e1.length; i++) {
                    const s = (t && t[e1[i].id]) || r(e1[i]);
                    t && (t[e1[i].id] = s);
                    let n = o[s];
                    n || (n = o[s] = []), n.push(e1[i]);
                  }
                  const i = [];
                  for (const e1 in o) i.push(o[e1]);
                  return i;
                })(e1.v(this._layerConfigs), this.keyCache);
                for (const e1 of s) {
                  const t = e1.map((e1) => this._layers[e1.id]),
                    r = t[0];
                  if ("none" === r.visibility) continue;
                  const o = r.source || "";
                  let i = this.familiesBySource[o];
                  i || (i = this.familiesBySource[o] = {});
                  const s = r.sourceLayer || "_geojsonTileLayer";
                  let n = i[s];
                  n || (n = i[s] = []), n.push(t);
                }
              }
            }
            class i {
              loadTile(t, r) {
                const { uid: o, encoding: i, rawImageData: s, padding: n } = t,
                  a =
                    e1.w.ImageBitmap && s instanceof e1.w.ImageBitmap
                      ? this.getImageData(s, n)
                      : s;
                r(null, new e1.D(o, a, i, t.convertToFloat, n < 1));
              }
              getImageData(e1, t) {
                (this.offscreenCanvas && this.offscreenCanvasContext) ||
                  ((this.offscreenCanvas = new OffscreenCanvas(
                    e1.width,
                    e1.height,
                  )),
                  (this.offscreenCanvasContext =
                    this.offscreenCanvas.getContext("2d", {
                      willReadFrequently: !0,
                    }))),
                  (this.offscreenCanvas.width = e1.width),
                  (this.offscreenCanvas.height = e1.height),
                  this.offscreenCanvasContext.drawImage(
                    e1,
                    0,
                    0,
                    e1.width,
                    e1.height,
                  );
                const r = this.offscreenCanvasContext.getImageData(
                  -t,
                  -t,
                  e1.width + 2 * t,
                  e1.height + 2 * t,
                );
                return (
                  this.offscreenCanvasContext.clearRect(
                    0,
                    0,
                    this.offscreenCanvas.width,
                    this.offscreenCanvas.height,
                  ),
                  r
                );
              }
            }
            function s(e1, t) {
              if (0 !== e1.length) {
                n(e1[0], t);
                for (var r = 1; r < e1.length; r++) n(e1[r], !t);
              }
            }
            function n(e1, t) {
              for (
                var r = 0, o = 0, i = 0, s = e1.length, n = s - 1;
                i < s;
                n = i++
              ) {
                var a = (e1[i][0] - e1[n][0]) * (e1[n][1] + e1[i][1]),
                  l = r + a;
                (o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r),
                  (r = l);
              }
              r + o >= 0 != !!t && e1.reverse();
            }
            var a = e1.g(function e1(t, r) {
              var o,
                i = t && t.type;
              if ("FeatureCollection" === i)
                for (o = 0; o < t.features.length; o++) e1(t.features[o], r);
              else if ("GeometryCollection" === i)
                for (o = 0; o < t.geometries.length; o++)
                  e1(t.geometries[o], r);
              else if ("Feature" === i) e1(t.geometry, r);
              else if ("Polygon" === i) s(t.coordinates, r);
              else if ("MultiPolygon" === i)
                for (o = 0; o < t.coordinates.length; o++)
                  s(t.coordinates[o], r);
              return t;
            });
            const l = e1.V.prototype.toGeoJSON;
            var h = {
                exports: {},
              },
              u = e1.p,
              c = e1.a.VectorTileFeature,
              f = d;
            function d(e1, t) {
              (this.options = t || {}),
                (this.features = e1),
                (this.length = e1.length);
            }
            function p(e1, t) {
              (this.id = "number" == typeof e1.id ? e1.id : void 0),
                (this.type = e1.type),
                (this.rawGeometry =
                  1 === e1.type ? [e1.geometry] : e1.geometry),
                (this.properties = e1.tags),
                (this.extent = t || 4096);
            }
            (d.prototype.feature = function (e1) {
              return new p(this.features[e1], this.options.extent);
            }),
              (p.prototype.loadGeometry = function () {
                var e1 = this.rawGeometry;
                this.geometry = [];
                for (var t = 0; t < e1.length; t++) {
                  for (var r = e1[t], o = [], i = 0; i < r.length; i++)
                    o.push(new u(r[i][0], r[i][1]));
                  this.geometry.push(o);
                }
                return this.geometry;
              }),
              (p.prototype.bbox = function () {
                this.geometry || this.loadGeometry();
                for (
                  var e1 = this.geometry,
                    t = 1 / 0,
                    r = -1 / 0,
                    o = 1 / 0,
                    i = -1 / 0,
                    s = 0;
                  s < e1.length;
                  s++
                )
                  for (var n = e1[s], a = 0; a < n.length; a++) {
                    var l = n[a];
                    (t = Math.min(t, l.x)),
                      (r = Math.max(r, l.x)),
                      (o = Math.min(o, l.y)),
                      (i = Math.max(i, l.y));
                  }
                return [t, o, r, i];
              }),
              (p.prototype.toGeoJSON = c.prototype.toGeoJSON);
            var g = e1.b,
              m = f;
            function y(e1) {
              var t = new g();
              return (
                (function (e1, t) {
                  for (var r in e1.layers) t.writeMessage(3, v, e1.layers[r]);
                })(e1, t),
                t.finish()
              );
            }
            function v(e1, t) {
              var r;
              t.writeVarintField(15, e1.version || 1),
                t.writeStringField(1, e1.name || ""),
                t.writeVarintField(5, e1.extent || 4096);
              var o = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {},
              };
              for (r = 0; r < e1.length; r++)
                (o.feature = e1.feature(r)), t.writeMessage(2, w, o);
              var i = o.keys;
              for (r = 0; r < i.length; r++) t.writeStringField(3, i[r]);
              var s = o.values;
              for (r = 0; r < s.length; r++) t.writeMessage(4, I, s[r]);
            }
            function w(e1, t) {
              var r = e1.feature;
              void 0 !== r.id && t.writeVarintField(1, r.id),
                t.writeMessage(2, x, e1),
                t.writeVarintField(3, r.type),
                t.writeMessage(4, b, r);
            }
            function x(e1, t) {
              var r = e1.feature,
                o = e1.keys,
                i = e1.values,
                s = e1.keycache,
                n = e1.valuecache;
              for (var a in r.properties) {
                var l = r.properties[a],
                  h = s[a];
                if (null !== l) {
                  void 0 === h && (o.push(a), (s[a] = h = o.length - 1)),
                    t.writeVarint(h);
                  var u = typeof l;
                  "string" !== u &&
                    "boolean" !== u &&
                    "number" !== u &&
                    (l = JSON.stringify(l));
                  var c = u + ":" + l,
                    f = n[c];
                  void 0 === f && (i.push(l), (n[c] = f = i.length - 1)),
                    t.writeVarint(f);
                }
              }
            }
            function S(e1, t) {
              return (t << 3) + (7 & e1);
            }
            function M(e1) {
              return (e1 << 1) ^ (e1 >> 31);
            }
            function b(e1, t) {
              for (
                var r = e1.loadGeometry(),
                  o = e1.type,
                  i = 0,
                  s = 0,
                  n = r.length,
                  a = 0;
                a < n;
                a++
              ) {
                var l = r[a],
                  h = 1;
                1 === o && (h = l.length), t.writeVarint(S(1, h));
                for (
                  var u = 3 === o ? l.length - 1 : l.length, c = 0;
                  c < u;
                  c++
                ) {
                  1 === c && 1 !== o && t.writeVarint(S(2, u - 1));
                  var f = l[c].x - i,
                    d = l[c].y - s;
                  t.writeVarint(M(f)), t.writeVarint(M(d)), (i += f), (s += d);
                }
                3 === o && t.writeVarint(S(7, 1));
              }
            }
            function I(e1, t) {
              var r = typeof e1;
              "string" === r
                ? t.writeStringField(1, e1)
                : "boolean" === r
                ? t.writeBooleanField(7, e1)
                : "number" === r &&
                  (e1 % 1 != 0
                    ? t.writeDoubleField(3, e1)
                    : e1 < 0
                    ? t.writeSVarintField(6, e1)
                    : t.writeVarintField(5, e1));
            }
            (h.exports = y),
              (h.exports.fromVectorTileJs = y),
              (h.exports.fromGeojsonVt = function (e1, t) {
                t = t || {};
                var r = {};
                for (var o in e1)
                  (r[o] = new m(e1[o].features, t)),
                    (r[o].name = o),
                    (r[o].version = t.version),
                    (r[o].extent = t.extent);
                return y({
                  layers: r,
                });
              }),
              (h.exports.GeoJSONWrapper = m);
            var k = e1.g(h.exports);
            const P = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: (e1) => e1,
              },
              _ =
                Math.fround ||
                ((T = new Float32Array(1)), (e1) => ((T[0] = +e1), T[0]));
            var T;
            const L = 3,
              C = 5,
              O = 6;
            class j {
              constructor(e1) {
                (this.options = Object.assign(Object.create(P), e1)),
                  (this.trees = new Array(this.options.maxZoom + 1)),
                  (this.stride = this.options.reduce ? 7 : 6),
                  (this.clusterProps = []);
              }
              load(e1) {
                const { log: t, minZoom: r, maxZoom: o } = this.options;
                t && console.time("total time");
                const i = `prepare ${e1.length} points`;
                t && console.time(i), (this.points = e1);
                const s = [];
                for (let t = 0; t < e1.length; t++) {
                  const r = e1[t];
                  if (!r.geometry) continue;
                  const [o, i] = r.geometry.coordinates,
                    n = _(z(o)),
                    a = _(D(i));
                  s.push(n, a, 1 / 0, t, -1, 1),
                    this.options.reduce && s.push(0);
                }
                let n = (this.trees[o + 1] = this._createTree(s));
                t && console.timeEnd(i);
                for (let e1 = o; e1 >= r; e1--) {
                  const r = +Date.now();
                  (n = this.trees[e1] = this._createTree(this._cluster(n, e1))),
                    t &&
                      console.log(
                        "z%d: %d clusters in %dms",
                        e1,
                        n.numItems,
                        +Date.now() - r,
                      );
                }
                return t && console.timeEnd("total time"), this;
              }
              getClusters(e1, t) {
                let r = ((((e1[0] + 180) % 360) + 360) % 360) - 180;
                const o = Math.max(-90, Math.min(90, e1[1]));
                let i =
                  180 === e1[2]
                    ? 180
                    : ((((e1[2] + 180) % 360) + 360) % 360) - 180;
                const s = Math.max(-90, Math.min(90, e1[3]));
                if (e1[2] - e1[0] >= 360) (r = -180), (i = 180);
                else if (r > i) {
                  const e1 = this.getClusters([r, o, 180, s], t),
                    n = this.getClusters([-180, o, i, s], t);
                  return e1.concat(n);
                }
                const n = this.trees[this._limitZoom(t)],
                  a = n.range(z(r), D(s), z(i), D(o)),
                  l = n.data,
                  h = [];
                for (const e1 of a) {
                  const t = this.stride * e1;
                  h.push(
                    l[t + C] > 1
                      ? F(l, t, this.clusterProps)
                      : this.points[l[t + L]],
                  );
                }
                return h;
              }
              getChildren(e1) {
                const t = this._getOriginId(e1),
                  r = this._getOriginZoom(e1),
                  o = "No cluster with the specified id.",
                  i = this.trees[r];
                if (!i) throw new Error(o);
                const s = i.data;
                if (t * this.stride >= s.length) throw new Error(o);
                const n =
                    this.options.radius /
                    (this.options.extent * Math.pow(2, r - 1)),
                  a = i.within(s[t * this.stride], s[t * this.stride + 1], n),
                  l = [];
                for (const t of a) {
                  const r = t * this.stride;
                  s[r + 4] === e1 &&
                    l.push(
                      s[r + C] > 1
                        ? F(s, r, this.clusterProps)
                        : this.points[s[r + L]],
                    );
                }
                if (0 === l.length) throw new Error(o);
                return l;
              }
              getLeaves(e1, t, r) {
                const o = [];
                return (
                  this._appendLeaves(o, e1, (t = t || 10), (r = r || 0), 0), o
                );
              }
              getTile(e1, t, r) {
                const o = this.trees[this._limitZoom(e1)],
                  i = Math.pow(2, e1),
                  { extent: s, radius: n } = this.options,
                  a = n / s,
                  l = (r - a) / i,
                  h = (r + 1 + a) / i,
                  u = {
                    features: [],
                  };
                return (
                  this._addTileFeatures(
                    o.range((t - a) / i, l, (t + 1 + a) / i, h),
                    o.data,
                    t,
                    r,
                    i,
                    u,
                  ),
                  0 === t &&
                    this._addTileFeatures(
                      o.range(1 - a / i, l, 1, h),
                      o.data,
                      i,
                      r,
                      i,
                      u,
                    ),
                  t === i - 1 &&
                    this._addTileFeatures(
                      o.range(0, l, a / i, h),
                      o.data,
                      -1,
                      r,
                      i,
                      u,
                    ),
                  u.features.length ? u : null
                );
              }
              getClusterExpansionZoom(e1) {
                let t = this._getOriginZoom(e1) - 1;
                for (; t <= this.options.maxZoom; ) {
                  const r = this.getChildren(e1);
                  if ((t++, 1 !== r.length)) break;
                  e1 = r[0].properties.cluster_id;
                }
                return t;
              }
              _appendLeaves(e1, t, r, o, i) {
                const s = this.getChildren(t);
                for (const t of s) {
                  const s = t.properties;
                  if (
                    (s && s.cluster
                      ? i + s.point_count <= o
                        ? (i += s.point_count)
                        : (i = this._appendLeaves(e1, s.cluster_id, r, o, i))
                      : i < o
                      ? i++
                      : e1.push(t),
                    e1.length === r)
                  )
                    break;
                }
                return i;
              }
              _createTree(t) {
                const r = new e1.K(
                  (t.length / this.stride) | 0,
                  this.options.nodeSize,
                  Float32Array,
                );
                for (let e1 = 0; e1 < t.length; e1 += this.stride)
                  r.add(t[e1], t[e1 + 1]);
                return r.finish(), (r.data = t), r;
              }
              _addTileFeatures(e1, t, r, o, i, s) {
                for (const n of e1) {
                  const e1 = n * this.stride,
                    a = t[e1 + C] > 1;
                  let l, h, u;
                  if (a)
                    (l = Z(t, e1, this.clusterProps)),
                      (h = t[e1]),
                      (u = t[e1 + 1]);
                  else {
                    const r = this.points[t[e1 + L]];
                    l = r.properties;
                    const [o, i] = r.geometry.coordinates;
                    (h = z(o)), (u = D(i));
                  }
                  const c = {
                    type: 1,
                    geometry: [
                      [
                        Math.round(this.options.extent * (h * i - r)),
                        Math.round(this.options.extent * (u * i - o)),
                      ],
                    ],
                    tags: l,
                  };
                  let f;
                  (f =
                    a || this.options.generateId
                      ? t[e1 + L]
                      : this.points[t[e1 + L]].id),
                    void 0 !== f && (c.id = f),
                    s.features.push(c);
                }
              }
              _limitZoom(e1) {
                return Math.max(
                  this.options.minZoom,
                  Math.min(Math.floor(+e1), this.options.maxZoom + 1),
                );
              }
              _cluster(e1, t) {
                const {
                    radius: r,
                    extent: o,
                    reduce: i,
                    minPoints: s,
                  } = this.options,
                  n = r / (o * Math.pow(2, t)),
                  a = e1.data,
                  l = [],
                  h = this.stride;
                for (let r = 0; r < a.length; r += h) {
                  if (a[r + 2] <= t) continue;
                  a[r + 2] = t;
                  const o = a[r],
                    u = a[r + 1],
                    c = e1.within(a[r], a[r + 1], n),
                    f = a[r + C];
                  let d = f;
                  for (const e1 of c) {
                    const r = e1 * h;
                    a[r + 2] > t && (d += a[r + C]);
                  }
                  if (d > f && d >= s) {
                    let e1,
                      s = o * f,
                      n = u * f,
                      p = -1;
                    const g =
                      (((r / h) | 0) << 5) + (t + 1) + this.points.length;
                    for (const o of c) {
                      const l = o * h;
                      if (a[l + 2] <= t) continue;
                      a[l + 2] = t;
                      const u = a[l + C];
                      (s += a[l] * u),
                        (n += a[l + 1] * u),
                        (a[l + 4] = g),
                        i &&
                          (e1 ||
                            ((e1 = this._map(a, r, !0)),
                            (p = this.clusterProps.length),
                            this.clusterProps.push(e1)),
                          i(e1, this._map(a, l)));
                    }
                    (a[r + 4] = g),
                      l.push(s / d, n / d, 1 / 0, g, -1, d),
                      i && l.push(p);
                  } else {
                    for (let e1 = 0; e1 < h; e1++) l.push(a[r + e1]);
                    if (d > 1)
                      for (const e1 of c) {
                        const r = e1 * h;
                        if (!(a[r + 2] <= t)) {
                          a[r + 2] = t;
                          for (let e1 = 0; e1 < h; e1++) l.push(a[r + e1]);
                        }
                      }
                  }
                }
                return l;
              }
              _getOriginId(e1) {
                return (e1 - this.points.length) >> 5;
              }
              _getOriginZoom(e1) {
                return (e1 - this.points.length) % 32;
              }
              _map(e1, t, r) {
                if (e1[t + C] > 1) {
                  const o = this.clusterProps[e1[t + O]];
                  return r ? Object.assign({}, o) : o;
                }
                const o = this.points[e1[t + L]].properties,
                  i = this.options.map(o);
                return r && i === o ? Object.assign({}, i) : i;
              }
            }
            function F(e1, t, r) {
              var o;
              return {
                type: "Feature",
                id: e1[t + L],
                properties: Z(e1, t, r),
                geometry: {
                  type: "Point",
                  coordinates: [((o = e1[t]), 360 * (o - 0.5)), E(e1[t + 1])],
                },
              };
            }
            function Z(e1, t, r) {
              const o = e1[t + C],
                i =
                  o >= 1e4
                    ? `${Math.round(o / 1e3)}k`
                    : o >= 1e3
                    ? Math.round(o / 100) / 10 + "k"
                    : o,
                s = e1[t + O],
                n = -1 === s ? {} : Object.assign({}, r[s]);
              return Object.assign(n, {
                cluster: !0,
                cluster_id: e1[t + L],
                point_count: o,
                point_count_abbreviated: i,
              });
            }
            function z(e1) {
              return e1 / 360 + 0.5;
            }
            function D(e1) {
              const t = Math.sin((e1 * Math.PI) / 180),
                r = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
              return r < 0 ? 0 : r > 1 ? 1 : r;
            }
            function E(e1) {
              const t = ((180 - 360 * e1) * Math.PI) / 180;
              return (360 * Math.atan(Math.exp(t))) / Math.PI - 90;
            }
            var N = {
              exports: {},
            };
            N.exports = (function () {
              function e1(r, o, i, s) {
                for (
                  var n,
                    a = s,
                    l = (i - o) >> 1,
                    h = i - o,
                    u = r[o],
                    c = r[o + 1],
                    f = r[i],
                    d = r[i + 1],
                    p = o + 3;
                  p < i;
                  p += 3
                ) {
                  var g = t(r[p], r[p + 1], u, c, f, d);
                  if (g > a) (n = p), (a = g);
                  else if (g === a) {
                    var m = Math.abs(p - l);
                    m < h && ((n = p), (h = m));
                  }
                }
                a > s &&
                  (n - o > 3 && e1(r, o, n, s),
                  (r[n + 2] = a),
                  i - n > 3 && e1(r, n, i, s));
              }
              function t(e1, t, r, o, i, s) {
                var n = i - r,
                  a = s - o;
                if (0 !== n || 0 !== a) {
                  var l = ((e1 - r) * n + (t - o) * a) / (n * n + a * a);
                  l > 1
                    ? ((r = i), (o = s))
                    : l > 0 && ((r += n * l), (o += a * l));
                }
                return (n = e1 - r) * n + (a = t - o) * a;
              }
              function r(e1, t, r, i) {
                var s = {
                  id: void 0 === e1 ? null : e1,
                  type: t,
                  geometry: r,
                  tags: i,
                  minX: 1 / 0,
                  minY: 1 / 0,
                  maxX: -1 / 0,
                  maxY: -1 / 0,
                };
                return (
                  (function (e1) {
                    var t = e1.geometry,
                      r = e1.type;
                    if (
                      "Point" === r ||
                      "MultiPoint" === r ||
                      "LineString" === r
                    )
                      o(e1, t);
                    else if ("Polygon" === r || "MultiLineString" === r)
                      for (var i = 0; i < t.length; i++) o(e1, t[i]);
                    else if ("MultiPolygon" === r)
                      for (i = 0; i < t.length; i++)
                        for (var s = 0; s < t[i].length; s++) o(e1, t[i][s]);
                  })(s),
                  s
                );
              }
              function o(e1, t) {
                for (var r = 0; r < t.length; r += 3)
                  (e1.minX = Math.min(e1.minX, t[r])),
                    (e1.minY = Math.min(e1.minY, t[r + 1])),
                    (e1.maxX = Math.max(e1.maxX, t[r])),
                    (e1.maxY = Math.max(e1.maxY, t[r + 1]));
              }
              function i(e1, t, o, l) {
                if (t.geometry) {
                  var h = t.geometry.coordinates,
                    u = t.geometry.type,
                    c = Math.pow(
                      o.tolerance / ((1 << o.maxZoom) * o.extent),
                      2,
                    ),
                    f = [],
                    d = t.id;
                  if (
                    (o.promoteId
                      ? (d = t.properties[o.promoteId])
                      : o.generateId && (d = l || 0),
                    "Point" === u)
                  )
                    s(h, f);
                  else if ("MultiPoint" === u)
                    for (var p = 0; p < h.length; p++) s(h[p], f);
                  else if ("LineString" === u) n(h, f, c, !1);
                  else if ("MultiLineString" === u) {
                    if (o.lineMetrics) {
                      for (p = 0; p < h.length; p++)
                        n(h[p], (f = []), c, !1),
                          e1.push(r(d, "LineString", f, t.properties));
                      return;
                    }
                    a(h, f, c, !1);
                  } else if ("Polygon" === u) a(h, f, c, !0);
                  else {
                    if ("MultiPolygon" !== u) {
                      if ("GeometryCollection" === u) {
                        for (p = 0; p < t.geometry.geometries.length; p++)
                          i(
                            e1,
                            {
                              id: d,
                              geometry: t.geometry.geometries[p],
                              properties: t.properties,
                            },
                            o,
                            l,
                          );
                        return;
                      }
                      throw new Error(
                        "Input data is not a valid GeoJSON object.",
                      );
                    }
                    for (p = 0; p < h.length; p++) {
                      var g = [];
                      a(h[p], g, c, !0), f.push(g);
                    }
                  }
                  e1.push(r(d, u, f, t.properties));
                }
              }
              function s(e1, t) {
                t.push(l(e1[0])), t.push(h(e1[1])), t.push(0);
              }
              function n(t, r, o, i) {
                for (var s, n, a = 0, u = 0; u < t.length; u++) {
                  var c = l(t[u][0]),
                    f = h(t[u][1]);
                  r.push(c),
                    r.push(f),
                    r.push(0),
                    u > 0 &&
                      (a += i
                        ? (s * f - c * n) / 2
                        : Math.sqrt(Math.pow(c - s, 2) + Math.pow(f - n, 2))),
                    (s = c),
                    (n = f);
                }
                var d = r.length - 3;
                (r[2] = 1),
                  e1(r, 0, d, o),
                  (r[d + 2] = 1),
                  (r.size = Math.abs(a)),
                  (r.start = 0),
                  (r.end = r.size);
              }
              function a(e1, t, r, o) {
                for (var i = 0; i < e1.length; i++) {
                  var s = [];
                  n(e1[i], s, r, o), t.push(s);
                }
              }
              function l(e1) {
                return e1 / 360 + 0.5;
              }
              function h(e1) {
                var t = Math.sin((e1 * Math.PI) / 180),
                  r = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
                return r < 0 ? 0 : r > 1 ? 1 : r;
              }
              function u(e1, t, o, i, s, n, a, l) {
                if (((i /= t), n >= (o /= t) && a < i)) return e1;
                if (a < o || n >= i) return null;
                for (var h = [], u = 0; u < e1.length; u++) {
                  var d = e1[u],
                    g = d.geometry,
                    m = d.type,
                    y = 0 === s ? d.minX : d.minY,
                    v = 0 === s ? d.maxX : d.maxY;
                  if (y >= o && v < i) h.push(d);
                  else if (!(v < o || y >= i)) {
                    var w = [];
                    if ("Point" === m || "MultiPoint" === m) c(g, w, o, i, s);
                    else if ("LineString" === m)
                      f(g, w, o, i, s, !1, l.lineMetrics);
                    else if ("MultiLineString" === m) p(g, w, o, i, s, !1);
                    else if ("Polygon" === m) p(g, w, o, i, s, !0);
                    else if ("MultiPolygon" === m)
                      for (var x = 0; x < g.length; x++) {
                        var S = [];
                        p(g[x], S, o, i, s, !0), S.length && w.push(S);
                      }
                    if (w.length) {
                      if (l.lineMetrics && "LineString" === m) {
                        for (x = 0; x < w.length; x++)
                          h.push(r(d.id, m, w[x], d.tags));
                        continue;
                      }
                      ("LineString" !== m && "MultiLineString" !== m) ||
                        (1 === w.length
                          ? ((m = "LineString"), (w = w[0]))
                          : (m = "MultiLineString")),
                        ("Point" !== m && "MultiPoint" !== m) ||
                          (m = 3 === w.length ? "Point" : "MultiPoint"),
                        h.push(r(d.id, m, w, d.tags));
                    }
                  }
                }
                return h.length ? h : null;
              }
              function c(e1, t, r, o, i) {
                for (var s = 0; s < e1.length; s += 3) {
                  var n = e1[s + i];
                  n >= r &&
                    n <= o &&
                    (t.push(e1[s]), t.push(e1[s + 1]), t.push(e1[s + 2]));
                }
              }
              function f(e1, t, r, o, i, s, n) {
                for (
                  var a, l, h = d(e1), u = 0 === i ? m : y, c = e1.start, f = 0;
                  f < e1.length - 3;
                  f += 3
                ) {
                  var p = e1[f],
                    v = e1[f + 1],
                    w = e1[f + 2],
                    x = e1[f + 3],
                    S = e1[f + 4],
                    M = 0 === i ? p : v,
                    b = 0 === i ? x : S,
                    I = !1;
                  n && (a = Math.sqrt(Math.pow(p - x, 2) + Math.pow(v - S, 2))),
                    M < r
                      ? b > r &&
                        ((l = u(h, p, v, x, S, r)), n && (h.start = c + a * l))
                      : M > o
                      ? b < o &&
                        ((l = u(h, p, v, x, S, o)), n && (h.start = c + a * l))
                      : g(h, p, v, w),
                    b < r && M >= r && ((l = u(h, p, v, x, S, r)), (I = !0)),
                    b > o && M <= o && ((l = u(h, p, v, x, S, o)), (I = !0)),
                    !s &&
                      I &&
                      (n && (h.end = c + a * l), t.push(h), (h = d(e1))),
                    n && (c += a);
                }
                var k = e1.length - 3;
                (p = e1[k]),
                  (v = e1[k + 1]),
                  (w = e1[k + 2]),
                  (M = 0 === i ? p : v) >= r && M <= o && g(h, p, v, w),
                  (k = h.length - 3),
                  s &&
                    k >= 3 &&
                    (h[k] !== h[0] || h[k + 1] !== h[1]) &&
                    g(h, h[0], h[1], h[2]),
                  h.length && t.push(h);
              }
              function d(e1) {
                var t = [];
                return (
                  (t.size = e1.size), (t.start = e1.start), (t.end = e1.end), t
                );
              }
              function p(e1, t, r, o, i, s) {
                for (var n = 0; n < e1.length; n++) f(e1[n], t, r, o, i, s, !1);
              }
              function g(e1, t, r, o) {
                e1.push(t), e1.push(r), e1.push(o);
              }
              function m(e1, t, r, o, i, s) {
                var n = (s - t) / (o - t);
                return e1.push(s), e1.push(r + (i - r) * n), e1.push(1), n;
              }
              function y(e1, t, r, o, i, s) {
                var n = (s - r) / (i - r);
                return e1.push(t + (o - t) * n), e1.push(s), e1.push(1), n;
              }
              function v(e1, t) {
                for (var o = [], i = 0; i < e1.length; i++) {
                  var s,
                    n = e1[i],
                    a = n.type;
                  if ("Point" === a || "MultiPoint" === a || "LineString" === a)
                    s = w(n.geometry, t);
                  else if ("MultiLineString" === a || "Polygon" === a) {
                    s = [];
                    for (var l = 0; l < n.geometry.length; l++)
                      s.push(w(n.geometry[l], t));
                  } else if ("MultiPolygon" === a)
                    for (s = [], l = 0; l < n.geometry.length; l++) {
                      for (var h = [], u = 0; u < n.geometry[l].length; u++)
                        h.push(w(n.geometry[l][u], t));
                      s.push(h);
                    }
                  o.push(r(n.id, a, s, n.tags));
                }
                return o;
              }
              function w(e1, t) {
                var r = [];
                (r.size = e1.size),
                  void 0 !== e1.start &&
                    ((r.start = e1.start), (r.end = e1.end));
                for (var o = 0; o < e1.length; o += 3)
                  r.push(e1[o] + t, e1[o + 1], e1[o + 2]);
                return r;
              }
              function x(e1, t) {
                if (e1.transformed) return e1;
                var r,
                  o,
                  i,
                  s = 1 << e1.z,
                  n = e1.x,
                  a = e1.y;
                for (r = 0; r < e1.features.length; r++) {
                  var l = e1.features[r],
                    h = l.geometry,
                    u = l.type;
                  if (((l.geometry = []), 1 === u))
                    for (o = 0; o < h.length; o += 2)
                      l.geometry.push(S(h[o], h[o + 1], t, s, n, a));
                  else
                    for (o = 0; o < h.length; o++) {
                      var c = [];
                      for (i = 0; i < h[o].length; i += 2)
                        c.push(S(h[o][i], h[o][i + 1], t, s, n, a));
                      l.geometry.push(c);
                    }
                }
                return (e1.transformed = !0), e1;
              }
              function S(e1, t, r, o, i, s) {
                return [
                  Math.round(r * (e1 * o - i)),
                  Math.round(r * (t * o - s)),
                ];
              }
              function M(e1, t, r, o, i) {
                for (
                  var s =
                      t === i.maxZoom ? 0 : i.tolerance / ((1 << t) * i.extent),
                    n = {
                      features: [],
                      numPoints: 0,
                      numSimplified: 0,
                      numFeatures: 0,
                      source: null,
                      x: r,
                      y: o,
                      z: t,
                      transformed: !1,
                      minX: 2,
                      minY: 1,
                      maxX: -1,
                      maxY: 0,
                    },
                    a = 0;
                  a < e1.length;
                  a++
                ) {
                  n.numFeatures++, b(n, e1[a], s, i);
                  var l = e1[a].minX,
                    h = e1[a].minY,
                    u = e1[a].maxX,
                    c = e1[a].maxY;
                  l < n.minX && (n.minX = l),
                    h < n.minY && (n.minY = h),
                    u > n.maxX && (n.maxX = u),
                    c > n.maxY && (n.maxY = c);
                }
                return n;
              }
              function b(e1, t, r, o) {
                var i = t.geometry,
                  s = t.type,
                  n = [];
                if ("Point" === s || "MultiPoint" === s)
                  for (var a = 0; a < i.length; a += 3)
                    n.push(i[a]),
                      n.push(i[a + 1]),
                      e1.numPoints++,
                      e1.numSimplified++;
                else if ("LineString" === s) I(n, i, e1, r, !1, !1);
                else if ("MultiLineString" === s || "Polygon" === s)
                  for (a = 0; a < i.length; a++)
                    I(n, i[a], e1, r, "Polygon" === s, 0 === a);
                else if ("MultiPolygon" === s)
                  for (var l = 0; l < i.length; l++) {
                    var h = i[l];
                    for (a = 0; a < h.length; a++)
                      I(n, h[a], e1, r, !0, 0 === a);
                  }
                if (n.length) {
                  var u = t.tags || null;
                  if ("LineString" === s && o.lineMetrics) {
                    for (var c in ((u = {}), t.tags)) u[c] = t.tags[c];
                    (u.mapbox_clip_start = i.start / i.size),
                      (u.mapbox_clip_end = i.end / i.size);
                  }
                  var f = {
                    geometry: n,
                    type:
                      "Polygon" === s || "MultiPolygon" === s
                        ? 3
                        : "LineString" === s || "MultiLineString" === s
                        ? 2
                        : 1,
                    tags: u,
                  };
                  null !== t.id && (f.id = t.id), e1.features.push(f);
                }
              }
              function I(e1, t, r, o, i, s) {
                var n = o * o;
                if (o > 0 && t.size < (i ? n : o)) r.numPoints += t.length / 3;
                else {
                  for (var a = [], l = 0; l < t.length; l += 3)
                    (0 === o || t[l + 2] > n) &&
                      (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])),
                      r.numPoints++;
                  i &&
                    (function (e1, t) {
                      for (
                        var r = 0, o = 0, i = e1.length, s = i - 2;
                        o < i;
                        s = o, o += 2
                      )
                        r += (e1[o] - e1[s]) * (e1[o + 1] + e1[s + 1]);
                      if (r > 0 === t)
                        for (o = 0, i = e1.length; o < i / 2; o += 2) {
                          var n = e1[o],
                            a = e1[o + 1];
                          (e1[o] = e1[i - 2 - o]),
                            (e1[o + 1] = e1[i - 1 - o]),
                            (e1[i - 2 - o] = n),
                            (e1[i - 1 - o] = a);
                        }
                    })(a, s),
                    e1.push(a);
                }
              }
              function k(e1, t) {
                var r = (t = this.options =
                  (function (e1, t) {
                    for (var r in t) e1[r] = t[r];
                    return e1;
                  })(Object.create(this.options), t)).debug;
                if (
                  (r && console.time("preprocess data"),
                  t.maxZoom < 0 || t.maxZoom > 24)
                )
                  throw new Error("maxZoom should be in the 0-24 range");
                if (t.promoteId && t.generateId)
                  throw new Error(
                    "promoteId and generateId cannot be used together.",
                  );
                var o = (function (e1, t) {
                  var r = [];
                  if ("FeatureCollection" === e1.type)
                    for (var o = 0; o < e1.features.length; o++)
                      i(r, e1.features[o], t, o);
                  else
                    i(
                      r,
                      "Feature" === e1.type
                        ? e1
                        : {
                            geometry: e1,
                          },
                      t,
                    );
                  return r;
                })(e1, t);
                (this.tiles = {}),
                  (this.tileCoords = []),
                  r &&
                    (console.timeEnd("preprocess data"),
                    console.log(
                      "index: maxZoom: %d, maxPoints: %d",
                      t.indexMaxZoom,
                      t.indexMaxPoints,
                    ),
                    console.time("generate tiles"),
                    (this.stats = {}),
                    (this.total = 0)),
                  (o = (function (e1, t) {
                    var r = t.buffer / t.extent,
                      o = e1,
                      i = u(e1, 1, -1 - r, r, 0, -1, 2, t),
                      s = u(e1, 1, 1 - r, 2 + r, 0, -1, 2, t);
                    return (
                      (i || s) &&
                        ((o = u(e1, 1, -r, 1 + r, 0, -1, 2, t) || []),
                        i && (o = v(i, 1).concat(o)),
                        s && (o = o.concat(v(s, -1)))),
                      o
                    );
                  })(o, t)).length && this.splitTile(o, 0, 0, 0),
                  r &&
                    (o.length &&
                      console.log(
                        "features: %d, points: %d",
                        this.tiles[0].numFeatures,
                        this.tiles[0].numPoints,
                      ),
                    console.timeEnd("generate tiles"),
                    console.log(
                      "tiles generated:",
                      this.total,
                      JSON.stringify(this.stats),
                    ));
              }
              function P(e1, t, r) {
                return 32 * ((1 << e1) * r + t) + e1;
              }
              return (
                (k.prototype.options = {
                  maxZoom: 14,
                  indexMaxZoom: 5,
                  indexMaxPoints: 1e5,
                  tolerance: 3,
                  extent: 4096,
                  buffer: 64,
                  lineMetrics: !1,
                  promoteId: null,
                  generateId: !1,
                  debug: 0,
                }),
                (k.prototype.splitTile = function (e1, t, r, o, i, s, n) {
                  for (
                    var a = [e1, t, r, o], l = this.options, h = l.debug;
                    a.length;

                  ) {
                    (o = a.pop()), (r = a.pop()), (t = a.pop()), (e1 = a.pop());
                    var c = 1 << t,
                      f = P(t, r, o),
                      d = this.tiles[f];
                    if (
                      !d &&
                      (h > 1 && console.time("creation"),
                      (d = this.tiles[f] = M(e1, t, r, o, l)),
                      this.tileCoords.push({
                        z: t,
                        x: r,
                        y: o,
                      }),
                      h)
                    ) {
                      h > 1 &&
                        (console.log(
                          "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                          t,
                          r,
                          o,
                          d.numFeatures,
                          d.numPoints,
                          d.numSimplified,
                        ),
                        console.timeEnd("creation"));
                      var p = "z" + t;
                      (this.stats[p] = (this.stats[p] || 0) + 1), this.total++;
                    }
                    if (((d.source = e1), i)) {
                      if (t === l.maxZoom || t === i) continue;
                      var g = 1 << (i - t);
                      if (r !== Math.floor(s / g) || o !== Math.floor(n / g))
                        continue;
                    } else if (
                      t === l.indexMaxZoom ||
                      d.numPoints <= l.indexMaxPoints
                    )
                      continue;
                    if (((d.source = null), 0 !== e1.length)) {
                      h > 1 && console.time("clipping");
                      var m,
                        y,
                        v,
                        w,
                        x,
                        S,
                        b = (0.5 * l.buffer) / l.extent,
                        I = 0.5 - b,
                        k = 0.5 + b,
                        _ = 1 + b;
                      (m = y = v = w = null),
                        (x = u(e1, c, r - b, r + k, 0, d.minX, d.maxX, l)),
                        (S = u(e1, c, r + I, r + _, 0, d.minX, d.maxX, l)),
                        (e1 = null),
                        x &&
                          ((m = u(x, c, o - b, o + k, 1, d.minY, d.maxY, l)),
                          (y = u(x, c, o + I, o + _, 1, d.minY, d.maxY, l)),
                          (x = null)),
                        S &&
                          ((v = u(S, c, o - b, o + k, 1, d.minY, d.maxY, l)),
                          (w = u(S, c, o + I, o + _, 1, d.minY, d.maxY, l)),
                          (S = null)),
                        h > 1 && console.timeEnd("clipping"),
                        a.push(m || [], t + 1, 2 * r, 2 * o),
                        a.push(y || [], t + 1, 2 * r, 2 * o + 1),
                        a.push(v || [], t + 1, 2 * r + 1, 2 * o),
                        a.push(w || [], t + 1, 2 * r + 1, 2 * o + 1);
                    }
                  }
                }),
                (k.prototype.getTile = function (e1, t, r) {
                  var o = this.options,
                    i = o.extent,
                    s = o.debug;
                  if (e1 < 0 || e1 > 24) return null;
                  var n = 1 << e1,
                    a = P(e1, (t = ((t % n) + n) % n), r);
                  if (this.tiles[a]) return x(this.tiles[a], i);
                  s > 1 && console.log("drilling down to z%d-%d-%d", e1, t, r);
                  for (var l, h = e1, u = t, c = r; !l && h > 0; )
                    h--,
                      (u = Math.floor(u / 2)),
                      (c = Math.floor(c / 2)),
                      (l = this.tiles[P(h, u, c)]);
                  return l && l.source
                    ? (s > 1 &&
                        console.log("found parent tile z%d-%d-%d", h, u, c),
                      s > 1 && console.time("drilling down"),
                      this.splitTile(l.source, h, u, c, e1, t, r),
                      s > 1 && console.timeEnd("drilling down"),
                      this.tiles[a] ? x(this.tiles[a], i) : null)
                    : null;
                }),
                function (e1, t) {
                  return new k(e1, t);
                }
              );
            })();
            var J = e1.g(N.exports);
            function Y(t, r) {
              const o = t.tileID.canonical;
              if (!this._geoJSONIndex) return r(null, null);
              const i = this._geoJSONIndex.getTile(o.z, o.x, o.y);
              if (!i) return r(null, null);
              const s = new (class {
                constructor(t) {
                  (this.layers = {
                    _geojsonTileLayer: this,
                  }),
                    (this.name = "_geojsonTileLayer"),
                    (this.extent = e1.E),
                    (this.length = t.length),
                    (this._features = t);
                }
                feature(t) {
                  return new (class {
                    constructor(t) {
                      (this._feature = t),
                        (this.extent = e1.E),
                        (this.type = t.type),
                        (this.properties = t.tags),
                        "id" in t &&
                          !isNaN(t.id) &&
                          (this.id = parseInt(t.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const t = [];
                        for (const r of this._feature.geometry)
                          t.push([new e1.P(r[0], r[1])]);
                        return t;
                      }
                      {
                        const t = [];
                        for (const r of this._feature.geometry) {
                          const o = [];
                          for (const t of r) o.push(new e1.P(t[0], t[1]));
                          t.push(o);
                        }
                        return t;
                      }
                    }
                    toGeoJSON(e1, t, r) {
                      return l.call(this, e1, t, r);
                    }
                  })(this._features[t]);
                }
              })(i.features);
              let n = k(s);
              (0 === n.byteOffset && n.byteLength === n.buffer.byteLength) ||
                (n = new Uint8Array(n)),
                r(null, {
                  vectorTile: s,
                  rawData: n.buffer,
                });
            }
            class G extends e1.d {
              constructor(e1, t, r, o, i, s) {
                super(e1, t, r, o, Y, s), i && (this.loadGeoJSON = i);
              }
              loadData(t, r) {
                const o = t && t.request,
                  i = o && o.collectResourceTiming;
                this.loadGeoJSON(t, (s, n) => {
                  if (s || !n) return r(s);
                  if ("object" != typeof n)
                    return r(
                      new Error(
                        `Input data given to '${t.source}' is not a valid GeoJSON object.`,
                      ),
                    );
                  {
                    a(n, !0);
                    try {
                      if (t.filter) {
                        const r = e1.e(t.filter, {
                          type: "boolean",
                          "property-type": "data-driven",
                          overridable: !1,
                          transition: !1,
                        });
                        if ("error" === r.result)
                          throw new Error(
                            r.value
                              .map((e1) => `${e1.key}: ${e1.message}`)
                              .join(", "),
                          );
                        const o = n.features.filter((e1) =>
                          r.value.evaluate(
                            {
                              zoom: 0,
                            },
                            e1,
                          ),
                        );
                        n = {
                          type: "FeatureCollection",
                          features: o,
                        };
                      }
                      this._geoJSONIndex = t.cluster
                        ? new j(
                            (function ({
                              superclusterOptions: t,
                              clusterProperties: r,
                            }) {
                              if (!r || !t) return t;
                              const o = {},
                                i = {},
                                s = {
                                  accumulated: null,
                                  zoom: 0,
                                },
                                n = {
                                  properties: null,
                                },
                                a = Object.keys(r);
                              for (const t of a) {
                                const [s, n] = r[t],
                                  a = e1.e(n),
                                  l = e1.e(
                                    "string" == typeof s
                                      ? [s, ["accumulated"], ["get", t]]
                                      : s,
                                  );
                                (o[t] = a.value), (i[t] = l.value);
                              }
                              return (
                                (t.map = (e1) => {
                                  n.properties = e1;
                                  const t = {};
                                  for (const e1 of a)
                                    t[e1] = o[e1].evaluate(s, n);
                                  return t;
                                }),
                                (t.reduce = (e1, t) => {
                                  n.properties = t;
                                  for (const t of a)
                                    (s.accumulated = e1[t]),
                                      (e1[t] = i[t].evaluate(s, n));
                                }),
                                t
                              );
                            })(t),
                          ).load(n.features)
                        : J(n, t.geojsonVtOptions);
                    } catch (s) {
                      return r(s);
                    }
                    this.loaded = {};
                    const l = {};
                    if (i) {
                      const r = e1.f(o);
                      r &&
                        ((l.resourceTiming = {}),
                        (l.resourceTiming[t.source] = JSON.parse(
                          JSON.stringify(r),
                        )));
                    }
                    r(null, l);
                  }
                });
              }
              reloadTile(e1, t) {
                const r = this.loaded;
                return r && r[e1.uid]
                  ? super.reloadTile(e1, t)
                  : this.loadTile(e1, t);
              }
              loadGeoJSON(t, r) {
                if (t.request) e1.h(t.request, r);
                else {
                  if ("string" != typeof t.data)
                    return r(
                      new Error(
                        `Input data given to '${t.source}' is not a valid GeoJSON object.`,
                      ),
                    );
                  try {
                    return r(null, JSON.parse(t.data));
                  } catch (e1) {
                    return r(
                      new Error(
                        `Input data given to '${t.source}' is not a valid GeoJSON object.`,
                      ),
                    );
                  }
                }
              }
              getClusterExpansionZoom(e1, t) {
                try {
                  t(
                    null,
                    this._geoJSONIndex.getClusterExpansionZoom(e1.clusterId),
                  );
                } catch (e1) {
                  t(e1);
                }
              }
              getClusterChildren(e1, t) {
                try {
                  t(null, this._geoJSONIndex.getChildren(e1.clusterId));
                } catch (e1) {
                  t(e1);
                }
              }
              getClusterLeaves(e1, t) {
                try {
                  t(
                    null,
                    this._geoJSONIndex.getLeaves(
                      e1.clusterId,
                      e1.limit,
                      e1.offset,
                    ),
                  );
                } catch (e1) {
                  t(e1);
                }
              }
            }
            class W {
              constructor(t, r) {
                (this.tileID = new e1.O(
                  t.tileID.overscaledZ,
                  t.tileID.wrap,
                  t.tileID.canonical.z,
                  t.tileID.canonical.x,
                  t.tileID.canonical.y,
                )),
                  (this.tileZoom = t.tileZoom),
                  (this.uid = t.uid),
                  (this.zoom = t.zoom),
                  (this.canonical = t.tileID.canonical),
                  (this.pixelRatio = t.pixelRatio),
                  (this.tileSize = t.tileSize),
                  (this.source = t.source),
                  (this.overscaling = this.tileID.overscaleFactor()),
                  (this.projection = t.projection),
                  (this.brightness = r);
              }
              parse(t, r, o, i) {
                this.status = "parsing";
                const s = new e1.O(
                    o.tileID.overscaledZ,
                    o.tileID.wrap,
                    o.tileID.canonical.z,
                    o.tileID.canonical.x,
                    o.tileID.canonical.y,
                  ),
                  n = {},
                  a = r.familiesBySource[o.source],
                  l = new e1.F(s, o.promoteId);
                return (
                  (l.bucketLayerIDs = []),
                  e1
                    .l(t)
                    .then((t) => {
                      if (!t) return i(new Error("Could not parse tile"));
                      const r = e1.j(t, 1 / e1.t(o.tileID.canonical)),
                        h =
                          t.json.extensionsUsed &&
                          t.json.extensionsUsed.includes(
                            "MAPBOX_mesh_features",
                          ),
                        u = new e1.k(this.zoom, {
                          brightness: this.brightness,
                        });
                      for (const o in a)
                        for (const i of a[o]) {
                          const o = i[0],
                            a = t.json.extensionsUsed;
                          o.recalculate(u, []);
                          const l = new e1.T(
                            r,
                            s,
                            a && a.includes("MAPBOX_mesh_features"),
                            this.brightness,
                          );
                          h || (l.needsUpload = !0),
                            (n[o.fqid] = l),
                            l.evaluate(o);
                        }
                      (this.status = "done"),
                        i(null, {
                          buckets: n,
                          featureIndex: l,
                        });
                    })
                    .catch((e1) => i(new Error(e1.message)))
                );
              }
            }
            class X {
              constructor(e1, t, r, o, i, s) {
                (this.actor = e1),
                  (this.layerIndex = t),
                  (this.brightness = s),
                  (this.loading = {}),
                  (this.loaded = {});
              }
              loadTile(t, r) {
                const o = t.uid,
                  i = (this.loading[o] = new W(t, this.brightness));
                e1.i(t.request, (e1, s) => {
                  const n = !this.loading[o];
                  return (
                    delete this.loading[o],
                    n || e1
                      ? ((i.status = "done"), n || (this.loaded[o] = i), r(e1))
                      : s && 0 !== s.byteLength
                      ? void i.parse(s, this.layerIndex, t, (e1, t) => {
                          (i.status = "done"),
                            (this.loaded = this.loaded || {}),
                            (this.loaded[o] = i),
                            e1 || !t ? r(e1) : r(null, t);
                        })
                      : ((i.status = "done"), (this.loaded[o] = i), r())
                  );
                });
              }
              reloadTile(e1, t) {
                const r = this.loaded,
                  o = e1.uid;
                if (r && r[o]) {
                  const i = r[o];
                  (i.projection = e1.projection),
                    (i.brightness = e1.brightness);
                  const s = (r, o) => {
                    i.reloadCallback &&
                      (delete i.reloadCallback, this.loadTile(e1, t)),
                      t(r, o);
                  };
                  "parsing" === i.status
                    ? (i.reloadCallback = s)
                    : "done" === i.status && this.loadTile(e1, t);
                }
              }
              abortTile(e1, t) {
                const r = e1.uid;
                this.loading[r] && delete this.loading[r], t();
              }
              removeTile(e1, t) {
                const r = this.loaded,
                  o = e1.uid;
                r && r[o] && delete r[o], t();
              }
            }
            class V {
              constructor(t) {
                (this.self = t),
                  (this.actor = new e1.A(t, this)),
                  (this.layerIndexes = {}),
                  (this.availableImages = {}),
                  (this.isSpriteLoaded = {}),
                  (this.projections = {}),
                  (this.defaultProjection = e1.m({
                    name: "mercator",
                  })),
                  (this.workerSourceTypes = {
                    vector: e1.d,
                    geojson: G,
                    "batched-model": X,
                  }),
                  (this.workerSources = {}),
                  (this.demWorkerSources = {}),
                  (this.self.registerWorkerSource = (e1, t) => {
                    if (this.workerSourceTypes[e1])
                      throw new Error(
                        `Worker source with name "${e1}" already registered.`,
                      );
                    this.workerSourceTypes[e1] = t;
                  }),
                  (this.self.registerRTLTextPlugin = (t) => {
                    if (e1.n.isParsed())
                      throw new Error("RTL text plugin already registered.");
                    (e1.n.applyArabicShaping = t.applyArabicShaping),
                      (e1.n.processBidirectionalText =
                        t.processBidirectionalText),
                      (e1.n.processStyledBidirectionalText =
                        t.processStyledBidirectionalText);
                  });
              }
              clearCaches(e1, t, r) {
                delete this.layerIndexes[e1],
                  delete this.availableImages[e1],
                  delete this.workerSources[e1],
                  delete this.demWorkerSources[e1],
                  r();
              }
              checkIfReady(e1, t, r) {
                r();
              }
              setReferrer(e1, t) {
                this.referrer = t;
              }
              spriteLoaded(t, { scope: r, isLoaded: o }) {
                if (
                  (this.isSpriteLoaded[t] || (this.isSpriteLoaded[t] = {}),
                  (this.isSpriteLoaded[t][r] = o),
                  this.workerSources[t] && this.workerSources[t][r])
                )
                  for (const i in this.workerSources[t][r]) {
                    const s = this.workerSources[t][r][i];
                    for (const t in s)
                      s[t] instanceof e1.d &&
                        ((s[t].isSpriteLoaded = o),
                        s[t].fire(new e1.o("isSpriteLoaded")));
                  }
              }
              setImages(e1, { scope: t, images: r }, o) {
                if (
                  (this.availableImages[e1] || (this.availableImages[e1] = {}),
                  (this.availableImages[e1][t] = r),
                  this.workerSources[e1] && this.workerSources[e1][t])
                ) {
                  for (const o in this.workerSources[e1][t]) {
                    const i = this.workerSources[e1][t][o];
                    for (const e1 in i) i[e1].availableImages = r;
                  }
                  o();
                } else o();
              }
              setProjection(t, r) {
                this.projections[t] = e1.m(r);
              }
              setBrightness(e1, t, r) {
                (this.brightness = t), r();
              }
              setLayers(e1, t, r) {
                this.getLayerIndex(e1, t.scope).replace(t.layers, t.options),
                  r();
              }
              updateLayers(e1, t, r) {
                this.getLayerIndex(e1, t.scope).update(
                  t.layers,
                  t.removedIds,
                  t.options,
                ),
                  r();
              }
              loadTile(e1, t, r) {
                (t.projection = this.projections[e1] || this.defaultProjection),
                  this.getWorkerSource(e1, t.type, t.source, t.scope).loadTile(
                    t,
                    r,
                  );
              }
              loadDEMTile(e1, t, r) {
                this.getDEMWorkerSource(e1, t.source, t.scope).loadTile(t, r);
              }
              reloadTile(e1, t, r) {
                (t.projection = this.projections[e1] || this.defaultProjection),
                  this.getWorkerSource(
                    e1,
                    t.type,
                    t.source,
                    t.scope,
                  ).reloadTile(t, r);
              }
              abortTile(e1, t, r) {
                this.getWorkerSource(e1, t.type, t.source, t.scope).abortTile(
                  t,
                  r,
                );
              }
              removeTile(e1, t, r) {
                this.getWorkerSource(e1, t.type, t.source, t.scope).removeTile(
                  t,
                  r,
                );
              }
              removeSource(e1, t, r) {
                if (
                  !(
                    this.workerSources[e1] &&
                    this.workerSources[e1][t.scope] &&
                    this.workerSources[e1][t.scope][t.type] &&
                    this.workerSources[e1][t.scope][t.type][t.source]
                  )
                )
                  return;
                const o = this.workerSources[e1][t.scope][t.type][t.source];
                delete this.workerSources[e1][t.scope][t.type][t.source],
                  void 0 !== o.removeSource ? o.removeSource(t, r) : r();
              }
              loadWorkerSource(e1, t, r) {
                try {
                  this.self.importScripts(t.url), r();
                } catch (e1) {
                  r(e1.toString());
                }
              }
              syncRTLPluginState(t, r, o) {
                try {
                  e1.n.setState(r);
                  const t = e1.n.getPluginURL();
                  if (e1.n.isLoaded() && !e1.n.isParsed() && null != t) {
                    this.self.importScripts(t);
                    const r = e1.n.isParsed();
                    o(
                      r
                        ? void 0
                        : new Error(
                            `RTL Text Plugin failed to import scripts from ${t}`,
                          ),
                      r,
                    );
                  }
                } catch (e1) {
                  o(e1.toString());
                }
              }
              setDracoUrl(e1, t) {
                this.dracoUrl = t;
              }
              getAvailableImages(e1, t) {
                this.availableImages[e1] || (this.availableImages[e1] = {});
                let r = this.availableImages[e1][t];
                return r || (r = []), r;
              }
              getLayerIndex(e1, t) {
                this.layerIndexes[e1] || (this.layerIndexes[e1] = {});
                let r = this.layerIndexes[e1][t];
                return (
                  r ||
                    ((r = this.layerIndexes[e1][t] = new o()), (r.scope = t)),
                  r
                );
              }
              getWorkerSource(e1, t, r, o) {
                if (
                  (this.workerSources[e1] || (this.workerSources[e1] = {}),
                  this.workerSources[e1][o] || (this.workerSources[e1][o] = {}),
                  this.workerSources[e1][o][t] ||
                    (this.workerSources[e1][o][t] = {}),
                  this.isSpriteLoaded[e1] || (this.isSpriteLoaded[e1] = {}),
                  !this.workerSources[e1][o][t][r])
                ) {
                  const i = {
                    send: (t, r, o, i, s, n) => {
                      this.actor.send(t, r, o, e1, s, n);
                    },
                    scheduler: this.actor.scheduler,
                  };
                  this.workerSources[e1][o][t][r] = new this.workerSourceTypes[
                    t
                  ](
                    i,
                    this.getLayerIndex(e1, o),
                    this.getAvailableImages(e1, o),
                    this.isSpriteLoaded[e1][o],
                    void 0,
                    this.brightness,
                  );
                }
                return this.workerSources[e1][o][t][r];
              }
              getDEMWorkerSource(e1, t, r) {
                return (
                  this.demWorkerSources[e1] || (this.demWorkerSources[e1] = {}),
                  this.demWorkerSources[e1][r] ||
                    (this.demWorkerSources[e1][r] = {}),
                  this.demWorkerSources[e1][r][t] ||
                    (this.demWorkerSources[e1][r][t] = new i()),
                  this.demWorkerSources[e1][r][t]
                );
              }
              enforceCacheSizeLimit(t, r) {
                e1.q(r);
              }
              getWorkerPerformanceMetrics(e1, t, r) {
                r(void 0, void 0);
              }
            }
            return (
              "undefined" != typeof WorkerGlobalScope &&
                "undefined" != typeof self &&
                self instanceof WorkerGlobalScope &&
                (self.worker = new V(self)),
              V
            );
          });
          define(["./shared"], function (e1) {
            "use strict";
            return e1.s;
          });
          //
          // Our custom intro provides a specialized "define()" function, called by the
          // AMD modules below, that sets up the worker blob URL and then executes the
          // main module, storing its exported value as 'mapboxgl'
          var mapboxgl$1 = mapboxgl;
          return mapboxgl$1;
        });
      },
      {},
    ],
    "5aoxi": [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _axios = require("axios");
        var _axiosDefault = parcelHelpers.interopDefault(_axios);
        var _alertsJs = require("./alerts.js");
        var _alertsJsDefault = parcelHelpers.interopDefault(_alertsJs);
        const updateSettings = async (data, type) => {
          try {
            const endpoint =
              type === "password" ? "updateMyPassword" : "updateMe";
            const res = await (0, _axiosDefault.default)({
              method: "PATCH",
              url: `/api/v1/users/${endpoint}`,
              data,
            });
            if (res.data.status === "success")
              (0, _alertsJsDefault.default)(
                "success",
                `${type.toUpperCase()} updated successfully!`,
              );
          } catch (err) {
            (0, _alertsJsDefault.default)("error", err.response.data.message);
          }
        };
        exports.default = updateSettings;
      },
      {
        axios: "cNk7h",
        "./alerts.js": "2hU5S",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
      },
    ],
    a2htd: [
      function (require, module, exports) {
        /* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        var _stripeJs = require("@stripe/stripe-js");
        var _axios = require("axios");
        var _axiosDefault = parcelHelpers.interopDefault(_axios);
        var _alertsJs = require("./alerts.js");
        var _alertsJsDefault = parcelHelpers.interopDefault(_alertsJs);
        const bookTour = async (tourId) => {
          const stripe = await (0, _stripeJs.loadStripe)(
            "pk_test_51OZ0X2DjxG0LY9R08L8rtAXsW6UCYlqtm4CEwbbvzMXLHa9jjsjCUHfWosrVe7s9Kbg3QCFT3lIGPkuzIY4YPu9e005nZBjvJ0",
          );
          try {
            const session = await (0, _axiosDefault.default).get(
              `/api/v1/bookings/checkout-session/${tourId}`,
            );
            window.location.replace(session.data.session.url);
          } catch (err) {
            (0, _alertsJsDefault.default)(
              "error",
              "Error in booking tour! Try again later.",
            );
          }
        };
        exports.default = bookTour;
      },
      {
        axios: "cNk7h",
        "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7",
        "@stripe/stripe-js": "hmF89",
        "./alerts.js": "2hU5S",
      },
    ],
    hmF89: [
      function (require, module, exports) {
        var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
        parcelHelpers.defineInteropFlag(exports);
        parcelHelpers.export(exports, "loadStripe", () => loadStripe);
        var V3_URL = "https://js.stripe.com/v3";
        var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
        var EXISTING_SCRIPT_MESSAGE =
          "loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used";
        var findScript = function findScript() {
          var scripts = document.querySelectorAll(
            'script[src^="'.concat(V3_URL, '"]'),
          );
          for (var i = 0; i < scripts.length; i++) {
            var script = scripts[i];
            if (!V3_URL_REGEX.test(script.src)) continue;
            return script;
          }
          return null;
        };
        var injectScript = function injectScript(params) {
          var queryString =
            params && !params.advancedFraudSignals
              ? "?advancedFraudSignals=false"
              : "";
          var script = document.createElement("script");
          script.src = "".concat(V3_URL).concat(queryString);
          var headOrBody = document.head || document.body;
          if (!headOrBody)
            throw new Error(
              "Expected document.body not to be null. Stripe.js requires a <body> element.",
            );
          headOrBody.appendChild(script);
          return script;
        };
        var registerWrapper = function registerWrapper(stripe, startTime) {
          if (!stripe || !stripe._registerWrapper) return;
          stripe._registerWrapper({
            name: "stripe-js",
            version: "2.3.0",
            startTime: startTime,
          });
        };
        var stripePromise = null;
        var onErrorListener = null;
        var onLoadListener = null;
        var onError = function onError(reject) {
          return function () {
            reject(new Error("Failed to load Stripe.js"));
          };
        };
        var onLoad = function onLoad(resolve, reject) {
          return function () {
            if (window.Stripe) resolve(window.Stripe);
            else reject(new Error("Stripe.js not available"));
          };
        };
        var loadScript = function loadScript(params) {
          // Ensure that we only attempt to load Stripe.js at most once
          if (stripePromise !== null) return stripePromise;
          stripePromise = new Promise(function (resolve, reject) {
            if (
              typeof window === "undefined" ||
              typeof document === "undefined"
            ) {
              // Resolve to null when imported server side. This makes the module
              // safe to import in an isomorphic code base.
              resolve(null);
              return;
            }
            if (window.Stripe && params) console.warn(EXISTING_SCRIPT_MESSAGE);
            if (window.Stripe) {
              resolve(window.Stripe);
              return;
            }
            try {
              var script = findScript();
              if (script && params) console.warn(EXISTING_SCRIPT_MESSAGE);
              else if (!script) script = injectScript(params);
              else if (
                script &&
                onLoadListener !== null &&
                onErrorListener !== null
              ) {
                var _script$parentNode;
                // remove event listeners
                script.removeEventListener("load", onLoadListener);
                script.removeEventListener("error", onErrorListener); // if script exists, but we are reloading due to an error,
                // reload script to trigger 'load' event
                (_script$parentNode = script.parentNode) === null ||
                  _script$parentNode === void 0 ||
                  _script$parentNode.removeChild(script);
                script = injectScript(params);
              }
              onLoadListener = onLoad(resolve, reject);
              onErrorListener = onError(reject);
              script.addEventListener("load", onLoadListener);
              script.addEventListener("error", onErrorListener);
            } catch (error) {
              reject(error);
              return;
            }
          }); // Resets stripePromise on error
          return stripePromise["catch"](function (error) {
            stripePromise = null;
            return Promise.reject(error);
          });
        };
        var initStripe = function initStripe(maybeStripe, args, startTime) {
          if (maybeStripe === null) return null;
          var stripe = maybeStripe.apply(undefined, args);
          registerWrapper(stripe, startTime);
          return stripe;
        }; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        var stripePromise$1;
        var loadCalled = false;
        var getStripePromise = function getStripePromise() {
          if (stripePromise$1) return stripePromise$1;
          stripePromise$1 = loadScript(null)["catch"](function (error) {
            // clear cache on error
            stripePromise$1 = null;
            return Promise.reject(error);
          });
          return stripePromise$1;
        }; // Execute our own script injection after a tick to give users time to do their
        // own script injection.
        Promise.resolve()
          .then(function () {
            return getStripePromise();
          })
          ["catch"](function (error) {
            if (!loadCalled) console.warn(error);
          });
        var loadStripe = function loadStripe() {
          for (
            var _len = arguments.length, args = new Array(_len), _key = 0;
            _key < _len;
            _key++
          )
            args[_key] = arguments[_key];
          loadCalled = true;
          var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script
          return getStripePromise().then(function (maybeStripe) {
            return initStripe(maybeStripe, args, startTime);
          });
        };
      },
      { "@parcel/transformer-js/src/esmodule-helpers.js": "eOtu7" },
    ],
  },
  ["3FfGI", "de0CH"],
  "de0CH",
  "parcelRequire11c7",
);

//# sourceMappingURL=index.js.map
